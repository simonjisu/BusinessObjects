{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["To find out which course has the most registered students, we need to count the number of students registered for each course.", "We will use the 'Student_Course_Registrations' table, which contains the 'student_id' and 'course_id'.", "We will group the results by 'course_id' to get the count of students for each course.", "We will order the results in descending order based on the count of students to get the course with the highest number of registrations at the top.", "Finally, we will limit the results to 1 to get only the course with the most registered students."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT course_id, COUNT(student_id) AS number_of_students \nFROM Student_Course_Registrations \nGROUP BY course_id \nORDER BY number_of_students DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["The question asks for the IDs of students who attended some courses.", "To find this information, we need to look at the 'Student_Course_Attendance' table, which records attendance of students for various courses.", "We will select the 'student_id' from this table.", "Using DISTINCT ensures that we only get unique student IDs, as a student may have attended multiple courses."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["We need to find the IDs of all students who have attended at least one course.", "The relevant table for this information is 'Student_Course_Attendance', which records attendance of students for courses.", "To get unique student IDs, we will use the DISTINCT keyword to avoid duplicates in our results.", "The final SQL query will select the distinct student_id from the Student_Course_Attendance table."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["We need to find the candidate who most recently accessed a course, which implies we need to look at the attendance records.", "The relevant table for attendance is 'Student_Course_Attendance', which contains the 'student_id' and 'date_of_attendance'.", "Candidates are linked to people through the 'candidate_id', which corresponds to 'student_id' in the attendance table.", "To get the most recent attendance, we will order the results by 'date_of_attendance' in descending order.", "Finally, we limit the results to 1 to get only the most recent record."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT c.candidate_id \nFROM Candidates c \nJOIN Student_Course_Attendance a ON c.candidate_id = a.student_id \nORDER BY a.date_of_attendance DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.77", "db_id": "student_assessment", "question": "What is detail of the student who registered the most number of courses?", "rationale": ["Identify the relevant tables: Students and Student_Course_Registrations are needed to get student details and their course registrations.", "Join the Students table with the Student_Course_Registrations table on the student_id to link students with their registered courses.", "Group the results by student_id to aggregate the number of courses each student has registered for.", "Order the results in descending order based on the count of course registrations to find the student with the most registrations.", "Limit the results to 1 to get only the top student who registered for the most courses."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT S.student_details \nFROM Students AS S \nJOIN Student_Course_Registrations AS R ON S.student_id = R.student_id \nGROUP BY S.student_id \nORDER BY COUNT(R.course_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["Identify the tables involved: We need to get course names and the count of registered students, which involves the 'Courses' and 'Student_Course_Registrations' tables.", "Join the tables: We will join 'Student_Course_Registrations' with 'Courses' on the course_id to get the course names along with the registrations.", "Group by course_id and course_name: To count the number of students registered for each course, we will group the results by course_id and course_name.", "Count the number of students: Use COUNT() function to count the number of student registrations for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT SC.course_id, C.course_name, COUNT(SCR.student_id) AS student_count \nFROM Student_Course_Registrations AS SCR \nJOIN Courses AS C ON SCR.course_id = C.course_id \nGROUP BY SC.course_id, C.course_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.90", "db_id": "student_assessment", "question": "What are the ids of the students who registered for course 301 most recently?", "rationale": ["Identify the relevant table: The 'Student_Course_Registrations' table contains information about student registrations for courses.", "Filter by course_id: We need to focus on registrations for course 301, so we will add a WHERE clause to filter by course_id.", "Order by registration date: To find the most recent registration, we will order the results by the 'registration_date' in descending order.", "Limit the results: Since we only want the most recent registration, we will limit the results to 1."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["We need to find distinct cities of addresses associated with students.", "To do this, we will need to join the Addresses table with the People_Addresses table to link addresses to people.", "Next, we will join the resulting table with the Students table to filter for only those people who are students.", "Finally, we will select the distinct cities from the Addresses table."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "pred_sql": "SELECT DISTINCT a.city\nFROM Addresses a\nJOIN People_Addresses pa ON a.address_id = pa.address_id\nJOIN Students s ON pa.person_id = s.student_id;", "hint": "\n"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["We need to find details of students who registered for courses but did not attend any.", "To achieve this, we will use a LEFT JOIN between the Students table and the Student_Course_Registrations table.", "The LEFT JOIN will allow us to include all students from the Students table and match them with their registrations in the Student_Course_Registrations table.", "We will filter the results using a WHERE clause to check for students who have no corresponding entries in the Student_Course_Registrations table (i.e., R.student_id IS NULL).", "Finally, we will select the student_id and student_details from the Students table."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "pred_sql": "SELECT S.student_id, S.student_details \nFROM Students AS S \nLEFT JOIN Student_Course_Registrations AS R ON S.student_id = R.student_id \nWHERE R.student_id IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Determine the specific course of interest, which is 'Statistics'.", "Filter the registrations to only include those for the 'Statistics' course.", "Order the results by the 'registration_date' to get the order of registration."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Determine the specific course of interest, which is 'Statistics'.", "Use a subquery to find the course_id associated with the course name 'Statistics'.", "Select the student_id from 'Student_Course_Registrations' where the course_id matches the one found in the subquery.", "Order the results by the registration_date to get the ids of students in the order they registered."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.123", "db_id": "bike_1", "question": "For each zip code, return the average mean temperature of August there.", "rationale": ["We need to calculate the average mean temperature for each zip code in August.", "To filter the records for August, we can use the strftime function to extract the month from the date column in the weather table.", "We will select the zip_code and the average of mean_temperature_f from the weather table.", "We will group the results by zip_code to get the average temperature for each zip code."], "gold_sql": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE '8/%' GROUP BY zip_code", "source_tables": ["weather"], "pred_sql": "SELECT zip_code, AVG(mean_temperature_f) AS average_mean_temperature\nFROM weather\nWHERE strftime('%m', date) = '08'\nGROUP BY zip_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.135", "db_id": "bike_1", "question": "Which bike traveled the most often in zip code 94002?", "rationale": ["Identify the relevant table for trips, which is the 'trip' table.", "Filter the trips based on the specified zip code (94002).", "Group the results by 'bike_id' to count how many times each bike was used.", "Order the results in descending order based on the count of trips to find the most frequently used bike.", "Limit the results to 1 to get only the bike that traveled the most often."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id, COUNT(*) as trip_count \nFROM trip \nWHERE zip_code = '94002' \nGROUP BY bike_id \nORDER BY trip_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.136", "db_id": "bike_1", "question": "What is the id of the bike that traveled the most in 94002?", "rationale": ["Identify the relevant table for trips, which is the 'trip' table.", "Filter the trips based on the zip code '94002'.", "Order the results by the duration of the trips in descending order to find the longest trip.", "Limit the results to 1 to get only the bike that traveled the most."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id FROM trip WHERE zip_code = '94002' ORDER BY duration DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.143", "db_id": "bike_1", "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?", "rationale": ["We need to find the names and ids of stations that had more than 14 bikes available on average or were installed in December.", "To find the average number of bikes available, we can use the 'status' table and group by 'station_id', calculating the average of 'bikes_available'.", "We will filter these results to only include those stations where the average is greater than 14.", "Next, we also need to check the installation date from the 'station' table to see if it falls in December. We can use the strftime function to extract the month from 'installation_date'.", "Finally, we combine both conditions using an OR clause to get the desired results."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT id, name FROM station WHERE id IN (SELECT station_id FROM status GROUP BY station_id HAVING AVG(bikes_available) > 14) OR strftime('%m', installation_date) = '12';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.144", "db_id": "bike_1", "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "rationale": ["We need to find the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December.", "To achieve this, we will join the 'station' table with the 'status' table on the station id.", "We will use the GROUP BY clause to group the results by station id and name, allowing us to calculate the average number of bikes available for each station.", "The HAVING clause will be used to filter the results based on two conditions: the average number of bikes available must be greater than 14, or the installation date must indicate that the station was installed in December.", "The installation date can be checked using a LIKE clause to match any date that contains '-12-' (indicating December).", "Finally, we will select the distinct ids and names of the stations that meet either of these conditions."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT DISTINCT T1.id, T1.name \nFROM station AS T1 \nJOIN status AS T2 ON T1.id = T2.station_id \nGROUP BY T1.id, T1.name \nHAVING AVG(T2.bikes_available) > 14 \nOR T1.installation_date LIKE '%-12-%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.145", "db_id": "bike_1", "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?", "rationale": ["Identify the relevant table: The 'weather' table contains the cloud cover data and zip codes.", "Filter the data: We need to filter the records for the specific zip code 94107.", "Group the results: We will group the results by cloud cover to count occurrences of each cloud cover rate.", "Order the results: We will order the results by the count of cloud cover rates in descending order to find the most common rates.", "Limit the results: We will limit the output to the top 3 most common cloud cover rates."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "pred_sql": "SELECT cloud_cover, COUNT(cloud_cover) as cover_count \nFROM weather \nWHERE zip_code = 94107 \nGROUP BY cloud_cover \nORDER BY cover_count DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.161", "db_id": "bike_1", "question": "For each trip, return its ending station's installation date.", "rationale": ["Identify the relevant tables: We need data from the 'trip' table for the ending station and the 'station' table for the installation date.", "Join the 'trip' table with the 'station' table on the end station ID to get the installation date of each ending station.", "Select the end station ID and its corresponding installation date from the joined tables."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T3.end_station_id, T1.installation_date FROM trip AS T3 JOIN station AS T1 ON T3.end_station_id = T1.id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.162", "db_id": "bike_1", "question": "What is the installation date for each ending station on all the trips?", "rationale": ["Identify the relevant tables: 'station' for installation dates and 'trip' for ending stations.", "We need to join the 'station' table with the 'trip' table on the condition that the station ID in the 'station' table matches the end station ID in the 'trip' table.", "Select the station name and installation date from the 'station' table.", "Group the results by the end station ID to ensure we get unique entries for each ending station."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T1.name, T1.installation_date FROM station AS T1 JOIN trip AS T2 ON T1.id = T2.end_station_id GROUP BY T2.end_station_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.163", "db_id": "bike_1", "question": "Which trip started from the station with the largest dock count? Give me the trip id.", "rationale": ["Identify the station with the largest dock count by ordering the 'station' table by 'dock_count' in descending order and limiting the result to 1.", "Use the 'id' of this station to filter the 'trip' table for trips that started from this station.", "Select the 'id' of the trip that meets this condition."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "pred_sql": "SELECT id FROM trip WHERE start_station_id = (SELECT id FROM station ORDER BY dock_count DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.165", "db_id": "bike_1", "question": "Count the number of trips that did not end in San Francisco city.", "rationale": ["Identify the requirement to count trips that did not end in San Francisco.", "To achieve this, we need to filter trips based on their end station's city.", "We can use a subquery to find all station IDs located in San Francisco.", "The subquery will select the IDs from the 'station' table where the city is 'San Francisco'.", "The main query will count all trips where the end station ID is not in the list of IDs returned by the subquery."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip WHERE end_station_id NOT IN (SELECT id FROM station WHERE city = 'San Francisco')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.166", "db_id": "bike_1", "question": "How many trips did not end in San Francisco?", "rationale": ["Identify the relevant table: The 'trip' table contains information about trips, including the end station name.", "Determine the condition: We need to count trips that did not end in San Francisco, which means we will filter out trips where the 'end_station_name' is 'San Francisco'.", "Construct the SQL query: We will use the COUNT function to count the number of trips that meet the condition specified."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != 'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip WHERE end_station_name != 'San Francisco';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.167", "db_id": "bike_1", "question": "In zip code 94107, on which day neither Fog nor Rain was not observed?", "rationale": ["Identify the relevant table: The question pertains to weather observations, so we will use the 'weather' table.", "Filter by zip code: We need to focus on records where the zip code is 94107.", "Exclude specific weather events: We want to find days where neither Fog nor Rain was observed, which means we need to filter out any records that contain these events in the 'events' column.", "Construct the SQL query: Combine the filters into a SELECT statement that retrieves the date from the 'weather' table based on the specified conditions."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT date FROM weather WHERE zip_code = 94107 AND events NOT LIKE '%Fog%' AND events NOT LIKE '%Rain%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.168", "db_id": "bike_1", "question": "On which day has it neither been foggy nor rained in the zip code of 94107?", "rationale": ["Identify the relevant table: The 'weather' table contains the necessary information about weather conditions.", "Determine the conditions for the query: We need to find days with no rain (precipitation_inches = 0) and no fog (events = 0).", "Specify the zip code: We are interested in the weather reports for the zip code 94107.", "Construct the SQL query: Select the date from the weather table where the zip code is 94107 and both conditions (no rain and no fog) are met."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT date FROM weather WHERE zip_code = 94107 AND precipitation_inches = 0 AND events = 0", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.183", "db_id": "bike_1", "question": "List all the cities in a decreasing order of each city's stations' highest latitude.", "rationale": ["We need to list all the cities from the 'station' table.", "To find the highest latitude for each city, we will use the MAX function on the 'lat' column.", "We will group the results by 'city' to ensure we get the highest latitude for each city.", "Finally, we will order the results in decreasing order of the highest latitude using ORDER BY clause."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, MAX(lat) AS highest_latitude FROM station GROUP BY city ORDER BY highest_latitude DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.184", "db_id": "bike_1", "question": "For each city, list their names in decreasing order by their highest station latitude.", "rationale": ["We need to list the names of bike stations for each city, ordered by their highest latitude.", "To achieve this, we can use a subquery to find the maximum latitude for each city from the 'station' table.", "We will select the city and name from the 'station' table where the latitude matches the maximum latitude found in the subquery.", "Finally, we will order the results by latitude in descending order to meet the requirement."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, name FROM station WHERE lat = (SELECT MAX(lat) FROM station GROUP BY city) ORDER BY lat DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.189", "db_id": "bike_1", "question": "For each station, return its longitude and the average duration of trips that started from the station.", "rationale": ["We need to select the longitude of each station and the average duration of trips that started from that station.", "The 'station' table contains the longitude information, while the 'trip' table contains the duration of trips and the starting station ID.", "To get the average duration of trips for each station, we will join the 'station' table with the 'trip' table on the condition that the station ID in the 'station' table matches the start station ID in the 'trip' table.", "We will use the AVG() function to calculate the average duration of trips for each station.", "Finally, we will group the results by the station ID to ensure we get one result per station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT S.long, AVG(T.duration) AS average_duration\nFROM station AS S\nJOIN trip AS T ON S.id = T.start_station_id\nGROUP BY S.id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.190", "db_id": "bike_1", "question": "For each start station id, what is its name, longitude and average duration of trips started there?", "rationale": ["Identify the relevant tables: 'station' for station details and 'trip' for trip durations.", "We need to select the station's id, name, longitude, and the average duration of trips that started at each station.", "Join the 'station' table (aliased as T1) with the 'trip' table (aliased as T2) on the condition that the station id in 'station' matches the start station id in 'trip'.", "Use the AVG() function to calculate the average duration of trips for each station.", "Group the results by station id, name, and longitude to ensure we get one result per station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T1.id, T1.name, T1.long, AVG(T2.duration) AS average_duration\nFROM station AS T1\nJOIN trip AS T2 ON T1.id = T2.start_station_id\nGROUP BY T1.id, T1.name, T1.long;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.192", "db_id": "bike_1", "question": "For each end station id, what is its name, latitude, and minimum duration for trips ended there?", "rationale": ["Identify the required columns: end station name, latitude, and minimum trip duration.", "The 'station' table contains the station names and latitude, while the 'trip' table contains the trip durations and end station IDs.", "Join the 'station' table (aliased as T1) with the 'trip' table (aliased as T2) on the condition that the station ID in the trip table matches the end station ID in the station table.", "Use the MIN() function to calculate the minimum duration of trips for each end station.", "Group the results by end station ID to ensure that we get one result per end station."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T1.name, T1.lat, MIN(T2.duration) \nFROM station AS T1 \nJOIN trip AS T2 ON T1.id = T2.end_station_id \nGROUP BY T2.end_station_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.196", "db_id": "bike_1", "question": "What are all the different zip codes that have a maximum dew point that was always below 70?", "rationale": ["We need to find all unique zip codes where the maximum dew point is always below 70.", "To achieve this, we will select distinct zip codes from the weather table.", "We will apply a condition to filter the records where the max_dew_point_f is less than 70."], "gold_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f < 70", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.205", "db_id": "bike_1", "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.", "rationale": ["We need to find zip codes where the average mean humidity is below 70.", "We can use the 'weather' table to filter for mean humidity less than 70.", "We also need to ensure that at least 100 trips took place for those zip codes.", "To do this, we can use the 'trip' table and group by zip code, counting the number of trips for each zip code.", "We will use a subquery to get the zip codes from the 'trip' table that have at least 100 trips.", "Finally, we will combine these two conditions using an IN clause to filter the zip codes accordingly."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code FROM weather WHERE mean_humidity < 70 AND zip_code IN (SELECT zip_code FROM trip GROUP BY zip_code HAVING COUNT(*) >= 100)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.206", "db_id": "bike_1", "question": "What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?", "rationale": ["We need to find zip codes with an average mean humidity below 70 and at least 100 trips.", "First, we will group the trips by zip code and count the number of trips for each zip code using COUNT(id).", "Next, we will filter these groups using HAVING to ensure that only those with at least 100 trips are included.", "To check the average mean humidity for each zip code, we will use a subquery that calculates the average mean humidity from the weather table for each zip code.", "Finally, we will ensure that this average mean humidity is less than 70 in the HAVING clause."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code \nFROM trip \nWHERE zip_code IS NOT NULL \nGROUP BY zip_code \nHAVING COUNT(id) >= 100 AND \n       (SELECT AVG(mean_humidity) \n        FROM weather \n        WHERE zip_code = trip.zip_code) < 70;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.304", "db_id": "product_catalog", "question": "What are the attribute data types with more than 3 attribute definitions?", "rationale": ["Identify the table that contains the attribute definitions, which is 'Attribute_Definitions'.", "Determine the relevant column that contains the data types of the attributes, which is 'attribute_data_type'.", "To find data types with more than 3 definitions, we need to group the results by 'attribute_data_type'.", "Use the COUNT function to count the number of attribute definitions for each data type.", "Apply the HAVING clause to filter groups where the count is greater than 3."], "gold_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  3", "source_tables": ["attribute_definitions"], "pred_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING COUNT(attribute_id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.316", "db_id": "product_catalog", "question": "Find the entry names of the catalog with the attribute that have the most entries.", "rationale": ["Identify the relevant tables: Catalog_Contents for entry names and Catalog_Contents_Additional_Attributes for attributes.", "Join Catalog_Contents with Catalog_Contents_Additional_Attributes on catalog_entry_id to link entries with their attributes.", "Group the results by catalog_entry_name to count how many attributes each entry has.", "Order the results by the count of attributes in descending order to find the entry with the most attributes.", "Limit the results to 1 to get only the entry name with the most attributes."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT cc.catalog_entry_name \nFROM Catalog_Contents AS cc \nJOIN Catalog_Contents_Additional_Attributes AS cca ON cc.catalog_entry_id = cca.catalog_entry_id \nGROUP BY cc.catalog_entry_name \nORDER BY COUNT(cca.catalog_entry_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.317", "db_id": "product_catalog", "question": "What is the entry name of the most expensive catalog (in USD)?", "rationale": ["Identify the relevant tables: Catalog_Contents for catalog entries and Catalogs for catalog information.", "Join Catalog_Contents with Catalogs to access the catalog details associated with each entry.", "Order the results by price in dollars in descending order to find the most expensive entry.", "Limit the results to 1 to get only the most expensive catalog entry name."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1", "source_tables": ["catalog_contents"], "pred_sql": "SELECT cc.catalog_entry_name FROM Catalog_Contents AS cc JOIN Catalogs AS c ON cc.catalog_level_number = c.catalog_id ORDER BY CAST(cc.price_in_dollars AS REAL) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.330", "db_id": "product_catalog", "question": "What are the names of catalog entries with level number 8?", "rationale": ["Identify the relevant tables: Catalog_Contents for catalog entries and Catalog_Contents_Additional_Attributes for additional attributes including level numbers.", "Join the Catalog_Contents table with the Catalog_Contents_Additional_Attributes table on the catalog_entry_id to link entries with their attributes.", "Filter the results to only include entries where the catalog_level_number is '8'.", "Select the catalog_entry_name from the resulting joined table."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  '8'", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id = t2.catalog_entry_id WHERE t2.catalog_level_number = '8'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.331", "db_id": "product_catalog", "question": "Find the names of the products with length smaller than 3 or height greater than 5.", "rationale": ["Identify the table that contains product information, which is the Catalog_Contents table.", "Determine the relevant columns needed for the query: catalog_entry_name for product names, length for the length condition, and height for the height condition.", "Construct the SELECT statement to retrieve the catalog_entry_name from the Catalog_Contents table.", "Add a WHERE clause to filter products based on the conditions: length smaller than 3 or height greater than 5."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name \nFROM Catalog_Contents \nWHERE length < 3 OR height > 5;", "hint": "\n"}
{"sample_id": "train.332", "db_id": "product_catalog", "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.", "rationale": ["Identify the relevant table: The question asks about catalog contents, which are stored in the 'Catalog_Contents' table.", "Determine the columns needed: We need the 'catalog_entry_name' and the 'length' of the catalog contents.", "Apply the filtering criteria: The question specifies that we want entries with a length below 3 or above 5, so we will use a WHERE clause to filter these results.", "Construct the SQL query: Combine the SELECT statement with the FROM clause and the WHERE clause to form a complete SQL query."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE length < 3 OR length > 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.338", "db_id": "product_catalog", "question": "On which days more than one revisions were made on catalogs.", "rationale": ["Identify the relevant table: The question pertains to revisions made on catalogs, which relates to the 'Catalogs' table.", "Focus on the 'date_of_latest_revision' column: This column indicates when the last revision was made for each catalog.", "Group by the 'date_of_latest_revision': To find out how many revisions were made on each day, we need to group the results by this date.", "Count the number of revisions: Use COUNT(*) to count how many catalogs were revised on each date.", "Filter for days with more than one revision: Use HAVING COUNT(*) > 1 to filter the results to only include days where more than one revision occurred."], "gold_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1", "source_tables": ["catalogs"], "pred_sql": "SELECT date_of_latest_revision, COUNT(*) as revision_count \nFROM Catalogs \nGROUP BY date_of_latest_revision \nHAVING COUNT(*) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their origins and destinations.", "Determine the required columns: We need the 'origin' column for flights headed to Honolulu.", "Specify the condition: We need to filter the results where the 'destination' is 'Honolulu'.", "Construct the SQL query: Combine the selected columns and conditions into a valid SQL statement."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight WHERE destination = 'Honolulu'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the required columns: We need the 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We want flights that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query: Using SELECT to get the required columns from the flight table with the specified conditions."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their prices, origins, and destinations.", "Determine the columns needed: We need the 'price' column to calculate the average price of flights.", "Filter the results: We want to find flights specifically from 'LA' to 'Honolulu', so we will add a WHERE clause to filter by 'origin' and 'destination'.", "Use the AVG() function: To calculate the average price, we will use the AVG() function on the 'price' column.", "Construct the SQL query: Combine all these elements into a single SQL query."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT AVG(price) AS average_price FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["Identify the tables needed: We need data from the 'aircraft' table for aircraft names and from the 'flight' table to count the number of flights.", "Determine the relationship: The 'flight' table has a foreign key 'aid' that relates to the 'aircraft' table's primary key 'aid'.", "Use a LEFT JOIN to include all aircraft even if they have no flights, ensuring we count flights correctly.", "Select the aircraft name and count the number of flights, using COUNT(f.flno) to get the number of flights per aircraft.", "Group the results by aircraft ID and name to aggregate the flight counts correctly."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT a.name, COUNT(f.flno) AS number_of_flights\nFROM aircraft a\nLEFT JOIN flight f ON a.aid = f.aid\nGROUP BY a.aid, a.name;", "hint": "\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables needed: We need data from the 'aircraft' table for aircraft names and from the 'flight' table to count the number of flights.", "We will use a LEFT JOIN to connect the 'aircraft' table with the 'flight' table on the aircraft ID (aid) since we want to include all aircraft even if they have no flights.", "We will use COUNT(f.flno) to count the number of flights for each aircraft. If an aircraft has no flights, it will still be included in the results with a count of 0.", "Finally, we will group the results by the aircraft ID (a.aid) to ensure we get a count for each individual aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT a.name, COUNT(f.flno) AS flight_count\nFROM aircraft a\nLEFT JOIN flight f ON a.aid = f.aid\nGROUP BY a.aid;", "hint": "\n"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["Identify the main table to query: employee.", "We need to find employees who are not certified to fly a specific aircraft (Boeing 737-800).", "To do this, we will use a subquery to find all employee IDs (eid) that are certified to fly the Boeing 737-800.", "The subquery will join the certificate table with the aircraft table to filter by the aircraft name 'Boeing 737-800'.", "The main query will select the names of employees whose IDs are not in the list returned by the subquery."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.name \nFROM employee e \nWHERE e.eid NOT IN (\n    SELECT c.eid \n    FROM certificate c \n    JOIN aircraft a ON c.aid = a.aid \n    WHERE a.name = 'Boeing 737-800'\n);", "hint": "\n"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["We need to find the name of the aircraft with the fewest number of certificates held by employees.", "To do this, we will join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid).", "We will group the results by the aircraft ID to count how many certificates each aircraft has.", "Next, we will order the results by the count of certificates in ascending order to get the aircraft with the fewest certificates at the top.", "Finally, we will limit the results to just one record to get the aircraft with the fewest certificates."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nORDER BY COUNT(c.eid) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.432", "db_id": "flight_1", "question": "What are the names of the aircraft that the least people are certified to fly?", "rationale": ["We need to find the names of aircraft with the least number of certified pilots.", "To do this, we will join the 'aircraft' table with the 'certificate' table on the aircraft ID ('aid').", "We will group the results by the aircraft ID to count how many employees are certified for each aircraft.", "We will use the HAVING clause to filter for those aircraft that have the minimum count of certified employees.", "To find the minimum count, we will use a subquery that counts the number of certifications for each aircraft and selects the minimum count from those counts."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nHAVING COUNT(c.eid) = (\n    SELECT MIN(cert_count)\n    FROM (\n        SELECT COUNT(eid) AS cert_count\n        FROM certificate\n        GROUP BY aid\n    ) AS counts\n);", "hint": "\n"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["Identify the relevant tables: employee, certificate, and aircraft.", "We need to find employees who have certificates to fly aircraft with a distance greater than 5000.", "Join the employee table with the certificate table on employee ID (eid) and then join with the aircraft table on aircraft ID (aid).", "Filter the results to include only those aircraft where the distance is greater than 5000.", "Group the results by employee ID to count the number of certificates each employee has.", "Order the results by the count of certificates in descending order to find the employee with the most certificates.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.salary, e.name \nFROM employee e \nJOIN certificate c ON e.eid = c.eid \nJOIN aircraft a ON c.aid = a.aid \nWHERE a.distance > 5000 \nGROUP BY e.eid \nORDER BY COUNT(c.aid) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The user is asking for all the different food allergies, which implies we need to retrieve unique allergy names.", "We will use the 'Has_Allergy' table since it contains the allergies associated with students.", "To get distinct allergy names, we will use the SELECT DISTINCT statement on the 'Allergy' column from the 'Has_Allergy' table."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Has_Allergy", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.452", "db_id": "allergy_1", "question": "How many animal type allergies exist?", "rationale": ["The question asks for the count of animal type allergies.", "To find this, we need to join the 'Has_Allergy' table with the 'Allergy_Type' table to access the allergy types.", "We will filter the results to only include those allergies that are categorized as 'Animal'.", "Finally, we will use COUNT(DISTINCT ...) to count the unique animal type allergies."], "gold_sql": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  'animal'", "source_tables": ["allergy_type"], "pred_sql": "SELECT COUNT(DISTINCT T2.allergytype) FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.allergy = T2.allergy WHERE T2.allergytype = 'Animal';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["Identify the tables involved: 'Has_Allergy' for student allergies and 'Allergy_Type' for allergy types.", "Join the 'Has_Allergy' table with the 'Allergy_Type' table on the Allergy column to associate students with their allergy types.", "Group the results by AllergyType to count how many allergies fall under each type.", "Use COUNT(*) to get the number of allergies for each type.", "Order the results in descending order based on the count of allergies to find the most common allergy type.", "Limit the results to 1 to get only the allergy type with the highest count."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT T2.AllergyType, COUNT(*) as AllergyCount \nFROM Has_Allergy AS T1 \nJOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \nGROUP BY T2.AllergyType \nORDER BY AllergyCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["The question asks for the least common allergy type, which implies we need to count the occurrences of each allergy type.", "To achieve this, we will join the 'Has_Allergy' table with the 'Allergy_Type' table on the Allergy column.", "We will group the results by the allergy type to get the count of students for each type.", "Next, we will order the results in ascending order based on the count to find the least common allergy type.", "Finally, we will limit the results to 1 to get only the least common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT T2.allergytype, COUNT(*) as allergy_count \nFROM Has_Allergy AS T1 \nJOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \nGROUP BY T2.allergytype \nORDER BY allergy_count ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student names, which is the 'Student' table.", "To get the full names, we need to concatenate the 'Fname' and 'LName' columns.", "Use the SQL SELECT statement to retrieve the concatenated names as 'FullName'."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName FROM Student;", "hint": "\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the table that contains student information, which is the 'Student' table.", "Determine the relevant column for filtering by gender, which is 'Sex'.", "Specify the condition to filter for male students, which is 'Sex = 'Male''.", "Select the 'StuID' column to retrieve the unique identifiers for the male students."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the majors, which is the 'Student' table.", "We need to group the results by the 'Major' column to count how many students are in each major.", "Order the results in descending order based on the count of students in each major to find the largest major.", "Limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major and ordered by the number of students in each major in descending order. The placeholder in the LIMIT clause represents the maximum number of majors to return.\",\n        \"virtual_table\": \"SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.502", "db_id": "allergy_1", "question": "Give the advisor with the most students.", "rationale": ["Identify the relevant table: The 'Student' table contains information about students and their advisors.", "Determine the required information: We need to find the advisor with the most students, which involves counting the number of students for each advisor.", "Use the COUNT function: This function will help us count the number of students associated with each advisor.", "Group the results: We will group the results by the advisor's name to aggregate the student counts correctly.", "Order the results: We will order the results in descending order based on the student count to get the advisor with the most students at the top.", "Limit the results: Since we only want the advisor with the most students, we will limit our results to 1."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(*) as StudentCount FROM Student GROUP BY Advisor ORDER BY StudentCount DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of academic advisors from the 'Student' table, grouped by the advisor's name. The results are ordered by the number of students assigned to each advisor in descending order, with a limit on the number of advisors returned, specified by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["Identify the relevant table: The 'Has_Allergy' table contains information about which students have which allergies.", "Determine the specific allergy of interest: The question asks about students with cat allergies.", "Construct the SQL query: Use the COUNT function to count the number of entries in the 'Has_Allergy' table where the Allergy column matches 'cat'."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(*) FROM Has_Allergy WHERE Allergy = 'cat';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the relevant tables: Has_Allergy and Student.", "We need to count the number of students affected by cat allergies, so we will use COUNT(*) to get the total number.", "Join the Has_Allergy table with the Student table on StuID to link students with their allergies.", "Filter the results where the Allergy is 'cat allergies'.", "Construct the SQL query using the above logic."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(*) FROM Has_Allergy AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.Allergy = 'cat allergies'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the tables needed: Has_Allergy for allergies and Student for student details.", "We need to count the number of students, so we will use the COUNT function.", "Join the Has_Allergy table with the Student table on StuID to link students with their allergies.", "Filter the results to include only female students by adding a condition in the WHERE clause: T2.Sex = 'Female'.", "Add another condition to check if the allergy is either 'Milk' or 'Eggs' using the OR operator.", "Combine these conditions in the WHERE clause to filter the results accordingly."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T2.Sex = 'Female' AND (T1.Allergy = 'Milk' OR T1.Allergy = 'Eggs')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.514", "db_id": "allergy_1", "question": "Which allergy is the most common?", "rationale": ["The question asks for the most common allergy, which implies we need to count occurrences of allergies.", "We will join the 'Has_Allergy' table with the 'Allergy_Type' table to get the allergy types associated with each student.", "Using COUNT(*) will allow us to count how many students have each type of allergy.", "We will group the results by the allergy type to aggregate the counts for each type.", "To find the most common allergy, we will order the results in descending order based on the count of students for each allergy type.", "Finally, we will limit the results to 1 to get only the most common allergy."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT T2.allergytype, count(*) as allergy_count FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy GROUP BY T2.allergytype ORDER BY allergy_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["Identify the tables needed: We need to retrieve student information (last name and age) and their allergies, so we will use the Student and Has_Allergy tables.", "Determine the relationships: The Has_Allergy table links students to their allergies via StuID. We will need to join the Has_Allergy table twice to check for both allergies (milk and cat).", "Select the required columns: We need to select the last name (LName) and age (Age) of the student from the Student table.", "Construct the SQL query: We will join the Student table with the Has_Allergy table twice, once for each allergy, and filter the results to include only those students who have both allergies."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.LName, S.Age \nFROM Student AS S \nJOIN Has_Allergy AS H1 ON S.StuID = H1.StuID \nJOIN Has_Allergy AS H2 ON S.StuID = H2.StuID \nWHERE H1.Allergy = 'milk' AND H2.Allergy = 'cat';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the tables needed: We need to retrieve student information (last names and ages) and their allergies, so we will use the 'Student' and 'Has_Allergy' tables.", "Determine the columns to select: We need the last names (LName) and ages (Age) of the students.", "Establish the relationship between tables: The 'Has_Allergy' table links students to their allergies through the StuID column, which is common in both tables.", "Filter the results: We want to find students who are allergic to 'milk' or 'cat', so we will use a WHERE clause with an IN condition to filter allergies.", "Construct the SQL query: Combine all the elements into a complete SQL query that selects the required columns from the joined tables with the specified conditions."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.LName, S.Age FROM Student AS S JOIN Has_Allergy AS H ON S.StuID = H.StuID WHERE H.Allergy IN ('milk', 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.523", "db_id": "allergy_1", "question": "Find the first name and gender of the student who has allergy to milk but not cat.", "rationale": ["Identify the tables needed: We need data from the Student and Has_Allergy tables.", "We want to select the first name (Fname) and gender (Sex) of students.", "We need to filter students who have an allergy to 'milk'.", "Additionally, we need to ensure that these students do not have an allergy to 'cat'.", "To achieve this, we can use a subquery to find all students with a 'cat' allergy and exclude them from our main query.", "Join the Student table with the Has_Allergy table on StuID to get the relevant information about students and their allergies."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex FROM Student AS S JOIN Has_Allergy AS H ON S.StuID = H.StuID WHERE H.Allergy = 'milk' AND S.StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.524", "db_id": "allergy_1", "question": "What are the first name and gender of the students who have allergy to milk but can put up with cats?", "rationale": ["Identify the relevant tables: We need to retrieve student information from the 'Student' table and allergy information from the 'Has_Allergy' table.", "Determine the required fields: We need the first name (Fname) and gender (Sex) of the students.", "Set the conditions for the query: We want students who have an allergy to milk. This means we will filter the 'Has_Allergy' table for records where Allergy = 'milk'.", "Additionally, we want to exclude students who have an allergy to cats. This can be done using a subquery that selects StuID from 'Has_Allergy' where Allergy = 'cats'.", "Join the 'Student' and 'Has_Allergy' tables on StuID to combine student data with their allergy information.", "Construct the SQL query using the identified fields and conditions."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex FROM Student AS S JOIN Has_Allergy AS H ON S.StuID = H.StuID WHERE H.Allergy = 'milk' AND S.StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'cats')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the tables needed: We need to get student ages from the Student table and filter allergies from the Has_Allergy and Allergy_Type tables.", "Join the tables: We will join the Student table with the Has_Allergy table on StuID, and then join with the Allergy_Type table on Allergy.", "Filter by allergy types: We need to filter the results to include only those allergies that are categorized as 'food' or 'animal'.", "Calculate the average age: We will use the AVG function to calculate the average age of the filtered students."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT AVG(CAST(Age AS INTEGER)) FROM Student AS S JOIN Has_Allergy AS HA ON S.StuID = HA.StuID JOIN Allergy_Type AS AT ON HA.Allergy = AT.Allergy WHERE AT.AllergyType IN ('food', 'animal')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["Identify the tables involved: We need to retrieve student names from the 'Student' table and check for allergies in the 'Has_Allergy' table.", "We want to find students who are not allergic to any type of food, which means we need to exclude those who have entries in the 'Has_Allergy' table.", "To achieve this, we can use a subquery that selects all 'StuID's from the 'Has_Allergy' table.", "The main query will select the first name (Fname) and last name (LName) of students whose 'StuID' is not in the list returned by the subquery."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname, LName FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["Identify the relevant tables: Has_Allergy, Student, and Allergy_Type.", "We need to count the number of male students (Sex = 'M') who have allergies related to food.", "Join the Has_Allergy table with the Student table on StuID to filter by gender.", "Join the Allergy_Type table to filter allergies specifically related to food.", "Use a WHERE clause to specify the conditions for male students and food allergies.", "Use the COUNT function to get the total number of male students with food allergies."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID JOIN Allergy_Type AS T3 ON T1.Allergy = T3.Allergy WHERE T2.Sex = 'M' AND T3.AllergyType = 'Food'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables needed: We need data from the Student and Has_Allergy tables.", "We want to find students with specific allergies (milk or cat), so we will join the Has_Allergy table with the Student table on StuID.", "We need to select distinct first names and city codes of students, so we will use SELECT DISTINCT to avoid duplicates.", "The WHERE clause will filter the results to include only those students who have allergies to either milk or cat using the IN operator."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code \nFROM Student AS S \nJOIN Has_Allergy AS HA ON S.StuID = HA.StuID \nWHERE HA.Allergy IN ('milk', 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["Identify the tables needed: We need data from the Student and Has_Allergy tables.", "We want distinct first names and cities, so we will select S.Fname and S.city_code.", "We need to join the Student table with the Has_Allergy table on StuID to link students with their allergies.", "We filter the results to include only those students who have allergies to either 'milk' or 'cat'.", "Use the IN clause to specify the allergies we are interested in: 'milk' and 'cat'.", "Finally, we use DISTINCT to ensure that we only get unique combinations of first names and city codes."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code \nFROM Student AS S \nJOIN Has_Allergy AS H ON S.StuID = H.StuID \nWHERE H.Allergy IN ('milk', 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["The query needs to find the names of countries and the average invoice size for each country.", "We will select the 'billing_country' from the 'invoices' table.", "To calculate the average invoice size, we will use the AVG() function on the 'total' column from the 'invoices' table.", "We need to group the results by 'billing_country' to get the average for each country.", "Finally, we will order the results by the average invoice size in descending order to get the top countries by size."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size \nFROM invoices \nGROUP BY billing_country \nORDER BY AVG(total) DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["We need to count the number of invoices for each state.", "The relevant table for invoices is the 'invoices' table, which contains a 'billing_state' column.", "To get the count of invoices per state, we can use the COUNT() function.", "We will group the results by 'billing_state' to get the count for each state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count FROM invoices GROUP BY billing_state;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["We need to find the states with the most invoices, which means we need to count the number of invoices per state.", "The relevant table for this information is the 'invoices' table, which contains a 'billing_state' column.", "We will use the COUNT() function to count the number of invoices for each state.", "To group the results by state, we will use the GROUP BY clause on the 'billing_state' column.", "Finally, we will order the results in descending order based on the count of invoices to get the states with the most invoices at the top."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count \nFROM invoices \nGROUP BY billing_state \nORDER BY invoice_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.568", "db_id": "store_1", "question": "What is the number of invoices and total money billed in them from CA?", "rationale": ["Identify the relevant table: invoices, which contains billing information.", "Determine the required fields: count of invoices and total amount billed.", "Use COUNT(*) to get the number of invoices and SUM(total) to calculate the total amount billed.", "Filter the results by the state 'CA' using a WHERE clause."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS number_of_invoices, SUM(total) AS total_billed FROM invoices WHERE billing_state = 'CA';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the table that contains the required information: The 'employees' table has the email and phone number of employees.", "Determine the specific employee: The question asks for Astrid Gruber, so we need to filter by first name 'Astrid' and last name 'Gruber'.", "Construct the SQL query to select the email and phone columns from the employees table where the first and last names match."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the street address of employees from the 'employees' table based on their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the employee being queried.\",\n        \"virtual_table\": \"SELECT address FROM employees WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["Identify the relevant table: The question asks about customers, so we will use the 'customers' table.", "Determine the condition: We need to count customers from California, which is specified in the 'state' column.", "Construct the SQL query: We will use the COUNT function to count the number of customers where the state is 'California'."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) FROM customers WHERE state = 'California';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: We need to find employees and their associated customers, so we will use the 'employees' and 'customers' tables.", "Join the tables: We will join the 'employees' table with the 'customers' table on the condition that the employee's ID matches the support representative ID in the customers table.", "Group by employee: To count how many customers each employee supports, we will group the results by employee ID.", "Count customers: We will use COUNT(c.id) to count the number of customers for each employee.", "Order by count: We will order the results in descending order based on the count of customers supported by each employee.", "Limit to one: Since we only want the employee who supports the most customers, we will limit the results to 1."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees who report to a specific manager from the 'employees' table. The placeholders in the WHERE clause represent the first and last names of the manager.\",\n        \"virtual_table\": \"SELECT T2.first_name , T2.last_name FROM employees AS T1 JOIN employees AS T2 ON T1.id = T2.reports_to WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["Identify the customer by name: 'Luca Mancini'.", "Use the customers table to find the id of Luca Mancini.", "Count the number of invoices associated with that customer id in the invoices table."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "pred_sql": "SELECT COUNT(*) FROM invoices WHERE customer_id IN (SELECT id FROM customers WHERE first_name = 'Luca' AND last_name = 'Mancini');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["Identify the track 'Balls to the Wall' in the tracks table.", "Join the tracks table with the albums table using the album_id foreign key.", "Select the title of the album that corresponds to the identified track."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT albums.title \nFROM albums \nJOIN tracks ON albums.id = tracks.album_id \nWHERE tracks.name = 'Balls to the Wall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\",\n        \"virtual_table\": \"SELECT title FROM albums WHERE title LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY title;\"\n    }\n}\n"}
{"sample_id": "train.626", "db_id": "store_1", "question": "What is the name of all tracks in the album named Balls to the Wall?", "rationale": ["Identify the relevant tables: We need to retrieve track names, which are stored in the 'tracks' table, and we need to filter these tracks based on the album title, which is stored in the 'albums' table.", "Establish the relationship: The 'tracks' table has a foreign key 'album_id' that references the 'id' in the 'albums' table. This means we can join these two tables on this key to get the necessary information.", "Formulate the SQL query: We will select the track names from the 'tracks' table and join it with the 'albums' table to filter by the album title 'Balls to the Wall'.", "Use the WHERE clause to specify that we only want tracks from the album with the title 'Balls to the Wall'."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN albums ON tracks.album_id = albums.id \nWHERE albums.title = 'Balls to the Wall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\",\n        \"virtual_table\": \"SELECT title FROM albums WHERE title LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY title;\"\n    }\n}\n"}
{"sample_id": "train.630", "db_id": "store_1", "question": "What are the names of all Rock tracks that are stored on MPEG audio files?", "rationale": ["Identify the relevant tables: tracks, media_types, and genres.", "We need to find the names of tracks, so we will select the 'name' column from the tracks table.", "To filter by genre, we will join the genres table on the genre_id column of the tracks table.", "To filter by media type, we will join the media_types table on the media_type_id column of the tracks table.", "The WHERE clause will specify that we want tracks where the genre name is 'Rock' and the media type name is 'MPEG audio'."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN media_types ON tracks.media_type_id = media_types.id \nJOIN genres ON tracks.genre_id = genres.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG audio';", "hint": "\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the tables involved: tracks, genres, and media_types.", "We need to select the track names from the tracks table.", "To filter tracks by genre, we join the genres table on the genre_id column of the tracks table.", "To filter tracks by media type, we join the media_types table on the media_type_id column of the tracks table.", "We apply a WHERE clause to filter for tracks that belong to the 'Rock' genre and have a media type of 'MPEG'."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN genres ON tracks.genre_id = genres.id \nJOIN media_types ON tracks.media_type_id = media_types.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG';", "hint": "\n"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["Identify the relevant tables: We need to find tracks that a specific customer (Dean Peeters) bought, so we will use the 'tracks', 'invoice_lines', 'invoices', and 'customers' tables.", "Join the tables: We will join 'tracks' with 'invoice_lines' on the track ID, then join 'invoice_lines' with 'invoices' on the invoice ID, and finally join 'invoices' with 'customers' on the customer ID. This will allow us to link tracks to the specific customer.", "Filter by customer name: We will add a WHERE clause to filter the results to only include purchases made by Dean Peeters, using both first and last name."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN invoice_lines ON tracks.id = invoice_lines.track_id \nJOIN invoices ON invoice_lines.invoice_id = invoices.id \nJOIN customers ON invoices.customer_id = customers.id \nWHERE customers.first_name = 'Dean' AND customers.last_name = 'Peeters';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\",\n        \"virtual_table\": \"SELECT title FROM albums WHERE title LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY title;\"\n    }\n}\n"}
{"sample_id": "train.686", "db_id": "customers_card_transactions", "question": "What are the full names of customers who do not have any accounts?", "rationale": ["We need to find customers who do not have any accounts.", "To do this, we can use a LEFT JOIN between the Customers table and a virtual table that counts the number of accounts per customer from the Accounts table.", "The virtual table will select customer_id and count the number of accounts grouped by customer_id.", "The LEFT JOIN will allow us to include all customers, even those without accounts, and we can filter for those with a NULL account count.", "Finally, we select the first and last names of these customers."], "gold_sql": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_first_name, c.customer_last_name \nFROM Customers c \nLEFT JOIN (SELECT customer_id, COUNT(*) as account_count FROM Accounts GROUP BY customer_id) a \nON c.customer_id = a.customer_id \nWHERE a.account_count IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\",\n        \"virtual_table\": \"SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers\"\n    }\n}\n"}
{"sample_id": "train.688", "db_id": "customers_card_transactions", "question": "What are the full names of customers who have accounts?", "rationale": ["We need to find the full names of customers who have accounts, which means we need to join the Customers table with the Accounts table.", "The first step is to create a virtual table that counts the number of accounts for each customer. This is done using the SQL query: 'SELECT customer_id, count(*) FROM Accounts GROUP BY customer_id'.", "Next, we need to select the first name and last name of customers from the Customers table. This can be done with the query: 'SELECT customer_id, customer_first_name, customer_last_name FROM Customers'.", "To get the full names of customers who have accounts, we will join the results of the first virtual table (account counts) with the Customers table on the customer_id field.", "The final SQL query will select the first and last names from the Customers table where there is a matching customer_id in the virtual table that counts accounts."], "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_first_name, c.customer_last_name \nFROM Customers c \nJOIN (SELECT customer_id, count(*) \n      FROM Accounts \n      GROUP BY customer_id) a \nON c.customer_id = a.customer_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\",\n        \"virtual_table\": \"SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers\"\n    }\n}\n"}
{"sample_id": "train.704", "db_id": "customers_card_transactions", "question": "Return the full name and phone of the customer who has card number 4560596484842.", "rationale": ["Identify the required information: full name and phone number of the customer.", "The full name can be constructed by concatenating the first name and last name from the Customers table.", "To find the customer associated with a specific card number, we need to join the Customers table with the Customers_Cards table using the customer_id.", "The inner query selects the customer_id from the Customers_Cards table where the card_number matches '4560596484842'.", "The outer query selects the full name and phone number from the Customers table where the customer_id is in the result of the inner query."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.card_number  =  '4560596484842'", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name, customer_phone FROM Customers WHERE customer_id IN (SELECT customer_id FROM Customers_Cards WHERE card_number = '4560596484842')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers\"\n    }\n}\n"}
{"sample_id": "train.717", "db_id": "customers_card_transactions", "question": "What is the customer id, first and last name with least number of accounts.", "rationale": ["We need to find the customer with the least number of accounts.", "First, we can summarize the number of accounts associated with each customer using a subquery that counts the accounts grouped by customer_id.", "Next, we will join this subquery with the Customers table to get the customer details (customer_id, first name, last name).", "Finally, we will order the results by the account count in ascending order and limit the result to 1 to get the customer with the least number of accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name \nFROM Customers c \nJOIN (SELECT customer_id, COUNT(*) as account_count \n      FROM Accounts \n      GROUP BY customer_id) a \nON c.customer_id = a.customer_id \nORDER BY a.account_count ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\",\n        \"virtual_table\": \"SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id\"\n    }\n}\n"}
{"sample_id": "train.718", "db_id": "customers_card_transactions", "question": "Return the id and full name of the customer who has the fewest accounts.", "rationale": ["We need to find the customer with the fewest accounts.", "The hint provides a virtual table that summarizes the number of accounts per customer using a GROUP BY clause on the Accounts table.", "We will use this virtual table to join with the Customers table to get the customer's details.", "We select the customer_id and concatenate the first and last name to get the full name.", "To find the customer with the fewest accounts, we will order the results by account count in ascending order and limit the result to 1."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name \nFROM Customers c \nJOIN (SELECT customer_id, COUNT(*) AS account_count \n      FROM Accounts \n      GROUP BY customer_id) AS account_summary \nON c.customer_id = account_summary.customer_id \nORDER BY account_count ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\",\n        \"virtual_table\": \"SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id\"\n    }\n}\n"}
{"sample_id": "train.721", "db_id": "customers_card_transactions", "question": "What is the card type code with most number of cards?", "rationale": ["Identify the relevant table: Customers_Cards contains the card type codes.", "We need to count the number of cards for each card type code.", "Use GROUP BY to group the results by card_type_code.", "Use COUNT(*) to count the number of cards for each type.", "Order the results in descending order based on the count to get the most frequent card type code at the top.", "Limit the results to 1 to get only the card type code with the most number of cards."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "pred_sql": "SELECT card_type_code FROM Customers_Cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table summarizes the different types of cards issued to customers, displaying the card type codes from the 'Customers_Cards' table. The results are grouped by card type code and ordered by the frequency of each type, allowing the user to specify a limit on the number of types returned.\",\n        \"virtual_table\": \"SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.735", "db_id": "customers_card_transactions", "question": "Show the number of transaction types.", "rationale": ["The user wants to show the number of transaction types.", "To achieve this, we need to count the occurrences of each transaction type in the 'Financial_Transactions' table.", "We will use the COUNT function to aggregate the total number of transactions for each type.", "The SQL query will select the 'transaction_type' and the count of transactions, grouping the results by 'transaction_type' to get the desired summary."], "gold_sql": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, COUNT(*) as transaction_count FROM Financial_Transactions GROUP BY transaction_type", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions associated with each account from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account identifier, while the count function aggregates the total number of transactions for each account.\",\n        \"virtual_table\": \"SELECT account_id ,  count(*) FROM Financial_transactions GROUP BY account_id\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table summarizes the different types of cards issued to customers, displaying the card type codes from the 'Customers_Cards' table. The results are grouped by card type code and ordered by the frequency of each type, allowing the user to specify a limit on the number of types returned.\",\n        \"virtual_table\": \"SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.743", "db_id": "customers_card_transactions", "question": "What is the transaction type that has processed the greatest total amount in transactions?", "rationale": ["We need to find the transaction type with the greatest total amount in transactions.", "To do this, we will select the 'transaction_type' and the sum of 'transaction_amount' from the 'Financial_Transactions' table.", "We will group the results by 'transaction_type' to aggregate the amounts for each type.", "Next, we will order the results in descending order based on the total amount to get the highest one at the top.", "Finally, we will limit the results to just one record to get the transaction type with the greatest total amount."], "gold_sql": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, SUM(transaction_amount) AS total_amount \nFROM Financial_Transactions \nGROUP BY transaction_type \nORDER BY total_amount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions associated with each account from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account identifier, while the count function aggregates the total number of transactions for each account.\",\n        \"virtual_table\": \"SELECT account_id ,  count(*) FROM Financial_transactions GROUP BY account_id\"\n    }\n}\n"}
{"sample_id": "train.893", "db_id": "insurance_fnol", "question": "What are the customer phone numbers under the policy \"Life Insurance\"?", "rationale": ["Identify the relevant tables: Available_Policies, Customers_Policies, and Customers.", "We need to retrieve customer phone numbers, which are in the Available_Policies table.", "Join the Available_Policies table with the Customers_Policies table on Policy_ID to link policies to customers.", "Join the Customers_Policies table with the Customers table on Customer_ID to access customer details.", "Filter the results to only include policies of type 'Life Insurance' using a WHERE clause."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "pred_sql": "SELECT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nJOIN Customers c ON cp.Customer_ID = c.Customer_ID \nWHERE ap.policy_type_code = 'Life Insurance';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.895", "db_id": "insurance_fnol", "question": "Which policy type has the most records in the database?", "rationale": ["Identify the table that contains policy types, which is 'Available_Policies'.", "We need to group the records by 'policy_type_code' to count how many records exist for each type.", "Use the COUNT function to count the occurrences of each policy type.", "Order the results in descending order to get the most common policy type at the top.", "Limit the results to 1 to get only the policy type with the most records."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "pred_sql": "SELECT policy_type_code FROM Available_Policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.897", "db_id": "insurance_fnol", "question": "What are all the customer phone numbers under the most popular policy type?", "rationale": ["Identify the most popular policy type by counting occurrences in the Available_Policies table.", "Use a subquery to select the policy_type_code that has the highest count, limiting the result to 1.", "Join the Available_Policies table with the Customers_Policies table to link policies to customers.", "Select distinct customer phone numbers from the Available_Policies table where the policy type matches the most popular policy type."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nJOIN (\n    SELECT policy_type_code \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    ORDER BY count(*) DESC \n    LIMIT 1\n) AS most_popular_policy ON ap.policy_type_code = most_popular_policy.policy_type_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.898", "db_id": "insurance_fnol", "question": "Find the phone numbers of customers using the most common policy type among the available policies.", "rationale": ["Identify the goal: We need to find the phone numbers of customers who are using the most common policy type.", "Understand the schema: We have tables for Customers, Policies, and a table that links customers to their policies.", "Use the hint provided: The hint gives a virtual table that summarizes policy types and identifies the most common one.", "Construct a subquery to find the most common policy type using the provided virtual table structure.", "Join the Customers table with Customers_Policies to link customers to their policies.", "Join the Available_Policies table to filter by the most common policy type found in the subquery.", "Select the Customer_Phone from the resulting joined tables."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT c.Customer_Phone \nFROM Customers c \nJOIN Customers_Policies cp ON c.Customer_ID = cp.Customer_ID \nJOIN Available_Policies ap ON cp.Policy_ID = ap.Policy_ID \nWHERE ap.policy_type_code = (\n    SELECT policy_type_code \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    ORDER BY count(*) DESC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1060", "db_id": "match_season", "question": "Show the players from college UCLA.", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their college.", "Determine the condition: We need to filter players based on their college, specifically those who attended UCLA.", "Use a subquery: Since the 'player' table does not directly contain college information, we will use a subquery to find the teams associated with UCLA from the 'match_season' table.", "Construct the subquery: The subquery will select 'Team_id' from 'match_season' where 'College' is 'UCLA'.", "Combine the main query and subquery: The main query will select 'Player' from the 'player' table where the 'Team' is in the result of the subquery."], "gold_sql": "SELECT Player FROM match_season WHERE College  =  'UCLA'", "source_tables": ["match_season"], "pred_sql": "SELECT Player FROM player WHERE Team IN (SELECT Team_id FROM match_season WHERE College = 'UCLA');", "hint": "\n"}
{"sample_id": "train.1082", "db_id": "match_season", "question": "Show the season, the player, and the name of the team that players belong to.", "rationale": ["The user wants to retrieve the season, player, and team name.", "We need to access the 'match_season' table to get the season and player information.", "To get the team name associated with each player, we will join the 'match_season' table with the 'team' table using the 'Team' identifier.", "The SQL query will select the 'Season' and 'Player' from 'match_season' and the 'Name' from 'team'."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "pred_sql": "SELECT T1.Season, T1.Player, T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team = T2.Team_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of match seasons, including the season name, player name, and the corresponding team name. The data is retrieved from the 'match_season' table, which is joined with the 'team' table to associate each player with their respective team using the team identifier.\",\n        \"virtual_table\": \"SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\",\n        \"virtual_table\": \"SELECT T2.Season ,  T2.Player ,  T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country\"\n    }\n}\n"}
{"sample_id": "train.1092", "db_id": "match_season", "question": "Show the country names and the corresponding number of players.", "rationale": ["We need to show the country names and the corresponding number of players.", "To achieve this, we will join the 'country' table with the 'match_season' table using the country identifier.", "The 'country' table contains the country names, and the 'match_season' table contains the players associated with those countries.", "We will use a COUNT function to count the number of players for each country.", "Finally, we will group the results by country name to get the count for each individual country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "pred_sql": "SELECT T1.Country_name, COUNT(T2.Player) AS Number_of_Players \nFROM country AS T1 \nJOIN match_season AS T2 ON T1.Country_id = T2.Country \nGROUP BY T1.Country_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct official native languages of countries represented by players in a specific position during matches. The placeholder in the WHERE clause represents the player's position.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T1.Official_native_language) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\",\n        \"virtual_table\": \"SELECT T2.Season ,  T2.Player ,  T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country\"\n    }\n}\n"}
{"sample_id": "train.1098", "db_id": "match_season", "question": "Show the top 3 most common colleges of players in match seasons.", "rationale": ["We need to find the top 3 most common colleges of players in match seasons.", "To do this, we will query the 'match_season' table, which contains a column for 'College'.", "We will use the COUNT function to count how many players are associated with each college.", "We will group the results by 'College' to aggregate the counts for each college.", "To get the most common colleges, we will order the results in descending order based on the count of players.", "Finally, we will limit the results to the top 3 colleges."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as College_Count FROM match_season GROUP BY College ORDER BY College_Count DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\",\n        \"virtual_table\": \"SELECT T2.Season ,  T2.Player ,  T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of match seasons, including the season name, player name, and the corresponding team name. The data is retrieved from the 'match_season' table, which is joined with the 'team' table to associate each player with their respective team using the team identifier.\",\n        \"virtual_table\": \"SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id\"\n    }\n}\n"}
{"sample_id": "train.1099", "db_id": "match_season", "question": "What are the three colleges from which the most players are from?", "rationale": ["Identify the relevant table: The 'match_season' table contains the 'College' column and player information.", "We need to count the number of players from each college, so we will use the COUNT() function.", "Group the results by 'College' to aggregate the player counts for each college.", "Order the results in descending order based on the player count to get the colleges with the most players at the top.", "Limit the results to the top three colleges using LIMIT 3."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as Player_Count \nFROM match_season \nGROUP BY College \nORDER BY Player_Count DESC \nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.1107", "db_id": "match_season", "question": "Return the names of countries that have players that play the Forward position, as well as players who play the Defender position.", "rationale": ["We need to find the names of countries that have players in specific positions (Forward and Defender).", "To do this, we will join the 'country' table with the 'match_season' table on the country identifier (Country_id).", "We will filter the results based on the player's position using a WHERE clause that checks if the position is either 'Forward' or 'Defender'.", "Finally, we will select distinct country names to avoid duplicates in the results."], "gold_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "pred_sql": "SELECT DISTINCT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id = T2.Country WHERE T2.Position IN ('Forward', 'Defender')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct official native languages of countries represented by players in a specific position during matches. The placeholder in the WHERE clause represents the player's position.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T1.Official_native_language) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\",\n        \"virtual_table\": \"SELECT T2.Season ,  T2.Player ,  T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country\"\n    }\n}\n"}
{"sample_id": "train.1109", "db_id": "match_season", "question": "Return the colleges that have players who play the Midfielder position, as well as players who play the Defender position.", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players, their positions, and the colleges they attended.", "Determine the required positions: We need to filter players who play as 'Midfielder' or 'Defender'.", "Use the SELECT statement to retrieve the 'College' column from the 'match_season' table.", "Apply a WHERE clause to filter the results based on the specified positions using the IN operator.", "Use DISTINCT to ensure that each college is listed only once in the results."], "gold_sql": "SELECT College FROM match_season WHERE POSITION  =  'Midfielder' INTERSECT SELECT College FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "pred_sql": "SELECT DISTINCT College \nFROM match_season \nWHERE Position IN ('Midfielder', 'Defender');", "hint": "\n"}
{"sample_id": "train.1222", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with type code \"Duplex\"?", "rationale": ["Identify the relevant tables: We need to access the Apartments and Apartment_Bookings tables to get the booking dates.", "Determine the necessary columns: We need the booking start and end dates from the Apartment_Bookings table.", "Establish the relationship: The Apartments table is linked to the Apartment_Bookings table through the apt_id column.", "Filter by apartment type: We need to filter the results to only include apartments with the type code 'Duplex'.", "Construct the SQL query: Combine the selected columns, join conditions, and where clause to form the complete SQL query."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  'Duplex'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartments a \nJOIN Apartment_Bookings ab ON a.apt_id = ab.apt_id \nWHERE a.apt_type_code = 'Duplex';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1224", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with more than 2 bedrooms?", "rationale": ["Identify the relevant tables: We need information from the Apartments and Apartment_Bookings tables.", "Determine the columns needed: We need the booking start and end dates from the Apartment_Bookings table.", "Filter criteria: We want apartments with more than 2 bedrooms, which is a condition on the Apartments table.", "Join the tables: We will join Apartments with Apartment_Bookings on the apt_id to get the necessary information.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartments a \nJOIN Apartment_Bookings ab ON a.apt_id = ab.apt_id \nWHERE a.bedroom_count > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1225", "db_id": "apartment_rentals", "question": "Find the booking start date and end date for the apartments that have more than two bedrooms.", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "Determine the columns needed: booking_start_date and booking_end_date from Apartment_Bookings.", "Filter apartments with more than two bedrooms using the bedroom_count column from Apartments.", "Join Apartment_Bookings with Apartments on the apt_id to correlate bookings with their respective apartments."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT booking_start_date, booking_end_date \nFROM Apartment_Bookings \nJOIN Apartments ON Apartment_Bookings.apt_id = Apartments.apt_id \nWHERE bedroom_count > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1229", "db_id": "apartment_rentals", "question": "Which apartments have bookings with status code \"Confirmed\"? Return their apartment numbers.", "rationale": ["Identify the relevant tables: Apartments and Apartment_Bookings are needed to find apartments with confirmed bookings.", "Join the Apartments table with the Apartment_Bookings table on the apt_id to link apartments with their bookings.", "Filter the results to include only those bookings where the booking_status_code is 'Confirmed'.", "Select the apt_number from the Apartments table to return the apartment numbers that meet the criteria."], "gold_sql": "SELECT DISTINCT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  'Confirmed'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT apt_number FROM Apartments a\nJOIN Apartment_Bookings ab ON a.apt_id = ab.apt_id\nWHERE ab.booking_status_code = 'Confirmed';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1232", "db_id": "apartment_rentals", "question": "Show the guest first names, start dates, and end dates of all the apartment bookings.", "rationale": ["Identify the required fields: guest first names, booking start dates, and booking end dates.", "Determine the relevant tables: 'Apartment_Bookings' for booking details and 'Guests' for guest information.", "Establish the relationship between the tables: 'Apartment_Bookings' has a foreign key 'guest_id' that links to 'Guests'.", "Construct the SQL query using a SELECT statement to retrieve the desired fields from the joined tables."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT Guests.guest_first_name, Apartment_Bookings.booking_start_date, Apartment_Bookings.booking_end_date\nFROM Apartment_Bookings\nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1234", "db_id": "apartment_rentals", "question": "Show the start dates and end dates of all the apartment bookings made by guests with gender code \"Female\".", "rationale": ["Identify the relevant tables: Apartment_Bookings and Guests.", "Determine the columns needed: booking_start_date and booking_end_date from Apartment_Bookings.", "Establish the relationship between the tables: join Apartment_Bookings with Guests on guest_id.", "Filter the results to include only those bookings made by guests with gender code 'Female'."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  'Female'", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT Apartment_Bookings.booking_start_date, Apartment_Bookings.booking_end_date \nFROM Apartment_Bookings \nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id \nWHERE Guests.gender_code = 'Female';", "hint": "\n"}
{"sample_id": "train.1238", "db_id": "apartment_rentals", "question": "Show the facility codes of apartments with more than 4 bedrooms.", "rationale": ["Identify the relevant tables: We need to access the 'Apartments' table for bedroom counts and the 'Apartment_Facilities' table for facility codes.", "Join the 'Apartments' table with the 'Apartment_Facilities' table on the 'apt_id' to link apartments with their facilities.", "Filter the results to include only those apartments that have more than 4 bedrooms by using a WHERE clause.", "Select the distinct facility codes from the joined tables to avoid duplicates in the results."], "gold_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "source_tables": ["apartments", "apartment_facilities"], "pred_sql": "SELECT DISTINCT af.facility_code \nFROM Apartments a \nJOIN Apartment_Facilities af ON a.apt_id = af.apt_id \nWHERE a.bedroom_count > 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1256", "db_id": "apartment_rentals", "question": "Show the top 3 apartment type codes sorted by the average number of rooms in descending order.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of rooms.", "Group by apartment type code: We need to group the results by the apt_type_code to calculate the average number of rooms for each type.", "Calculate the average number of rooms: Use the AVG function on the room_count column to get the average number of rooms for each apartment type.", "Sort the results: Order the results in descending order based on the average number of rooms to get the types with more rooms first.", "Limit the results: We only want the top 3 apartment type codes, so we use the LIMIT clause."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1258", "db_id": "apartment_rentals", "question": "Show the apartment type code that has the largest number of total rooms, together with the number of bathrooms and number of bedrooms.", "rationale": ["Identify the relevant columns needed: apt_type_code, bathroom_count, bedroom_count from the Apartments table.", "Determine the condition to find the apartment type with the largest number of total rooms, which requires a subquery to find the maximum room_count.", "Use a SELECT statement to retrieve apt_type_code, bathroom_count, and bedroom_count where the room_count matches the maximum value found in the subquery."], "gold_sql": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, bathroom_count, bedroom_count FROM Apartments WHERE room_count = (SELECT MAX(room_count) FROM Apartments)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1261", "db_id": "apartment_rentals", "question": "Which apartment type code appears the most often?", "rationale": ["Identify the relevant table: The Apartments table contains the apt_type_code which we need to analyze.", "Group the data: We need to group the apartments by their type code to count how many apartments exist for each type.", "Count the occurrences: Use the COUNT function to count the number of apartments for each type code.", "Order the results: We want to order the results in descending order based on the count to find the most common type code.", "Limit the results: Since we only want the most common type code, we will limit the results to 1."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1262", "db_id": "apartment_rentals", "question": "Show the most common apartment type code among apartments with more than 1 bathroom.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of bathrooms.", "Filter apartments: We need to filter apartments that have more than 1 bathroom, which can be done using a WHERE clause.", "Group by apartment type: To find the most common apartment type code, we will group the results by apt_type_code.", "Count occurrences: We will order the grouped results by the count of apartments in each type to find the most common one.", "Limit the results: Since we only want the most common type, we will limit the results to 1."], "gold_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count > 1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1272", "db_id": "apartment_rentals", "question": "Show the apartment numbers of apartments with unit status availability of both 0 and 1.", "rationale": ["Identify the relevant tables: Apartments and View_Unit_Status.", "We need to retrieve apartment numbers, so we will select 'apt_number' from the Apartments table.", "To check the availability status, we will join the Apartments table with the View_Unit_Status table on 'apt_id'.", "We need to filter the results based on the availability status, which is indicated by the 'available_yn' column in the View_Unit_Status table.", "The condition specifies that we want apartments with availability status of both '0' and '1', which means we will use the IN clause to filter these values."], "gold_sql": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1", "source_tables": ["view_unit_status", "apartments"], "pred_sql": "SELECT apt_number FROM Apartments a JOIN View_Unit_Status vus ON a.apt_id = vus.apt_id WHERE vus.available_yn IN ('0', '1');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1294", "db_id": "soccer_1", "question": "How many leagues are there in England?", "rationale": ["Identify the relevant table: The question asks about leagues, so we will use the 'League' table.", "Determine the condition: We need to filter the leagues to only those in England.", "Construct the SQL query: We will use the COUNT function to count the number of leagues that match the condition."], "gold_sql": "SELECT count(*) FROM Country AS T1 JOIN League AS T2 ON T1.id  =  T2.country_id WHERE T1.name  =  'England'", "source_tables": ["country", "league"], "pred_sql": "SELECT COUNT(*) AS league_count FROM League WHERE name = 'England';", "hint": "\n"}
{"sample_id": "train.1303", "db_id": "soccer_1", "question": "List all of the player ids with a height of at least 180cm and an overall rating higher than 85.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to select player ids, which are found in the Player table under the column 'player_api_id'.", "We need to filter players based on their height (at least 180 cm) and their overall rating (higher than 85).", "Join the Player table with the Player_Attributes table on the player_api_id to access both height and overall rating.", "Construct the SQL query to select player_api_id from the Player table where height is at least 180 and overall rating is greater than 85."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE overall_rating  >  85", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT P.player_api_id FROM Player AS P JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.height >= 180 AND PA.overall_rating > 85;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who have an overall skill rating higher than the average overall rating of all players recorded in the 'Player_Attributes' table. The query uses a subquery to calculate the average overall rating and filters the results accordingly.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.overall_rating  >  ( SELECT avg(overall_rating) FROM Player_Attributes )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of players from the 'Player' table who have the highest overall skill rating recorded in the 'Player_Attributes' table. The query joins the 'Player' and 'Player_Attributes' tables based on the player's API identifier and filters the results to only include players whose dribbling attribute matches the maximum overall rating found in the 'Player_Attributes' table.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.dribbling  =  ( SELECT max(overall_rating) FROM Player_Attributes)\"\n    }\n}\n"}
{"sample_id": "train.1304", "db_id": "soccer_1", "question": "List all of the ids for left-footed players with a height between 180cm and 190cm.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to filter players based on their preferred foot, which is in the Player_Attributes table.", "We also need to filter players based on their height, which is in the Player table.", "Join the Player table with the Player_Attributes table using the player_api_id as the common key.", "Select the id of players who are left-footed and have a height between 180cm and 190cm."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 AND height  <=  190 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE preferred_foot  =  'left'", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT P.id FROM Player AS P JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE PA.preferred_foot = 'left' AND P.height BETWEEN 180 AND 190;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of players from the 'Player' table who have the highest overall skill rating recorded in the 'Player_Attributes' table. The query joins the 'Player' and 'Player_Attributes' tables based on the player's API identifier and filters the results to only include players whose dribbling attribute matches the maximum overall rating found in the 'Player_Attributes' table.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.dribbling  =  ( SELECT max(overall_rating) FROM Player_Attributes)\"\n    }\n}\n"}
{"sample_id": "train.1306", "db_id": "soccer_1", "question": "List the names and birthdays of the top five players in terms of potential.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to retrieve player names and birthdays, so we will select 'player_name' and 'birthday' from the Player table.", "To find the top five players in terms of potential, we will use a subquery on the Player_Attributes table to order players by their potential in descending order and limit the results to five.", "The subquery will return the 'player_api_id' of the top five players based on potential.", "We will then use this list of 'player_api_id' to filter the Player table to get the corresponding names and birthdays."], "gold_sql": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT 5", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT player_name, birthday FROM Player WHERE player_api_id IN (SELECT player_api_id FROM Player_Attributes ORDER BY potential DESC LIMIT 5)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of players from the 'Player' table who have the highest overall skill rating recorded in the 'Player_Attributes' table. The query joins the 'Player' and 'Player_Attributes' tables based on the player's API identifier and filters the results to only include players whose dribbling attribute matches the maximum overall rating found in the 'Player_Attributes' table.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.dribbling  =  ( SELECT max(overall_rating) FROM Player_Attributes)\"\n    }\n}\n"}
{"sample_id": "train.1511", "db_id": "insurance_and_eClaims", "question": "Which type of policy is most frequently used? Give me the policy type code.", "rationale": ["Identify the relevant table: The question asks about policy types, so we will focus on the 'Policies' table.", "Determine the required information: We need to find the most frequently used policy type code.", "Use aggregation: We will use the COUNT function to count occurrences of each Policy_Type_Code.", "Group the results: We will group the results by Policy_Type_Code to get the frequency of each type.", "Order the results: We will order the results in descending order based on frequency to get the most common policy type at the top.", "Limit the results: We will limit the output to 1 to get only the most frequently used policy type."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(*) as Frequency\nFROM Policies\nGROUP BY Policy_Type_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\",\n        \"virtual_table\": \"SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)\"\n    }\n}\n"}
{"sample_id": "train.1513", "db_id": "insurance_and_eClaims", "question": "Find all the policy types that are used by more than 2 customers.", "rationale": ["Identify the relevant table: The 'Policies' table contains the 'Policy_Type_Code' and 'Customer_ID' which are needed to find the policy types used by customers.", "Group the results by 'Policy_Type_Code': This allows us to count how many distinct customers are associated with each policy type.", "Use the HAVING clause: This clause filters the grouped results to only include those policy types that have more than 2 distinct customers associated with them."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code FROM Policies GROUP BY Policy_Type_Code HAVING COUNT(DISTINCT Customer_ID) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\",\n        \"virtual_table\": \"SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)\"\n    }\n}\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["The question asks for the total and average amount paid in claim headers.", "To get the total amount paid, we can use the SUM() function on the Amount_Piad column from the Claim_Headers table.", "To get the average amount paid, we can use the AVG() function on the same Amount_Piad column.", "We will select both the total and average amounts in a single SQL query using a SELECT statement."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Piad) AS Total_Amount_Paid, AVG(Amount_Piad) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\",\n        \"virtual_table\": \"SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\",\n        \"virtual_table\": \"SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1518", "db_id": "insurance_and_eClaims", "question": "How much amount in total were claimed in the most recently created document?", "rationale": ["Identify the relevant tables: Claim_Headers for claim amounts and Claims_Documents for document creation dates.", "Join Claim_Headers with Claims_Documents on Claim_Header_ID to link claims with their documents.", "Filter the results to only include claims associated with the most recently created document by using a subquery to find the maximum Created_Date in Claims_Documents.", "Use SUM() to calculate the total amount claimed from the filtered results."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT SUM(ch.Amount_Claimed) AS Total_Claimed\nFROM Claim_Headers AS ch\nJOIN Claims_Documents AS cd ON ch.Claim_Header_ID = cd.Claim_ID\nWHERE cd.Created_Date = (SELECT MAX(Created_Date) FROM Claims_Documents);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\",\n        \"virtual_table\": \"SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\",\n        \"virtual_table\": \"SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Claim_Headers for claims, Policies for linking claims to customers, and Customers for customer details.", "Join the Claim_Headers table with the Policies table on Policy_ID to link claims to their respective policies.", "Join the resulting table with the Customers table on Customer_ID to get customer details associated with each claim.", "Use a subquery to find the maximum Amount_Piad from the Claim_Headers table, which represents the largest amount claimed in a single claim.", "Filter the results to only include the customer details where the Amount_Piad matches the maximum amount found in the subquery."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT t3.Customer_Details FROM Claim_Headers AS t1 JOIN Policies AS t2 ON t1.Policy_ID = t2.Policy_ID JOIN Customers AS t3 ON t2.Customer_ID = t3.Customer_ID WHERE t1.Amount_Piad = (SELECT max(Amount_Piad) FROM Claim_Headers)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\",\n        \"virtual_table\": \"SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\",\n        \"virtual_table\": \"SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1521", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the minimum amount of payment in one claim?", "rationale": ["Identify the relevant tables: Claim_Headers, Policies, and Customers are needed to find the customer associated with the minimum payment in claims.", "Join the Claim_Headers table with the Policies table on Policy_ID to link claims to their respective policies.", "Join the resulting table with the Customers table on Customer_ID to access customer details.", "Use a subquery to find the minimum Amount_Piad from the Claim_Headers table.", "Filter the results to only include the customer details where the Amount_Piad matches the minimum amount found in the subquery."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT t3.Customer_Details FROM Claim_Headers AS t1 JOIN Policies AS t2 ON t1.Policy_ID = t2.Policy_ID JOIN Customers AS t3 ON t2.Customer_ID = t3.Customer_ID WHERE t1.Amount_Piad = (SELECT MIN(Amount_Piad) FROM Claim_Headers)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\",\n        \"virtual_table\": \"SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)\"\n    }\n}\n"}
{"sample_id": "train.1531", "db_id": "insurance_and_eClaims", "question": "Find the names of the customers who have an deputy policy.", "rationale": ["Identify the relevant tables: Customers and Policies are needed to find customer details and their associated policies.", "Determine the relationship: The Policies table has a foreign key linking to the Customers table via Customer_ID.", "Filter for the specific policy type: We need to find customers with a policy type code that indicates a deputy policy.", "Construct the SQL query: Use a JOIN to connect the Customers and Policies tables, and filter the results based on the Policy_Type_Code for deputy policies."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT c.Customer_Details \nFROM Policies p \nJOIN Customers c ON p.Customer_ID = c.Customer_ID \nWHERE p.Policy_Type_Code = 'deputy';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\",\n        \"virtual_table\": \"SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1533", "db_id": "insurance_and_eClaims", "question": "Find the names of customers who either have an deputy policy or uniformed policy.", "rationale": ["Identify the tables needed: Customers and Policies.", "We need to retrieve customer names, which are in the Customers table under Customer_Details.", "We need to filter policies based on their type, specifically 'deputy' or 'uniformed'.", "Join the Customers table with the Policies table on Customer_ID to link customers with their policies.", "Use a WHERE clause to filter the results to only include policies of type 'deputy' or 'uniformed'.", "Select distinct customer details to avoid duplicates in case a customer has multiple relevant policies."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy' OR t1.policy_type_code  =  'Uniform'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT DISTINCT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nWHERE p.Policy_Type_Code IN ('deputy', 'uniformed')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\",\n        \"virtual_table\": \"SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)\"\n    }\n}\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find the customer associated with the most recently started policy, so we will join the Customers table with the Policies table on Customer_ID.", "To find the most recent policy, we will use a subquery to get the maximum Start_Date from the Policies table.", "The main query will select Customer_Details from the Customers table where the Start_Date matches the maximum Start_Date found in the subquery."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT t2.Customer_Details FROM Policies AS t1 JOIN Customers AS t2 ON t1.Customer_ID = t2.Customer_ID WHERE t1.Start_Date = (SELECT max(Start_Date) FROM Policies)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\",\n        \"virtual_table\": \"SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "Determine the columns needed: account_id, account_name, and other_account_details from Accounts.", "Establish the relationship between Accounts and Customers using the customer_id foreign key.", "Filter the results to include only those accounts associated with the customer whose first name is 'Meaghan'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Accounts.account_id, Accounts.account_name, Accounts.other_account_details \nFROM Accounts \nJOIN Customers ON Accounts.customer_id = Customers.customer_id \nWHERE Customers.customer_first_name = 'Meaghan';", "hint": "\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "Determine the columns needed: account_name and other_account_details from Accounts.", "Establish the relationship between Customers and Accounts using the customer_id foreign key.", "Filter the results to only include the customer named Meaghan Keeling by using a WHERE clause with both first and last names."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Accounts.account_name, Accounts.other_account_details \nFROM Customers \nJOIN Accounts ON Customers.customer_id = Accounts.customer_id \nWHERE Customers.customer_first_name = 'Meaghan' AND Customers.customer_last_name = 'Keeling';", "hint": "\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "Determine the columns needed: full names (first and last) from Customers and account name from Accounts.", "Join the Customers table with the Accounts table on the customer_id field to link customers with their accounts.", "Filter the results to include only those accounts where the account name is '900'.", "Select the concatenated first and last names as full_name."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nJOIN Accounts ON Customers.customer_id = Accounts.customer_id\nWHERE Accounts.account_name = '900';", "hint": "\n"}
{"sample_id": "train.1568", "db_id": "customers_and_invoices", "question": "Return the id and full name of the customer with the most accounts.", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to join these two tables on the customer_id to link customers with their accounts.", "We will group the results by customer_id to count the number of accounts each customer has.", "Use COUNT(a.account_id) to count the number of accounts for each customer.", "Order the results in descending order based on the count of accounts to find the customer with the most accounts.", "Limit the results to 1 to get only the top customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id\nORDER BY COUNT(a.account_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1579", "db_id": "customers_and_invoices", "question": "How many transaction does each account have? Show the number and account id.", "rationale": ["The question asks for the number of transactions associated with each account, which implies a need to count transactions grouped by account ID.", "The relevant table for transactions is 'Financial_Transactions', which contains the 'account_id' column.", "To get the count of transactions for each account, we can use the COUNT() function in SQL.", "We will group the results by 'account_id' to ensure we get a count for each unique account.", "The final SQL query will select the 'account_id' and the count of transactions, labeling the count as 'transaction_count'."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT account_id, COUNT(*) AS transaction_count \nFROM Financial_Transactions \nGROUP BY account_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\",\n        \"virtual_table\": \"SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id\"\n    }\n}\n"}
{"sample_id": "train.1589", "db_id": "customers_and_invoices", "question": "Show the account name, id and the number of transactions for each account.", "rationale": ["We need to retrieve the account name and id along with the number of transactions for each account.", "The 'Accounts' table contains the account information including 'account_id' and 'account_name'.", "The 'Financial_Transactions' table contains the transaction details including 'transaction_id' and 'account_id'.", "To count the number of transactions per account, we can use a LEFT JOIN between 'Accounts' and 'Financial_Transactions' on 'account_id'.", "We will use the COUNT function to count the number of transactions for each account.", "Finally, we will group the results by 'account_id' and 'account_name' to get the desired output."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "pred_sql": "SELECT a.account_id, a.account_name, COUNT(ft.transaction_id) AS number_of_transactions\nFROM Accounts a\nLEFT JOIN Financial_Transactions ft ON a.account_id = ft.account_id\nGROUP BY a.account_id, a.account_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\",\n        \"virtual_table\": \"SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id\"\n    }\n}\n"}
{"sample_id": "train.1599", "db_id": "customers_and_invoices", "question": "Show the invoice number and the number of transactions for each invoice.", "rationale": ["We need to show the invoice number and the number of transactions for each invoice.", "The 'Financial_Transactions' table contains the 'invoice_number' and 'transaction_id' which we can use to count the number of transactions per invoice.", "We will use the COUNT() function to count the number of transactions grouped by 'invoice_number'.", "The final SQL query will select 'invoice_number' and the count of 'transaction_id' as 'number_of_transactions' from the 'Financial_Transactions' table, grouping by 'invoice_number'."], "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"], "pred_sql": "SELECT invoice_number, COUNT(transaction_id) AS number_of_transactions \nFROM Financial_Transactions \nGROUP BY invoice_number;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\",\n        \"virtual_table\": \"SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id\"\n    }\n}\n"}
{"sample_id": "train.1602", "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?", "rationale": ["We need to find the invoice number and invoice date for the invoice with the greatest number of transactions.", "To do this, we first need to identify which order has the greatest number of invoices. We can achieve this by grouping the invoices by order_id and counting them.", "The subquery `SELECT order_id FROM Invoices GROUP BY order_id ORDER BY COUNT(*) DESC LIMIT 1` will give us the order_id with the highest count of invoices.", "Once we have the order_id, we can then select the corresponding invoice_number and invoice_date from the Invoices table where the order_id matches."], "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"], "pred_sql": "SELECT invoice_number, invoice_date \nFROM Invoices \nWHERE order_id = (\n    SELECT order_id \n    FROM Invoices \n    GROUP BY order_id \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\",\n        \"virtual_table\": \"SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id\"\n    }\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["We need to show the order ids and the number of items in each order.", "To achieve this, we will use the 'Order_Items' table, which contains the 'order_id' and 'order_item_id'.", "We will group the results by 'order_id' to aggregate the number of items for each order.", "Using the COUNT function on 'order_item_id' will give us the total number of items for each order.", "The final SQL query will select the 'order_id' and the count of 'order_item_id' as 'number_of_items'."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT order_id, COUNT(order_item_id) AS number_of_items FROM Order_Items GROUP BY order_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\",\n        \"virtual_table\": \"SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.\",\n        \"virtual_table\": \"SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.\",\n        \"virtual_table\": \"SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name\"\n    }\n}\n"}
{"sample_id": "train.2049", "db_id": "party_people", "question": "Show all ministers who do not belong to Progress Party.", "rationale": ["Identify the tables involved: We need to retrieve information about ministers and their associated parties, so we will use the 'member' and 'party' tables.", "Determine the relevant columns: We want to show the names of the ministers, which are in the 'member' table under 'Member_Name'.", "Establish the relationship between tables: The 'member' table has a foreign key 'Party_ID' that links to the 'party' table's 'Party_ID'.", "Filter the results: We need to exclude members who belong to the 'Progress Party'. This requires a WHERE clause that checks if the 'Party_name' in the 'party' table is not equal to 'Progress Party'.", "Use DISTINCT to avoid duplicate names: Since multiple members can belong to the same party, we will use DISTINCT to ensure each minister's name appears only once."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT DISTINCT m.Member_Name \nFROM member m \nJOIN party p ON m.Party_ID = p.Party_ID \nWHERE p.Party_name != 'Progress Party';", "hint": "\n"}
{"sample_id": "train.2058", "db_id": "party_people", "question": "How many members are in each party?", "rationale": ["Identify the tables needed: We need the 'party' table to get party names and the 'member' table to count members.", "Join the 'party' table with the 'member' table on the Party_ID to associate members with their respective parties.", "Use COUNT() function to count the number of members for each party.", "Group the results by party name to get the count of members in each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT p.Party_name, COUNT(m.Member_ID) AS Member_Count\nFROM party AS p\nJOIN member AS m ON p.Party_ID = m.Party_ID\nGROUP BY p.Party_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of party events associated with a specific region and event name. It joins the 'region', 'party', and 'party_events' tables to filter the results based on the specified region name and event name. The placeholders in the WHERE clause represent the region's name and the event's name.\",\n        \"virtual_table\": \"SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2071", "db_id": "party_people", "question": "Show party names and the number of events for each party.", "rationale": ["Identify the tables needed: We need data from the 'party' table for party names and the 'party_events' table to count the events.", "We will use a LEFT JOIN to connect the 'party' table with the 'party_events' table on the Party_ID, ensuring we include all parties even if they have no events.", "We will use COUNT(party_events.Event_ID) to count the number of events for each party.", "Finally, we will group the results by party name to get the count of events for each individual party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT party.Party_name, COUNT(party_events.Event_ID) AS Number_of_Events \nFROM party \nLEFT JOIN party_events ON party.Party_ID = party_events.Party_ID \nGROUP BY party.Party_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of party events associated with a specific region and event name. It joins the 'region', 'party', and 'party_events' tables to filter the results based on the specified region name and event name. The placeholders in the WHERE clause represent the region's name and the event's name.\",\n        \"virtual_table\": \"SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the tables involved: region, party, and party_events.", "Determine the relationship between the tables: region is linked to party via Region_ID, and party is linked to party_events via Party_ID.", "We need to count the number of events, so we will use the COUNT function.", "Filter the results based on the region name ('United Kingdom') and the event name ('Annual Meeting').", "Construct the SQL query using the identified tables, relationships, and filters."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.Region_ID = t2.Region_ID JOIN party_events AS t3 ON t2.Party_ID = t3.Party_ID WHERE t1.Region_name = 'United Kingdom' AND t3.Event_Name = 'Annual Meeting'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of party events associated with a specific region and event name. It joins the 'region', 'party', and 'party_events' tables to filter the results based on the specified region name and event name. The placeholders in the WHERE clause represent the region's name and the event's name.\",\n        \"virtual_table\": \"SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2176", "db_id": "formula_1", "question": "What are the names and years of all races that had a driver with the last name Lewis?", "rationale": ["We need to find the names and years of all races that had a driver with the last name Lewis.", "To do this, we will join the 'races' table with the 'results' table on the raceId, since results contain information about which drivers participated in which races.", "Next, we will join the 'results' table with the 'drivers' table on the driverId to access the driver's last name.", "Finally, we will filter the results to only include those where the driver's surname is 'Lewis'.", "We will select distinct race names and years to avoid duplicates."], "gold_sql": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = 'Lewis'", "source_tables": ["results", "drivers", "races"], "pred_sql": "SELECT DISTINCT races.name, races.year \nFROM races \nJOIN results ON races.raceId = results.raceId \nJOIN drivers ON results.driverId = drivers.driverId \nWHERE drivers.surname = 'Lewis';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the tables needed: We need the 'drivers', 'results', and 'races' tables to find the drivers who participated in specific races.", "Join the 'drivers' table with the 'results' table to get the race results for each driver.", "Join the 'results' table with the 'races' table to filter for the Australian Grand Prix.", "Use a subquery to find drivers who participated in the Chinese Grand Prix and exclude them from the main query results.", "Select distinct first names and last names of drivers who participated in the Australian Grand Prix but not in the Chinese Grand Prix."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT DISTINCT d.forename, d.surname \nFROM drivers AS d \nJOIN results AS r1 ON d.driverId = r1.driverId \nJOIN races AS ra1 ON r1.raceId = ra1.raceId \nWHERE ra1.name = 'Australian Grand Prix' \nAND d.driverId NOT IN (\n    SELECT d2.driverId \n    FROM drivers AS d2 \n    JOIN results AS r2 ON d2.driverId = r2.driverId \n    JOIN races AS ra2 ON r2.raceId = ra2.raceId \n    WHERE ra2.name = 'Chinese Grand Prix'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2183", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who was in position 1 as standing and won?", "rationale": ["Identify the relevant tables: 'drivers' for driver information and 'driverStandings' for standings and wins.", "We need to select distinct forenames of drivers, so we will use SELECT DISTINCT on the 'forename' column from the 'drivers' table.", "To filter the results, we will join the 'drivers' table with the 'driverStandings' table on the 'driverId'.", "We need to apply conditions: the position must be 1 and the number of wins must be greater than 0.", "Construct the SQL query using the identified columns and conditions."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverStandings AS T2 ON T1.driverId = T2.driverId WHERE T2.position = 1 AND T2.wins > 0", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the official names of constructors from the 'constructors' table who are from a specific nationality and have scored more points than a specified threshold in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.\",\n        \"virtual_table\": \"SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = [PLACEHOLDER-TYPE:STRING] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2185", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["Identify the relevant tables: 'drivers' for driver information and 'driverStandings' for standings details.", "We need to select distinct forenames of drivers, so we will use SELECT DISTINCT on the 'forename' column from the 'drivers' table.", "To filter the results, we will join the 'drivers' table with the 'driverStandings' table on the 'driverId' column.", "We need to apply two conditions: the position must be 1 (indicating a win) and the points must be greater than 20.", "Construct the SQL query using the identified columns and conditions."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverStandings AS T2 ON T1.driverId = T2.driverId WHERE T2.position = 1 AND T2.points > 20", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the official names of constructors from the 'constructors' table who are from a specific nationality and have scored more points than a specified threshold in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.\",\n        \"virtual_table\": \"SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = [PLACEHOLDER-TYPE:STRING] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2186", "db_id": "formula_1", "question": "What are the first names of the different drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["Identify the relevant tables: 'drivers' for driver information and 'driverStandings' for standings details.", "We need to select distinct first names of drivers, so we will use SELECT DISTINCT on the 'forename' column from the 'drivers' table.", "Join the 'drivers' table with the 'driverStandings' table on the driverId to correlate driver information with their standings.", "Filter the results to include only those drivers who have a finishing position of 1 in the standings (T2.position = 1).", "Additionally, filter to include only those drivers who have more than 20 points (T2.points > 20).", "Construct the final SQL query using the above conditions."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverStandings AS T2 ON T1.driverId = T2.driverId WHERE T2.position = 1 AND T2.points > 20", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the official names of constructors from the 'constructors' table who are from a specific nationality and have scored more points than a specified threshold in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.\",\n        \"virtual_table\": \"SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = [PLACEHOLDER-TYPE:STRING] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2189", "db_id": "formula_1", "question": "What are the numbers of races for each constructor id?", "rationale": ["The question asks for the number of races for each constructor id.", "To get the number of races per constructor, we can use the 'constructorResults' table, which contains results for each race associated with a constructor.", "We will use the COUNT() function to count the number of entries (races) for each constructorId.", "We will group the results by constructorId to get the count for each individual constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(*) AS numberOfRaces FROM constructorResults GROUP BY constructorId", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the official names of constructors from the 'constructors' table who are from a specific nationality and have scored more points than a specified threshold in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.\",\n        \"virtual_table\": \"SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = [PLACEHOLDER-TYPE:STRING] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of the total number of constructor standings grouped by each constructor's identifier from the 'constructorStandings' table. The placeholder in the SELECT clause represents the constructor's ID.\",\n        \"virtual_table\": \"SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the relevant tables: 'constructors' for constructor information and 'constructorStandings' for points earned.", "We need to select the names of constructors, so we will select the 'name' column from the 'constructors' table.", "To filter for Japanese constructors, we will add a condition in the WHERE clause to check if the 'nationality' is 'Japanese'.", "Next, we need to ensure that these constructors have earned more than 5 points, so we will add another condition in the WHERE clause to check if the 'points' in the 'constructorStandings' table is greater than 5.", "Finally, we will join the 'constructors' table with the 'constructorStandings' table on the 'constructorId' to link constructors with their standings."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorStandings AS T2 ON T1.constructorId = T2.constructorId WHERE T1.nationality = 'Japanese' AND T2.points > 5", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the official names of constructors from the 'constructors' table who are from a specific nationality and have scored more points than a specified threshold in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.\",\n        \"virtual_table\": \"SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = [PLACEHOLDER-TYPE:STRING] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races, lapTimes, and circuits are needed to find the average fastest lap speed for a specific race.", "We need to join the races table with the lapTimes table to access the fastest lap speed data for each race.", "We also need to join the circuits table to filter for the Monaco Grand Prix specifically.", "The WHERE clause will filter for the circuit name 'Monaco' and the year 2008.", "Finally, we will use the AVG() function to calculate the average of the fastest lap speeds from the lapTimes table."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(lapTimes.fastestLapSpeed) AS average_fastest_lap_speed \nFROM races \nJOIN lapTimes ON races.raceId = lapTimes.raceId \nJOIN circuits ON races.circuitId = circuits.circuitId \nWHERE circuits.name = 'Monaco' AND races.year = 2008;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2221", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["Identify the relevant tables: We need data from the 'lapTimes', 'results', and 'races' tables to find the maximum fastest lap speed for a specific race.", "Determine the relationship between the tables: 'lapTimes' is linked to 'results' through raceId, and 'results' is linked to 'races' through raceId as well.", "Filter the races table to find the specific race: We need to filter the races to find the one named 'Monaco Grand Prix' in the year 2008.", "Select the maximum fastest lap speed: We will use the MAX function on the 'fastestLapSpeed' column from the 'lapTimes' table, ensuring we only consider entries that match our race criteria."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(fastestLapSpeed) \nFROM lapTimes AS LT \nJOIN results AS R ON LT.raceId = R.raceId \nJOIN races AS RA ON R.raceId = RA.raceId \nWHERE RA.name = 'Monaco Grand Prix' AND RA.year = 2008;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: We need data from the 'results', 'races', and 'circuits' tables to find the maximum fastest lap speed for the Monaco Grand Prix in 2008.", "Filter the races: We need to filter the races to only include those that took place in Monaco in the year 2008. This requires joining the 'races' table with the 'circuits' table on 'circuitId' and applying the appropriate WHERE conditions.", "Select the maximum fastest lap speed: We will use the MAX() function on the 'fastestLapSpeed' column from the 'results' table to get the maximum value."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(fastestLapSpeed) AS max_fastest_lap_speed \nFROM results AS R \nJOIN races AS RA ON R.raceId = RA.raceId \nJOIN circuits AS C ON RA.circuitId = C.circuitId \nWHERE C.name = 'Monaco' AND RA.year = 2008;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["Identify the relevant tables: We need to use the 'races' table for race names and years, and the 'results' table for fastest lap speeds.", "Join the 'races' table with the 'results' table on the raceId to access both race names and their corresponding fastest lap speeds.", "Filter the results to include only races that occurred after the year 2004.", "Group the results by race name to calculate the maximum fastest lap speed for each race.", "Select the maximum fastest lap speed using the MAX() function and order the results by year."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT R.name, MAX(RS.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races AS R\nJOIN results AS RS ON R.raceId = RS.raceId\nWHERE R.year > 2004\nGROUP BY R.name\nORDER BY R.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2225", "db_id": "formula_1", "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to get race names and fastest lap speeds.", "Join the races table with results to link each race with its results.", "Join the results table with lapTimes to access the fastest lap speeds for each driver in each race.", "Filter the races to include only those held after 2004 using a WHERE clause.", "Group the results by race name to calculate the average fastest lap speed for each race.", "Use AVG() function to calculate the average fastest lap speed for each race.", "Order the final results by year of the race."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT R.name, AVG(L.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races AS R\nJOIN results AS Res ON R.raceId = Res.raceId\nJOIN lapTimes AS L ON Res.raceId = L.raceId AND Res.driverId = L.driverId\nWHERE R.year > 2004\nGROUP BY R.name\nORDER BY R.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2226", "db_id": "formula_1", "question": "What is the average fastest lap speed for races held after 2004, for each race, ordered by year?", "rationale": ["Identify the relevant tables: 'races', 'results', and 'lapTimes' are needed to get the race year and fastest lap speed.", "Join the 'races' table with the 'results' table on 'raceId' to link races with their results.", "Join the 'results' table with the 'lapTimes' table on 'raceId' and 'driverId' to get the fastest lap speed for each driver in each race.", "Filter the results to include only races held after 2004 using a WHERE clause.", "Group the results by year to calculate the average fastest lap speed for each year using AVG() function.", "Order the final results by year to present them in chronological order."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT races.year, AVG(lapTimes.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races\nJOIN results ON races.raceId = results.raceId\nJOIN lapTimes ON results.raceId = lapTimes.raceId AND results.driverId = lapTimes.driverId\nWHERE races.year > 2004\nGROUP BY races.year\nORDER BY races.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2243", "db_id": "machine_repair", "question": "What is the starting year of the oldest technicians?", "rationale": ["Identify the relevant table: The question pertains to technicians, so we will focus on the 'technician' table.", "Determine the required information: We need the starting year of the oldest technicians, which implies we need to find the minimum value in the 'Starting_Year' column.", "Construct the SQL query: We will use the MIN() function to get the earliest starting year from the 'Starting_Year' column in the 'technician' table."], "gold_sql": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT MIN(Starting_Year) AS Oldest_Starting_Year FROM technician;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of technicians who are assigned to repair tasks for machines that have a value point greater than a specified threshold. The placeholders in the WHERE clause represent the minimum value points for filtering the machines.\",\n        \"virtual_table\": \"SELECT T3.Name FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID WHERE T2.value_points  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of technician teams from the 'technician' table, grouped by their team identifier. The results are ordered by the number of technicians in each team in descending order, and the placeholder allows for limiting the number of teams returned.\",\n        \"virtual_table\": \"SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2248", "db_id": "machine_repair", "question": "What are the teams with the most technicians?", "rationale": ["Identify the relevant table: The 'technician' table contains information about technicians and their teams.", "Group the results by team: Use GROUP BY to aggregate the data based on the 'Team' column.", "Count the number of technicians in each team: Use COUNT(*) to count the number of entries for each team.", "Order the results: Use ORDER BY COUNT(*) DESC to sort the teams by the number of technicians in descending order."], "gold_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of technician teams from the 'technician' table, grouped by their team identifier. The results are ordered by the number of technicians in each team in descending order, and the placeholder allows for limiting the number of teams returned.\",\n        \"virtual_table\": \"SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of technicians who are assigned to repair tasks for machines that have a value point greater than a specified threshold. The placeholders in the WHERE clause represent the minimum value points for filtering the machines.\",\n        \"virtual_table\": \"SELECT T3.Name FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID WHERE T2.value_points  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2258", "db_id": "machine_repair", "question": "What are the names of the technicians  and how many machines are they assigned to repair?", "rationale": ["We need to find the names of technicians and the count of machines they are assigned to repair.", "To achieve this, we will use the 'repair_assignment' table to link technicians with their assigned repairs.", "We will join the 'repair_assignment' table with the 'technician' table on the technician_id to get the names of the technicians.", "We will use the COUNT function to count the number of machines (Machine_ID) assigned to each technician.", "Finally, we will group the results by technician name to get the count for each technician."], "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name", "source_tables": ["repair_assignment", "technician"], "pred_sql": "SELECT T3.Name, COUNT(T1.Machine_ID) AS Machine_Count \nFROM repair_assignment AS T1 \nJOIN technician AS T3 ON T1.technician_id = T3.technician_id \nGROUP BY T3.Name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of technicians who are assigned to repair tasks for machines that have a value point greater than a specified threshold. The placeholders in the WHERE clause represent the minimum value points for filtering the machines.\",\n        \"virtual_table\": \"SELECT T3.Name FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID WHERE T2.value_points  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of technician teams from the 'technician' table, grouped by their team identifier. The results are ordered by the number of technicians in each team in descending order, and the placeholder allows for limiting the number of teams returned.\",\n        \"virtual_table\": \"SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2328", "db_id": "csu_1", "question": "Find all the campuses opened in 1958.", "rationale": ["Identify the relevant table: The question asks about campuses, which are listed in the 'Campuses' table.", "Determine the condition: We need to find campuses that were opened in the year 1958, which corresponds to the 'Year' column in the 'Campuses' table.", "Construct the SQL query: We will select all relevant columns (Id, Campus, Location, County, Year) from the 'Campuses' table where the 'Year' is '1958'."], "gold_sql": "SELECT campus FROM campuses WHERE YEAR  =  1958", "source_tables": ["campuses"], "pred_sql": "SELECT Id, Campus, Location, County, Year FROM Campuses WHERE Year = '1958';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2334", "db_id": "csu_1", "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.", "rationale": ["Identify the relevant table: The question asks for campus names based on their location, so we will use the 'Campuses' table.", "Determine the filtering criteria: We need to filter campuses that are either in 'Northridge, Los Angeles' or 'San Francisco, San Francisco'.", "Construct the SQL query: We will select the 'Campus' column from the 'Campuses' table where the 'Location' matches either of the specified locations using an OR condition."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE (Location = 'Northridge, Los Angeles' OR Location = 'San Francisco, San Francisco');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name. The campuses are ordered by the total number of degrees awarded, in descending order, and the result is limited to a specified number of campuses. The placeholder in the LIMIT clause represents the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2350", "db_id": "csu_1", "question": "Which campus has the most faculties in year 2003?", "rationale": ["Identify the relevant tables: 'Campuses' for campus names and 'faculty' for faculty counts.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Filter the results to only include records from the year 2003.", "Order the results by the number of faculty members in descending order to find the campus with the most faculty.", "Limit the results to 1 to get only the campus with the highest number of faculty."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T1.Campus, T2.Faculty \nFROM Campuses AS T1 \nJOIN faculty AS T2 ON T1.Id = T2.Campus \nWHERE T2.Year = 2003 \nORDER BY T2.Faculty DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2356", "db_id": "csu_1", "question": "report the total number of degrees granted between 1998 and 2002.", "rationale": ["Identify the relevant table: The 'degrees' table contains information about degrees awarded, including the year and the number of degrees.", "Determine the columns needed: We need to sum the 'Degrees' column to get the total number of degrees granted.", "Apply the filter: We need to filter the results to include only those records where the 'Year' is between 1998 and 2002.", "Construct the SQL query: Use the SUM function to calculate the total degrees and specify the appropriate WHERE clause for the year range."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(Degrees) AS TotalDegreesGranted \nFROM degrees \nWHERE Year BETWEEN '1998' AND '2002';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name. The campuses are ordered by the total number of degrees awarded, in descending order, and the result is limited to a specified number of campuses. The placeholder in the LIMIT clause represents the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to count the total number of degrees granted after the year 2000, so we will use the degrees table for this count.", "We need to filter the campuses to only include those in Orange County, which is a column in the Campuses table.", "Join the Campuses table with the degrees table on the campus identifier to link campuses with their awarded degrees.", "Apply a WHERE clause to filter degrees awarded after 2000 and campuses located in Orange County.", "Group the results by campus to get the total number of degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT C.Campus, COUNT(D.Degrees) AS TotalDegrees\nFROM Campuses C\nJOIN degrees D ON C.Id = D.Campus\nWHERE C.County = 'Orange' AND D.Year > '2000'\nGROUP BY C.Campus;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name. The campuses are ordered by the total number of degrees awarded, in descending order, and the result is limited to a specified number of campuses. The placeholder in the LIMIT clause represents the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant table for total enrollments, which is the 'enrollments' table.", "Filter the results for the year 1956 by using the condition 'Year = '1956'.", "Add conditions to filter campuses with more than 400 total enrollment and more than 200 full-time equivalent enrollment using 'TotalEnrollment_AY > 400' and 'FTE_AY > 200'.", "Select the 'Campus' column to get the names of the campuses that meet these criteria."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT Campus FROM enrollments WHERE Year = '1956' AND TotalEnrollment_AY > 400 AND FTE_AY > 200;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2363", "db_id": "csu_1", "question": "What campus started in year 1956, has more than 200 full time students, and more than 400 students enrolled?", "rationale": ["Identify the relevant tables: Campuses and enrollments are needed to answer the question.", "Join the Campuses table with the enrollments table on the campus identifier.", "Filter the results to only include campuses that started in the year 1956.", "Add conditions to ensure that the full-time equivalent (FTE) enrollments are greater than 200 and total enrollments are greater than 400."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT C.Campus \nFROM Campuses C \nJOIN enrollments E ON C.Id = E.Campus \nWHERE C.Year = '1956' \nAND E.FTE_AY > '200' \nAND E.TotalEnrollment_AY > '400';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2366", "db_id": "csu_1", "question": "List the campuses in Los Angeles county.", "rationale": ["Identify the relevant table: The 'Campuses' table contains information about campuses, including their location and county.", "Determine the filtering criteria: We need to filter campuses based on the county, specifically 'Los Angeles'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' column from the 'Campuses' table where the 'County' column matches 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name. The campuses are ordered by the total number of degrees awarded, in descending order, and the result is limited to a specified number of campuses. The placeholder in the LIMIT clause represents the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: 'degrees' for the degrees conferred and 'Campuses' for campus identification.", "We need to filter the degrees awarded in the year 2000 and specifically for 'San Jose State University'.", "Join the 'degrees' table with the 'Campuses' table on the campus identifier to get the campus name.", "Use a SUM function to calculate the total number of degrees conferred for the specified campus and year."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(Degrees) AS TotalDegrees\nFROM degrees\nJOIN Campuses ON degrees.Campus = Campuses.Id\nWHERE Campuses.Campus = 'San Jose State University' AND degrees.Year = '2000';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name. The campuses are ordered by the total number of degrees awarded, in descending order, and the result is limited to a specified number of campuses. The placeholder in the LIMIT clause represents the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2374", "db_id": "csu_1", "question": "What is the number of faculty lines in campus \"Long Beach State University\" in 2002?", "rationale": ["Identify the relevant tables: 'Campuses' for campus names and 'faculty' for faculty data.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Filter the results to only include the campus named 'Long Beach State University'.", "Further filter the results to only include data from the year 2002.", "Select the number of faculty members from the joined tables."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2002 AND T2.campus  =  'Long Beach State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T2.Faculty \nFROM Campuses AS T1 \nJOIN faculty AS T2 ON T1.Id = T2.Campus \nWHERE T1.Campus = 'Long Beach State University' AND T2.Year = 2002;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2376", "db_id": "csu_1", "question": "How many faculty lines are there in \"San Francisco State University\" in year 2004?", "rationale": ["Identify the relevant tables: 'Campuses' for campus names and 'faculty' for faculty data.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Filter the results to only include records for 'San Francisco State University'.", "Further filter the results to only include records for the year 2004.", "Select the number of faculty members from the filtered results."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T2.Faculty \nFROM Campuses AS T1 \nJOIN faculty AS T2 ON T1.Id = T2.Campus \nWHERE T1.Campus = 'San Francisco State University' AND T2.Year = 2004;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant tables: 'Campuses' for campus names and 'faculty' for faculty data.", "We need to filter the faculty data for a specific campus, which is 'San Francisco State University'.", "We also need to filter the faculty data for the year 2004.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Select the number of faculty members from the 'faculty' table where the campus name matches and the year is 2004."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T2.faculty FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus WHERE T1.Campus = 'San Francisco State University' AND T2.Year = 2004", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2381", "db_id": "csu_1", "question": "How many faculty members did the university that conferred the most degrees in 2002 have?", "rationale": ["Identify the year of interest, which is 2002.", "Join the 'Campuses' table with the 'faculty' table to get the number of faculty members for each campus in 2002.", "Also join the 'degrees' table to get the number of degrees awarded by each campus in 2002.", "Filter the results to only include data from the year 2002 for both faculty and degrees.", "Order the results by the number of degrees awarded in descending order to find the campus that conferred the most degrees.", "Limit the results to 1 to get only the campus with the highest number of degrees awarded."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT T2.Faculty FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus JOIN degrees AS T3 ON T1.Id = T3.Campus WHERE T2.Year = 2002 AND T3.Year = 2002 ORDER BY T3.Degrees DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2382", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the least number of degrees in year 2001?", "rationale": ["Identify the year of interest, which is 2001.", "Determine the campus that conferred the least number of degrees in 2001 by using a subquery that groups by campus and orders by the sum of degrees in ascending order.", "Join the 'faculty' table with the 'degrees' table to filter faculty data corresponding to the campus with the least degrees awarded in 2001.", "Count the number of faculty lines for that specific campus in the year 2001."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(*) FROM faculty AS T2 JOIN degrees AS T3 ON T2.campus = T3.campus WHERE T3.year = 2001 AND T3.campus = (SELECT T1.campus FROM degrees AS T1 WHERE T1.year = 2001 GROUP BY T1.campus ORDER BY SUM(T1.degrees) ASC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the relevant tables: 'faculty' for faculty members and 'degrees' for the number of degrees awarded.", "Join the 'Campuses' table with 'faculty' and 'degrees' to correlate faculty data with the number of degrees awarded at each campus.", "Filter the results for the year 2001 in both the 'faculty' and 'degrees' tables.", "Order the results by the number of degrees awarded in ascending order to find the campus with the least number of degrees awarded.", "Limit the results to 1 to get only the campus with the least degrees and retrieve the corresponding faculty count."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT T2.Faculty FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus JOIN degrees AS T3 ON T1.Id = T3.Campus WHERE T2.Year = 2001 AND T3.Year = 2001 ORDER BY T3.Degrees ASC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "Determine the specific campus of interest, which is 'San Jose State'.", "Use a subquery to find the 'Id' of 'San Jose State' from the 'Campuses' table.", "Filter the records in 'discipline_enrollments' by the campus 'Id' obtained from the subquery.", "Sum the 'Undergraduate' column to get the total number of undergraduates for 'San Jose State'."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT SUM(Undergraduate) AS TotalUndergraduates \nFROM discipline_enrollments \nWHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Jose State') \nGROUP BY Campus;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2397", "db_id": "candidate_poll", "question": "Return the poll resource associated with the most candidates.", "rationale": ["The task is to return the poll resource associated with the most candidates.", "To achieve this, we need to group the records in the 'candidate' table by the 'Poll_Source' column.", "We will count the number of occurrences of each poll source using the COUNT function.", "Next, we will order the results in descending order based on the count to get the poll source with the highest number of candidates.", "Finally, we will limit the results to just one entry to get the top poll source."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of poll sources from the 'candidate' table, grouped by the source and ordered by the number of occurrences. The placeholder in the LIMIT clause allows the user to specify the maximum number of poll sources to retrieve.\",\n        \"virtual_table\": \"SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the gender distribution of candidates based on their support rates. It joins the 'people' and 'candidate' tables on the 'People_ID' field, grouping the results by gender and ordering them by the average unsure rate of the candidates. The placeholder in the LIMIT clause allows for specifying the number of results to return.\",\n        \"virtual_table\": \"SELECT t1.sex FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex ORDER BY avg(t2.unsure_rate) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2405", "db_id": "candidate_poll", "question": "Return the poll source corresponding to the candidate who has the oppose rate.", "rationale": ["Identify the relevant table: The 'candidate' table contains the 'Poll_Source' and 'Oppose_rate' columns.", "Determine the condition: We need to find the poll source corresponding to candidates who have an oppose rate, which implies we are looking for records where 'Oppose_rate' is not null.", "Construct the SQL query: We will select 'Poll_Source' from the 'candidate' table where 'Oppose_rate' is not null."], "gold_sql": "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source FROM candidate WHERE Oppose_rate IS NOT NULL", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of poll sources from the 'candidate' table, grouped by the source and ordered by the number of occurrences. The placeholder in the LIMIT clause allows the user to specify the maximum number of poll sources to retrieve.\",\n        \"virtual_table\": \"SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the gender distribution of candidates based on their support rates. It joins the 'people' and 'candidate' tables on the 'People_ID' field, grouping the results by gender and ordering them by the average unsure rate of the candidates. The placeholder in the LIMIT clause allows for specifying the number of results to return.\",\n        \"virtual_table\": \"SELECT t1.sex FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex ORDER BY avg(t2.unsure_rate) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2417", "db_id": "candidate_poll", "question": "For each sex, what is the name and sex of the candidate with the oppose rate for their sex?", "rationale": ["We need to find the name and sex of candidates based on their oppose rates, grouped by sex.", "To do this, we will join the 'people' table with the 'candidate' table on the 'People_ID' field.", "We will filter the results to only include candidates whose oppose rate is equal to the maximum oppose rate for their respective sex.", "This requires a subquery that selects the maximum oppose rate from the candidate table, grouped by sex from the people table."], "gold_sql": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex", "source_tables": ["candidate", "people"], "pred_sql": "SELECT p.Name, p.Sex FROM people AS p JOIN candidate AS c ON p.People_ID = c.People_ID WHERE c.Oppose_rate = (SELECT MAX(Oppose_rate) FROM candidate AS c2 JOIN people AS p2 ON c2.People_ID = p2.People_ID WHERE p2.Sex = p.Sex)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the gender distribution of candidates based on their support rates. It joins the 'people' and 'candidate' tables on the 'People_ID' field, grouping the results by gender and ordering them by the average unsure rate of the candidates. The placeholder in the LIMIT clause allows for specifying the number of results to return.\",\n        \"virtual_table\": \"SELECT t1.sex FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex ORDER BY avg(t2.unsure_rate) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2434", "db_id": "movie_1", "question": "Find the titles of all movies directed by steven spielberg.", "rationale": ["Identify the relevant table: The 'Movie' table contains the information about movie titles and their directors.", "Determine the required columns: We need the 'title' column from the 'Movie' table.", "Specify the condition: We want movies directed by 'steven spielberg', so we will filter the results using a WHERE clause on the 'director' column.", "Construct the SQL query: Combine the selected columns, table, and condition into a complete SQL statement."], "gold_sql": "SELECT title FROM Movie WHERE director = 'Steven Spielberg'", "source_tables": ["movie"], "pred_sql": "SELECT title FROM Movie WHERE director = 'steven spielberg'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the total number of ratings grouped by each director's name.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director\"\n    }\n}\n"}
{"sample_id": "train.2461", "db_id": "movie_1", "question": "What are the different names of all reviewers whose ratings do not have a date field?", "rationale": ["Identify the requirement: We need the names of reviewers whose ratings do not have a date field.", "Understand the schema: The Reviewer table contains reviewer names and the Rating table contains ratings linked to reviewers with a date field.", "Formulate the subquery: We need to find all rIDs from the Rating table where the ratingDate is not null.", "Use NOT IN to filter out those reviewers from the Reviewer table who have ratings with a date.", "Construct the final SQL query to select names from the Reviewer table based on the filtered rIDs."], "gold_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  'null'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT name FROM Reviewer WHERE rID NOT IN (SELECT rID FROM Rating WHERE ratingDate IS NOT NULL)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\",\n        \"virtual_table\": \"SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2476", "db_id": "movie_1", "question": "Find the names of all reviewers who rated Gone with the Wind.", "rationale": ["Identify the tables involved: Reviewer, Rating, and Movie.", "We need to find the names of reviewers, so we will select the 'name' column from the Reviewer table.", "To link reviewers to their ratings, we will join the Rating table on the rID column.", "Next, we need to connect the ratings to the specific movie, so we will join the Movie table on the mID column.", "Finally, we will filter the results to only include ratings for the movie titled 'Gone with the Wind' using a WHERE clause."], "gold_sql": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  'Gone with the Wind'", "source_tables": ["rating", "movie", "reviewer"], "pred_sql": "SELECT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nJOIN Movie ON Rating.mID = Movie.mID \nWHERE Movie.title = 'Gone with the Wind';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\",\n        \"virtual_table\": \"SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2483", "db_id": "movie_1", "question": "What are the names of all the reviewers and movie names?", "rationale": ["The question asks for the names of all reviewers and movie names, which means we need to retrieve data from both the Reviewer and Movie tables.", "To get the names of reviewers, we will select the 'name' column from the Reviewer table.", "To get the movie names, we will select the 'title' column from the Movie table.", "Since there is a relationship between reviewers and movies through the Rating table, we need to join these three tables: Reviewer, Rating, and Movie.", "We will join the Reviewer table with the Rating table on the reviewer ID (rID) and then join the Rating table with the Movie table on the movie ID (mID).", "The final SQL query will select the reviewer's name and the movie title from these joined tables."], "gold_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "source_tables": ["movie", "reviewer"], "pred_sql": "SELECT Reviewer.name, Movie.title FROM Reviewer JOIN Rating ON Reviewer.rID = Rating.rID JOIN Movie ON Rating.mID = Movie.mID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\",\n        \"virtual_table\": \"SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2495", "db_id": "movie_1", "question": "For each director, how many reviews have they received?", "rationale": ["Identify the tables involved: Movie and Rating.", "Determine the relationship between the tables: Movie has a director and Rating has ratings linked to movies.", "We need to count the number of reviews (ratings) for each director.", "Use a JOIN to combine Movie and Rating tables on the movie ID (mID).", "Group the results by director to get the count of ratings for each director."], "gold_sql": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the total number of ratings grouped by each director's name.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2500", "db_id": "movie_1", "question": "What are the names and years of the movies that has the top 3 highest rating star?", "rationale": ["The question asks for the names and years of movies with the top 3 highest ratings.", "To find the top 3 highest ratings, we need to calculate the average rating for each movie.", "We can use a subquery to select the movie IDs (mID) of the top 3 movies based on their average rating.", "The virtual table provided in the hint gives a structure to calculate the average rating for each movie and order them by this average rating in descending order.", "We will limit the results of this subquery to 3 to get the top 3 movies.", "Finally, we will select the title and year of these movies from the Movie table using the movie IDs obtained from the subquery."], "gold_sql": "SELECT T2.title ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID ORDER BY T1.stars DESC LIMIT 3", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title, year FROM Movie WHERE mID IN (SELECT T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT 3)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\",\n        \"virtual_table\": \"SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    }\n}\n"}
{"sample_id": "train.2502", "db_id": "movie_1", "question": "For each director, return the director's name together with the title of the movie they directed that received the highest rating among all of their movies, and the value of that rating. Ignore movies whose director is NULL.", "rationale": ["We need to find the highest-rated movie for each director.", "First, we will join the Movie and Rating tables on the movie ID (mID).", "Next, we will group the results by movie ID and find the maximum rating for each movie using MAX(stars).", "We will then join this result back to the Movie table to get the title of the movie along with the director's name.", "We will filter out any movies where the director is NULL.", "Finally, we will select the director's name, the title of their highest-rated movie, and the value of that rating."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT M.director, M.title, R.max_rating\nFROM Movie AS M\nJOIN (SELECT mID, MAX(stars) AS max_rating\n      FROM Rating\n      GROUP BY mID) AS R ON M.mID = R.mID\nWHERE M.director IS NOT NULL\nGROUP BY M.director, M.title, R.max_rating;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the total number of ratings grouped by each director's name.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of movie titles along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2503", "db_id": "movie_1", "question": "For each director, what are the titles and ratings for all the movies they reviewed?", "rationale": ["We need to retrieve the titles of movies and their ratings for each director.", "To do this, we will join the Movie table with the Rating table on the movie ID (mID).", "Next, we will also join the Reviewer table to get the names of the reviewers who rated the movies.", "The final output should include the movie title, the rating (stars), and the director's name.", "We will order the results by director and then by movie title for better readability."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT M.title, R.stars, M.director \nFROM Movie AS M \nJOIN Rating AS R ON M.mID = R.mID \nJOIN Reviewer AS Rev ON R.rID = Rev.rID \nORDER BY M.director, M.title;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the total number of ratings grouped by each director's name.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2505", "db_id": "movie_1", "question": "For each reviewer id, what is the title and rating for the movie with the smallest rating?", "rationale": ["We need to find the title and rating for the movie with the smallest rating for each reviewer id.", "To achieve this, we will join the Rating table with the Movie table to get the movie titles along with their ratings.", "We will use a subquery to find the minimum rating for each reviewer by filtering the Rating table based on the reviewer id.", "The subquery will return the smallest rating for each reviewer, which we will then use to filter the main query results.", "Finally, we will order the results by reviewer id to group them accordingly."], "gold_sql": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID", "source_tables": ["rating", "movie"], "pred_sql": "SELECT R.rID, M.title, R.stars \nFROM Rating R \nJOIN Movie M ON R.mID = M.mID \nWHERE R.stars = (SELECT MIN(stars) FROM Rating WHERE rID = R.rID) \nORDER BY R.rID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\",\n        \"virtual_table\": \"SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    }\n}\n"}
{"sample_id": "train.2507", "db_id": "movie_1", "question": "For each director, what is the title and score of their most poorly rated movie?", "rationale": ["We need to find the most poorly rated movie for each director.", "To do this, we will first join the 'Movie' and 'Rating' tables on the movie ID (mID).", "Next, we will calculate the average rating for each movie using the AVG function on the stars column from the Rating table.", "We will group the results by both the movie ID and the director to ensure we get the average rating for each movie directed by each director.", "To find the most poorly rated movie, we will order the results by average rating in ascending order.", "Finally, we will limit the results to get only one entry per director, which represents their most poorly rated movie."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T1.director, T2.title, avg(T1.stars) AS average_rating \nFROM Rating AS T1 \nJOIN Movie AS T2 ON T1.mID = T2.mID \nGROUP BY T2.mID, T1.director \nORDER BY average_rating ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the total number of ratings grouped by each director's name.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    }\n}\n"}
{"sample_id": "train.2508", "db_id": "movie_1", "question": "What is the name of the movie that is rated by most of times?", "rationale": ["We need to find the movie that has been rated the most times.", "To do this, we will join the 'Rating' table with the 'Movie' table using the movie identifier (mID).", "We will group the results by movie identifier (mID) to count how many times each movie has been rated.", "We will use the COUNT function to count the number of ratings for each movie.", "To get the movie that has been rated the most, we will order the results in descending order based on the count of ratings.", "Finally, we will limit the results to 1 to get only the top-rated movie."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID GROUP BY T1.mID ORDER BY COUNT(T1.mID) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of movie titles along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of movie titles along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2509", "db_id": "movie_1", "question": "What is the name of the movie that has been reviewed the most?", "rationale": ["To find the movie that has been reviewed the most, we need to count the number of reviews for each movie.", "We will join the Rating table with the Movie table using the movie identifier (mID).", "We will group the results by the movie identifier to count the number of reviews for each movie.", "We will order the results in descending order based on the count of reviews to get the most reviewed movie at the top.", "Finally, we will limit the results to just one entry to get the top movie with the most reviews."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.title, COUNT(T1.mID) AS review_count FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID GROUP BY T2.mID ORDER BY review_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of movie titles along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2517", "db_id": "movie_1", "question": "What are the ids of all moviest hat have not been reviewed by Britanny Harris?", "rationale": ["Identify the requirement: We need to find movie IDs that have not been reviewed by Britanny Harris.", "Use the 'Rating' table to get all movie IDs that have been rated.", "Use a subquery to find movie IDs that have been rated by Britanny Harris by joining the 'Rating' and 'Reviewer' tables on the reviewer ID (rID).", "The subquery will select movie IDs where the reviewer's name is 'Britanny Harris'.", "Use the EXCEPT operator to subtract the movie IDs that have been rated by Britanny Harris from the complete list of movie IDs in the 'Rating' table."], "gold_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID = T2.rID WHERE T2.name = 'Britanny Harris'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\",\n        \"virtual_table\": \"SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2518", "db_id": "movie_1", "question": "Find the average rating star for each movie that received at least 2 ratings.", "rationale": ["We need to find the average rating star for each movie that received at least 2 ratings.", "To do this, we will join the 'Rating' table (T1) with the 'Movie' table (T2) on the movie identifier (mID).", "We will calculate the average of the stars given in the ratings using the AVG() function.", "To ensure we only get movies with at least 2 ratings, we will use the HAVING clause with COUNT(T1.rID) >= 2 after grouping by movie identifier (T1.mID).", "Finally, we will select the movie title and the average rating in our query."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2", "source_tables": ["rating"], "pred_sql": "SELECT T2.title, avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID GROUP BY T1.mID HAVING COUNT(T1.rID) >= 2", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of movie titles along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of movie titles along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2528", "db_id": "movie_1", "question": "What are the names of reviewers who had rated 3 star and 4 star?", "rationale": ["We need to find the names of reviewers who rated movies with 3 stars and 4 stars.", "To do this, we will join the Reviewer table with the Rating table on the reviewer ID (rID).", "We will select the distinct names from the Reviewer table to avoid duplicates.", "The condition for the ratings will be specified in the WHERE clause, using the IN operator to filter for ratings of 3 and 4 stars."], "gold_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nWHERE Rating.stars IN ('3', '4');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\",\n        \"virtual_table\": \"SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2530", "db_id": "movie_1", "question": "What are the names of movies that get 3 star and 4 star?", "rationale": ["We need to find the names of movies that received ratings of 3 stars and 4 stars.", "To do this, we will join the 'Rating' table with the 'Movie' table on the movie identifier (mID).", "We will filter the results to include only those ratings that are either 3 or 4 stars using the WHERE clause.", "Finally, we will select the movie titles from the Movie table and group the results by title to ensure we get unique movie names."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID WHERE T1.stars IN ('3', '4') GROUP BY T2.title;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\",\n        \"virtual_table\": \"SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2576", "db_id": "inn_1", "question": "Find the most popular room in the hotel. The most popular room is the room that had seen the largest number of reservations.", "rationale": ["To find the most popular room, we need to count the number of reservations for each room.", "We will join the Reservations table with the Rooms table on the RoomId to get the room details along with the reservation counts.", "We will group the results by RoomId to aggregate the count of reservations for each room.", "We will order the results by the count of reservations in descending order to get the room with the highest number of reservations at the top.", "Finally, we will limit the results to 1 to get only the most popular room."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T2.roomName, COUNT(T1.Code) AS reservation_count \nFROM Reservations AS T1 \nJOIN Rooms AS T2 ON T1.Room = T2.RoomId \nGROUP BY T2.RoomId \nORDER BY reservation_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n        \"virtual_table\": \"SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n        \"virtual_table\": \"SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2577", "db_id": "inn_1", "question": "Which room has the largest number of reservations?", "rationale": ["Identify the table that contains reservation data, which is the 'Reservations' table.", "We need to count the number of reservations for each room, so we will use the COUNT() function on the 'Code' column in the 'Reservations' table.", "We will group the results by the 'Room' column to get the count of reservations for each room.", "To find the room with the largest number of reservations, we will order the results in descending order based on the count of reservations.", "Finally, we will limit the results to only one room using LIMIT 1."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T1.Room, COUNT(T1.Code) AS ReservationCount FROM Reservations AS T1 GROUP BY T1.Room ORDER BY ReservationCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\",\n        \"virtual_table\": \"SELECT kids FROM Reservations WHERE FirstName = [PLACEHOLDER-TYPE:STRING] AND LastName  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n        \"virtual_table\": \"SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2578", "db_id": "inn_1", "question": "How many kids stay in the rooms reserved by ROY SWEAZY?", "rationale": ["Identify the relevant table: The question pertains to the number of kids in reservations, so we will focus on the Reservations table.", "Determine the necessary columns: We need to sum the 'Kids' column from the Reservations table.", "Filter by guest name: We need to filter the results to only include reservations made by 'ROY SWEAZY'.", "Construct the SQL query: We will use the SUM function to calculate the total number of kids for the specified guest."], "gold_sql": "SELECT kids FROM Reservations WHERE FirstName = 'ROY' AND LastName  =  'SWEAZY';", "source_tables": ["reservations"], "pred_sql": "SELECT SUM(Kids) AS TotalKids FROM Reservations WHERE FirstName = 'ROY' AND LastName = 'SWEAZY';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\",\n        \"virtual_table\": \"SELECT kids FROM Reservations WHERE FirstName = [PLACEHOLDER-TYPE:STRING] AND LastName  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n        \"virtual_table\": \"SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n        \"virtual_table\": \"SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2582", "db_id": "inn_1", "question": "Which room has the highest rate? List the room's full name, rate, check in and check out date.", "rationale": ["Identify the relevant tables: Rooms and Reservations.", "We need to find the room with the highest rate, which is stored in the Reservations table.", "Join the Rooms table with the Reservations table on the RoomId to access room details along with reservation details.", "Select the room's name, rate (from Reservations), check-in and check-out dates.", "Order the results by the rate in descending order to get the highest rate at the top.", "Limit the results to 1 to get only the room with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT R.roomName, R.basePrice AS Rate, Res.CheckIn, Res.CheckOut \nFROM Rooms AS R \nJOIN Reservations AS Res ON R.RoomId = Res.Room \nORDER BY Res.Rate DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n        \"virtual_table\": \"SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n        \"virtual_table\": \"SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2583", "db_id": "inn_1", "question": "Return the name, rate, check in and check out date for the room with the highest rate.", "rationale": ["Identify the required fields: room name, rate, check-in date, and check-out date.", "Determine the tables involved: Rooms and Reservations.", "Join the Reservations table with the Rooms table on the RoomId to access room details.", "Use a subquery to find the maximum rate from the Reservations table.", "Filter the results to only include the reservation(s) with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT R.roomName, R.Rate, R.CheckIn, R.CheckOut \nFROM Reservations AS R \nJOIN Rooms AS RM ON R.Room = RM.RoomId \nWHERE R.Rate = (SELECT MAX(Rate) FROM Reservations)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n        \"virtual_table\": \"SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n        \"virtual_table\": \"SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2589", "db_id": "inn_1", "question": "Find the total number of king beds available.", "rationale": ["The user wants to find the total number of king beds available.", "To achieve this, we need to count the number of rooms that have 'king' as their bed type.", "We will use the COUNT() function to count the rows that match this condition.", "The SQL query will select from the 'Rooms' table where the 'bedType' is 'king'."], "gold_sql": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT COUNT(*) AS total_king_beds FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n        \"virtual_table\": \"SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\",\n        \"virtual_table\": \"SELECT kids FROM Reservations WHERE FirstName = [PLACEHOLDER-TYPE:STRING] AND LastName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2590", "db_id": "inn_1", "question": "List the names and decor of rooms that have a king bed. Sort the list by their price.", "rationale": ["Identify the relevant table: The 'Rooms' table contains the information about room names, decor, and bed types.", "Determine the criteria: We need to filter rooms that have a king bed, which is specified in the 'bedType' column.", "Select the required columns: We need to retrieve the 'roomName' and 'decor' columns from the 'Rooms' table.", "Sort the results: The results should be sorted by 'basePrice' in ascending order to list cheaper rooms first."], "gold_sql": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName, decor FROM Rooms WHERE bedType = 'king' ORDER BY basePrice ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n        \"virtual_table\": \"SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by the decoration type. The placeholder in the LIMIT clause allows for specifying the maximum number of decoration types to return.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2594", "db_id": "inn_1", "question": "What is the decor of room Recluse and defiance?", "rationale": ["Identify the relevant table: The question pertains to the 'Rooms' table, specifically asking for the decor of certain rooms.", "Determine the specific rooms: The rooms in question are 'Recluse' and 'defiance'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'decor' column from the 'Rooms' table where the 'roomName' matches either 'Recluse' or 'defiance'.", "Use the IN clause to specify multiple room names in the WHERE condition."], "gold_sql": "SELECT decor FROM Rooms WHERE roomName  =  'Recluse and defiance';", "source_tables": ["rooms"], "pred_sql": "SELECT decor FROM Rooms WHERE roomName IN ('Recluse', 'defiance');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by the decoration type. The placeholder in the LIMIT clause allows for specifying the maximum number of decoration types to return.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n        \"virtual_table\": \"SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2604", "db_id": "inn_1", "question": "Find the first and last names of people who payed more than the rooms' base prices.", "rationale": ["Identify the tables involved: Reservations and Rooms.", "Determine the columns needed: FirstName and LastName from Reservations, and basePrice from Rooms.", "Establish the relationship between the tables: Reservations.Room corresponds to Rooms.RoomId.", "Formulate the condition: We need to find reservations where the Rate is greater than the basePrice of the corresponding room.", "Construct the SQL query using a JOIN to combine data from both tables based on the Room identifier and apply the condition."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T1.FirstName, T1.LastName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room = T2.RoomId WHERE T1.Rate > T2.basePrice", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n        \"virtual_table\": \"SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\",\n        \"virtual_table\": \"SELECT kids FROM Reservations WHERE FirstName = [PLACEHOLDER-TYPE:STRING] AND LastName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2609", "db_id": "inn_1", "question": "How many rooms have a king bed?", "rationale": ["The user wants to know how many rooms have a king bed.", "To find this, we need to count the number of entries in the 'Rooms' table where the 'bedType' column is equal to 'king'.", "The SQL query will use the COUNT() function to get the total number of such rooms."], "gold_sql": "SELECT count(*) FROM Rooms WHERE bedType  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT COUNT(*) FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n        \"virtual_table\": \"SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\",\n        \"virtual_table\": \"SELECT kids FROM Reservations WHERE FirstName = [PLACEHOLDER-TYPE:STRING] AND LastName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2612", "db_id": "inn_1", "question": "Find the name of the room with the maximum occupancy.", "rationale": ["Identify the table that contains room information, which is the 'Rooms' table.", "Determine the relevant column for maximum occupancy, which is 'maxOccupancy'.", "To find the room with the maximum occupancy, we need to sort the results by 'maxOccupancy' in descending order.", "Since we only want the room with the highest occupancy, we will limit the results to 1 using 'LIMIT 1'.", "Construct the SQL query to select 'roomName' from 'Rooms', order by 'maxOccupancy' in descending order, and limit the result to 1."], "gold_sql": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n        \"virtual_table\": \"SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n        \"virtual_table\": \"SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2621", "db_id": "inn_1", "question": "What is the average minimum and price of the rooms for each different decor.", "rationale": ["Identify the required information: average minimum price of rooms for each different decor.", "The relevant table for this information is 'Rooms', which contains the 'decor' and 'basePrice' columns.", "To calculate the average price, we will use the AVG() function on the 'basePrice' column.", "We need to group the results by 'decor' to get the average price for each type of decor.", "The final SQL query will select the 'decor' and the average price calculated from 'basePrice', grouped by 'decor'."], "gold_sql": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;", "source_tables": ["rooms"], "pred_sql": "SELECT decor, AVG(basePrice) AS average_price FROM Rooms GROUP BY decor;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by the decoration type. The placeholder in the LIMIT clause allows for specifying the maximum number of decoration types to return.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n        \"virtual_table\": \"SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2628", "db_id": "inn_1", "question": "List the name of rooms with king or queen bed.", "rationale": ["Identify the relevant table: The question pertains to room names and bed types, so we will focus on the 'Rooms' table.", "Determine the columns needed: We need the 'roomName' column for the output and the 'bedType' column to filter the results.", "Formulate the WHERE clause: The user is interested in rooms with either a 'king' or 'queen' bed, which will be specified in the WHERE clause.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE bedType = 'king' OR bedType = 'queen';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n        \"virtual_table\": \"SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by the decoration type. The placeholder in the LIMIT clause allows for specifying the maximum number of decoration types to return.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["We need to find the name of each room and the number of times reservations were made for it.", "To achieve this, we will select the 'roomName' from the 'Rooms' table.", "We will also count the number of reservations associated with each room, which can be done using COUNT on the 'Code' column from the 'Reservations' table.", "Since not all rooms may have reservations, we will use a LEFT JOIN to include all rooms even if they have zero reservations.", "The join condition will be based on matching 'RoomId' from 'Rooms' with 'Room' from 'Reservations'.", "Finally, we will group the results by 'roomName' to get the count of reservations for each room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservation_count FROM Rooms LEFT JOIN Reservations ON Rooms.RoomId = Reservations.Room GROUP BY Rooms.roomName;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\",\n        \"virtual_table\": \"SELECT kids FROM Reservations WHERE FirstName = [PLACEHOLDER-TYPE:STRING] AND LastName  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n        \"virtual_table\": \"SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["Identify the table needed: The question asks for details of trucks, so we will use the 'Trucks' table.", "Select all columns: We need all details, so we will use SELECT *.", "Order by license number: The question specifies to order the results by the truck's license number, so we will add ORDER BY truck_licence_number."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "pred_sql": "SELECT * FROM Trucks ORDER BY truck_licence_number;", "hint": "\n"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to find customer names, so we will select 'customer_name' from the Customers table.", "To filter customers based on their address, we need to join the Customers table with the Customer_Addresses table using 'customer_id'.", "Next, we join the Customer_Addresses table with the Addresses table using 'address_id' to access the state information.", "Finally, we apply a WHERE clause to filter out customers whose state is 'California'."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT customer_name \nFROM Customers c \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nJOIN Addresses a ON ca.address_id = a.address_id \nWHERE a.state_province_county != 'California';", "hint": "\n"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["Identify the relevant tables: Delivery_Routes, Delivery_Route_Locations, and Order_Deliveries are needed to find the route with the highest number of deliveries.", "Join the Delivery_Routes table with Delivery_Route_Locations on route_id to link routes to their locations.", "Join the resulting table with Order_Deliveries on location_code to associate deliveries with their respective routes.", "Group the results by route_name to count the number of deliveries for each route.", "Order the results in descending order based on the count of deliveries to find the route with the highest number.", "Limit the results to 1 to get only the top route."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "pred_sql": "SELECT route_name\nFROM Delivery_Routes\nJOIN Delivery_Route_Locations ON Delivery_Routes.route_id = Delivery_Route_Locations.route_id\nJOIN Order_Deliveries ON Delivery_Route_Locations.location_code = Order_Deliveries.location_code\nGROUP BY route_name\nORDER BY COUNT(Order_Deliveries.actual_order_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3175", "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and PROFESSOR.", "We need to count the number of distinct professors teaching a specific class, which is identified by the CLASS_CODE 'ACCT-211'.", "Join the CLASS table with the PROFESSOR table on the PROF_NUM field to link classes with their respective professors.", "Use a WHERE clause to filter the results to only include the class with CLASS_CODE 'ACCT-211'.", "Use COUNT(DISTINCT T2.emp_num) to count the unique professors teaching that class."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT T2.emp_num) AS professor_count \nFROM CLASS AS T1 \nJOIN PROFESSOR AS T2 ON T1.PROF_NUM = T2.EMP_NUM \nWHERE T1.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and PROFESSOR are needed to find professors teaching a specific class.", "Use the CLASS table to filter for the class with the code 'ACCT-211'.", "Join the CLASS table with the PROFESSOR table on the professor's identifier (PROF_NUM).", "Count the distinct professors associated with the specified class code to avoid duplicates."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT T2.emp_num) AS professor_count \nFROM CLASS AS T1 \nJOIN PROFESSOR AS T2 ON T1.PROF_NUM = T2.EMP_NUM \nWHERE T1.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["Identify the tables needed: We need information from the PROFESSOR (for first names), CLASS (to link professors to courses), and COURSE (to filter by course code).", "Join the CLASS table with the EMPLOYEE table to get the first names of professors teaching the classes.", "Join the CLASS table with the COURSE table to filter for the specific course 'ACCT-211'.", "Select the first names and date of birth of professors from the EMPLOYEE table after filtering for the course."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT T2.emp_fname, T2.emp_dob FROM CLASS AS T1 JOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM JOIN COURSE AS T3 ON T1.CRS_CODE = T3.CRS_CODE WHERE T3.CRS_CODE = 'ACCT-211'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3188", "db_id": "college_1", "question": "Where is the history department?", "rationale": ["The user is asking for the location of the history department, which implies we need to retrieve information from the DEPARTMENT table.", "To find the history department, we will filter the DEPARTMENT table using the condition where DEPT_NAME is 'History'.", "We will select the DEPT_NAME and DEPT_ADDRESS columns to provide the name and address of the history department."], "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"], "pred_sql": "SELECT DEPT_NAME, DEPT_ADDRESS FROM DEPARTMENT WHERE DEPT_NAME = 'History';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["The question asks for different locations of the school with the code BUS, which refers to the department addresses associated with that school code.", "To find the locations, we need to query the DEPARTMENT table, specifically the DEPT_ADDRESS column.", "We will filter the results using a WHERE clause to specify the school code as 'BUS'.", "Using DISTINCT ensures that we only get unique addresses, avoiding duplicates in the results."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT dept_address FROM department WHERE school_code = 'BUS'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.\",\n        \"virtual_table\": \"SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of distinct department addresses from the 'DEPARTMENT' table for a specific school. The placeholder in the WHERE clause represents the school code being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["Identify the relevant tables: We need to gather information about courses and their associated departments, which involves the COURSE and CLASS tables.", "Determine the relationship: The COURSE table has a DEPT_CODE that links to the DEPARTMENT table, and the CLASS table has a CRS_CODE that links to the COURSE table.", "Aggregate the data: We want to calculate the total credit hours offered by each department, which requires summing the CRS_CREDIT from the COURSE table.", "Group the results: To get the total credit hours per department, we will group the results by DEPT_CODE from the COURSE table.", "Construct the SQL query: Using a JOIN between COURSE and CLASS on CRS_CODE, we can sum the credit hours and group by department code."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT T1.dept_code, SUM(T1.crs_credit) AS total_credit FROM course AS T1 JOIN class AS T2 ON T1.crs_code = T2.crs_code GROUP BY T1.dept_code", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping the results.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3202", "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["The question asks for the total credits offered by the department.", "To find this information, we need to sum the credit hours from the COURSE table.", "The COURSE table contains the credit hours for each course, identified by the CRS_CODE.", "The CLASS table is linked to the COURSE table through the CRS_CODE, allowing us to associate classes with their respective courses.", "We will use a JOIN operation to combine the COURSE and CLASS tables based on the CRS_CODE.", "Finally, we will group the results by DEPT_CODE to get the total credits offered by each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT sum(T1.crs_credit) AS total_credits, T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code = T2.crs_code GROUP BY T1.dept_code", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping the results.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["To find the school with the smallest number of professors, we need to count the number of professors associated with each school.", "We can achieve this by joining the 'department' table with the 'professor' table on the department code.", "We will group the results by the school code to get the count of professors for each school.", "To find the school with the smallest number of professors, we will order the results by the count of professors in ascending order.", "Finally, we will limit the results to 1 to get only the school with the smallest number of professors."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "pred_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code = T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.\",\n        \"virtual_table\": \"SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3215", "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["Identify the tables needed: We need the PROFESSOR and DEPARTMENT tables to find the number of professors with a Ph.D. in each department.", "Join the DEPARTMENT and PROFESSOR tables on the DEPT_CODE to associate professors with their respective departments.", "Filter the results to include only those professors who have a Ph.D. by using a WHERE clause that checks for 'Ph.D.' in the PROF_HIGH_DEGREE column.", "Group the results by DEPT_CODE to count the number of professors in each department.", "Select the DEPT_CODE and the count of professors as num_professors."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "pred_sql": "SELECT T1.dept_code, COUNT(*) AS num_professors \nFROM department AS T1 \nJOIN professor AS T2 ON T1.dept_code = T2.dept_code \nWHERE T2.prof_high_degree = 'Ph.D.' \nGROUP BY T1.dept_code", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.\",\n        \"virtual_table\": \"SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["The task is to find the number of students for each department.", "We need to count the number of students, which can be done using the COUNT() function.", "The students are identified by their department code, which is stored in the 'dept_code' column of the 'student' table.", "To get the count of students grouped by department, we will use the GROUP BY clause on the 'dept_code' column.", "The SQL query will select the count of students and the department code, grouping the results by department code."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT count(*), dept_code FROM student GROUP BY dept_code", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students grouped by their department codes from the 'student' table. The placeholder in the SELECT statement represents the department code for which the count of students is being aggregated.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    }\n}\n"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["Identify the goal: Calculate the total credit hours completed by students in each department.", "Use the 'STUDENT' table, which contains the 'STU_HRS' column representing credit hours and 'DEPT_CODE' for department identification.", "Group the results by 'DEPT_CODE' to aggregate the total hours for each department.", "Use the SUM function to calculate the total hours for each department.", "Construct the SQL query using SELECT, SUM, and GROUP BY clauses."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT dept_code, SUM(stu_hrs) AS total_hours FROM student GROUP BY dept_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping the results.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["Identify the relevant tables: We need to look at the COURSE and CLASS tables to find the total credits offered by each department.", "Join the COURSE and CLASS tables on the CRS_CODE to link courses with their respective classes.", "Use the SUM function to calculate the total credit hours for each department by grouping the results based on DEPT_CODE.", "Order the results in descending order to find the department with the most credits.", "Limit the results to 1 to get only the department that offers the most credits."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "pred_sql": "SELECT DEPT_CODE, SUM(crs_credit) AS total_credits FROM COURSE AS T1 JOIN CLASS AS T2 ON T1.CRS_CODE = T2.CRS_CODE GROUP BY DEPT_CODE ORDER BY total_credits DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping the results.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the relevant tables: We need to find student information related to a specific class, so we will use the ENROLL, CLASS, and STUDENT tables.", "Join the ENROLL table with the CLASS table on CLASS_CODE to link students to their classes.", "Join the resulting table with the STUDENT table on STU_NUM to get student details.", "Filter the results to only include students enrolled in the class with CRS_CODE 'ACCT-211'.", "Select the first names of the students from the final result."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME FROM ENROLL JOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE JOIN STUDENT ON ENROLL.STU_NUM = STUDENT.STU_NUM WHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["We need to find the first names of students enrolled in a specific class (ACCT-211) and who received a grade of C.", "To do this, we will join the STUDENT table with the ENROLL table on the student number (STU_NUM) to get the enrollment details for each student.", "Next, we will join the resulting table with the CLASS table on the class code (CLASS_CODE) to filter for the specific class (ACCT-211).", "Finally, we will apply a WHERE clause to filter for students who received a grade of C in that class.", "The final output will select the first names (STU_FNAME) of those students."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT S.STU_FNAME \nFROM STUDENT AS S \nJOIN ENROLL AS E ON S.STU_NUM = E.STU_NUM \nJOIN CLASS AS C ON E.CLASS_CODE = C.CLASS_CODE \nWHERE C.CLASS_CODE = 'ACCT-211' AND E.ENROLL_GRADE = 'C';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["We need to find the department with the most students enrolled.", "First, we can create a virtual table that counts the number of students in each department using the 'student' table, grouping by 'dept_code'.", "Next, we will order this count in descending order to get the department with the highest number of students at the top.", "To retrieve the name of the department, we will join this result with the 'department' table using the 'dept_code'.", "Finally, we will limit our result to just one department, which will be the one with the most students."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT dept_name FROM department WHERE dept_code = (SELECT dept_code FROM student GROUP BY dept_code ORDER BY count(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students grouped by their department codes from the 'student' table. The placeholder in the SELECT statement represents the department code for which the count of students is being aggregated.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table that are associated with classes in the 'CLASS' table. It joins the 'ENROLL' table to link students to classes, the 'COURSE' table to connect classes to their respective courses, and finally the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the number of classes in descending order, with a limit on the number of departments returned as specified by a placeholder.\",\n        \"virtual_table\": \"SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3257", "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["Identify the relevant table: The CLASS table contains information about classes, including the room where they are held.", "Determine the required columns: We need the course codes (CRS_CODE) for classes held in room KLR209.", "Construct the SQL query: Use a SELECT statement to retrieve distinct CRS_CODE from the CLASS table where CLASS_ROOM is 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE FROM CLASS WHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping the results.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.\",\n        \"virtual_table\": \"SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about class locations and course codes.", "Determine the required columns: We need the course codes (CRS_CODE) from the CLASS table.", "Specify the condition: We want to filter the results to only include classes held in room 'KLR209'.", "Construct the SQL query: Use SELECT DISTINCT to get unique course codes from the CLASS table where the CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE \nFROM CLASS \nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping the results.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.\",\n        \"virtual_table\": \"SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed since we want student names and their grades.", "We need to join these tables on the common key, which is STUDENT.STU_NUM and ENROLL.STU_NUM.", "We want to filter the results to only include students who received a grade of 'C'.", "Select the distinct first names of the students who meet the criteria."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["Identify the relevant table: We need to find the first names of professors, so we will focus on the PROFESSOR table.", "Determine the condition: We want professors who do not teach a class. This means we need to find professors whose EMP_NUM is not present in the CLASS table.", "Construct the subquery: The subquery will select PROF_NUM from the CLASS table to identify professors who are teaching classes.", "Combine the main query and subquery: The main query will select EMP_FNAME from the PROFESSOR table where EMP_NUM is not in the results of the subquery."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME FROM PROFESSOR WHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the relevant tables: We need to focus on the PROFESSOR table to get the first names of professors.", "Determine the condition: We want professors who are not teaching any classes, which means we need to find professors whose EMP_NUM is not present in the CLASS table's PROF_NUM.", "Construct the subquery: The subquery will select all PROF_NUM from the CLASS table to identify professors who are teaching classes.", "Combine the main query and subquery: The main query will select the first names from the PROFESSOR table where the EMP_NUM is not in the results of the subquery."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT emp_fname FROM PROFESSOR WHERE emp_num NOT IN (SELECT prof_num FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the table that contains information about professors and their degrees, which is the PROFESSOR table.", "Determine the relevant column that indicates the highest degree attained by professors, which is PROF_HIGH_DEGREE.", "Formulate a SQL query to count the number of professors whose highest degree is either 'Ph.D.' or 'Masters'.", "Use the COUNT function to get the total number of professors meeting the criteria and filter using the WHERE clause with the IN operator."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) FROM PROFESSOR WHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    }\n}\n"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, COURSE, PROFESSOR, and DEPARTMENT.", "Join the CLASS table with EMPLOYEE to get the professor's first name.", "Join the CLASS table with COURSE to filter by course codes 'CIS-220' and 'QM-261'.", "Join with PROFESSOR to ensure we are getting the correct professors for the classes.", "Join with DEPARTMENT if needed for additional information, but in this case, we only need the professor's first name.", "Use a WHERE clause to filter the results to only include the specified course codes."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "pred_sql": "SELECT T2.emp_fname FROM CLASS AS T1 JOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM JOIN COURSE AS T3 ON T1.CRS_CODE = T3.CRS_CODE JOIN PROFESSOR AS T4 ON T2.EMP_NUM = T4.EMP_NUM JOIN DEPARTMENT AS T5 ON T4.DEPT_CODE = T5.DEPT_CODE WHERE T3.CRS_CODE IN ('CIS-220', 'QM-261')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the tables needed: STUDENT, ENROLL, CLASS, COURSE, and DEPARTMENT.", "We need to find the first names of students, so we will select the STU_FNAME column from the STUDENT table.", "Students are enrolled in classes, so we will join the ENROLL table to link students to their classes.", "The CLASS table will be joined to get the course codes associated with each class.", "Next, we join the COURSE table to get the department codes for each course.", "Finally, we join the DEPARTMENT table to filter by department names 'Accounting' and 'Computer Info. Systems'.", "Use a WHERE clause to specify that we only want departments that match either 'Accounting' or 'Computer Info. Systems'.", "Use DISTINCT to ensure that we only get unique first names of students."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME \nFROM STUDENT AS S \nJOIN ENROLL AS E ON S.STU_NUM = E.STU_NUM \nJOIN CLASS AS C ON E.CLASS_CODE = C.CLASS_CODE \nJOIN COURSE AS CR ON C.CRS_CODE = CR.CRS_CODE \nJOIN DEPARTMENT AS D ON CR.DEPT_CODE = D.DEPT_CODE \nWHERE D.DEPT_NAME IN ('Accounting', 'Computer Info. Systems')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3308", "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, PROFESSOR, and DEPARTMENT.", "Join the CLASS table with EMPLOYEE to get the first names of professors.", "Join the EMPLOYEE table with PROFESSOR to get office details.", "Join the PROFESSOR table with DEPARTMENT to filter by department name.", "Add a WHERE clause to filter for professors in the History department and with a Ph.D."], "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"], "pred_sql": "SELECT T2.emp_fname, T4.prof_office FROM CLASS AS T1 JOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM JOIN PROFESSOR AS T4 ON T2.EMP_NUM = T4.EMP_NUM JOIN DEPARTMENT AS T5 ON T4.DEPT_CODE = T5.DEPT_CODE WHERE T5.DEPT_NAME = 'History' AND T4.PROF_HIGH_DEGREE = 'Ph.D';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3319", "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["Identify the tables needed: STUDENT for student names and ENROLL for enrollment details including grades.", "We need to find students who received either an 'A' or a 'C' in any course, so we will filter the ENROLL table based on the ENROLL_GRADE column.", "To get the names of the students, we will select the first and last names from the STUDENT table.", "We will join the STUDENT table with the ENROLL table on the student number (STU_NUM) to link students with their grades.", "Finally, we will use a WHERE clause to filter for grades 'A' or 'C' and use DISTINCT to avoid duplicate names in the result."], "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME, S.STU_LNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nWHERE E.ENROLL_GRADE IN ('A', 'C');", "hint": "\n"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, PROFESSOR, and DEPARTMENT.", "We need to get the first names of professors and their highest degree, so we will select 'emp_fname' from EMPLOYEE and 'prof_high_degree' from PROFESSOR.", "Join the CLASS table with EMPLOYEE to get the professor's first name using the 'prof_num' foreign key.", "Join the PROFESSOR table to get the highest degree of the professor using the 'emp_num' foreign key.", "Join the DEPARTMENT table to filter professors by the 'Computer Information Systems' department using the 'dept_code'.", "Construct the SQL query with the necessary SELECT and JOIN statements, including the WHERE clause for filtering by department."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "pred_sql": "SELECT T2.emp_fname, T4.prof_high_degree \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.prof_num = T2.emp_num \nJOIN PROFESSOR AS T4 ON T2.emp_num = T4.emp_num \nJOIN DEPARTMENT AS T5 ON T4.dept_code = T5.dept_code \nWHERE T5.dept_name = 'Computer Information Systems'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE are needed to find the department name and course description.", "Join the DEPARTMENT table with the COURSE table on the DEPT_CODE to link courses to their respective departments.", "Filter the results to only include courses where the description contains the word 'Statistics' using a WHERE clause with LIKE operator.", "Select the DEPT_NAME from the DEPARTMENT table as the final output."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT D.DEPT_NAME \nFROM DEPARTMENT AS D \nJOIN COURSE AS C ON D.DEPT_CODE = C.DEPT_CODE \nWHERE C.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    }\n}\n"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["The question asks for the types and countries of competitions.", "To get the types of competitions, we need to select the 'Competition_type' column from the 'competition' table.", "To get the countries where these competitions are held, we also need to select the 'Country' column from the same table.", "Using DISTINCT ensures that we get unique combinations of competition types and countries.", "The final SQL query combines these selections into a single query."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT Competition_type, Country FROM competition", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n        \"virtual_table\": \"SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n        \"virtual_table\": \"SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3355", "db_id": "sports_competition", "question": "Please show the names and the players of clubs.", "rationale": ["Identify the tables needed: 'club' for club names and 'player' for player names.", "Determine the relationship between the tables: 'player' has a foreign key 'Club_ID' that references 'club'.", "Use a JOIN operation to combine data from both tables based on the 'Club_ID'.", "Select the desired columns: club names from the 'club' table and player names from the 'player' table."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "pred_sql": "SELECT c.name AS club_name, p.name AS player_name \nFROM club c \nJOIN player p ON c.Club_ID = p.Club_ID;", "hint": "\n"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["Identify the relevant table: The 'player' table contains information about players and their positions.", "Determine the required calculation: We need to calculate the average number of points scored by players in each position.", "Group the results: Use GROUP BY to group the players by their Position.", "Filter the results: Use HAVING to filter out positions where the average points are greater than 20."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player GROUP BY Position HAVING AVG(Points) > 20;", "hint": "\n"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant column for player positions, which is 'Position'.", "Identify the column that contains the points scored by players, which is 'Points'.", "Formulate the condition to filter players based on their points: greater than 20 or less than 10.", "Construct the SQL query to select the 'Position' from the 'player' table where the points meet the specified conditions."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player WHERE Points > 20 OR Points < 10;", "hint": "\n"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about the competitions, including their type and country.", "Filter for tournament competitions: We need to focus on competitions where the Competition_type is 'tournament'.", "Group by country: To find out how many tournaments each country participated in, we will group the results by the 'Country' column.", "Count the number of tournaments: We will count the number of occurrences for each country using COUNT(*).", "Order the results: We want to order the results in descending order based on the count of tournaments to find the country with the most tournaments.", "Limit the results: Finally, we will limit the results to only show the top country with the most tournaments."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country, COUNT(*) as Tournament_Count \nFROM competition \nWHERE Competition_type = 'tournament' \nGROUP BY Country \nORDER BY Tournament_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n        \"virtual_table\": \"SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n        \"virtual_table\": \"SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3384", "db_id": "sports_competition", "question": "what is the name of the country that participated in the most tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about the competitions, including their type and country.", "Filter for tournament competitions: We need to focus on competitions that are of type 'tournament'.", "Group by country: To find out which country participated in the most tournaments, we will group the results by the 'Country' column.", "Count the occurrences: We will count how many tournaments each country participated in.", "Order by count: We will order the results in descending order based on the count of tournaments.", "Limit to one result: Finally, we will limit the results to only the top country that participated in the most tournaments."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country FROM competition WHERE Competition_type = 'tournament' GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n        \"virtual_table\": \"SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3388", "db_id": "sports_competition", "question": "What are the countries that have never participated in any friendly-type competitions?", "rationale": ["Identify the countries that have participated in competitions by selecting distinct countries from the competition table.", "Filter out the countries that have participated in friendly-type competitions by using a subquery that selects distinct countries where the competition type is 'friendly'.", "Use the NOT IN clause to exclude these countries from the main query, ensuring we only get countries that have never participated in friendly-type competitions."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT Country FROM competition WHERE Competition_type != 'friendly' AND Country NOT IN (SELECT DISTINCT Country FROM competition WHERE Competition_type = 'friendly')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n        \"virtual_table\": \"SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n        \"virtual_table\": \"SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["Identify the relevant table: The 'employees' table contains the necessary information about employees' names and salaries.", "Determine the required fields: We need to select the first name, last name, and salary of employees.", "Apply the condition: We want to filter employees who earn below 6000, which will be done using a WHERE clause."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "pred_sql": "SELECT first_name, last_name, salary FROM employees WHERE salary < 6000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\",\n        \"virtual_table\": \"SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (first and last name), hire date, salary, and department id.", "To get the full name, we can concatenate the first name and last name.", "We need to filter employees whose first name does not contain the letter 'M'.", "The SQL query will select the concatenated full name, hire date, salary, and department id from the employees table with the specified condition."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT CONCAT(first_name, ' ', last_name) AS full_name, hire_date, salary, department_id FROM employees WHERE first_name NOT LIKE '%M%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: first name, last name, hire date, salary, and department number.", "Filter employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by department number, which corresponds to the department_id in the employees table."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT first_name, last_name, hire_date, department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["Identify the required fields: full name (first and last name), hire date, salary, and department id.", "To create the full name, concatenate the first name and last name using '||'.", "Filter employees whose first name does not contain the letter 'M' using the NOT LIKE operator.", "Order the results by department id in ascending order.", "Construct the SQL query using the SELECT statement with the identified fields and conditions."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The question pertains to job titles and salaries, so we will focus on the 'jobs' table.", "Determine the condition: We need to find jobs with salaries over 9000, which refers to the minimum salary for each job.", "Construct the SQL query: We will select the 'JOB_TITLE' from the 'jobs' table where 'MIN_SALARY' is greater than 9000."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE FROM jobs WHERE MIN_SALARY > 9000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The 'jobs' table contains the job titles and salary information.", "Determine the required columns: We need 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY'.", "Specify the condition for maximum salary: We want jobs where the 'MAX_SALARY' is between 12000 and 18000.", "Construct the SQL query using SELECT to retrieve the specified columns from the 'jobs' table with the appropriate WHERE clause."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY FROM jobs WHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\",\n        \"virtual_table\": \"SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["The question asks for employee ids and their final dates of employment at their last job.", "To find the last job end date for each employee, we can use the 'job_history' table which contains records of employees' job histories.", "We will select the 'employee_id' and the maximum 'end_date' for each employee from the 'job_history' table.", "Using the MAX function allows us to retrieve the latest end date for each employee's job history.", "We will group the results by 'employee_id' to ensure we get one record per employee."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT employee_id, MAX(end_date) AS last_job_end_date FROM job_history GROUP BY employee_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the employee's unique identifier, while the MAX function is used to retrieve the latest end date for each employee's job history.\",\n        \"virtual_table\": \"SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["We need to display the average salary of employees for each department who gets a commission percentage.", "To calculate the average salary, we will use the AVG() function on the SALARY column from the employees table.", "We need to join the employees table with the departments table to get the department names corresponding to each employee.", "The join condition will be on the DEPARTMENT_ID column present in both tables.", "We will filter the employees to include only those who have a non-null COMMISSION_PCT, indicating they receive a commission.", "Finally, we will group the results by department name to get the average salary for each department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_NAME, AVG(e.SALARY) AS AVERAGE_SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nWHERE e.COMMISSION_PCT IS NOT NULL \nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\",\n        \"virtual_table\": \"SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\",\n        \"virtual_table\": \"SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["Identify the table needed: The question is about employees' salaries, so we will use the 'employees' table.", "Determine the required calculation: We need to calculate the average salary, which can be done using the AVG() function.", "Filter the results: We only want employees who have a commission percentage that is not null, so we will add a WHERE clause to filter out those employees.", "Construct the SQL query: Combine the AVG() function with the SELECT statement and apply the WHERE clause to get the desired result."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT AVG(salary) AS average_salary FROM employees WHERE commission_pct IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\",\n        \"virtual_table\": \"SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["Identify the required columns: COUNTRY_ID from the countries table and the count of cities from the locations table.", "To get the number of cities for each country, we need to join the countries table with the locations table on the COUNTRY_ID.", "Use COUNT function to count the number of cities associated with each country.", "Group the results by COUNTRY_ID to ensure we get a count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT countries.COUNTRY_ID, COUNT(locations.CITY) AS number_of_cities\nFROM countries\nJOIN locations ON countries.COUNTRY_ID = locations.COUNTRY_ID\nGROUP BY countries.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["Identify the tables needed: 'countries' for country information and 'locations' for city information.", "Determine the relationship between the tables: 'locations' has a foreign key 'COUNTRY_ID' that links to 'countries'.", "Use a JOIN to combine 'countries' and 'locations' on the 'COUNTRY_ID'.", "Count the number of cities (from 'locations') for each country (from 'countries').", "Group the results by 'COUNTRY_ID' to get the count of cities per country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT c.COUNTRY_ID, COUNT(l.CITY) AS CITY_COUNT\nFROM countries c\nJOIN locations l ON c.COUNTRY_ID = l.COUNTRY_ID\nGROUP BY c.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["Identify the requirement to return detailed info of jobs done by employees earning a salary of 12000 or more.", "Start with the 'jobs' table to get all job details.", "To find relevant jobs, we need to link jobs with employees through the 'job_history' table.", "We need to filter employees based on their salary, specifically those earning 12000 or more.", "Create a subquery to select employee IDs from the 'employees' table where the salary is greater than or equal to 12000.", "Next, use this list of employee IDs to find corresponding job IDs in the 'job_history' table.", "Finally, use these job IDs to filter the 'jobs' table and retrieve all relevant job details."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "pred_sql": "SELECT jobs.* FROM jobs WHERE jobs.JOB_ID IN (SELECT job_history.JOB_ID FROM job_history WHERE job_history.EMPLOYEE_ID IN (SELECT employees.EMPLOYEE_ID FROM employees WHERE employees.SALARY >= 12000))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the employee's unique identifier, while the MAX function is used to retrieve the latest end date for each employee's job history.\",\n        \"virtual_table\": \"SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id\"\n    }\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the requirement: We need information about employees who are managers.", "To find employees who are managers, we can look for employees whose IDs appear in the manager_id field of the employees table.", "We will use a subquery to select distinct manager_ids from the employees table.", "We will join the employees table with the departments and locations tables to get additional information such as department name, city, and state/province.", "The final query will select the first name, last name, department name, city, and state/province for those employees who are managers."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT T1.first_name, T1.last_name, T2.department_name, T3.city, T3.state_province \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nWHERE T1.employee_id IN (SELECT DISTINCT manager_id FROM employees WHERE manager_id IS NOT NULL);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["We need to find departments where any manager is managing 4 or more employees.", "To do this, we will count the number of employees in each department.", "We can use the COUNT function to count the employees grouped by department_id.", "The HAVING clause will filter the results to only include departments with 4 or more employees."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(*) >= 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find distinct department IDs where a manager oversees 4 or more employees.", "To achieve this, we will join the 'employees' table with the 'departments' table on the department ID.", "We will group the results by department ID to count the number of employees in each department.", "Using the COUNT function, we will filter the groups to only include those with 4 or more employees using the HAVING clause."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT T2.department_id \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nGROUP BY T2.department_id \nHAVING COUNT(T1.employee_id) >= 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of employees grouped by their respective department names from the 'departments' table. The placeholder in the SELECT statement allows for the retrieval of department names, while the COUNT function aggregates the number of employees in each department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["Identify the relevant table: The 'employees' table contains the information about employees and their salaries.", "Determine the conditions: We need to find employees with salaries above the minimum salary for their job and below 2500.", "Use a subquery to find the minimum salary: The subquery (SELECT MIN(MIN_SALARY) FROM jobs) retrieves the minimum salary from the jobs table.", "Combine the conditions in the WHERE clause: The final query selects all columns from the employees table where the salary is greater than the minimum salary from jobs and less than 2500."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "pred_sql": "SELECT * FROM employees WHERE salary > (SELECT MIN(MIN_SALARY) FROM jobs) AND salary < 2500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["Identify the employee with the first name 'Clara' to find their department ID.", "Join the employees table with the departments table to get the department ID for Clara.", "Use a subquery to filter employees who belong to the same department as Clara.", "Select the full names (concatenation of first and last names) and hire dates of those employees."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "pred_sql": "SELECT CONCAT(e.FIRST_NAME, ' ', e.LAST_NAME) AS full_name, e.HIRE_DATE \nFROM employees e \nWHERE e.DEPARTMENT_ID = (SELECT d.DEPARTMENT_ID \n                         FROM employees c \n                         JOIN departments d ON c.DEPARTMENT_ID = d.DEPARTMENT_ID \n                         WHERE c.FIRST_NAME = 'Clara')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the requirement: We need the full names and hire dates of employees in the same department as someone named Clara, excluding Clara herself.", "Use the provided virtual table to get the first and last names of employees along with their hire dates.", "Join the employees table with the departments table to filter employees based on their department.", "To find the department of Clara, we need a subquery that selects the department_id from the employees table where the first name is 'Clara'.", "Finally, ensure that we exclude Clara from the results by adding a condition in the WHERE clause that checks for first_name not equal to 'Clara'."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT T1.first_name, T1.last_name, T1.hire_date \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nWHERE T2.department_id = (SELECT department_id FROM employees WHERE first_name = 'Clara') \nAND T1.first_name != 'Clara';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["Identify the main requirement: We need to display the employee number and name (first name and last name) for all employees who work in a department with any employee whose name contains a 'T'.", "To achieve this, we will need to use a subquery to find the department IDs of employees whose first or last name contains 'T'.", "The subquery will select distinct department IDs from the employees table where either the first name or last name matches the condition.", "The outer query will then select the employee ID, first name, and last name from the employees table where the department ID is in the list obtained from the subquery."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME \nFROM employees e \nWHERE e.DEPARTMENT_ID IN (\n    SELECT DISTINCT e2.DEPARTMENT_ID \n    FROM employees e2 \n    WHERE e2.FIRST_NAME LIKE '%T%' OR e2.LAST_NAME LIKE '%T%'\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the requirement: We need to display employee number and job id for employees whose salary is less than any salary of those with job title 'MK_MAN'.", "To achieve this, we need to find the minimum salary of employees with the job title 'MK_MAN'.", "We can do this by first selecting the job_id from the jobs table where the job_title is 'MK_MAN'.", "Next, we will use this job_id to find the minimum salary from the employees table.", "Finally, we will select employee_id and job_id from the employees table where their salary is less than this minimum salary."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT employee_id, job_id FROM employees WHERE salary < (SELECT MIN(salary) FROM employees WHERE job_id = (SELECT job_id FROM jobs WHERE job_title = 'MK_MAN'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department id for each department that has more than 2 employees.", "To achieve this, we will use the 'employees' table which contains the salary and department information.", "We will group the results by 'department_id' to aggregate the salaries for each department.", "The SUM function will be used to calculate the total salaries for each department.", "To filter departments with more than 2 employees, we will use the COUNT function in the HAVING clause."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT T1.department_id, SUM(T1.salary) AS total_salaries \nFROM employees AS T1 \nGROUP BY T1.department_id \nHAVING COUNT(T1.employee_id) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\",\n        \"virtual_table\": \"SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\",\n        \"virtual_table\": \"SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To get the full name, we can concatenate the first name and last name from the employees table.", "We will use a subquery to find the maximum salary for each department. The subquery will select the maximum salary from the employees table where the department ID matches the current department ID in the outer query.", "The outer query will select the department ID, full name, and salary from the employees table where the salary matches the maximum salary found in the subquery."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) FROM employees WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\",\n        \"virtual_table\": \"SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\",\n        \"virtual_table\": \"SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the tables needed: employees for names, departments for department information, and locations for city information.", "Join the employees table with the departments table on department_id to get department names.", "Join the resulting table with the locations table on location_id to get city information.", "Filter the results to include only those employees whose first names contain the letter 'Z' using the LIKE operator."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name, T1.last_name, T3.city \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nWHERE T1.first_name LIKE '%Z%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed to retrieve the employee's full name and the country they are working in: employees, departments, locations, and countries.", "Join the employees table with the departments table on DEPARTMENT_ID to get department information.", "Join the departments table with the locations table on LOCATION_ID to get location information.", "Join the locations table with the countries table on COUNTRY_ID to get the country name.", "Select the first name and last name from the employees table and the country name from the countries table.", "Use a WHERE clause to filter the results for a specific employee ID."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, c.COUNTRY_NAME \nFROM employees AS e \nJOIN departments AS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations AS l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries AS c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE e.EMPLOYEE_ID = ?", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["Identify the tables needed: 'employees' for employee data and 'departments' for department names.", "Join the 'employees' table with the 'departments' table on the common column 'DEPARTMENT_ID'.", "Select the department name from the 'departments' table and count the number of employees from the 'employees' table.", "Use the COUNT function to aggregate the number of employees per department.", "Group the results by department name to get the count for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT T2.DEPARTMENT_NAME, COUNT(*) AS NUMBER_OF_EMPLOYEES FROM employees AS T1 JOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID GROUP BY T2.DEPARTMENT_NAME", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of employees grouped by their respective department names from the 'departments' table. The placeholder in the SELECT statement allows for the retrieval of department names, while the COUNT function aggregates the number of employees in each department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["Identify the tables needed: 'employees' for employee data and 'departments' for department names.", "Join the 'employees' table with the 'departments' table on the common column 'DEPARTMENT_ID'.", "Select the department name from the 'departments' table and count the number of employees from the 'employees' table.", "Group the results by department name to get the count of employees in each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT T2.DEPARTMENT_NAME, COUNT(*) \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nGROUP BY T2.DEPARTMENT_NAME", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of employees grouped by their respective department names from the 'departments' table. The placeholder in the SELECT statement allows for the retrieval of department names, while the COUNT function aggregates the number of employees in each department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["We need to display the full name (first and last name) and salary of employees.", "To get the employees' names and salaries, we will select from the 'employees' table.", "We need to join the 'departments' table to link employees to their respective departments.", "We also need to join the 'locations' table to filter departments based on their location (city).", "The condition specifies that we are only interested in departments located in London, so we will add a WHERE clause to filter by city."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name, T1.last_name, T1.salary \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nWHERE T3.city = 'London';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the tables needed: employees, departments, and locations.", "Join the employees table with the departments table on department_id to get department information.", "Join the resulting table with the locations table on location_id to get location information.", "Filter the results to only include employees whose department is located in the city of London.", "Select the first name, last name, and salary of the employees from the final joined table."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name, T1.last_name, T1.salary \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nWHERE T3.city = 'London'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3532", "db_id": "music_1", "question": "Find the id of the song that lasts the longest.", "rationale": ["Identify the table that contains the song information, which is the 'song' table.", "Determine the relevant column for the song duration, which is 'duration'.", "To find the longest song, we need to order the results by the 'duration' column in descending order.", "Since we only need the id of the longest song, we will select 'f_id' from the 'song' table.", "Finally, limit the results to 1 to get only the longest song."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT f_id FROM song ORDER BY duration DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["Identify the relevant tables: We need to use the 'song' table to find the shortest song and the 'artist' table to get the artist names.", "Determine the criteria for the shortest song: We need to find the minimum duration from the 'song' table.", "Construct a subquery to find the minimum duration: This will help us filter the songs that have this minimum duration.", "Join the results to get the artist names: We will select the artist names from the 'song' table where the duration matches the minimum duration found in the subquery."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "pred_sql": "SELECT artist_name FROM song WHERE duration = (SELECT MIN(duration) FROM song)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["Identify the relevant table: The 'song' table contains the duration of songs.", "Determine the condition: We need to find songs with a duration of 4 minutes, which is represented as '4:00'.", "Construct the SQL query: Use the COUNT function to count the number of records in the 'song' table that meet the duration condition."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "pred_sql": "SELECT COUNT(*) FROM song WHERE duration = '4:00';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3549", "db_id": "music_1", "question": "What is the average rating of songs produced by female artists?", "rationale": ["Identify the relevant tables: We need to use the 'artist' table to filter by gender and the 'song' table to get the ratings of the songs.", "We are interested in female artists, so we will filter the 'artist' table where gender is 'female'.", "We need to join the 'artist' table with the 'song' table on the artist's name to access the ratings of the songs produced by these artists.", "Finally, we will calculate the average rating of these songs using the AVG() function."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "pred_sql": "SELECT AVG(T3.rating) AS average_rating FROM artist AS T1 JOIN song AS T3 ON T1.artist_name = T3.artist_name WHERE T1.gender = 'female';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["Identify the table that contains the file formats, which is the 'files' table.", "We need to count how many files exist for each format, so we will use the COUNT() function.", "To group the results by file format, we will use the GROUP BY clause on the 'formats' column.", "To find the most used file format, we will order the results in descending order based on the count of files.", "Finally, we will limit the results to only one entry to get the most used file format."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(*) as file_count \nFROM files \nGROUP BY formats \nORDER BY file_count DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3556", "db_id": "music_1", "question": "What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?", "rationale": ["Identify the table that contains the file information, which is the 'files' table.", "We need to filter the files based on the format, specifically looking for 'mp4'. This can be done using the LIKE operator in SQL.", "Additionally, we need to check the resolution of the files to ensure it is smaller than 1000. Since resolution is stored as text, we will cast it to an integer for comparison.", "Combine these conditions in the WHERE clause of the SQL query to filter the results accordingly."], "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"], "pred_sql": "SELECT f_id FROM files WHERE formats LIKE '%mp4%' AND CAST(resolution AS INTEGER) < 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["Identify the relevant tables: We need to use the 'artist' table to find the country of origin and the 'song' table to filter songs in Bangla.", "Filter artists by gender: We want female artists, so we will add a condition for gender = 'female'.", "Filter songs by language: We need to find songs that are in Bangla, which can be done by checking the 'languages' column in the 'song' table.", "Use a subquery: To find the country of female artists who produced songs in Bangla, we will use a subquery to get the artist names from the 'song' table where the language is Bangla.", "Combine conditions: Finally, we will combine these conditions to get the desired result."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT country FROM artist WHERE gender = 'female' AND artist_name IN (SELECT artist_name FROM song WHERE languages LIKE '%Bangla%');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["Identify the relevant table: We need to find information about artists, specifically their countries and genders, which are in the 'artist' table.", "Filter for female artists: We will add a condition to select only those artists whose gender is 'female'.", "Identify the language condition: We need to find artists who have sung songs in the Bangla language, which is found in the 'song' table.", "Use a subquery to find relevant artists: We will create a subquery that selects artist names from the 'song' table where the languages include 'Bangla'.", "Combine the conditions: The main query will select the country from the 'artist' table where the gender is 'female' and the artist name is in the list of names returned by the subquery."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT country FROM artist WHERE gender = 'female' AND artist_name IN (SELECT artist_name FROM song WHERE languages LIKE '%Bangla%')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["Identify the tables involved: We need information from the 'artist' and 'song' tables.", "Determine the required fields: We need the 'gender' and 'artist_name' from the 'artist' table.", "Establish the relationship: The 'artist' table is linked to the 'song' table through the 'artist_name' field.", "Find the song with the smallest resolution: We can use a subquery to find the minimum resolution from the 'song' table.", "Combine the results: Use a JOIN to combine the artist information with the song that has the smallest resolution."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.gender, artist.artist_name \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.resolution = (SELECT MIN(resolution) FROM song);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3567", "db_id": "music_1", "question": "For each file format, return the number of artists who released songs in that format.", "rationale": ["Identify the relevant tables: We need to work with the 'files', 'song', and 'artist' tables to get the required information about file formats and artists.", "Determine the relationships: The 'files' table is linked to the 'song' table through the 'f_id' column, and the 'song' table is linked to the 'artist' table through the 'artist_name' column.", "Select the required columns: We need to select the 'formats' from the 'files' table and count the distinct 'artist_name' from the 'artist' table to get the number of artists for each format.", "Group by file formats: To get the count of artists for each file format, we will group the results by the 'formats' column from the 'files' table.", "Construct the SQL query: Combine all these elements into a complete SQL query."], "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"], "pred_sql": "SELECT f.formats, COUNT(DISTINCT a.artist_name) AS artist_count \nFROM files AS f \nJOIN song AS s ON f.f_id = s.f_id \nJOIN artist AS a ON s.artist_name = a.artist_name \nGROUP BY f.formats;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3576", "db_id": "music_1", "question": "What are the names and genders of all artists who released songs in the month of March?", "rationale": ["Identify the tables involved: We need information from the 'artist' table for names and genders, and from the 'song' table for release dates.", "Determine the relationship between the tables: The 'artist' table can be joined with the 'song' table on the 'artist_name' column.", "Formulate the SELECT statement: We want to select 'artist_name' and 'gender' from the 'artist' table.", "Add the JOIN clause to connect 'artist' and 'song' tables based on 'artist_name'.", "Specify the condition for the release date: We need songs released in March, which can be checked using a LIKE clause with '%-03-%'.", "Combine all parts to form the final SQL query."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "pred_sql": "SELECT T1.artist_name, T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name WHERE T2.releasedate LIKE '%-03-%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["To find the languages used most often in songs, we need to count the occurrences of each language in the 'song' table.", "We will select the 'languages' column and use the COUNT function to count how many times each language appears.", "We will group the results by 'languages' to aggregate the counts for each language.", "Finally, we will order the results in descending order based on the count to show the most frequently used languages at the top."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "pred_sql": "SELECT languages, COUNT(*) as language_count FROM song GROUP BY languages ORDER BY language_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3590", "db_id": "music_1", "question": "What are the names of all male British artists?", "rationale": ["Identify the relevant table: The 'artist' table contains information about artists, including their names, countries, and genders.", "Determine the criteria for selection: We need to find male artists from Britain.", "Construct the SQL query: Use a SELECT statement to retrieve the 'artist_name' from the 'artist' table where the 'country' is 'Britain' and the 'gender' is 'male'."], "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"], "pred_sql": "SELECT artist_name FROM artist WHERE country = 'Britain' AND gender = 'male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3598", "db_id": "music_1", "question": "What is the average rating and resolution of all bangla songs?", "rationale": ["Identify the relevant table: The 'song' table contains the information about songs, including their genre and rating.", "Filter the songs: We need to filter the songs to only include those that belong to the 'bangla' genre. This is done using the WHERE clause: `WHERE genre_is = 'bangla'`.", "Calculate the average rating: To find the average rating of the filtered songs, we use the AVG() function on the 'rating' column.", "Select resolution: We also need to include the resolution of these songs in our result. Since we want to get the resolution of all bangla songs, we can select it directly as well.", "Construct the SQL query: Combine all these elements into a single SQL query that selects the average rating and resolution for all bangla songs."], "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"], "pred_sql": "SELECT AVG(rating) AS average_rating, resolution FROM song WHERE genre_is = 'bangla'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3599", "db_id": "music_1", "question": "What are the maximum and minimum resolution of songs whose duration is 3 minutes?", "rationale": ["Identify the relevant table: The 'song' table contains the resolution and duration of songs.", "Determine the condition: We need songs with a duration of 3 minutes, which is represented as '3:00'.", "Select the maximum and minimum resolution: Use the MAX() and MIN() functions to get the highest and lowest resolution values respectively.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter by duration."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "pred_sql": "SELECT MAX(resolution) AS max_resolution, MIN(resolution) AS min_resolution FROM song WHERE duration = '3:00'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["Identify the columns needed: maximum duration and resolution of songs, grouped by languages.", "Use the MAX() function to get the maximum values for duration and resolution.", "Group the results by the 'languages' column to aggregate the data accordingly.", "Order the results by 'languages' to have a sorted output."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "pred_sql": "SELECT languages, MAX(duration) AS max_duration, MAX(resolution) AS max_resolution \nFROM song \nGROUP BY languages \nORDER BY languages;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["Identify the relevant tables: 'song' and 'genre'.", "We need to group the results by genre, so we will use the 'g_name' column from the 'genre' table.", "To find the shortest duration of songs, we will use the MIN() function on the 'duration' column from the 'song' table.", "To find the lowest rating of songs, we will also use the MIN() function on the 'rating' column from the 'song' table.", "We need to join the 'song' table with the 'genre' table on the genre name to get the genre information for each song.", "Finally, we will order the results by genre name."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "pred_sql": "SELECT genre.g_name, MIN(song.duration) AS shortest_duration, MIN(song.rating) AS lowest_rating\nFROM song\nJOIN genre ON song.genre_is = genre.g_name\nGROUP BY genre.g_name\nORDER BY genre.g_name;", "hint": "\n"}
{"sample_id": "train.3607", "db_id": "music_1", "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "rationale": ["Identify the tables needed: We need information from the 'artist' table for artist names and countries, and from the 'song' table for song resolutions.", "Determine the relationship between the tables: The 'artist' table is linked to the 'song' table through the 'artist_name' column.", "Filter the songs based on resolution: We need to find songs with a resolution greater than 900.", "Select the required fields: We want to select the artist's name and country from the 'artist' table.", "Construct the SQL query using JOIN to combine data from both tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE song.resolution > 900;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3619", "db_id": "music_1", "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their languages and associated artists.", "Filter songs by language: We need to filter the songs to only include those where the language is 'Bangla'.", "Count the number of songs per artist: We will group the results by 'artist_name' and count the number of songs for each artist using COUNT(song_name).", "Order the results: To find the top artists, we will order the results in descending order based on the count of songs.", "Limit the results: Finally, we will limit the output to the top 3 artists."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist_name, COUNT(song_name) AS song_count \nFROM song \nWHERE languages = 'Bangla' \nGROUP BY artist_name \nORDER BY song_count DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3623", "db_id": "music_1", "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "Determine the columns needed: duration from 'song', file_size and formats from 'files'.", "Establish the relationship between the tables using the foreign key: song.f_id = files.f_id.", "Filter the results to include only songs where the genre is 'pop'.", "Order the results by the song title (song_name).", "Construct the SQL query using SELECT, JOIN, WHERE, and ORDER BY clauses."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT song.duration, files.file_size, files.formats \nFROM song \nJOIN files ON song.f_id = files.f_id \nWHERE song.genre_is = 'pop' \nORDER BY song.song_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "Determine the columns needed: duration and formats from 'song', file size from 'files'.", "Establish the relationship between the tables using foreign keys: 'song.f_id' relates to 'files.f_id'.", "Filter the results to include only pop songs by using the condition 's.genre_is = 'pop''.", "Order the results alphabetically by song title using 'ORDER BY s.song_name ASC'."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT s.duration, f.file_size, f.formats \nFROM song s \nJOIN files f ON s.f_id = f.f_id \nWHERE s.genre_is = 'pop' \nORDER BY s.song_name ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["Identify the relevant tables: We need the 'salary' table to get player salaries and the 'team' table to find the team named 'Boston Red Stockings'.", "Join the 'salary' table with the 'team' table on 'team_id' to associate salaries with the correct team.", "Filter the results to only include salaries from players in the 'Boston Red Stockings' team.", "Use the AVG() function to calculate the average salary of these players."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "pred_sql": "SELECT AVG(s.salary) FROM salary AS s JOIN team AS t ON s.team_id = t.team_id WHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\",\n        \"virtual_table\": \"SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their birth countries.", "Group the data: We need to group the results by 'birth_country' to count how many players are from each country.", "Count the players: Use the COUNT function to count the number of players from each country.", "Order the results: We want to order the results in ascending order based on the count of players, so that countries with fewer players come first.", "Limit the results: We only want the top three countries with the least players, so we use a LIMIT clause with a value of 3."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of countries where players were born, grouped by country and ordered by the number of players from each country in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of countries to return.\",\n        \"virtual_table\": \"SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["Identify the tables needed: 'team' for team names and IDs, and 'salary' for salary information.", "Join the 'team' table with the 'salary' table on 'team_id' to associate each team with its salaries.", "Use the MAX() function to find the highest salary for each team.", "Group the results by 'team_id' and 'name' to ensure we get the maximum salary for each team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T1.name, T1.team_id, MAX(T2.salary) AS max_salary \nFROM team AS T1 \nJOIN salary AS T2 ON T1.team_id = T2.team_id \nGROUP BY T1.team_id, T1.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3658", "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["We need to retrieve the team name, team id, and the maximum salary for each team.", "The relevant tables are 'team' for team details and 'salary' for salary information.", "We will join the 'team' table with the 'salary' table on the 'team_id' column to combine the data.", "To find the maximum salary for each team, we will use the MAX() function on the 'salary' column.", "We will group the results by 'team.team_id' and 'team.name' to ensure we get one result per team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM team\nJOIN salary ON team.team_id = salary.team_id\nGROUP BY team.team_id, team.name;", "hint": "\n"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["We need to find the team with the lowest average salary.", "To do this, we will join the 'salary' table with the 'team' table using the 'team_id' column.", "We will group the results by 'team.team_id' to calculate the average salary for each team.", "Next, we will order the results by the average salary in ascending order to get the lowest average salary at the top.", "Finally, we will limit the results to 1 to get only the team with the lowest average salary.", "We will select the 'name' and 'team_id' of that team."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nGROUP BY team.team_id\nORDER BY AVG(salary.salary) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["We need to find players who won awards in both 1960 and 1961.", "To do this, we will join the 'player' table with the 'player_award' table twice: once for the year 1960 and once for the year 1961.", "The join condition will be based on the player_id to ensure we are looking at the same player in both cases.", "We will select the first name and last name of the players from the 'player' table.", "Finally, we will filter the results to include only those players who have awards recorded for both years."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.name_first, p.name_last \nFROM player p \nJOIN player_award pa1 ON p.player_id = pa1.player_id \nJOIN player_award pa2 ON p.player_id = pa2.player_id \nWHERE pa1.year = 1960 AND pa2.year = 1961;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a specified year of death. The placeholder in the WHERE clause represents the year of death.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.3663", "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["Identify the relevant table: The 'player' table contains the first name, last name, weight, and height of players.", "Determine the conditions: We need to filter players based on their weight being greater than 220 or their height being less than 75.", "Construct the SQL query: Use a SELECT statement to retrieve 'name_first' and 'name_last' from the 'player' table with the specified conditions in the WHERE clause."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a specified year of death. The placeholder in the WHERE clause represents the year of death.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.3664", "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["Identify the relevant table: The 'player' table contains the first name, last name, weight, and height of players.", "Determine the conditions: We need players with a weight greater than 220 or a height less than 75.", "Construct the SQL query: Use a SELECT statement to retrieve 'name_first' and 'name_last' from the 'player' table where the specified conditions are met."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a specified year of death. The placeholder in the WHERE clause represents the year of death.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) of the Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason AS p\nJOIN team AS t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: We need to look at the 'postseason' table for postseason results and the 'team' table for team names.", "Determine the condition: We are interested in the team 'Boston Red Stockings' and their wins in the postseason.", "Use a JOIN operation: We will join the 'postseason' table with the 'team' table on the winning team ID to filter for the specific team.", "Select the maximum score: We will use the MAX function to get the highest number of wins for the specified team."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) FROM postseason AS p JOIN team AS t ON p.team_id_winner = t.team_id WHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3672", "db_id": "baseball_1", "question": "For each year, return the year and the number of times the team Boston Red Stockings won in the postseasons.", "rationale": ["Identify the relevant table for postseason results, which is the 'postseason' table.", "Determine the condition for winning, which is when 'team_id_winner' matches the team ID for 'Boston Red Stockings'.", "Use a subquery to find the 'team_id' for 'Boston Red Stockings' from the 'team' table.", "Group the results by 'year' to count the number of wins for each year.", "Count the number of times the team won in each year using COUNT(*) and alias it as 'wins'."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "pred_sql": "SELECT year, COUNT(*) AS wins\nFROM postseason\nWHERE team_id_winner = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')\nGROUP BY year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3677", "db_id": "baseball_1", "question": "What is the total salary paid by team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant tables: We need to calculate the total salary, so we will use the 'salary' table and join it with the 'team' table to filter by team name.", "Determine the filtering criteria: We need to filter for the team 'Boston Red Stockings' and the year 2010.", "Construct the SQL query: We will use the SUM function to calculate the total salary for the specified team and year, joining the 'salary' table with the 'team' table on 'team_id'."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT SUM(salary.salary) \nFROM salary \nJOIN team ON salary.team_id = team.team_id \nWHERE team.name = 'Boston Red Stockings' AND salary.year = 2010;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\",\n        \"virtual_table\": \"SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant table: The 'salary' table contains the salary information for players.", "Filter by year: We need to focus on the year 2001, so we will add a WHERE clause to filter the records for that year.", "Select the necessary columns: We want to retrieve the 'player_id' and 'salary' columns from the 'salary' table.", "Order the results: To find the highest salaries, we will order the results in descending order based on the 'salary' column.", "Limit the results: Since we only want the top 3 salaries, we will use the LIMIT clause to restrict the output to 3 records."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3682", "db_id": "baseball_1", "question": "How much salary did the top 3 well-paid players get in 2001?", "rationale": ["Identify the relevant table: The 'salary' table contains the salary information for players.", "Filter by year: We need to focus on the year 2001, so we will add a WHERE clause to filter the records for that year.", "Sort the results: To find the top 3 well-paid players, we will order the results by the 'salary' column in descending order.", "Limit the results: We will use LIMIT 3 to get only the top 3 salaries."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3683", "db_id": "baseball_1", "question": "What were all the salary values of players in 2010 and 2001?", "rationale": ["Identify the relevant table for salary information, which is the 'salary' table.", "Determine the years of interest, which are 2010 and 2001.", "Construct a SQL query to select the 'salary' column from the 'salary' table where the 'year' is either 2010 or 2001 using the IN clause."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT salary FROM salary WHERE year IN (2010, 2001);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["To find the year with the least number of players inducted into the Hall of Fame, we need to count the number of inductees for each year.", "We can use the `hall_of_fame` table, which contains the `yearid` for each induction.", "We will group the results by `yearid` and use the `COUNT(*)` function to count the number of inductees for each year.", "To find the year with the least inductees, we will order the results in ascending order based on the count and limit the results to 1 to get the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY COUNT(*) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["To find the year with the least number of players inducted into the Hall of Fame, we need to count the number of inductees for each year.", "We can use the COUNT function to aggregate the total number of inductees per year from the hall_of_fame table.", "We will group the results by the year of induction (yearid) to get the count for each year.", "To find the year with the least inductees, we will order the results in ascending order based on the count of inductees.", "Finally, we will limit the results to just one entry to get the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY COUNT(*) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: home_game and park.", "We need to find the total number of games played in a specific park (Columbia Park) in a specific year (1907).", "Join the home_game table with the park table on the park_id to access park names.", "Filter the results to only include games played in 'Columbia Park' and in the year 1907.", "Use the SUM function to calculate the total number of games played."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(T1.games) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id = T2.park_id WHERE T2.park_name = 'Columbia Park' AND T1.year = 1907;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: home_game and park.", "We need to count the number of games played in a specific park (Columbia Park) in a specific year (1907).", "Join the home_game table with the park table on the park_id to access park names.", "Filter the results for the year 1907 and the park name 'Columbia Park'.", "Use the SUM function to count the total number of games played in that park for that year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(T1.games) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id = T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant tables: home_game and team.", "We need to find the total number of games played in Atlanta in the year 2000.", "The home_game table contains the number of games played, while the team table contains the city information.", "Join the home_game table with the team table on the team_id to access both games and city information.", "Filter the results to only include games played in Atlanta for the year 2000.", "Use the SUM function to calculate the total number of games played."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.city = 'Atlanta' AND T1.year = 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: home_game and team.", "We need to find the total number of games played in Atlanta in the year 2000.", "Join the home_game table with the team table on team_id to access team information.", "Filter the results for the city 'Atlanta' and the year 2000.", "Use the SUM function to calculate the total number of games played."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.city = 'Atlanta' AND T1.year = 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3693", "db_id": "baseball_1", "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?", "rationale": ["Identify the relevant tables: home_game and team.", "We need to calculate the total attendance for home games played by the Boston Red Stockings.", "Join the home_game table with the team table on team_id to filter by team name.", "Use the SUM function to aggregate the attendance over the specified years (2000 to 2010).", "Construct the SQL query using the identified elements."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\",\n        \"virtual_table\": \"SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3698", "db_id": "baseball_1", "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?", "rationale": ["Identify the relevant tables: We need the 'player' table for player names and the 'salary' table for salary records.", "Join the 'player' table with the 'salary' table to get the players who have salary records.", "We need to filter for players who were paid by the Washington Nationals in both 2005 and 2007.", "To do this, we can join the 'salary' table twice: once for 2005 and once for 2007, ensuring both records belong to the same player.", "Use subqueries to get the team_id for the Washington Nationals from the 'team' table.", "Select the first and last names of the players who meet these criteria."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT p.name_first, p.name_last \nFROM player p \nJOIN salary s1 ON p.player_id = s1.player_id \nJOIN salary s2 ON p.player_id = s2.player_id \nWHERE s1.team_id = (SELECT team_id FROM team WHERE name = 'Washington Nationals') AND s1.year = '2005' \nAND s2.team_id = (SELECT team_id FROM team WHERE name = 'Washington Nationals') AND s2.year = '2007';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a specified year of death. The placeholder in the WHERE clause represents the year of death.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant tables: 'home_game' for home games and 'team' for team names.", "Join the 'home_game' table with the 'team' table on 'team_id' to get team names associated with home games.", "Filter the results for the year 1980 to focus on that specific season.", "Group the results by team to aggregate the number of home games played by each team.", "Order the results by the total number of home games in ascending order to find the team with the least number of home games.", "Limit the results to 1 to get only the team with the least number of home games."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id WHERE T1.year = 1980 GROUP BY T2.team_id ORDER BY SUM(T1.games) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3709", "db_id": "baseball_1", "question": "Which park had most attendances in 2008?", "rationale": ["Identify the relevant tables: home_game for attendance data and park for park names.", "Join the home_game table with the park table on park_id to get park names along with attendance data.", "Filter the results to only include records from the year 2008.", "Order the results by attendance in descending order to find the park with the highest attendance.", "Limit the results to 1 to get only the park with the most attendance."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id = T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\",\n        \"virtual_table\": \"SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3857", "db_id": "insurance_policies", "question": "Find the settlement amount of the claim with the largest claim amount. Show both the settlement amount and claim amount.", "rationale": ["Identify the table needed: The 'Claims' table contains the relevant information about claim amounts and settled amounts.", "Determine the requirement: We need to find the settlement amount of the claim with the largest claim amount.", "Use the hint provided: The hint suggests using a virtual table that orders claims by the claimed amount in descending order.", "Construct the SQL query: Select 'Amount_Settled' and 'Amount_Claimed' from 'Claims', order by 'Amount_Claimed' in descending order, and limit the results to 1 to get the largest claim."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"], "pred_sql": "SELECT Amount_Settled, Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the amounts claimed and settled for insurance claims from the 'Claims' table. The results are ordered by the claimed amount in descending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3862", "db_id": "insurance_policies", "question": "Among all the claims, which settlements have a claimed amount that is no more than the average? List the claim start date.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find settlements where the claimed amount is no more than the average claimed amount.", "To do this, we will join the Claims table with the Settlements table on Claim_ID.", "We will filter the results using a WHERE clause that compares the Amount_Claimed in Settlements to the average Amount_Claimed from the Claims table.", "Finally, we will select the Start_Date from the Claims table for the filtered results."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT c.Start_Date\nFROM Claims AS cl\nJOIN Settlements AS s ON cl.Claim_ID = s.Claim_ID\nWHERE s.Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Claims)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the amounts claimed and settled for insurance claims from the 'Claims' table. The results are ordered by the claimed amount in descending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3863", "db_id": "insurance_policies", "question": "Return the claim start date for the claims whose claimed amount is no more than the average", "rationale": ["Identify the relevant table: The 'Claims' table contains the information about claims, including the claimed amounts and the claim dates.", "Determine the condition: We need to find claims where the claimed amount is no more than the average claimed amount. This requires calculating the average of 'Amount_Claimed' from the 'Claims' table.", "Construct the subquery: The subquery will calculate the average claimed amount using 'SELECT AVG(Amount_Claimed) FROM Claims'.", "Combine the main query and subquery: The main query will select 'Date_Claim_Made' from 'Claims' where 'Amount_Claimed' is less than or equal to the result of the subquery.", "Final SQL query: The complete SQL statement combines these elements to retrieve the desired claim start dates."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Claims)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the amounts claimed and settled for insurance claims from the 'Claims' table. The results are ordered by the claimed amount in descending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3868", "db_id": "insurance_policies", "question": "How many settlements were made on the claim with the most recent claim settlement date? List the number and the claim id.", "rationale": ["Identify the most recent claim settlement date from the Settlements table using a subquery.", "Join the Claims table with the Settlements table on Claim_ID to link claims with their settlements.", "Filter the results to only include settlements that match the most recent claim settlement date.", "Count the number of settlements for each claim that meets the criteria and select the Claim_ID along with the count."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT COUNT(*) AS Settlement_Count, T1.Claim_ID \nFROM Claims AS T1 \nJOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID \nWHERE T2.Date_Claim_Settled = (SELECT MAX(Date_Claim_Settled) FROM Settlements) \nGROUP BY T1.Claim_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of settlements associated with each insurance claim from the 'Claims' table. The placeholder in the SELECT statement represents the unique identifier for each claim, while the count reflects the number of settlements linked to that claim.\",\n        \"virtual_table\": \"SELECT T1.Claim_id ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3869", "db_id": "insurance_policies", "question": "Find the claim id and the number of settlements made for the claim with the most recent settlement date.", "rationale": ["We need to find the claim ID and the number of settlements for the claim with the most recent settlement date.", "To achieve this, we will first create a virtual table that counts the number of settlements for each claim by joining the Claims and Settlements tables.", "The join condition is based on the Claim_ID, which is common in both tables.", "Next, we need to filter the results to only include the claim(s) with the most recent settlement date. This can be done using a subquery that selects the maximum Date_Claim_Settled from the Settlements table.", "Finally, we group the results by Claim_ID to get the count of settlements for each claim."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT T1.Claim_ID, COUNT(*) AS Number_of_Settlements \nFROM Claims AS T1 \nJOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID \nWHERE T2.Date_Claim_Settled = (SELECT MAX(Date_Claim_Settled) FROM Settlements) \nGROUP BY T1.Claim_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of settlements associated with each insurance claim from the 'Claims' table. The placeholder in the SELECT statement represents the unique identifier for each claim, while the count reflects the number of settlements linked to that claim.\",\n        \"virtual_table\": \"SELECT T1.Claim_id ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3878", "db_id": "insurance_policies", "question": "What is the most popular payment method?", "rationale": ["Identify the table relevant to payment methods, which is the 'Payments' table.", "To find the most popular payment method, we need to group the records by 'Payment_Method_Code'.", "We will count the occurrences of each payment method using the COUNT function.", "To determine popularity, we will order the results in descending order based on the count of each payment method.", "Finally, we will limit the results to 1 to get only the most popular payment method."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.\",\n        \"virtual_table\": \"SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3879", "db_id": "insurance_policies", "question": "Which payment method is used the most often?", "rationale": ["Identify the table relevant to payment methods, which is the 'Payments' table.", "To find the most frequently used payment method, we need to group the records by 'Payment_Method_Code'.", "We will count the occurrences of each payment method using the COUNT function.", "To get the most often used payment method, we will order the results in descending order based on the count.", "Finally, we will limit the results to 1 to get only the top payment method."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.\",\n        \"virtual_table\": \"SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3880", "db_id": "insurance_policies", "question": "With which kind of payment method were the least number of payments processed?", "rationale": ["Identify the relevant table: The Payments table contains information about payment transactions, including the payment method used.", "Group by payment method: To find out how many payments were processed for each payment method, we need to group the results by the Payment_Method_Code.", "Count the number of payments: We will use the count function to count the number of payments for each payment method.", "Order by frequency: To find the least used payment method, we will order the results in ascending order based on the count of payments.", "Limit the results: Since we only want the payment method with the least number of payments, we will limit the results to 1."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.\",\n        \"virtual_table\": \"SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3886", "db_id": "insurance_policies", "question": "Which kind of policy type was chosen by the most customers?", "rationale": ["Identify the relevant table: The question pertains to the types of insurance policies, which are stored in the 'Customer_Policies' table.", "Group by policy type: To find out which policy type was chosen by the most customers, we need to group the records in 'Customer_Policies' by 'Policy_Type_Code'.", "Count the occurrences: We will count the number of occurrences of each policy type using the COUNT function.", "Order by frequency: To determine which policy type was chosen the most, we will order the results in descending order based on the count of each policy type.", "Limit the results: Since we only want the most chosen policy type, we will limit the results to 1."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "pred_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies from the 'Customer_Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.\",\n        \"virtual_table\": \"SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3893", "db_id": "insurance_policies", "question": "Which customers do not have any policies? Find the details of these customers.", "rationale": ["Identify the Customers table which contains customer details.", "Identify the Customer_Policies table which contains policies linked to customers.", "To find customers without any policies, we need to select customers whose IDs are not present in the Customer_Policies table.", "Use a subquery to select all Customer_IDs from the Customer_Policies table and use the NOT IN clause to filter out those customers from the Customers table."], "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"], "pred_sql": "SELECT * FROM Customers WHERE Customer_ID NOT IN (SELECT Customer_ID FROM Customer_Policies);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies from the 'Customer_Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.\",\n        \"virtual_table\": \"SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3895", "db_id": "insurance_policies", "question": "Which claims had exactly one settlement? For each, tell me the the date the claim was made, the date it was settled and the amount settled.", "rationale": ["Identify the relevant tables: Claims and Settlements are needed to get the claim details and settlement amounts.", "We need to find claims that have exactly one settlement. This can be done by counting the number of settlements for each claim using a subquery.", "The subquery selects Claim_IDs from the Claims table, joining with the Settlements table, grouping by Claim_ID, and filtering with HAVING COUNT(*) = 1 to ensure only claims with one settlement are selected.", "The main query selects the Date_Claim_Made, Date_Claim_Settled from the Claims table and Amount_Settled from the Settlements table, joining them on Claim_ID.", "Finally, we filter the main query using the results of the subquery to only include claims that have exactly one settlement."], "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT C.Date_Claim_Made, C.Date_Claim_Settled, S.Amount_Settled \nFROM Claims AS C \nJOIN Settlements AS S ON C.Claim_ID = S.Claim_ID \nWHERE C.Claim_ID IN (\n    SELECT T1.Claim_ID \n    FROM Claims AS T1 \n    JOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID \n    GROUP BY T1.Claim_ID \n    HAVING COUNT(*) = 1\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of settlements associated with each insurance claim from the 'Claims' table. The placeholder in the SELECT statement represents the unique identifier for each claim, while the count reflects the number of settlements linked to that claim.\",\n        \"virtual_table\": \"SELECT T1.Claim_id ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to count the number of employees (physicians) in each department.", "Join the Department table with the Physician table on the Head of the department.", "Group the results by department to get the count of physicians in each department.", "Order the results by the count of physicians in descending order to find the department with the most employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT d.Name, COUNT(p.EmployeeID) AS EmployeeCount\nFROM Department d\nLEFT JOIN Physician p ON d.Head = p.EmployeeID\nGROUP BY d.DepartmentID\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["Identify the relevant tables: Department and Affiliated_With.", "Join the Department table with the Affiliated_With table on the DepartmentID to get the count of physicians in each department.", "Group the results by DepartmentID to aggregate the count of physicians per department.", "Order the results by the count of physicians in descending order to find the department with the most employees.", "Limit the results to 1 to get only the top department."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT d.Name, COUNT(a.Physician) AS EmployeeCount\nFROM Department d\nJOIN Affiliated_With a ON d.DepartmentID = a.Department\nGROUP BY d.DepartmentID\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3901", "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["Identify the department with the least number of employees by counting the number of physicians affiliated with each department.", "Use the 'Affiliated_With' table to count the number of physicians for each department.", "Order the results by the count of physicians in ascending order to find the department with the least employees.", "Limit the results to 1 to get only the department with the least employees.", "Once we have the DepartmentID of the department with the least employees, we can find the head of that department from the 'Department' table."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Head FROM Department WHERE DepartmentID = (SELECT DepartmentID FROM Affiliated_With GROUP BY DepartmentID ORDER BY COUNT(Physician) ASC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["Identify the head of each department by joining the 'Department' table with the 'Physician' table on the 'Head' column.", "To find the department with the least number of employees, use the 'Affiliated_With' table to count the number of physicians affiliated with each department.", "Group the results by 'DepartmentID' and order them by the count of physicians in ascending order to get the department with the least number of employees.", "Use a subquery to get the 'DepartmentID' of the department with the least number of employees.", "Finally, select the name and position of the physician who is the head of that department."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Department \nJOIN Physician ON Department.Head = Physician.EmployeeID \nWHERE Department.DepartmentID = \n  (SELECT DepartmentID \n   FROM Affiliated_With \n   GROUP BY DepartmentID \n   ORDER BY COUNT(Physician) \n   LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3903", "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["Identify the department with the least employees by counting the number of physicians affiliated with each department.", "Use a subquery to find the DepartmentID that has the minimum count of physicians.", "Join the Department table with the Physician table to get the names and positions of the heads of departments.", "Select the Name and Position of the physician who is the head of the department identified in the previous step."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Department \nJOIN Physician ON Department.Head = Physician.EmployeeID \nWHERE Department.DepartmentID = (SELECT DepartmentID \n                                   FROM Affiliated_With \n                                   GROUP BY DepartmentID \n                                   ORDER BY COUNT(Physician) \n                                   LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["Identify the relevant tables: Appointment and Patient.", "We need to retrieve the names of patients who have made appointments, which means we will join the Appointment table with the Patient table.", "The join condition will be based on the Patient's SSN in the Patient table matching the Patient identifier in the Appointment table.", "We will select the distinct names of patients to avoid duplicates, as a patient may have multiple appointments."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT Patient.Name \nFROM Appointment \nJOIN Patient ON Appointment.Patient = Patient.SSN;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of nurses who are on call, filtered by specific block floor and block code statuses. The placeholders in the WHERE clause represent the identifiers for the blocked floor and blocked code statuses.\",\n        \"virtual_table\": \"SELECT nurse FROM on_call WHERE blockfloor  =  [PLACEHOLDER-TYPE:NUMBER] AND blockcode  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["We need to find the names of all physicians and their primary affiliated departments' names.", "The relevant tables are 'Physician', 'Department', and 'Affiliated_With'.", "We will join 'Affiliated_With' with 'Physician' to get the physician names and with 'Department' to get the department names.", "We need to filter the results to only include primary affiliations, which is indicated by the 'PrimaryAffiliation' column in the 'Affiliated_With' table.", "The final SQL query selects the physician names and their corresponding department names where the affiliation is primary."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name, Department.Name \nFROM Affiliated_With \nJOIN Physician ON Affiliated_With.Physician = Physician.EmployeeID \nJOIN Department ON Affiliated_With.Department = Department.DepartmentID \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3928", "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["Identify the tables needed: Physician and Patient.", "We need to count the number of patients each physician takes care of, which is indicated by the Patient's PCP (Primary Care Physician) being linked to the Physician's EmployeeID.", "Use a LEFT JOIN to connect the Physician table with the Patient table on the condition that Patient.PCP = Physician.EmployeeID.", "Count the number of patients for each physician using COUNT(Patient.SSN).", "Group the results by Physician.Name to get the count for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name, COUNT(Patient.SSN) AS NumberOfPatients\nFROM Physician\nLEFT JOIN Patient ON Physician.EmployeeID = Patient.PCP\nGROUP BY Physician.Name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["Identify the relevant tables: Physician and Patient.", "Determine the relationship: A physician can be a primary care physician (PCP) for multiple patients.", "Join the Physician table with the Patient table on the PCP field.", "Group the results by physician to count the number of patients each physician is responsible for.", "Use HAVING clause to filter those physicians who are in charge of more than one patient."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT p.Name\nFROM Physician p\nJOIN Patient pt ON p.EmployeeID = pt.PCP\nGROUP BY p.EmployeeID\nHAVING COUNT(pt.SSN) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3940", "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["Identify the relevant tables: 'Physician', 'Prescribes', and 'Medication'.", "We need to find the names of physicians who have prescribed a specific medication, 'Thesisin'.", "Join the 'Prescribes' table with the 'Physician' table on the physician's identifier (EmployeeID).", "Join the 'Prescribes' table with the 'Medication' table on the medication code.", "Filter the results where the medication name is 'Thesisin'.", "Select distinct physician names to avoid duplicates."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT DISTINCT Physician.Name \nFROM Prescribes \nJOIN Physician ON Prescribes.Physician = Physician.EmployeeID \nJOIN Medication ON Prescribes.Medication = Medication.Code \nWHERE Medication.Name = 'Thesisin';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3941", "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication.", "We need to find the names of physicians who prescribe a specific medication, which is 'Thesisin'.", "Join the Physician table with the Prescribes table on the EmployeeID and Physician columns respectively.", "Join the Prescribes table with the Medication table on the Medication code.", "Filter the results where the medication name is 'Thesisin'.", "Select the Name column from the Physician table to get the names of the physicians."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT Physician.Name \nFROM Physician \nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician \nJOIN Medication ON Prescribes.Medication = Medication.Code \nWHERE Medication.Name = 'Thesisin';", "hint": "\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["Identify the relevant tables: Medication and Prescribes.", "We need to count the number of medications prescribed for each brand, so we will join the Medication table with the Prescribes table on the medication code.", "Select the brand from the Medication table and count the number of prescriptions from the Prescribes table.", "Group the results by the brand to get the count for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT m.Brand, COUNT(p.Medication) AS NumberOfMedications\nFROM Medication m\nJOIN Prescribes p ON m.Code = p.Medication\nGROUP BY m.Brand;", "hint": "\n"}
{"sample_id": "train.3948", "db_id": "hospital_1", "question": "Find the patient who has the most recent undergoing treatment?", "rationale": ["Identify the relevant table: The 'Undergoes' table contains information about patients undergoing procedures, including the date of the procedures.", "Select the patient identifier from the 'Undergoes' table: We need to retrieve the 'Patient' column.", "Order the results by the date of the procedures: We will sort the results by 'DateUndergoes' in descending order to get the most recent treatment first.", "Limit the results to one: To find only the patient with the most recent undergoing treatment, we will limit the results to 1."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT u.Patient\nFROM Undergoes u\nORDER BY u.DateUndergoes DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3949", "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["Identify the relevant tables: Patient and Undergoes are the main tables needed to find patients undergoing treatments.", "Join the Patient table with the Undergoes table on the patient identifier (SSN) to link patients with their treatments.", "Order the results by the DateUndergoes in descending order to get the most recent treatment first.", "Limit the results to 1 to get only the most recent patient undergoing treatment."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT Patient.Name\nFROM Patient\nJOIN Undergoes ON Patient.SSN = Undergoes.Patient\nORDER BY Undergoes.DateUndergoes DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: 'Prescribes' for prescriptions and 'Physician' for physician details.", "We need to find the physician who prescribed the highest dose, so we will use the 'Dose' column from the 'Prescribes' table.", "To get the physician's name, we will join the 'Prescribes' table with the 'Physician' table on the physician identifier (EmployeeID).", "We will use a subquery to find the maximum dose prescribed by any physician.", "The final query will select the name of the physician whose dose matches the maximum dose found in the subquery."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT Physician.Name\nFROM Prescribes\nJOIN Physician ON Prescribes.Physician = Physician.EmployeeID\nWHERE Prescribes.Dose = (SELECT MAX(Dose) FROM Prescribes);", "hint": "\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["Identify the tables needed: Physician and Affiliated_With.", "We need to select the EmployeeID from the Physician table and the Department from the Affiliated_With table.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns respectively.", "Filter the results to include only those records where the PrimaryAffiliation is 'Yes' to get primary affiliations."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department FROM Physician JOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician WHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["Identify the table that contains procedure information, which is the Procedures table.", "Determine the relevant columns needed for the query: Name and Cost of the procedures.", "To find the most costly procedures, sort the results by the Cost column in descending order.", "Limit the results to the top three entries to get the three most costly procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "\n"}
{"sample_id": "train.3972", "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find physicians who are trained in specific procedures, so we will join the Physician table with the Trained_In table on the EmployeeID and Physician columns.", "Next, we will join the Procedures table to get the cost of each procedure, linking it through the Treatment column in Trained_In and the Code column in Procedures.", "We need to filter the results to only include procedures that cost more than 5000, so we will add a WHERE clause for Procedures.Cost > 5000.", "Finally, we select the distinct names of the physicians who meet this criterion."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT DISTINCT Physician.Name\nFROM Physician\nJOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician\nJOIN Procedures ON Trained_In.Treatment = Procedures.Code\nWHERE Procedures.Cost > 5000;", "hint": "\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find the physician associated with the most expensive procedure.", "Join the Physician table with the Trained_In table on the EmployeeID and Physician columns.", "Then join the result with the Procedures table on the Treatment and Code columns.", "To find the most expensive procedure, we can use a subquery to get the maximum cost from the Procedures table.", "Finally, select the name of the physician whose trained procedure matches the maximum cost."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT p.Name\nFROM Physician p\nJOIN Trained_In t ON p.EmployeeID = t.Physician\nJOIN Procedures pr ON t.Treatment = pr.Code\nWHERE pr.Cost = (SELECT MAX(Cost) FROM Procedures)", "hint": "\n"}
{"sample_id": "train.3980", "db_id": "hospital_1", "question": "Find all procedures which cost more than 1000 or which physician John Wen was trained in.", "rationale": ["Identify the relevant tables: Procedures and Trained_In, as well as Physician for the physician's name.", "We need to select the procedure names from the Procedures table.", "We will join the Procedures table with the Trained_In table on the procedure code to find out which physicians are trained in which procedures.", "We will also join the Trained_In table with the Physician table to filter by the physician's name, 'John Wen'.", "The WHERE clause will include two conditions: one for procedures costing more than 1000 and another for those associated with 'John Wen'.", "Use DISTINCT to ensure that we do not get duplicate procedure names in the result."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT DISTINCT Procedures.Name \nFROM Procedures \nLEFT JOIN Trained_In ON Procedures.Code = Trained_In.Treatment \nLEFT JOIN Physician ON Trained_In.Physician = Physician.EmployeeID \nWHERE Procedures.Cost > 1000 OR Physician.Name = 'John Wen';", "hint": "\n"}
{"sample_id": "train.3993", "db_id": "hospital_1", "question": "How many patients are not using Procrastin-X as medication?", "rationale": ["Identify the main goal: Count the number of patients not using 'Procrastin-X' as medication.", "To find patients not using a specific medication, we need to check the 'Prescribes' table where medications are linked to patients.", "First, we need to find the code for 'Procrastin-X' from the 'Medication' table.", "Next, we will create a subquery that selects all patients who have been prescribed 'Procrastin-X'.", "Finally, we will count all patients from the 'Patient' table whose SSN is not in the list of patients prescribed 'Procrastin-X'."], "gold_sql": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )", "source_tables": ["patient", "prescribes", "medication"], "pred_sql": "SELECT COUNT(*) AS PatientCount \nFROM Patient \nWHERE SSN NOT IN (\n    SELECT Patient \n    FROM Prescribes \n    WHERE Medication = (SELECT Code FROM Medication WHERE Name = 'Procrastin-X')\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4256", "db_id": "club_1", "question": "What are the first names of all the students?", "rationale": ["The question asks for the first names of all students, which corresponds to the 'Fname' column in the 'Student' table.", "To retrieve the first names, we need to select the 'Fname' column from the 'Student' table without any conditions or filters, as we want all students.", "The SQL query will be a simple SELECT statement that specifies the column to retrieve from the specified table."], "gold_sql": "SELECT DISTINCT fname FROM student", "source_tables": ["student"], "pred_sql": "SELECT Fname FROM Student;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  [PLACEHOLDER-TYPE:STRING] AND t3.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4271", "db_id": "club_1", "question": "Give me the first name and last name for all the female members of the club \"Bootup Baltimore\".", "rationale": ["Identify the tables needed: We need data from the Student, Member_of_club, and Club tables.", "Determine the columns to select: We need the first name (Fname) and last name (LName) of female members.", "Establish the relationships: We will join the Student table with Member_of_club on StuID, and then join Member_of_club with Club on ClubID.", "Filter for female students: We will add a condition to filter where Sex is 'Female'.", "Filter for the specific club: We will add a condition to filter where ClubName is 'Bootup Baltimore'.", "Construct the SQL query using the selected columns and the established joins and filters."], "gold_sql": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  'Bootup Baltimore' AND t3.sex  =  'F'", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Fname, LName FROM Student AS s JOIN Member_of_club AS m ON s.StuID = m.StuID JOIN Club AS c ON m.ClubID = c.ClubID WHERE s.Sex = 'Female' AND c.ClubName = 'Bootup Baltimore';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  [PLACEHOLDER-TYPE:STRING] AND t3.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4277", "db_id": "club_1", "question": "Find the club which has the largest number of members majoring in \"600\".", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "We need to count the number of members in each club who are majoring in '600'.", "Join the Club table with the Member_of_club table on ClubID to link clubs with their members.", "Join the resulting table with the Student table on StuID to access student details, specifically their Major.", "Filter the results to include only those students whose Major is '600'.", "Group the results by Club name to aggregate the member counts for each club.", "Order the results by the count of members in descending order to find the club with the most members majoring in '600'.", "Limit the results to 1 to get only the club with the largest number of members."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  '600' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Club.ClubName, COUNT(Member_of_club.StuID) AS MemberCount\nFROM Club\nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID\nJOIN Student ON Member_of_club.StuID = Student.StuID\nWHERE Student.Major = '600'\nGROUP BY Club.ClubName\nORDER BY MemberCount DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  [PLACEHOLDER-TYPE:STRING] AND t3.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4278", "db_id": "club_1", "question": "Find the name of the club that has the most female students.", "rationale": ["Identify the tables involved: We need to get club names and count female students, so we will use the Student, Club, and Member_of_club tables.", "Join the tables: We need to join the Club table with the Member_of_club table on ClubID, and then join the Member_of_club table with the Student table on StuID to access student details.", "Filter for female students: We will add a WHERE clause to filter students by sex, specifically looking for 'Female'.", "Group by club name: To count the number of female students in each club, we will group the results by ClubName.", "Count female students: We will use COUNT(s.StuID) to count the number of female students in each club.", "Order by count: We will order the results in descending order based on the count of female students to find the club with the most female members.", "Limit the results: Finally, we will limit the results to 1 to get only the club with the most female students."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT c.ClubName\nFROM Club c\nJOIN Member_of_club m ON c.ClubID = m.ClubID\nJOIN Student s ON m.StuID = s.StuID\nWHERE s.Sex = 'Female'\nGROUP BY c.ClubName\nORDER BY COUNT(s.StuID) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  [PLACEHOLDER-TYPE:STRING] AND t3.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4312", "db_id": "club_1", "question": "List the clubs that have at least a member with advisor \"1121\".", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "We need to find clubs that have members with a specific advisor, which means we will join the Club table with the Member_of_club table and then with the Student table.", "The join condition will be based on the ClubID in the Club and Member_of_club tables, and the StuID in the Member_of_club and Student tables.", "We need to filter the results where the Advisor column in the Student table matches '1121'.", "Finally, we select distinct club names to avoid duplicates in the result."], "gold_sql": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  1121", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT DISTINCT c.ClubName \nFROM Club AS c \nJOIN Member_of_club AS m ON c.ClubID = m.ClubID \nJOIN Student AS s ON m.StuID = s.StuID \nWHERE s.Advisor = '1121';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  [PLACEHOLDER-TYPE:STRING] AND t3.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: Grants and Organisations are needed to get the total grant amount and filter by organisation type.", "Join the Grants table with the Organisations table on the organisation_id to access the organisation type for each grant.", "Filter the results to include only those organisations that are described as 'research'. This requires a subquery to find the organisation_type associated with 'research' from the Organisation_Types table.", "Use the SUM function to calculate the total grant amount for the filtered organisations."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT SUM(grant_amount) AS total_grant_amount \nFROM Grants \nJOIN Organisations ON Grants.organisation_id = Organisations.organisation_id \nWHERE Organisations.organisation_type = (SELECT organisation_type FROM Organisation_Types WHERE organisation_type_description = 'research')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the role code for the leader role from the Staff_Roles table.", "Count the number of staff members associated with each project that has at least one leader role.", "Select the project with the maximum number of staff members by grouping by project_id and ordering by the count of staff members in descending order.", "Join this result with the Project_Staff table to get the start and end dates of staff members working on that project."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT ps.date_from, ps.date_to \nFROM Project_Staff ps \nJOIN ( \n    SELECT project_id \n    FROM Project_Staff \n    WHERE role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Leader') \n    GROUP BY project_id \n    ORDER BY COUNT(staff_id) DESC \n    LIMIT 1 \n) AS most_staff_project ON ps.project_id = most_staff_project.project_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4328", "db_id": "tracking_grants_for_research", "question": "Find the organisation ids and details of the organisations which are involved in", "rationale": ["The user wants to find the organisation ids and details of the organisations involved.", "We need to select the 'organisation_id' and 'organisation_details' from the 'Organisations' table.", "There are no specific filters or conditions mentioned in the user's query, so we will retrieve all records from the 'Organisations' table."], "gold_sql": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  6000", "source_tables": ["grants", "organisations"], "pred_sql": "SELECT organisation_id, organisation_details FROM Organisations", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of organisations from the 'Organisations' table that are associated with a specific type of organisation. It joins the 'Organisations' table with the 'Organisation_Types' table to filter organisations based on their type description. The placeholder in the WHERE clause represents the description of the organisation type, and the results are ordered by the organisation details.\",\n        \"virtual_table\": \"SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING] ORDER BY organisation_details\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields to associate research staff with their respective organisations.", "Group the results by organisation_id and organisation_type to count the number of research staff per organisation type.", "Order the results in descending order based on the count of research staff to find the organisation type with the most research staff.", "Limit the results to 1 to get only the top organisation type with the most research staff."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT T1.organisation_type, T1.organisation_id \nFROM Organisations AS T1 \nJOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id \nGROUP BY T1.organisation_id, T1.organisation_type \nORDER BY count(T2.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4331", "db_id": "tracking_grants_for_research", "question": "What is the type and id of the organization that has the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff are needed to find the organization type and ID associated with research staff.", "Join the Organisations table with the Research_Staff table on the organisation_id to link organizations with their respective research staff.", "Group the results by organisation_id and organisation_type to aggregate the count of research staff for each organization.", "Order the results by the count of research staff in descending order to find the organization with the most research staff.", "Limit the results to 1 to get only the top organization with the most research staff."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT T1.organisation_type, T1.organisation_id \nFROM Organisations AS T1 \nJOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id \nGROUP BY T1.organisation_id, T1.organisation_type \nORDER BY count(T2.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4333", "db_id": "tracking_grants_for_research", "question": "What is the type of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff are needed to find the organization type associated with research staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id to link organizations with their research staff.", "Group the results by organisation type to count the number of research staff in each type.", "Order the results in descending order based on the count of research staff to find the type with the most staff.", "Limit the results to 1 to get only the top organization type."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the relevant tables: Documents, Grants, and Organisations.", "We need to retrieve the 'sent_date' from the Documents table.", "Join the Documents table with the Grants table on 'grant_id' to access grant amounts.", "Join the Grants table with the Organisations table to filter by organisation type if needed.", "Apply a condition to filter grants with an amount greater than 5000."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT T1.sent_date FROM Documents AS T1 JOIN Grants AS T2 ON T1.grant_id = T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id = T3.organisation_id WHERE T2.grant_amount > 5000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.4335", "db_id": "tracking_grants_for_research", "question": "What are the send dates for all documents that have a grant amount of more than 5000 and are involved in research?", "rationale": ["Identify the relevant tables: Documents and Grants.", "We need to retrieve the 'sent_date' from the Documents table.", "We need to filter documents based on the grant amount, which is in the Grants table.", "Join the Documents table with the Grants table on 'grant_id'.", "Apply the condition to filter grants with an amount greater than 5000."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT T1.sent_date FROM Documents AS T1 JOIN Grants AS T2 ON T1.grant_id = T2.grant_id WHERE T2.grant_amount > 5000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4343", "db_id": "tracking_grants_for_research", "question": "When did researchers start and stop working?", "rationale": ["Identify the relevant table: Project_Staff contains the start and end dates of staff members' involvement in projects.", "Determine the necessary columns: We need the 'date_from' and 'date_to' columns to know when researchers started and stopped working.", "Filter by role: We need to filter the results to only include researchers, which can be done by joining with the Staff_Roles table to find the appropriate role code for researchers.", "Construct the SQL query: Combine the information to create a SQL query that selects the start and end dates for researchers."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to FROM Project_Staff WHERE role_code = (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%researcher%')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4349", "db_id": "tracking_grants_for_research", "question": "What are the details for the project whose research has been published?", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes are needed to find project details related to published research.", "Join the Projects table with Project_Outcomes to link projects with their outcomes.", "Join the resulting table with Research_Outcomes to filter for those outcomes that indicate research has been published.", "Use a WHERE clause to specify that we are looking for outcomes that have 'published' in their description.", "Select the project_id and project_details from the final joined result."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE '%Published%'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT P.project_id, P.project_details FROM Projects AS P JOIN Project_Outcomes AS PO ON P.project_id = PO.project_id JOIN Research_Outcomes AS RO ON PO.outcome_code = RO.outcome_code WHERE RO.outcome_description LIKE '%published%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of tasks associated with each project along with the project details from the 'Projects' table. The count is grouped by the unique project identifier, allowing users to see how many tasks are linked to each project.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the tables involved: Projects and Project_Outcomes.", "We need to join these tables on the project_id to relate projects to their outcomes.", "We will select the project details and project ID from the Projects table.", "To find the project with the most outcomes, we will group the results by project_id and count the outcomes for each project.", "We will order the results in descending order based on the count of outcomes.", "Finally, we will limit the results to only one project, which will be the one with the most outcomes."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT T1.project_details, T1.project_id FROM Projects AS T1 JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated outcomes in the 'Project_Outcomes' table. The placeholder in the WHERE clause indicates that we are filtering projects based on their unique identifiers, ensuring we only retrieve those without outcomes.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )\"\n    }\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id respectively to link organisations with their research staff.", "Group the results by organisation_id, organisation_type, and organisation_details to aggregate the count of research staff for each organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT O.organisation_id, O.organisation_type, O.organisation_details \nFROM Organisations AS O \nJOIN Research_Staff AS R ON O.organisation_id = R.employer_organisation_id \nGROUP BY O.organisation_id, O.organisation_type, O.organisation_details \nORDER BY COUNT(R.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4361", "db_id": "tracking_grants_for_research", "question": "What are the ids, types, and details of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff are needed to get the organization details and the count of research staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields to link organizations with their respective research staff.", "Group the results by organisation_id, organisation_type, and organisation_details to aggregate the count of research staff for each organization.", "Order the results by the count of research staff in descending order to get the organization with the most research staff at the top.", "Limit the results to 1 to get only the organization with the highest count of research staff."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT O.organisation_id, O.organisation_type, O.organisation_details \nFROM Organisations AS O \nJOIN Research_Staff AS R ON O.organisation_id = R.employer_organisation_id \nGROUP BY O.organisation_id, O.organisation_type, O.organisation_details \nORDER BY COUNT(R.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff for staff involvement in projects and Staff_Roles for role descriptions.", "Join the Project_Staff table with the Staff_Roles table on the role_code to get the role descriptions.", "Group the results by role_code to count how many projects each role is involved in.", "Order the results by the count of projects in descending order to find the role involved in the most projects.", "Limit the results to 1 to get only the top role with the most projects."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT ps.staff_id, sr.role_description\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nGROUP BY ps.role_code\nORDER BY COUNT(ps.project_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4367", "db_id": "tracking_grants_for_research", "question": "For grants that have descriptions of Regular and Initial Applications, what are their start dates?", "rationale": ["Identify the relevant tables: Grants, Documents, and Document_Types.", "We need to retrieve the start dates of grants, so we will select 'grant_start_date' from the Grants table.", "To filter the grants based on document descriptions, we will join the Documents table with the Grants table using 'grant_id'.", "Next, we will join the Document_Types table with the Documents table using 'document_type_code' to access the document descriptions.", "We will filter the results where the document descriptions are either 'Regular Applications' or 'Initial Applications' using a WHERE clause with an IN condition."], "gold_sql": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Regular' INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Initial Application'", "source_tables": ["grants", "document_types", "documents"], "pred_sql": "SELECT G.grant_start_date FROM Grants AS G JOIN Documents AS D ON G.grant_id = D.grant_id JOIN Document_Types AS DT ON D.document_type_code = DT.document_type_code WHERE DT.document_description IN ('Regular Applications', 'Initial Applications')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["Identify the tables involved: We need to count documents per grant, so we will use the 'Documents' and 'Grants' tables.", "Join the 'Documents' table with the 'Grants' table on 'grant_id' to associate each document with its corresponding grant.", "Group the results by 'grant_id' to count the number of documents for each grant.", "Use COUNT() to get the number of documents for each grant and alias it as 'document_count'.", "To find which grant has the most documents, we can use a subquery that counts documents grouped by 'grant_id' and finds the maximum count.", "The final query will select the grant id, the count of documents, and the document id for the grant with the maximum document count."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT D.grant_id, COUNT(D.document_id) AS document_count, D.document_id \nFROM Documents AS D \nJOIN Grants AS G ON D.grant_id = G.grant_id \nGROUP BY D.grant_id \nHAVING COUNT(D.document_id) = (SELECT MAX(doc_count) \n                               FROM (SELECT COUNT(document_id) AS doc_count \n                                     FROM Documents \n                                     GROUP BY grant_id))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4372", "db_id": "tracking_grants_for_research", "question": "What are all the details of the organisations described as 'Sponsor'? Sort the result in an ascending order.", "rationale": ["Identify the relevant tables: Organisations and Organisation_Types.", "Determine the relationship between the tables: Organisations has a foreign key to Organisation_Types via organisation_type.", "Filter the organisations based on the description 'Sponsor' from Organisation_Types.", "Select all relevant details from the Organisations table.", "Sort the results in ascending order based on organisation_details."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "pred_sql": "SELECT organisation_id, organisation_type, organisation_details FROM Organisations AS T1 JOIN Organisation_Types AS T2 ON T1.organisation_type = T2.organisation_type WHERE T2.organisation_type_description = 'Sponsor' ORDER BY organisation_details ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the details of organisations from the 'Organisations' table that are associated with a specific type of organisation. It joins the 'Organisations' table with the 'Organisation_Types' table to filter organisations based on their type description. The placeholder in the WHERE clause represents the description of the organisation type, and the results are ordered by the organisation details.\",\n        \"virtual_table\": \"SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING] ORDER BY organisation_details\"\n    }\n}\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant table: The question asks for project details, which are found in the 'Projects' table.", "Determine the condition: We need to filter the projects based on the project detail being 'sint'.", "Construct the SQL query: Use a SELECT statement to retrieve 'project_details' from the 'Projects' table where 'project_details' matches 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT project_details FROM Projects WHERE project_details = 'sint'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of tasks associated with each project along with the project details from the 'Projects' table. The count is grouped by the unique project identifier, allowing users to see how many tasks are linked to each project.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant project by filtering the Projects table for the project detail 'sint'.", "Retrieve the organisation_id associated with the identified project.", "Use the organisation_id to find the corresponding grant_id from the Grants table.", "With the grant_id, find the document_type_code from the Documents table.", "Finally, use the document_type_code to get the document_description from the Document_Types table."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT document_description FROM Document_Types WHERE document_type_code IN (SELECT document_type_code FROM Documents WHERE grant_id IN (SELECT grant_id FROM Grants WHERE organisation_id IN (SELECT organisation_id FROM Projects WHERE project_details = 'sint')));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of tasks associated with each project along with the project details from the 'Projects' table. The count is grouped by the unique project identifier, allowing users to see how many tasks are linked to each project.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id\"\n    }\n}\n"}
{"sample_id": "train.4383", "db_id": "tracking_grants_for_research", "question": "What is the id of the organization with the maximum number of outcomes and how many outcomes are there?", "rationale": ["Identify the tables involved: Organisations, Projects, and Project_Outcomes.", "Join the Organisations table with the Projects table on organisation_id to link organisations to their projects.", "Join the resulting table with the Project_Outcomes table on project_id to link projects to their outcomes.", "Group the results by organisation_id to count the number of outcomes for each organisation.", "Order the results by the count of outcomes in descending order to find the organisation with the maximum outcomes.", "Limit the results to 1 to get only the organisation with the maximum number of outcomes."], "gold_sql": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT organisation_id, COUNT(outcome_code) AS outcome_count \nFROM Organisations \nJOIN Projects ON Organisations.organisation_id = Projects.organisation_id \nJOIN Project_Outcomes ON Projects.project_id = Project_Outcomes.project_id \nGROUP BY Organisations.organisation_id \nORDER BY outcome_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.4384", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects launched by the organisation", "rationale": ["The user wants to list project details of projects launched by an organisation.", "To achieve this, we need to select the 'project_details' from the 'Projects' table.", "We need to filter the projects based on the organisation that launched them.", "To find the organisations with projects, we can use a subquery that groups the projects by 'organisation_id' and orders them by the count of projects in descending order.", "Since the user did not specify a limit on the number of organisations, we will not include a LIMIT clause in our final query."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC )", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of tasks associated with each project along with the project details from the 'Projects' table. The count is grouped by the unique project identifier, allowing users to see how many tasks are linked to each project.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["The user wants to know the staff roles of the staff members associated with projects.", "To find the staff roles, we need to select the 'role_code' from the 'Project_Staff' table.", "The hint provides a virtual table that describes how to filter staff members based on their involvement dates, but it does not specify any dates in the user query.", "Since no specific date range is provided in the user query, we will retrieve all role codes from the 'Project_Staff' table without filtering by date."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code FROM Project_Staff", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4394", "db_id": "tracking_grants_for_research", "question": "What are the descriptions of all the project outcomes?", "rationale": ["The user wants to retrieve descriptions of all project outcomes.", "The relevant table for project outcomes is 'Project_Outcomes', which contains the columns 'outcome_code' and 'outcome_details'.", "To get the descriptions, we need to select 'outcome_code' and 'outcome_details' from the 'Project_Outcomes' table.", "The SQL query will be a simple SELECT statement that retrieves these two columns from the 'Project_Outcomes' table."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code", "source_tables": ["project_outcomes", "research_outcomes"], "pred_sql": "SELECT outcome_code, outcome_details FROM Project_Outcomes", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated outcomes in the 'Project_Outcomes' table. The placeholder in the WHERE clause indicates that we are filtering projects based on their unique identifiers, ensuring we only retrieve those without outcomes.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["To find the most common role for the staff, we need to count the occurrences of each role code in the Project_Staff table.", "We will use the COUNT function to count how many times each role_code appears.", "We will group the results by role_code to get the count for each role.", "To determine which role is the most common, we will order the results in descending order based on the count.", "Finally, we will limit the results to 1 to get only the most common role."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count \nFROM Project_Staff \nGROUP BY role_code \nORDER BY role_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4410", "db_id": "network_2", "question": "Who is the oldest person whose job is student?", "rationale": ["Identify the target job title, which is 'student'.", "Use a subquery to find the maximum age of individuals with the job title 'student'.", "Construct the main query to select the name of the person whose job is 'student' and whose age matches the maximum age found in the subquery."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "pred_sql": "SELECT name FROM Person WHERE job = 'student' AND age = (SELECT max(age) FROM Person WHERE job = 'student')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE age  =  (SELECT max(age) FROM person)\"\n    }\n}\n"}
{"sample_id": "train.4439", "db_id": "network_2", "question": "What is the name and age of every male? Order the results by age.", "rationale": ["Identify the relevant table: The 'Person' table contains the necessary information about individuals, including their name, age, and gender.", "Filter by gender: We need to select only those individuals who are male, which requires a WHERE clause to filter the results based on the 'gender' column.", "Select the required columns: We need to retrieve both the 'name' and 'age' of the individuals, so we specify these columns in the SELECT statement.", "Order the results: The results should be ordered by age, which is done using the ORDER BY clause."], "gold_sql": "SELECT name FROM Person WHERE gender  =  'male' ORDER BY age", "source_tables": ["person"], "pred_sql": "SELECT name, age FROM Person WHERE gender = 'male' ORDER BY age", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE age  =  (SELECT max(age) FROM person)\"\n    }\n}\n"}
{"sample_id": "train.4441", "db_id": "network_2", "question": "What are the names and ages of every person who is a friend of both Dan and Alice?", "rationale": ["Identify the tables involved: We need data from the Person table for names and ages, and the PersonFriend table to find friends of Dan and Alice.", "We need to find friends of both Dan and Alice. This requires joining the PersonFriend table twice: once for Dan and once for Alice.", "Use INNER JOIN to connect the Person table with the PersonFriend table based on the friend's name.", "Filter the results to include only those friends who are listed as friends of both Dan and Alice.", "Select the name and age of these friends from the Person table."], "gold_sql": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, P.age FROM Person P JOIN PersonFriend PF1 ON P.name = PF1.friend JOIN PersonFriend PF2 ON P.name = PF2.friend WHERE PF1.name = 'Dan' AND PF2.name = 'Alice';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4444", "db_id": "network_2", "question": "Find the name of the person who has friends with age above 40 and under age 30?", "rationale": ["Identify the tables involved: We need to use both the 'Person' and 'PersonFriend' tables to find the names of individuals who have friends with specific age criteria.", "Determine the relationship: The 'PersonFriend' table links a person to their friends, so we will join 'Person' and 'PersonFriend' on the name of the friend.", "Set the conditions for age: We need to filter for friends who are either above 40 or under 30 years old. This means we will apply a WHERE clause to check the age of friends in the 'Person' table.", "Select distinct names: Since we are interested in the names of people who have friends meeting the age criteria, we will select distinct names from the result set to avoid duplicates."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT p.name \nFROM Person p \nJOIN PersonFriend pf ON p.name = pf.friend \nWHERE p.age > 40 OR p.age < 30;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE age  =  (SELECT max(age) FROM person)\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4445", "db_id": "network_2", "question": "What are the names of every person who has a friend over 40 and under 30?", "rationale": ["Identify the main table to query from, which is the 'Person' table for the names of individuals.", "We need to find friends of these individuals, so we will join the 'PersonFriend' table on the person's name.", "Next, we need to join again with the 'Person' table to access the age of the friends.", "The condition requires us to filter friends who are either over 40 or under 30 years old.", "We use DISTINCT to ensure that we only get unique names of individuals who meet the criteria."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT p1.name \nFROM Person p1 \nJOIN PersonFriend pf1 ON p1.name = pf1.name \nJOIN Person p2 ON pf1.friend = p2.name \nWHERE (p2.age > 40 OR p2.age < 30);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4449", "db_id": "network_2", "question": "What are the names of the people who have no friends who are students?", "rationale": ["Identify the main requirement: We need the names of people who have no friends that are students.", "To find friends who are students, we need to look at the 'Person' table and filter by job = 'student'.", "We will create a subquery to select names of friends who are students.", "Next, we need to find names of people in the 'Person' table who are not in the list of friends who are students.", "This can be achieved using a NOT IN clause with the subquery that selects names of friends who are students."], "gold_sql": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  'student'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT name FROM Person WHERE name NOT IN (SELECT name FROM PersonFriend WHERE friend IN (SELECT name FROM Person WHERE job = 'student'));", "hint": "\n"}
{"sample_id": "train.4454", "db_id": "network_2", "question": "Find the name of persons who are friends with Bob.", "rationale": ["Identify the table that contains friendship information, which is the 'PersonFriend' table.", "We need to find friends of a specific person, in this case, 'Bob'.", "The query should select the 'friend' column from the 'PersonFriend' table where the 'name' is 'Bob'.", "Additionally, we want to filter the results to only include the most recent friendship established by using a subquery that selects the maximum 'year' for Bob from the same table.", "Combine these elements into a single SQL query."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Bob' AND year = (SELECT max(year) FROM PersonFriend WHERE name = 'Bob')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    }\n}\n"}
{"sample_id": "train.4455", "db_id": "network_2", "question": "What are the names of all of Bob's friends?", "rationale": ["Identify the table that contains the friends of a person, which is the PersonFriend table.", "We need to filter the friends specifically for Bob, so we will use a WHERE clause to specify that the name is 'Bob'.", "The hint suggests using a virtual table that lists friends filtered by the most recent year of friendship established, but since we only need the names of all of Bob's friends, we can simplify the query to just select the friends without filtering by year."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Bob'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4456", "db_id": "network_2", "question": "Find the names of females who are friends with Zach", "rationale": ["Identify the gender of the individuals we are interested in, which is 'female'.", "We need to find the names of females, so we will use the 'Person' table to filter by gender.", "Next, we need to find the friends of Zach. We will use the 'PersonFriend' table to get the list of friends for Zach.", "We will use a subquery to select friends from the 'PersonFriend' table where the name is 'Zach'.", "Finally, we will combine these two queries to get the names of females who are also friends with Zach."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Zach' AND T1.gender  =  'female'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT name FROM Person WHERE gender = 'female' AND name IN (SELECT friend FROM PersonFriend WHERE name = 'Zach')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4465", "db_id": "network_2", "question": "What are the different names of friends who are younger than the average age for a friend?", "rationale": ["Identify the requirement to find friends who are younger than the average age.", "Calculate the average age of all individuals in the Person table using AVG(age).", "Filter the friends from the PersonFriend table based on the condition that their age is less than the calculated average age.", "Use a subquery to select friends from the Person table where their age is less than the average age.", "Ensure to select distinct names to avoid duplicates in the final result."], "gold_sql": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT friend FROM PersonFriend WHERE friend IN (SELECT name FROM Person WHERE age < (SELECT AVG(age) FROM Person))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4466", "db_id": "network_2", "question": "Who has friends that are older than the average age? Print their friends and their ages as well", "rationale": ["First, we need to find the average age of all individuals in the Person table. This can be done using the AVG() function.", "Next, we need to identify friends of individuals from the PersonFriend table. We will join the PersonFriend table with the Person table to get the ages of these friends.", "We will filter the results to include only those friends whose age is greater than the average age calculated in the first step.", "Finally, we will select the friend's name and their age to display the required information."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT pf.friend, p.age \nFROM PersonFriend pf \nJOIN Person p ON pf.friend = p.name \nWHERE p.age > (SELECT AVG(age) FROM Person)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4467", "db_id": "network_2", "question": "Whare the names, friends, and ages of all people who are older than the average age of a person?", "rationale": ["Identify the required fields: names, friends, and ages of people.", "To get the names and ages, we need to select from the 'Person' table.", "To get the friends, we need to join the 'PersonFriend' table on the name.", "We need to filter the results to include only those people whose age is greater than the average age of all persons.", "The average age can be calculated using a subquery: (SELECT AVG(age) FROM Person).", "Combine all these elements into a single SQL query."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name, pf.friend, p.age \nFROM Person p \nJOIN PersonFriend pf ON p.name = pf.name \nWHERE p.age > (SELECT AVG(age) FROM Person)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE age  =  (SELECT max(age) FROM person)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4473", "db_id": "network_2", "question": "What are the names of all people who are friends with Alice for the shortest amount of time?", "rationale": ["Identify the person of interest, which is 'Alice'.", "We need to find the friends of Alice, so we will query the PersonFriend table where the name is 'Alice'.", "To find the friends with whom Alice has been friends for the shortest amount of time, we need to find the minimum year of friendship established.", "We will use a subquery to get the minimum year from the PersonFriend table for Alice.", "Finally, we will select the friends from the PersonFriend table where the year matches the minimum year found in the subquery."], "gold_sql": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Alice' AND year = (SELECT MIN(year) FROM PersonFriend WHERE name = 'Alice')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    }\n}\n"}
{"sample_id": "train.4475", "db_id": "network_2", "question": "What are the names, ages, and jobs of all people who are friends with Alice for the longest amount of time?", "rationale": ["Identify the relevant tables: We need to gather information from the 'Person' table for names, ages, and jobs, and from the 'PersonFriend' table to find friends of Alice.", "We need to join the 'Person' table with the 'PersonFriend' table on the condition that the name in 'Person' matches the friend in 'PersonFriend'.", "We filter the results to only include friends of Alice by using a WHERE clause on the 'name' column of the 'PersonFriend' table.", "To find the friends who have been friends with Alice for the longest time, we can order the results by the 'year' column in ascending order.", "Finally, we select the name, age, and job of the friend who has been friends with Alice for the longest time by limiting the results to 1."], "gold_sql": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, P.age, P.job \nFROM Person P \nJOIN PersonFriend PF ON P.name = PF.friend \nWHERE PF.name = 'Alice' \nORDER BY PF.year ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    }\n}\n"}
{"sample_id": "train.4478", "db_id": "network_2", "question": "Which person whose friends have the oldest average age?", "rationale": ["To find the person whose friends have the oldest average age, we need to calculate the average age of friends for each person.", "We will join the 'PersonFriend' table with the 'Person' table to get the ages of friends.", "We will group the results by the person's name to calculate the average age of their friends using AVG function.", "Next, we will order the results by the average age in descending order to find the oldest average age.", "Finally, we will limit the results to 1 to get the person with the oldest average age of friends."], "gold_sql": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT 1", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name FROM Person p JOIN (SELECT pf.name, AVG(CAST(p.age AS INTEGER)) AS avg_age FROM PersonFriend pf JOIN Person p ON pf.friend = p.name GROUP BY pf.name) AS avg_ages ON p.name = avg_ages.name ORDER BY avg_age DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE age  =  (SELECT max(age) FROM person)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4480", "db_id": "network_2", "question": "What is the total number of people who has no friend living in the city of Austin.", "rationale": ["We need to count the total number of people who have no friends living in Austin.", "First, we filter the 'Person' table to only include those who live in Austin.", "Next, we need to check if these people have friends. We can do this by using a subquery that selects friends from the 'PersonFriend' table where the person's name matches.", "The subquery will return a list of friends for each person, and we want to exclude those names from our count.", "Finally, we use the COUNT function to get the total number of people who meet these criteria."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT COUNT(*) FROM Person WHERE city = 'Austin' AND name NOT IN (SELECT friend FROM PersonFriend WHERE name = Person.name)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4503", "db_id": "document_management", "question": "Find the types of documents with more than 4 documents.", "rationale": ["We need to find the types of documents that have more than 4 documents associated with them.", "To achieve this, we will join the 'Documents' table with the 'Document_Structures' table using the 'document_structure_code'.", "We will group the results by 'document_structure_code' to count the number of documents for each structure.", "Using the HAVING clause, we can filter the groups to only include those with a count greater than 4.", "Finally, we will select the 'document_structure_description' from the 'Document_Structures' table to get the desired output."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code = t2.document_structure_code GROUP BY t1.document_structure_code HAVING COUNT(t1.document_code) > 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average access count of documents grouped by their document structure code. The placeholder in the LIMIT clause allows the user to specify the maximum number of groups to return, based on the ascending order of their count.\",\n        \"virtual_table\": \"SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of document structure descriptions from the 'Document_Structures' table, which are associated with documents in the 'Documents' table. The results are grouped by the document structure code and ordered by the number of documents associated with each structure, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code  =  t2.document_structure_code GROUP BY t1.document_structure_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4504", "db_id": "document_management", "question": "What are the codes of types of documents of which there are for or more?", "rationale": ["Identify the table that contains the document types, which is the 'Documents' table.", "We need to group the results by 'document_type_code' to count how many documents exist for each type.", "Use the HAVING clause to filter the groups to only include those with a count of 4 or more."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code FROM Documents GROUP BY document_type_code HAVING COUNT(*) >= 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of document structure descriptions from the 'Document_Structures' table, which are associated with documents in the 'Documents' table. The results are grouped by the document structure code and ordered by the number of documents associated with each structure, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code  =  t2.document_structure_code GROUP BY t1.document_structure_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4505", "db_id": "document_management", "question": "Find the total access count of all documents in the most popular document type.", "rationale": ["Identify the requirement to find the total access count of all documents in the most popular document type.", "To determine the most popular document type, we need to group the documents by their document type code and sum their access counts.", "We will order these groups by the total access count in descending order to find the most popular one.", "Using a subquery, we can select the document type code that has the highest total access count.", "Finally, we will sum the access counts of all documents that match this most popular document type code."], "gold_sql": "SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT SUM(access_count) FROM documents WHERE document_type_code = (SELECT document_type_code FROM documents GROUP BY document_type_code ORDER BY SUM(access_count) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average access count of documents grouped by their document structure code. The placeholder in the LIMIT clause allows the user to specify the maximum number of groups to return, based on the ascending order of their count.\",\n        \"virtual_table\": \"SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4525", "db_id": "document_management", "question": "Find names of the document without any images.", "rationale": ["Identify the main table to query: The 'Documents' table contains the names of the documents.", "Determine the condition for documents without images: We need to find documents that do not have any associated images, which can be checked using the 'Document_Sections_Images' table.", "Use a subquery to find documents with images: The subquery will select all document codes from the 'Document_Sections_Images' table, which indicates that those documents have images.", "Use the NOT IN clause: The main query will select document names from the 'Documents' table where the document code is not in the list of document codes returned by the subquery."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "pred_sql": "SELECT document_name FROM Documents WHERE document_code NOT IN (SELECT DISTINCT document_code FROM Document_Sections_Images)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of document structure descriptions from the 'Document_Structures' table, which are associated with documents in the 'Documents' table. The results are grouped by the document structure code and ordered by the number of documents associated with each structure, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code  =  t2.document_structure_code GROUP BY t1.document_structure_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4532", "db_id": "document_management", "question": "Count the number of users that are logged in.", "rationale": ["Identify the table that contains user information, which is the 'Users' table.", "To count the number of users, we will use the COUNT() function.", "Since the question asks for the number of users that are logged in, we assume all users in the 'Users' table are considered logged in unless specified otherwise.", "Construct the SQL query to select the count of all users from the 'Users' table."], "gold_sql": "SELECT count(*) FROM users WHERE user_login  =  1", "source_tables": ["users"], "pred_sql": "SELECT COUNT(*) AS logged_in_users FROM Users;", "hint": "\n"}
{"sample_id": "train.4733", "db_id": "department_store", "question": "Return the distinct name of customers whose order status is Pending, in the order of customer id.", "rationale": ["Identify the relevant tables: Customers and Customer_Orders.", "We need to find customers with a specific order status, which is 'Pending'.", "Use a subquery to get distinct customer_ids from Customer_Orders where order_status_code is 'Pending'.", "Join this result with the Customers table to get the customer names.", "Select distinct customer names to avoid duplicates.", "Order the results by customer_id as specified."], "gold_sql": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending' ORDER BY T2.customer_id", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT customer_name FROM Customers WHERE customer_id IN (SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_status_code = 'Pending') ORDER BY customer_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The date is determined by finding the earliest order date associated with a particular order status, represented by a placeholder.\",\n        \"virtual_table\": \"SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4736", "db_id": "department_store", "question": "What are the names and addressed of customers who have both New and Pending orders?", "rationale": ["Identify the relevant tables: Customers, Customer_Orders, and Customer_Addresses.", "We need to select customer names and their addresses, so we will join Customers with Customer_Orders and Customer_Addresses.", "The condition requires customers to have both 'New' and 'Pending' orders, which means we need to filter the orders based on their status codes.", "Using a GROUP BY clause on customer_id allows us to aggregate the results for each customer.", "The HAVING clause checks that the count of distinct order statuses for each customer is 2, ensuring they have both statuses."], "gold_sql": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'New' INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending'", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT c.customer_name, ca.address_id \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nWHERE co.order_status_code IN ('New', 'Pending') \nGROUP BY c.customer_id \nHAVING COUNT(DISTINCT co.order_status_code) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The date is determined by finding the earliest order date associated with a particular order status, represented by a placeholder.\",\n        \"virtual_table\": \"SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4749", "db_id": "department_store", "question": "Find the id and name of the staff who has been assigned for the shortest period.", "rationale": ["Identify the relevant tables: We need to look at the Staff and Staff_Department_Assignments tables to find the staff members and their assignment periods.", "Determine the assignment period: The assignment period can be calculated by subtracting the date_assigned_from from date_assigned_to.", "Find the shortest assignment period: We can order the results by the calculated assignment period and limit the results to get the staff member with the shortest period.", "Select the required fields: We need to select the staff_id and staff_name from the Staff table for the staff member with the shortest assignment period."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Staff_Department_Assignments ORDER BY date_assigned_to - date_assigned_from LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\",\n        \"virtual_table\": \"SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["Identify the relevant tables: We need to retrieve staff information, which is in the 'Staff' table, and their assignment details from the 'Staff_Department_Assignments' table.", "Determine the criteria: We want to find the staff member who has been assigned for the least amount of time. This can be determined by looking at the 'date_assigned_from' column in the 'Staff_Department_Assignments' table.", "Use a subquery to find the staff ID with the earliest 'date_assigned_from': We can order the assignments by 'date_assigned_from' in ascending order and limit the result to 1 to get the earliest assignment.", "Join the results with the 'Staff' table: We need to retrieve the staff name along with the staff ID, so we will join the 'Staff' table with the result of our subquery using the staff ID."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Staff_Department_Assignments ORDER BY date_assigned_from ASC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\",\n        \"virtual_table\": \"SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4753", "db_id": "department_store", "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.", "rationale": ["Identify the requirement to find distinct customer IDs who made orders after cancelled orders.", "Use a subquery to find the minimum order date for orders that have a status of 'Cancelled'.", "The main query selects distinct customer IDs from the 'Customer_Orders' table where the order date is greater than the date obtained from the subquery."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "pred_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date > (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code = 'Cancelled')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The date is determined by finding the earliest order date associated with a particular order status, represented by a placeholder.\",\n        \"virtual_table\": \"SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4755", "db_id": "department_store", "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?", "rationale": ["Identify the requirement to find staff IDs who had assignments earlier than any Clerical Staff.", "Use the provided virtual table structure to create a subquery that finds the maximum end date of assignments for Clerical staff.", "The subquery will be: (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical').", "The main query will select staff_id from Staff_Department_Assignments where the date_assigned_to is less than the result of the subquery."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "pred_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to < (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\",\n        \"virtual_table\": \"SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to join these tables to access customer names and their addresses.", "The Customers table contains customer names and IDs, while the Addresses table contains address details.", "The Customer_Addresses table serves as a bridge between Customers and Addresses, linking customer IDs to address IDs.", "Use a JOIN operation to combine these tables based on their relationships: Customers to Customer_Addresses on customer_id, and Customer_Addresses to Addresses on address_id.", "Filter the results to include only those addresses that contain 'TN' in their address details using the LIKE operator."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "pred_sql": "SELECT c.customer_name, c.customer_id \nFROM Customers c \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nJOIN Addresses a ON ca.address_id = a.address_id \nWHERE a.address_details LIKE '%TN%';", "hint": "\n"}
{"sample_id": "train.4760", "db_id": "department_store", "question": "What are the names and genders of staff who were assigned in 2016?", "rationale": ["Identify the relevant tables: 'Staff' for staff details and 'Staff_Department_Assignments' for assignment dates.", "We need to select the staff names and genders, which are in the 'Staff' table.", "Join the 'Staff' table with the 'Staff_Department_Assignments' table on 'staff_id' to link staff members with their assignments.", "Filter the results to include only those assignments that started in 2016 by using a WHERE clause with a date condition that checks if 'date_assigned_from' starts with '2016'."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT T1.staff_name, T1.staff_gender FROM Staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id = T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\",\n        \"virtual_table\": \"SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["Identify the staff members who have been assigned to multiple jobs.", "To do this, we can use the Staff_Department_Assignments table to group by staff_id and count the distinct job_title_code for each staff member.", "We will filter those groups to only include staff members with a count greater than 1, indicating multiple job assignments.", "Finally, we will join this result with the Staff table to get the names of those staff members."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Staff_Department_Assignments GROUP BY staff_id HAVING COUNT(DISTINCT job_title_code) > 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\",\n        \"virtual_table\": \"SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["Identify the relevant table: Customers, which contains customer_id, customer_name, customer_address, and payment_method_code.", "Filter customers based on their address containing 'WY'. This can be done using the LIKE operator with a wildcard: '%WY%'.", "Exclude customers who use a credit card for payment by checking that payment_method_code is not equal to 'CREDIT_CARD'.", "Combine these conditions in the WHERE clause of the SQL query to retrieve the desired customer ids and names."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name \nFROM Customers \nWHERE customer_address LIKE '%WY%' \nAND payment_method_code != 'CREDIT_CARD';", "hint": "\n"}
{"sample_id": "train.4793", "db_id": "department_store", "question": "Find the average price of all product clothes.", "rationale": ["Identify the table that contains product information, which is the 'Products' table.", "Determine the relevant column for price, which is 'product_price'.", "To find the average price, use the AVG() function.", "Filter the products to only include those that are classified as clothes by using a WHERE clause on 'product_type_code'.", "Construct the SQL query to select the average price from the Products table where the product type is clothes."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "pred_sql": "SELECT AVG(product_price) AS average_price\nFROM Products\nWHERE product_type_code = 'clothes';", "hint": "\n"}
{"sample_id": "train.4795", "db_id": "department_store", "question": "Find the name of the most expensive hardware product.", "rationale": ["Identify the relevant table: Products.", "Determine the criteria for 'hardware' products, which is indicated by the product_type_code.", "Select the product_name from the Products table.", "Order the results by product_price in descending order to get the most expensive product at the top.", "Limit the results to 1 to get only the most expensive hardware product."], "gold_sql": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1", "source_tables": ["products"], "pred_sql": "SELECT product_name FROM Products WHERE product_type_code = 'hardware' ORDER BY product_price DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["Identify the relevant table: The 'product' table contains the 'max_page_size' and 'product_id' columns.", "Group the results by 'max_page_size' to aggregate products with the same page size.", "Use the HAVING clause to filter groups where the count of 'product_id' is greater than 3, indicating more than 3 products listed for that page size."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING COUNT(product_id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4903", "db_id": "store_product", "question": "What is the maximum page size for everything that has more than 3 products listed?", "rationale": ["Identify the requirement: We need to find the maximum page size for products that have more than 3 stores listing them.", "To achieve this, we will use a subquery to first find all products that are listed in more than 3 stores.", "The subquery will group the 'store_product' table by 'Product_ID' and count the number of 'Store_ID' entries for each product.", "We will use the HAVING clause to filter these groups to only include those with a count greater than 3.", "Next, we will use this subquery in the main query to select the 'max_page_size' from the 'product' table for those products that meet the criteria."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size FROM product WHERE product_id IN (SELECT Product_ID FROM store_product GROUP BY Product_ID HAVING COUNT(Store_ID) > 3);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4913", "db_id": "store_product", "question": "What is the total number of residents for the districts with the 3 largest areas?", "rationale": ["Identify the requirement to find the total number of residents in districts with the largest areas.", "Determine that we need to sum the population of districts, which is stored in the 'City_Population' column of the 'district' table.", "To find the districts with the largest areas, we will order the districts by 'City_Area' in descending order and limit the results to the top 3.", "Use a subquery to select the 'District_ID' of these top 3 districts based on area.", "Finally, sum the 'City_Population' for these selected districts to get the total number of residents."], "gold_sql": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3", "source_tables": ["district"], "pred_sql": "SELECT SUM(City_Population) AS Total_Residents \nFROM district \nWHERE District_ID IN (\n    SELECT District_ID \n    FROM district \n    ORDER BY City_Area DESC \n    LIMIT 3\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of stores grouped by the city where their respective districts are headquartered. The placeholders in the query represent the relationships between stores and districts, allowing for aggregation of store counts based on the city names.\",\n        \"virtual_table\": \"SELECT t3.headquartered_city ,  count(*) FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in each city, with a limit on the number of cities returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["Identify the relevant tables: store, store_district, and district are needed to find stores in a specific district.", "Join the store table with the store_district table on Store_ID to link stores to their respective districts.", "Join the resulting table with the district table on District_ID to access district names.", "Filter the results where the District_name is 'Khanewal' to get only those stores located in Khanewal District.", "Select the Store_Name from the filtered results to get the names of the stores."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT s.Store_Name FROM store AS s JOIN store_district AS sd ON s.Store_ID = sd.Store_ID JOIN district AS d ON sd.District_ID = d.District_ID WHERE d.District_name = 'Khanewal'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in each city, with a limit on the number of cities returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of stores grouped by the city where their respective districts are headquartered. The placeholders in the query represent the relationships between stores and districts, allowing for aggregation of store counts based on the city names.\",\n        \"virtual_table\": \"SELECT t3.headquartered_city ,  count(*) FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city\"\n    }\n}\n"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["Identify the tables involved: store, store_district, and district.", "Join the store table with store_district on Store_ID to link stores to their respective districts.", "Join the resulting table with the district table on District_ID to access the city information.", "Group the results by the Headquartered_City to count the number of stores in each city.", "Order the results by the count of stores in descending order to find the city with the most stores.", "Limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT t3.Headquartered_City FROM store AS t1 JOIN store_district AS t2 ON t1.Store_ID = t2.Store_ID JOIN district AS t3 ON t2.District_ID = t3.District_ID GROUP BY t3.Headquartered_City ORDER BY COUNT(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in each city, with a limit on the number of cities returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of stores grouped by the city where their respective districts are headquartered. The placeholders in the query represent the relationships between stores and districts, allowing for aggregation of store counts based on the city names.\",\n        \"virtual_table\": \"SELECT t3.headquartered_city ,  count(*) FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city\"\n    }\n}\n"}
{"sample_id": "train.4930", "db_id": "store_product", "question": "Find products with max page size as \"A4\" and pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to filter products based on 'max_page_size' being 'A4' and 'pages_per_minute_color' being less than 5.", "Construct the SQL query: Use the SELECT statement to retrieve the 'product' column from the 'product' table, applying the specified conditions in the WHERE clause."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE max_page_size = 'A4' AND pages_per_minute_color < 5", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4932", "db_id": "store_product", "question": "Find products with max page size as \"A4\" or pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to find products with a maximum page size of 'A4' or a pages per minute color speed less than 5.", "Use the OR operator: Since we are looking for products that meet either of the two conditions, we will use the OR operator in the WHERE clause.", "Construct the SQL query: Based on the conditions and the structure of the 'product' table, we can construct the SQL query."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < 5", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4935", "db_id": "store_product", "question": "What are all of the products whose name includes the substring \"Scanner\"?", "rationale": ["Identify the relevant table: The 'product' table contains the information about products.", "Determine the required condition: We need to find products whose name includes the substring 'Scanner'.", "Use the SQL LIKE operator: The LIKE operator allows us to search for a specified pattern in a column.", "Construct the SQL query: We will select the 'product' column from the 'product' table where the 'product' name matches the pattern '%Scanner%'."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4937", "db_id": "store_product", "question": "What is the most common maximum page size?", "rationale": ["Identify the relevant table: The 'product' table contains the 'max_page_size' column which is needed to answer the question.", "Determine the goal: We need to find the most common maximum page size, which implies counting occurrences of each maximum page size.", "Use GROUP BY: To count how many times each maximum page size appears, we will group the results by 'max_page_size'.", "Count occurrences: Use COUNT(*) to count the number of products for each maximum page size.", "Order results: To find the most common maximum page size, we will order the results in descending order based on the count.", "Limit results: Since we only want the most common maximum page size, we will limit the results to 1."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1", "source_tables": ["product"], "pred_sql": "SELECT max_page_size, COUNT(*) as count FROM product GROUP BY max_page_size ORDER BY count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4938", "db_id": "store_product", "question": "Find the name of the products that are not using the most frequently-used max page size.", "rationale": ["Identify the requirement to find products that do not use the most frequently-used max page size.", "To achieve this, we need to first determine what the most frequently-used max page size is.", "We can do this by using a subquery that selects the maximum value of max_page_size from the product table.", "Then, we can select products from the product table where the max_page_size is not equal to this maximum value."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE max_page_size != (SELECT max(max_page_size) FROM product)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["Identify the table that contains the enrollment information, which is the 'College' table.", "To find the average number of students enrolled in each college, we need to use the AVG() function on the 'enr' column.", "The query should select the average enrollment from the 'College' table without any additional filtering, as we want the overall average for all colleges."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "pred_sql": "SELECT AVG(enr) AS average_enrollment FROM College;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\",\n        \"virtual_table\": \"SELECT cName FROM college WHERE enr  >  (SELECT max(enr) FROM college WHERE state  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["The question asks for the average training hours of players.", "Since the schema does not explicitly mention training hours, we will assume that the 'HS' column in the Player table represents some form of training hours or is a proxy for it.", "We need to join the Player table with the Tryout table to ensure we are only considering players who participated in tryouts.", "The average can be calculated using the AVG() function in SQL.", "The final SQL query will select the average of the 'HS' column from the Player table after performing the necessary join."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT avg(T1.HS) FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4956", "db_id": "soccer_2", "question": "Find the name and training hours of players whose hours are below 1500.", "rationale": ["The query needs to find players whose training hours are below 1500.", "Since the training hours are not directly available in the provided schema, we need to infer that the decision in the Tryout table might indicate whether a player's hours are below a certain threshold.", "We will select player names from the Player table where their IDs match those in the Tryout table with a decision indicating they are below 1500.", "The final SQL query will use a subquery to filter players based on their IDs from the Tryout table."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE decision = 'below 1500')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\",\n        \"virtual_table\": \"SELECT pName FROM Player WHERE yCard  =  [PLACEHOLDER-TYPE:STRING] ORDER BY HS DESC\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who attended high schools with an enrollment number less than a specified value. The placeholder in the WHERE clause represents the enrollment number of students.\",\n        \"virtual_table\": \"SELECT pName ,  HS FROM Player WHERE HS  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4961", "db_id": "soccer_2", "question": "What are the different types of player positions?", "rationale": ["The question asks for the different types of player positions.", "To find the different types of player positions, we need to select the 'pPos' column from the 'Tryout' table.", "Using 'DISTINCT' will ensure that we only get unique player positions without duplicates."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT pPos FROM Tryout;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\",\n        \"virtual_table\": \"SELECT pName FROM Player WHERE yCard  =  [PLACEHOLDER-TYPE:STRING] ORDER BY HS DESC\"\n    }\n}\n"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["The question asks for the number of students accepted after the tryout.", "To find this, we need to count the entries in the 'Tryout' table where the decision is 'accepted'.", "The SQL query will use the COUNT() function to count these entries.", "The final SQL query will be: SELECT COUNT(*) FROM tryout WHERE decision = 'accepted';"], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) FROM tryout WHERE decision = 'accepted';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["Identify the need to calculate maximum, average, and minimum training hours of players.", "Understand that training hours can be derived from the number of tryouts each player has participated in.", "Create a subquery to count the number of tryouts for each player, which will represent their training hours.", "Use the outer query to calculate the max, avg, and min of these training hours from the subquery."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT max(training_hours), avg(training_hours), min(training_hours) FROM (SELECT pID, COUNT(*) AS training_hours FROM Tryout GROUP BY pID) AS training_data;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4967", "db_id": "soccer_2", "question": "What is the average, maximum, and minimum for the number of hours spent training?", "rationale": ["The question asks for the average, maximum, and minimum hours spent training, which implies we need to calculate these statistics from a relevant column.", "The hint provided mentions a virtual table that calculates average and maximum values from the 'Player' table based on a decision from the 'Tryout' table.", "To get the minimum value as well, we need to include the min() function in our SQL query.", "We will join the 'Player' table with the 'Tryout' table on the player ID (pID) to filter players based on their tryout decisions.", "The WHERE clause will specify a decision, which is currently a placeholder in the hint. We will replace it with a specific decision for our query."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT avg(T1.HS) AS average_hours, max(T1.HS) AS max_hours, min(T1.HS) AS min_hours FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'specific_decision'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4970", "db_id": "soccer_2", "question": "What are the names of players whose training hours is between 500 and 1500?", "rationale": ["The question asks for the names of players whose training hours are between 500 and 1500.", "We need to select the player names from the Player table.", "We will join the Player table with the Tryout table on the player ID (pID) to filter based on tryout decisions.", "The decision regarding the player's tryout is assumed to be 'accepted' for this query, as it is a common decision type.", "We will apply a condition to filter players based on their training hours being between 500 and 1500."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT T1.pName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'accepted' AND T1.training_hours BETWEEN 500 AND 1500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\",\n        \"virtual_table\": \"SELECT pName FROM Player WHERE yCard  =  [PLACEHOLDER-TYPE:STRING] ORDER BY HS DESC\"\n    }\n}\n"}
{"sample_id": "train.4971", "db_id": "soccer_2", "question": "What are the names of players who train between 500 and 1500 hours?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find player names, so we will select 'pName' from the Player table.", "We need to join the Player table with the Tryout table on 'pID' to link players with their tryout decisions.", "The question specifies a range of training hours (500 to 1500), so we will filter the results based on this condition.", "Assuming that the decision made regarding the player's tryout is 'accepted', we will include this condition in the WHERE clause."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT T1.pName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'accepted' AND T2.hours BETWEEN 500 AND 1500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4975", "db_id": "soccer_2", "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?", "rationale": ["Identify the relevant table: The question pertains to colleges, so we will use the 'College' table.", "Determine the columns needed: We need the names of the colleges (cName) and their enrollment numbers (enr).", "Set the conditions: We need colleges with an enrollment number greater than 10000 and located in Louisiana.", "Construct the SQL query: Using the SELECT statement to retrieve cName and enr from the College table with the specified conditions."], "gold_sql": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = 'LA'", "source_tables": ["college"], "pred_sql": "SELECT cName, enr FROM College WHERE enr > 10000 AND state = 'Louisiana'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\",\n        \"virtual_table\": \"SELECT cName FROM college WHERE enr  >  (SELECT max(enr) FROM college WHERE state  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who attended high schools with an enrollment number less than a specified value. The placeholder in the WHERE clause represents the enrollment number of students.\",\n        \"virtual_table\": \"SELECT pName ,  HS FROM Player WHERE HS  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4981", "db_id": "soccer_2", "question": "What are the name of the players who received a card in descending order of the hours of training?", "rationale": ["The question asks for the names of players who received a card, which implies we need to select from the 'Player' table.", "The hint suggests that we can use a virtual table that selects player names and orders them by high school attended.", "Since the question specifies ordering in descending order, we will use 'ORDER BY HS DESC'.", "We do not have a specific year of eligibility or decision mentioned in the question, so we will select all players without filtering by 'yCard' or 'decision'."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player ORDER BY HS DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\",\n        \"virtual_table\": \"SELECT pName FROM Player WHERE yCard  =  [PLACEHOLDER-TYPE:STRING] ORDER BY HS DESC\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["Identify the relevant table: The 'Tryout' table contains the positions players are trying out for.", "Count the occurrences of each position: Use COUNT(*) to count how many players are trying out for each position.", "Group the results by position: Use GROUP BY pPos to aggregate the counts for each position.", "Order the results: Use ORDER BY position_count DESC to sort the positions by their popularity in descending order.", "Limit the results to the most popular position: Use LIMIT 1 to get only the top result."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["To find the most popular position at tryouts, we need to count how many players tried out for each position.", "We can achieve this by selecting the position (pPos) from the Tryout table and counting the occurrences of each position.", "We will group the results by the position to get the count for each one.", "To determine which position is the most popular, we will order the results by the count in descending order.", "Finally, we will limit the results to just one entry to get the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count FROM Tryout GROUP BY pPos ORDER BY position_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["Identify the relevant tables: We need to look at the 'Tryout' table since it contains information about players and their positions.", "Determine the required information: We need to find the minimum hours played by students in different positions.", "Assume there is a column for hours played in the Tryout table (not explicitly mentioned in the schema), we will group by position and use the MIN function to find the minimum hours for each position.", "Construct the SQL query using GROUP BY to aggregate results by position and select the minimum hours."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(hours) AS min_hours\nFROM Tryout\nGROUP BY pPos;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["Identify the required information: We need to find the minimum time students spent practicing for each position.", "Determine the relevant tables: The 'Practice' table is assumed to contain the practice times associated with each player's position.", "Use aggregation: We will use the MIN function to find the minimum practice time for each position.", "Group the results: We will group the results by position (pPos) to get the minimum time for each one."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(practice_time) AS min_practice_time\nFROM Practice\nGROUP BY pPos;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["Identify the tables involved: Player and Tryout.", "We need the names of players, which are in the Player table (column pName).", "We also need the hours spent practicing, which is not directly mentioned in the schema but can be assumed to be part of the Tryout table based on the context of the question.", "Join the Player table with the Tryout table on the pID column to link players with their tryout decisions.", "Filter the results to include only those players who received a 'yes' decision in their tryouts."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT T1.pName, T2.hours_spent_practicing FROM player AS T1 JOIN tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["Identify the relevant tables: We need to retrieve player names based on their tryout decisions and positions, so we will use the 'Player' and 'Tryout' tables.", "Determine the join condition: The 'Player' table can be joined with the 'Tryout' table using the 'pID' column, which is common to both tables.", "Specify the selection criteria: We are interested in players who had a successful tryout for the position of striker. This means we need to filter the results where 'decision' is 'successful' and 'pPos' is 'striker'.", "Construct the SQL query: Using the identified tables, join condition, and selection criteria, we can construct the SQL query to retrieve the names of the players."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'successful' AND T2.pPos = 'striker'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["The question asks for the average number of hours spent practicing for students who got rejected.", "We need to find players who participated in tryouts and received a 'rejected' decision.", "To do this, we will join the Player table with the Tryout table on the player ID (pID).", "We will then filter the results to only include those where the decision is 'rejected'.", "Finally, we will calculate the average of the hours spent practicing, which is represented by the HS column in the Player table."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT avg(T1.HS) FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'rejected'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5018", "db_id": "soccer_2", "question": "Which college has any student who is a goalie and succeeded in the tryout.", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find colleges that have students who are goalies and succeeded in their tryouts.", "Join the College table with the Tryout table on the college name (cName).", "Filter the results where the decision is 'succeeded' and the position (pPos) is 'goalie'.", "Select distinct college names to avoid duplicates."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT T1.cName \nFROM College AS T1 \nJOIN Tryout AS T2 ON T1.cName = T2.cName \nWHERE T2.decision = 'succeeded' AND T2.pPos = 'goalie';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find the state and enrollment of colleges where students got accepted in the tryout decision.", "The Tryout table contains the decision made regarding players' tryouts, so we will filter this table for the decision 'accepted'.", "We will join the College table with the Tryout table on the college name (cName) to get the relevant information from both tables.", "Select the state and enrollment number (enr) from the College table where the decision in the Tryout table is 'accepted'."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT C.state, C.enr FROM College AS C JOIN Tryout AS T ON C.cName = T.cName WHERE T.decision = 'accepted';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["Identify the colleges that have accepted students during tryouts by using the Tryout table to filter for decisions that indicate acceptance.", "Join the College table with the Tryout table on the college name to get the relevant colleges.", "Use a subquery to select distinct college names from the Tryout table where the decision is 'accepted'.", "In the main query, sum the enrollment numbers of these colleges, ensuring to convert the enrollment number from text to integer for accurate summation.", "Group the results by state to get the total enrollment per state for colleges that accepted students."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT SUM(CAST(enr AS INTEGER)) AS total_enrollment, state FROM College WHERE cName IN (SELECT DISTINCT T1.cName FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName WHERE T2.decision = 'accepted') GROUP BY state;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5026", "db_id": "soccer_2", "question": "Find the names of schools that have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant table: The 'Tryout' table contains information about players and their positions.", "Determine the required columns: We need the 'cName' column to find the names of schools.", "Filter the results: We want to find schools where players are trying out for either 'goalie' or 'mid' positions.", "Use the DISTINCT keyword: To ensure that we only get unique college names, we will use DISTINCT in our query."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT cName FROM Tryout WHERE pPos IN ('goalie', 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5028", "db_id": "soccer_2", "question": "Find the names of states that have some college students playing in goalie and mid positions.", "rationale": ["We need to find distinct states where colleges have students playing in specific positions (goalie and mid).", "To achieve this, we will join the College table with the Tryout table on the college name (cName).", "We will filter the results based on the positions specified (goalie and mid) using the IN clause in the WHERE statement.", "Finally, we will select distinct states from the resulting joined table to avoid duplicates."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT T1.state \nFROM College AS T1 \nJOIN Tryout AS T2 ON T1.cName = T2.cName \nWHERE T2.pPos IN ('goalie', 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5029", "db_id": "soccer_2", "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find distinct states from the College table where players are trying out for specific positions.", "Join the College table with the Tryout table on the college name (cName).", "Filter the results based on the positions of 'goalie' and 'mid-field' using the IN clause.", "Select distinct states from the filtered results."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT T1.state \nFROM College AS T1 \nJOIN Tryout AS T2 ON T1.cName = T2.cName \nWHERE T2.pPos IN ('goalie', 'mid-field')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["Identify the positions of interest: goalie and mid.", "Use the Tryout table to filter for players trying out for these positions.", "Count the distinct colleges (cName) from the filtered results to avoid duplicates."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(DISTINCT cName) FROM Tryout WHERE pPos IN ('goalie', 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5037", "db_id": "soccer_2", "question": "What is the count of states with college students playing in the mid position but not as goalies?", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to count distinct states, so we will use COUNT(DISTINCT state).", "Join the College table with the Tryout table on the college name (cName).", "Filter the results to include only players who are playing in the 'mid' position and not as goalies.", "Assume that 'accepted' is the decision indicating participation in the tryout for the mid position.", "Construct the SQL query using the identified conditions."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')", "source_tables": ["tryout", "college"], "pred_sql": "SELECT COUNT(DISTINCT T1.state) FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName WHERE T2.decision = 'accepted' AND T2.pPos = 'mid'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["Identify the requirement to find states with colleges that have enrollments less than some other college.", "To achieve this, we need to compare the enrollment numbers of colleges.", "We can use a subquery to find the maximum enrollment number from the College table.", "The outer query will select distinct states from the College table where the enrollment is less than the maximum enrollment found in the subquery."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE enr < (SELECT MAX(enr) FROM College)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\",\n        \"virtual_table\": \"SELECT cName FROM college WHERE enr  >  (SELECT max(enr) FROM college WHERE state  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who attended high schools with an enrollment number less than a specified value. The placeholder in the WHERE clause represents the enrollment number of students.\",\n        \"virtual_table\": \"SELECT pName ,  HS FROM Player WHERE HS  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5102", "db_id": "cre_Drama_Workshop_Groups", "question": "Show the minimum, average, maximum order quantity of all invoices.", "rationale": ["Identify the relevant table: Invoices contains the order quantities we need to analyze.", "Use aggregate functions to calculate minimum, average, and maximum order quantities: MIN(), AVG(), and MAX() respectively.", "Select the Order_Quantity column from the Invoices table and apply the aggregate functions to it.", "Construct the SQL query to retrieve the minimum, average, and maximum order quantities from the Invoices table."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "pred_sql": "SELECT MIN(Order_Quantity) AS Min_Quantity, AVG(Order_Quantity) AS Avg_Quantity, MAX(Order_Quantity) AS Max_Quantity \nFROM Invoices;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n        \"virtual_table\": \"SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n        \"virtual_table\": \"SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5118", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the payment method code used by the most orders?", "rationale": ["Identify the relevant table: Invoices contains the payment_method_code and Order_ID.", "Group the results by payment_method_code to count how many orders are associated with each payment method.", "Use COUNT(Order_ID) to count the number of orders for each payment method.", "Order the results in descending order to get the payment method with the most orders at the top.", "Limit the results to 1 to get only the top payment method code."], "gold_sql": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices"], "pred_sql": "SELECT payment_method_code\nFROM Invoices\nGROUP BY payment_method_code\nORDER BY COUNT(Order_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5127", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the descriptions of the service types that cost more than 100.", "rationale": ["Identify the relevant table: The question asks for service types, which are found in the Services table.", "Determine the required columns: We need the descriptions of the service types, so we will select the 'Service_Type_Description' column.", "Filter the results: The question specifies that we only want service types that cost more than 100, so we will add a WHERE clause to filter based on 'Product_Price'.", "Construct the SQL query: Combine the selected columns, table, and filter condition into a complete SQL query."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT Service_Type_Description \nFROM Services \nWHERE Product_Price > 100;", "hint": "\n"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["Identify the relevant tables: We need to find workshop groups and services, so we will use the 'Drama_Workshop_Groups' and 'Services' tables.", "Determine the relationship: The 'Services' table has a foreign key 'Workshop_Group_ID' that links to 'Drama_Workshop_Groups'.", "Filter the services: We need to filter the services to only those with the product name 'film'.", "Select the distinct workshop group names: We want the names of the workshop groups, so we will select 'Store_Name' from 'Drama_Workshop_Groups' and ensure we get distinct values."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "pred_sql": "SELECT DISTINCT dg.Store_Name\nFROM Drama_Workshop_Groups dg\nJOIN Services s ON dg.Workshop_Group_ID = s.Workshop_Group_ID\nWHERE s.Product_Name = 'film';", "hint": "\n"}
{"sample_id": "train.5142", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the order details of the products with price higher than 2000?", "rationale": ["Identify the relevant tables: Customer_Orders, Order_Items, and Products are needed to get order details and product information.", "Select the necessary columns: We need order details (Order_ID, Order_Date, Planned_Delivery_Date, Actual_Delivery_Date) from Customer_Orders and product details (Product_Name, Product_Price) from Products.", "Join the tables: Use JOIN to connect Customer_Orders with Order_Items on Order_ID and Order_Items with Products on Product_ID.", "Apply the filter: Use a WHERE clause to filter products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT o.Order_ID, o.Order_Date, o.Planned_Delivery_Date, o.Actual_Delivery_Date, oi.Order_Quantity, p.Product_Name, p.Product_Price \nFROM Customer_Orders o \nJOIN Order_Items oi ON o.Order_ID = oi.Order_ID \nJOIN Products p ON oi.Product_ID = p.Product_ID \nWHERE p.Product_Price > 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n        \"virtual_table\": \"SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n        \"virtual_table\": \"SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["Identify the relevant tables: We need to look at the 'Invoice_Items' table for order details and the 'Products' table for product prices.", "Filter products based on price: We will filter products with a price greater than 2000 from the 'Products' table.", "Join the results: We will use a subquery to get the Product_IDs of products with a price above 2000 and use that in the main query to get the corresponding order details from 'Invoice_Items'.", "Select the required columns: We need to select Order_ID, Product_ID, and Order_Quantity from the 'Invoice_Items' table."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_ID, Product_ID, Order_Quantity FROM Invoice_Items WHERE Product_ID IN (SELECT Product_ID FROM Products WHERE Product_Price > 2000)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n        \"virtual_table\": \"SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n        \"virtual_table\": \"SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5160", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the most frequent status of bookings?", "rationale": ["Identify the relevant table: The question pertains to the 'Bookings' table, which contains the 'Status_Code' column that indicates the status of each booking.", "Count the frequency of each status: Use the COUNT() function to count how many times each 'Status_Code' appears in the 'Bookings' table.", "Group the results: Use GROUP BY to group the results by 'Status_Code' so that we can count occurrences for each unique status.", "Order the results: Use ORDER BY to sort the results by frequency in descending order, so the most frequent status appears first.", "Limit the results: Use LIMIT 1 to return only the most frequent status."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Frequency\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most common status code, which implies counting occurrences of each status code.", "Use the COUNT function: We will count how many times each status code appears in the 'Bookings' table.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each unique status code.", "Order the results: To find the most common status code, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most common status code, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Count\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["Identify the relevant tables: We need to find workshop groups and their bookings, so we will use the Drama_Workshop_Groups and Bookings tables.", "Determine the relationship: The Drama_Workshop_Groups table has a Workshop_Group_ID that links to the Bookings table's Workshop_Group_ID.", "Filter the bookings: We need to filter the bookings to only those with a status code of 'stop'.", "Select the required information: We want the names of the workshop groups, which are found in the Store_Name column of the Drama_Workshop_Groups table.", "Use DISTINCT to avoid duplicate names in the result."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "pred_sql": "SELECT DISTINCT dg.Store_Name\nFROM Drama_Workshop_Groups dg\nJOIN Bookings b ON dg.Workshop_Group_ID = b.Workshop_Group_ID\nWHERE b.Status_Code = 'stop';", "hint": "\n"}
{"sample_id": "train.5171", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the description of the service type that offers not only the photo product but also the film product.", "rationale": ["Identify the relevant tables: Ref_Service_Types for service descriptions, Services for linking services to products, and Order_Items for product details.", "Join Ref_Service_Types with Services on Service_Type_Code to get the service descriptions associated with each service.", "Join Services with Order_Items to link services to the products they offer.", "Filter the products to include only those that are 'photo' and 'film'.", "Use a subquery to find Product_IDs for 'photo' and 'film'.", "Group the results by Service_Type_Description to aggregate services that offer both products.", "Use HAVING clause to ensure that only service types offering both products are included, which means counting distinct Product_IDs should equal 2."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT DISTINCT rst.Service_Type_Description\nFROM Ref_Service_Types rst\nJOIN Services s ON rst.Service_Type_Code = s.Service_Type_Code\nJOIN Order_Items oi ON s.Product_ID = oi.Product_ID\nWHERE oi.Product_ID IN (\n    SELECT Product_ID\n    FROM Products\n    WHERE Product_Name IN ('photo', 'film')\n)\nGROUP BY rst.Service_Type_Description\nHAVING COUNT(DISTINCT oi.Product_ID) = 2;", "hint": "\n"}
{"sample_id": "train.5459", "db_id": "voter_2", "question": "Find the average age of female students.", "rationale": ["Identify the table needed: The 'Student' table contains the age and gender information.", "Determine the condition: We need to filter for female students, which is done using the 'Sex' column.", "Calculate the average: Use the AVG() function to calculate the average age of the filtered results."], "gold_sql": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  'F'", "source_tables": ["student"], "pred_sql": "SELECT avg(Age) FROM Student WHERE Sex = 'Female'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5466", "db_id": "voter_2", "question": "What are the distinct president votes on 08/30/2015?", "rationale": ["Identify the relevant table for the query, which is 'Voting_record' for the president votes.", "We need to select distinct president votes, so we will use SELECT DISTINCT President_Vote.", "The condition specifies a date, which corresponds to the 'Registration_Date' column in the Voting_record table.", "We will filter the results to only include records where the Registration_Date is '2015-08-30'."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote FROM Voting_record WHERE Registration_Date = '2015-08-30'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["The query needs to show all distinct president votes made on a specific date, which is 08/30/2015.", "To achieve this, we will select distinct values from the 'President_Vote' column in the 'Voting_record' table.", "We will filter the results based on the 'Registration_Date' column to match the specified date.", "The final SQL query will be constructed accordingly."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote FROM Voting_record WHERE Registration_Date = '08/30/2015'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5476", "db_id": "voter_2", "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.", "rationale": ["Identify the tables involved: Student and Voting_record.", "We need to find distinct ages of students, so we will select the Age column from the Student table.", "We need to join the Student table with the Voting_record table on the condition that the StuID in Student matches the Secretary_Vote in Voting_record.", "We need to filter the results based on the Election_Cycle, which is specified as 'fall'.", "Construct the SQL query using SELECT DISTINCT to get unique ages of students who voted for the secretary candidate in the fall election cycle."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT T1.Age FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Secretary_Vote WHERE T2.Election_Cycle = 'fall'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["Identify the relevant tables: Student and Voting_record.", "Determine the relationship between the tables: Student's StuID is linked to Voting_record's Treasurer_Vote.", "We need to find advisors for students who voted for a treasurer in a specific election cycle, which is 'spring'.", "Use SELECT DISTINCT to get unique advisors from the Student table based on the voting records in the Voting_record table.", "Construct the SQL query using JOIN to combine the two tables on the StuID and Treasurer_Vote, and filter by the Election_Cycle."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT T1.Advisor FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Treasurer_Vote WHERE T2.Election_Cycle = 'spring'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5486", "db_id": "voter_2", "question": "How many male (sex is M) students have class senator votes in the fall election cycle?", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "Determine the condition for counting students: they must be male (Sex = 'M').", "Identify the voting record condition: they must have voted in the fall election cycle.", "Join the two tables on the student ID (StuID) and the class senator vote.", "Count the number of records that meet these conditions."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT count(*) FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Class_Senator_Vote WHERE T1.Sex = 'M' AND T2.Election_Cycle = 'fall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are registered to vote in a specific election cycle and belong to a particular gender. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "Determine the columns needed: average age from 'Student' and filtering based on city code and voting record for secretary.", "Use a JOIN to connect 'Student' and 'Voting_record' on the StuID and Secretary_Vote columns.", "Apply the WHERE clause to filter students by city code 'NYC' and the specific election cycle 'spring'.", "Construct the SQL query to calculate the average age of the filtered students."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT avg(T1.Age) FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Secretary_Vote WHERE T1.city_code = 'NYC' AND T2.Election_Cycle = 'spring'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5492", "db_id": "voter_2", "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "We need to find the average age of female students, so we will filter by 'Sex' = 'F'.", "We are interested in students who have voted for the secretary candidate, which means we will join the 'Student' table with the 'Voting_record' table on the condition that 'StuID' from 'Student' matches 'Secretary_Vote' from 'Voting_record'.", "The election cycle specified is 'spring', so we will add a condition to filter by 'Election_Cycle' = 'spring'.", "Using the average function, we can calculate the average age of the filtered results."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT avg(T1.Age) FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Secretary_Vote WHERE T1.Sex = 'F' AND T2.Election_Cycle = 'spring'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["Identify the columns needed: We need distinct first names of students, so we will select 'Fname' from the 'Student' table.", "Join the 'Student' table with the 'Voting_record' table on the condition that 'StuID' in 'Student' matches 'Vice_President_Vote' in 'Voting_record'. This will allow us to filter students based on their voting records.", "Add a WHERE clause to filter out students whose city code is 'PIT'. We want those whose city code is not 'PIT'.", "Use DISTINCT to ensure that we only get unique first names in the result."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Fname FROM Student JOIN Voting_record ON Student.StuID = Voting_record.Vice_President_Vote WHERE Student.city_code != 'PIT';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5495", "db_id": "voter_2", "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?", "rationale": ["Identify the requirement to find distinct first names of students.", "The relevant table for student information is the 'Student' table, which contains the 'Fname' column.", "The 'Voting_record' table is needed to check for vice president votes, specifically the 'Vice_President_Vote' column.", "We need to filter students who have voted for the vice president, which means we will check for non-null values in the 'Vice_President_Vote' column.", "Additionally, we need to ensure that the city code of the students is not 'PIT'.", "To achieve this, we will use a subquery to get the StuIDs of students who voted for the vice president and then filter the main query based on this condition and the city code condition."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Fname FROM Student WHERE StuID IN (SELECT StuID FROM Voting_record WHERE Vice_President_Vote IS NOT NULL) AND city_code != 'PIT';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5496", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is not 2192.", "rationale": ["Identify the requirement to find distinct last names of students who voted for president.", "The relevant table for student information is 'Student' and for voting records is 'Voting_record'.", "We need to filter students based on their votes for president, which corresponds to the 'President_Vote' column in the 'Voting_record' table.", "We also need to ensure that the advisor of these students is not '2192'.", "To achieve this, we will use a subquery to select all 'StuID's from 'Voting_record' where they voted for president.", "Finally, we will select distinct last names from the 'Student' table where the 'StuID' is in the result of the subquery and the advisor is not '2192'."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student WHERE StuID IN (SELECT President_Vote FROM Voting_record) AND Advisor != '2192';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5499", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes and have 8741 as the advisor?", "rationale": ["Identify the requirement to find distinct last names of students who voted for president.", "The relevant table for student information is 'Student' and for voting records is 'Voting_record'.", "We need to filter students based on their votes for president, which corresponds to the 'President_Vote' column in the 'Voting_record' table.", "We also need to filter students whose advisor is '8741'.", "To achieve this, we can use a subquery to select the 'President_Vote' from 'Voting_record' and then filter the 'Student' table based on this subquery and the advisor condition."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student WHERE StuID IN (SELECT President_Vote FROM Voting_record) AND Advisor = '8741';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and sex.", "Filter the records: We need to focus on female students, so we will add a WHERE clause to filter by Sex = 'F'.", "Group the results: To find the most common major, we will group the results by the Major column.", "Count occurrences: We will order the grouped results by the count of students in each major in descending order to find the most common one.", "Limit the results: Since we only want the most common major, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student WHERE Sex = 'F' GROUP BY Major ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major field of study. The results are ordered by the number of students in each major in descending order, with a limit on the number of majors returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are registered to vote in a specific election cycle and belong to a particular gender. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and gender.", "Filter for female students: We need to focus on female students, so we will add a WHERE clause to filter by Sex = 'Female'.", "Group by major: To find out how many female students are in each major, we will group the results by the Major column.", "Count the number of female students in each major: We will use COUNT(*) to count the number of students in each major after filtering and grouping.", "Order the results: We want to order the results in descending order based on the count of female students, so we will use ORDER BY COUNT(*) DESC.", "Limit the results: Since we only want the major with the most female students, we will limit the results to 1 using LIMIT 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student WHERE Sex = 'Female' GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major field of study. The results are ordered by the number of students in each major in descending order, with a limit on the number of majors returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are registered to vote in a specific election cycle and belong to a particular gender. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to count the number of products, so we will use the COUNT function.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to filter by category.", "Add a WHERE clause to filter for products in the 'Spices' category and with a typical selling price greater than 1000."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT count(*) FROM Products AS p JOIN Ref_Product_Categories AS pc ON p.product_category_code = pc.product_category_code WHERE pc.product_category_description = 'Spices' AND p.typical_selling_price > 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the tables needed: Products and Ref_Product_Categories.", "We need to retrieve the product category descriptions, so we will select 'product_category_description' from Ref_Product_Categories.", "Join the Products table with Ref_Product_Categories on 'product_category_code' to link products to their categories.", "Filter the products based on their descriptions containing the letter 't' using the LIKE operator with a wildcard.", "Use DISTINCT to ensure that we only get unique category descriptions."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description FROM Products AS p JOIN Ref_Product_Categories AS rpc ON p.product_category_code = rpc.product_category_code WHERE p.product_description LIKE '%t%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\",\n        \"virtual_table\": \"SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["Identify the tables involved: Products, Product_Characteristics, and Characteristics.", "Determine the relationship between these tables using their foreign keys.", "We need to count distinct characteristic names associated with the product 'cumin'.", "Use a JOIN to connect Products to Product_Characteristics and then to Characteristics.", "Filter the results where the product name is 'cumin'.", "Use the COUNT function with DISTINCT to get the number of unique characteristic names."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM Products AS t1 JOIN Product_Characteristics AS t2 ON t1.product_id = t2.product_id JOIN Characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id WHERE t1.product_name = 'cumin'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\",\n        \"virtual_table\": \"SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["Identify the tables involved: Products, Product_Characteristics, Characteristics, and Ref_Colors.", "Determine the relationships between these tables using foreign keys: Products to Product_Characteristics, Product_Characteristics to Characteristics, and Products to Ref_Colors.", "Use a JOIN operation to combine these tables based on their relationships.", "Filter the results using a WHERE clause to check for products with color description 'white' or characteristic name 'hot'.", "Count the total number of products that meet either of these conditions using COUNT(*) function."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT count(*) FROM Products AS t1 JOIN Product_Characteristics AS t2 ON t1.product_id = t2.product_id JOIN Characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id JOIN Ref_Colors AS t4 ON t1.color_code = t4.color_code WHERE t4.color_description = 'white' OR t3.characteristic_name = 'hot'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant product category for 'Herb' products.", "Join the Products table with Product_Characteristics to find product IDs associated with the 'Herb' characteristic.", "Use the characteristic name 'Herb' to filter the Characteristics table and get the corresponding characteristic IDs.", "Select the product category codes from the Products table that match the product IDs found in the previous step.", "Finally, retrieve the unit of measure from the Ref_Product_Categories table using the product category codes obtained."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT unit_of_measure FROM Ref_Product_Categories WHERE product_category_code IN (SELECT product_category_code FROM Products WHERE product_id IN (SELECT product_id FROM Product_Characteristics WHERE characteristic_id IN (SELECT characteristic_id FROM Characteristics WHERE characteristic_name = 'Herb')));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the tables needed: We need to get the product category code and unit of measure for a specific product named 'chervil'.", "The relevant tables are 'Products' for product details and 'Ref_Product_Categories' for category details.", "Join the 'Products' table with the 'Ref_Product_Categories' table on the product_category_code to access both product and category information.", "Filter the results by the product name 'chervil' to get the specific product's details."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT product_category_code, unit_of_measure FROM Ref_Product_Categories AS rpc JOIN Products AS p ON rpc.product_category_code = p.product_category_code WHERE p.product_name = 'chervil'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\",\n        \"virtual_table\": \"SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["Identify the tables involved: Products and Ref_Colors.", "Join the Products table with the Ref_Colors table on the color_code column to get color descriptions for each product.", "Group the results by color_description to aggregate the products by their colors.", "Order the results by the count of products in descending order to find the most common color description.", "Limit the results to 1 to get only the top color description."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT t2.color_description FROM Products AS t1 JOIN Ref_Colors AS t2 ON t1.color_code = t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["Identify the tables involved: Products and Ref_Colors.", "Join the Products table with the Ref_Colors table on the color_code to get color descriptions for each product.", "Group the results by color description to count how many products are associated with each color.", "Order the results by the count of products in ascending order to find the color used by the least products.", "Limit the results to 1 to get only the description of the color used by the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT t2.color_description FROM Products AS t1 JOIN Ref_Colors AS t2 ON t1.color_code = t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To achieve this, we will join the 'Product_Characteristics' table with the 'Characteristics' table to get the characteristic names.", "Next, we will join the 'Products' table to link each characteristic to its respective products.", "We will group the results by the characteristic name to count how many distinct products each characteristic is associated with.", "Finally, we will use the HAVING clause to filter the results to only include characteristics that are linked to two or more products."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT t3.characteristic_name\nFROM product_characteristics AS t2\nJOIN characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id\nJOIN products AS t1 ON t2.product_id = t1.product_id\nGROUP BY t3.characteristic_name\nHAVING COUNT(DISTINCT t1.product_id) >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\",\n        \"virtual_table\": \"SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to query.", "Select the 'Builder' column: We want to list the builders, so we will select this column.", "Use DISTINCT to avoid duplicate entries: Since multiple railways can have the same builder, we will use DISTINCT to ensure each builder is listed only once.", "Order the results: We need the results in ascending alphabetical order, so we will use ORDER BY Builder ASC.", "Construct the SQL query: Combine all these elements into a complete SQL query."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "pred_sql": "SELECT DISTINCT Builder FROM railway ORDER BY Builder ASC;", "hint": "\n"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["Identify the relevant tables: 'railway' and 'train'.", "We need to find the railway associated with the most trains, so we will join the 'railway' table with the 'train' table on 'Railway_ID'.", "We will group the results by 'Railway_ID' and 'Builder' to count the number of trains associated with each railway.", "Use COUNT(train.Train_ID) to count the number of trains for each railway.", "Order the results in descending order based on the count of trains to get the railway with the most trains at the top.", "Limit the results to 1 to get only the railway associated with the most trains."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "pred_sql": "SELECT railway.Railway_ID, railway.Builder \nFROM railway \nJOIN train ON railway.Railway_ID = train.Railway_ID \nGROUP BY railway.Railway_ID, railway.Builder \nORDER BY COUNT(train.Train_ID) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["We need to find the most common builder of railways, which means we will be counting how many railways each builder has constructed.", "To do this, we will select the 'Builder' column from the 'railway' table and count the occurrences of each builder using COUNT(*).", "We will group the results by 'Builder' to aggregate the counts for each builder.", "Next, we will order the results in descending order based on the count of railways built (BuilderCount).", "Finally, we will limit the results to just one entry to get the most common builder."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "pred_sql": "SELECT Builder, COUNT(*) as BuilderCount \nFROM railway \nGROUP BY Builder \nORDER BY BuilderCount DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["Identify the table to query: The relevant table is 'Student' since we need student information.", "Determine the columns needed: We need the 'LName' column for the last names of students.", "Define the conditions for selection: We need students who are either female, live in a city with code 'BAL', or are male and under 20 years old.", "Construct the SQL query using the SELECT statement to retrieve 'LName' from 'Student' where the defined conditions are met."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "pred_sql": "SELECT LName FROM Student WHERE (Sex = 'Female') OR (city_code = 'BAL') OR (Sex = 'Male' AND Age < '20');", "hint": "\n"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["Identify the relevant tables: Dorm and Has_amenity are needed to get dormitory information and their amenities.", "We need to count the number of amenities for each dormitory, so we will use COUNT() function on the amenity identifier from Has_amenity.", "We need to filter dormitories that can accommodate more than 100 students, which is done using a WHERE clause on the student_capacity column in the Dorm table.", "We will group the results by dormid and dorm_name to get the count of amenities for each dormitory.", "Finally, we will select the dormid, dorm_name, and the count of amenities in the final output."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "pred_sql": "SELECT D.dormid, D.dorm_name, COUNT(HA.amenid) AS amenity_count \nFROM Dorm AS D \nJOIN Has_amenity AS HA ON D.dormid = HA.dormid \nWHERE D.student_capacity > 100 \nGROUP BY D.dormid, D.dorm_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\",\n        \"virtual_table\": \"SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables needed: We need to count students, so we will use the 'Student' table and the 'Lives_in' table to find out where students live.", "Join the 'Student' table with the 'Lives_in' table on the student ID to link students with their dorms.", "Next, we need to filter the dorms based on gender. We will join the 'Dorm' table to access the gender information of each dorm.", "We will apply a WHERE clause to filter for dorms that are designated for males (D.gender = 'male').", "Finally, we will use COUNT(*) to get the total number of students living in male dorms."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(*) FROM Student AS S JOIN Lives_in AS L ON S.StuID = L.stuid JOIN Dorm AS D ON L.dormid = D.dormid WHERE D.gender = 'male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\",\n        \"virtual_table\": \"SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["Identify the main goal: Find the first names of students living in the dorm with the most amenities.", "Join the 'Student' table with the 'Lives_in' table to link students to their respective dorms.", "Use a subquery to find the dormitory IDs that have the most amenities.", "Join the 'Dorm' table with the 'Has_amenity' table to count the number of amenities for each dorm.", "Group the results by dormitory ID and order them by the count of amenities in descending order.", "Limit the results of the subquery to 1 to get the dorm with the most amenities.", "Use the result of the subquery in the main query to filter students living in that dorm."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT T1.Fname FROM Student AS T1 JOIN Lives_in AS T2 ON T1.StuID = T2.stuid WHERE T2.dormid IN (SELECT T3.dormid FROM Dorm AS T3 JOIN Has_amenity AS T4 ON T3.dormid = T4.dormid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\",\n        \"virtual_table\": \"SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["Identify the information needed: first name and age of students living in dorms with a specific amenity (TV Lounge).", "Start with the Student table to get the first name and age.", "Use the Lives_in table to find which students live in which dorms.", "Filter the dorms based on the amenities they have by joining the Has_amenity and Dorm_amenity tables.", "Specifically, look for dorms that have the amenity 'TV Lounge'.", "Construct a subquery to find dorm IDs that have the 'TV Lounge' amenity.", "Use this subquery to filter the Lives_in table to get student IDs of those who live in those dorms.", "Finally, use these student IDs to filter the Student table to get the desired first names and ages."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "pred_sql": "SELECT Fname, Age FROM Student WHERE StuID IN (SELECT stuid FROM Lives_in WHERE dormid IN (SELECT dormid FROM Has_amenity WHERE amenid IN (SELECT amenid FROM Dorm_amenity WHERE amenity_name = 'TV Lounge')));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\",\n        \"virtual_table\": \"SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the main goal: Retrieve the email addresses of customers who have filed complaints about the product with the greatest number of complaints.", "To find the product with the greatest number of complaints, a subquery is needed that counts complaints grouped by product_id and orders them in descending order, limiting the result to the top one.", "Join the Customers table with the Complaints table on customer_id to get the email addresses of customers who have made complaints.", "Use the result of the subquery to filter the complaints to only those related to the product with the highest complaint count."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT t1.email_address FROM Customers AS t1 JOIN Complaints AS t2 ON t1.customer_id = t2.customer_id WHERE t2.product_id = (SELECT product_id FROM Complaints GROUP BY product_id ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["Identify the customer who has filed the least amount of complaints by using a subquery that counts complaints grouped by customer ID and orders them in ascending order, limiting the result to 1.", "Join the Complaints table with the Products table to find the products associated with the complaints made by that customer.", "Select the product names from the Products table where the product ID matches the complaints made by the identified customer."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT p.product_name FROM Products p JOIN Complaints c ON p.product_id = c.product_id WHERE c.customer_id = (SELECT customer_id FROM Customers c1 JOIN Complaints c2 ON c1.customer_id = c2.customer_id GROUP BY c1.customer_id ORDER BY COUNT(*) ASC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the relevant tables: Staff, Complaints, and Products.", "We need to find the last name of the staff member handling a complaint related to the product with the lowest price.", "Join the Staff table with the Complaints table on staff_id to link staff members to complaints.", "Join the Complaints table with the Products table on product_id to link complaints to products.", "Use a subquery to find the minimum product price from the Products table.", "Filter the results to only include complaints related to the product with the lowest price and select the last name of the staff member."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT s.last_name \nFROM Staff s \nJOIN Complaints c ON s.staff_id = c.staff_id \nJOIN Products p ON c.product_id = p.product_id \nWHERE p.product_price = (SELECT MIN(product_price) FROM Products)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["Identify the relevant table: The Complaints table contains the complaint status information.", "Determine the required fields: We need the complaint status code and the count of records for each status.", "Group the results: Use GROUP BY to aggregate the results by complaint status code.", "Filter the results: Use HAVING to filter out any complaint statuses that have 3 or fewer records."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "pred_sql": "SELECT complaint_status_code, COUNT(*) as record_count \nFROM Complaints \nGROUP BY complaint_status_code \nHAVING COUNT(*) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["Identify the need to count customers based on their type.", "Use the Customers table to access customer data.", "Group the results by customer_type_code to count how many customers belong to each type.", "Order the results in descending order based on the count to find the most common customer type.", "Limit the results to 1 to get only the most common customer type."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT count(*) FROM Customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the states where customers reside, grouping the results by state and ordering them by the number of customers in each state. The placeholder in the LIMIT clause allows for specifying the maximum number of states to return.\",\n        \"virtual_table\": \"SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the states where customers reside, grouping the results by state and ordering them by the number of customers in each state. The placeholder in the LIMIT clause allows for specifying the maximum number of states to return.\",\n        \"virtual_table\": \"SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to find the first names of staff members, so we will select 'first_name' from the Staff table.", "To determine how many complaints each staff member has handled, we will join the Staff table with the Complaints table on 'staff_id'.", "We will group the results by 'staff_id' to aggregate the number of complaints handled by each staff member.", "We will order the results in descending order based on the count of complaints to get the top staff members who handled the most complaints.", "Finally, we will limit the results to the top 5 staff members."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT s.first_name FROM Staff s JOIN Complaints c ON s.staff_id = c.staff_id GROUP BY s.staff_id ORDER BY COUNT(c.complaint_id) DESC LIMIT 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["We need to return the first names of staff members who have handled complaints.", "To find out which staff members have handled complaints, we will join the Staff table with the Complaints table on the staff_id column.", "We will group the results by staff_id to aggregate the number of complaints each staff member has handled.", "Next, we will order the results in descending order based on the count of complaints handled by each staff member.", "Finally, we will limit the results to the top 5 staff members who have handled the most complaints."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT s.first_name FROM Staff s JOIN Complaints c ON s.staff_id = c.staff_id GROUP BY s.staff_id ORDER BY COUNT(c.complaint_id) DESC LIMIT 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The user wants to see all investor details, which means we need to select all columns from the Investors table.", "The SQL query to retrieve all columns from a table is done using 'SELECT *'.", "We specify the table name 'Investors' to get the data from that specific table."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "pred_sql": "SELECT * FROM Investors;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["Identify the main goal: to show details of all investors who have made transactions with a share count greater than 100.", "Determine the necessary tables: Investors and Transactions are required to get investor details and their transaction information.", "Establish the relationship between the tables: Investors are linked to Transactions through the investor_id.", "Construct the SQL query: Select investor_id and Investor_details from Investors, joining with Transactions on investor_id, and filter for share_count greater than 100."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "pred_sql": "SELECT I.investor_id, I.Investor_details \nFROM Investors AS I \nJOIN Transactions AS T ON I.investor_id = T.investor_id \nWHERE T.share_count > 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["Identify the tables involved: Lots, Transactions, and Transactions_Lots.", "Determine the relationship between these tables: Lots are linked to Transactions through Transactions_Lots.", "Select the lot details from the Lots table.", "Filter the results based on the share count from the Transactions table, specifically looking for transactions with a share count smaller than 50."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT L.lot_details \nFROM Lots AS L \nJOIN Transactions_Lots AS TL ON L.lot_id = TL.lot_id \nJOIN Transactions AS T ON TL.transaction_id = T.transaction_id \nWHERE T.share_count < 50;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\",\n        \"virtual_table\": \"SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["Identify the tables involved: We need to get transaction amounts and their types, so we will use the Transactions and Ref_Transaction_Types tables.", "Determine the necessary columns: We need the transaction type description from Ref_Transaction_Types and the amount of transaction from Transactions.", "Join the tables: We will join Transactions with Ref_Transaction_Types on the transaction_type_code to link transaction amounts with their respective types.", "Calculate the average: We will use the AVG() function to calculate the average transaction amount for each transaction type.", "Group the results: We will group the results by transaction type description to get the average for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\",\n        \"virtual_table\": \"SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["Identify the relevant table: The Transactions table contains the share count and transaction type code.", "Determine the required aggregation: We need to find the maximum and minimum share counts for each transaction type.", "Use the GROUP BY clause to group results by transaction_type_code, allowing us to calculate the max and min share counts for each type.", "Select the transaction_type_code along with the aggregated max and min share counts in the final output."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT transaction_type_code, MAX(share_count) AS max_share_count, MIN(share_count) AS min_share_count \nFROM Transactions \nGROUP BY transaction_type_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\",\n        \"virtual_table\": \"SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["The question asks for details of all sales and purchases, which means we need to retrieve data from both the Sales and Purchases tables.", "To get the details from both tables, we will use a LEFT JOIN to combine the Sales table with the Purchases table based on their transaction IDs.", "We select the relevant columns from both tables: sales_transaction_id and sales_details from the Sales table, and purchase_transaction_id and purchase_details from the Purchases table."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "pred_sql": "SELECT S.sales_transaction_id, S.sales_details, P.purchase_transaction_id, P.purchase_details \nFROM Sales AS S \nLEFT JOIN Purchases AS P ON S.sales_transaction_id = P.purchase_transaction_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\",\n        \"virtual_table\": \"SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5898", "db_id": "cre_Theme_park", "question": "What is the average price range of five star hotels that allow pets?", "rationale": ["Identify the relevant table: The Hotels table contains information about hotel star ratings and whether pets are allowed.", "Determine the criteria: We need to filter for five-star hotels (star_rating_code = '5') and those that allow pets (pets_allowed_yn = 'Yes').", "Use the AVG function: To find the average price range, we will use the AVG function on the price_range column.", "Construct the SQL query: Combine the selected columns and criteria into a complete SQL query."], "gold_sql": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  '5' AND pets_allowed_yn  =  1", "source_tables": ["hotels"], "pred_sql": "SELECT avg(price_range) FROM Hotels WHERE star_rating_code = '5' AND pets_allowed_yn = 'Yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average price range of hotels from the 'Hotels' table that meet specific criteria. The placeholders in the WHERE clause represent the star rating code and whether pets are allowed, allowing users to specify their desired conditions.\",\n        \"virtual_table\": \"SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5904", "db_id": "cre_Theme_park", "question": "Find all the locations whose names contain the word \"film\".", "rationale": ["Identify the table that contains location names: Locations.", "Determine the column that holds the names of the locations: Location_Name.", "Use the SQL SELECT statement to retrieve all columns from the Locations table.", "Apply a WHERE clause to filter results where Location_Name contains the word 'film', using the LIKE operator with wildcards."], "gold_sql": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE '%film%'", "source_tables": ["locations"], "pred_sql": "SELECT * FROM Locations WHERE Location_Name LIKE '%film%';", "hint": "\n"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["Identify the relevant table for museums, which is the 'Museums' table.", "Determine the required columns: 'Museum_Details' and 'Opening_Hours'.", "Construct the SQL query to select these columns from the 'Museums' table."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT Museum_Details, Opening_Hours FROM Museums", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5916", "db_id": "cre_Theme_park", "question": "Give me the detail and opening hour for each museum.", "rationale": ["Identify the relevant table for museums, which is the 'Museums' table.", "Determine the required fields: 'Museum_Details' and 'Opening_Hours'.", "Construct the SQL query to select these fields from the 'Museums' table."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT Museum_Details, Opening_Hours FROM Museums", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Royal_Family.", "Determine the relationship between the tables: Tourist_Attractions has a foreign key linking to Royal_Family.", "Select the desired columns: Name, Description, How_to_Get_There, and Other_Details from Tourist_Attractions.", "Join the Tourist_Attractions table with the Royal_Family table on the appropriate foreign key.", "Construct the SQL query to retrieve the required details about tourist attractions related to the royal family."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "pred_sql": "SELECT T1.Name, T1.Description, T1.How_to_Get_There, T1.Other_Details \nFROM Tourist_Attractions AS T1 \nJOIN Royal_Family AS T2 ON T1.Tourist_Attraction_ID = T2.Royal_Family_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5923", "db_id": "cre_Theme_park", "question": "What are the details of the shops that can be accessed by walk?", "rationale": ["Identify the relevant tables: Shops and Tourist_Attractions.", "Determine the relationship between shops and tourist attractions: Shops are linked to Tourist_Attractions via Shop_ID.", "Filter the results based on the access method: We want shops that can be accessed by walking, so we will filter on the How_to_Get_There column of the Tourist_Attractions table.", "Construct the SQL query to select the Shop_ID and Shop_Details from the Shops table, joining it with the Tourist_Attractions table, and applying the filter for walking access."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "pred_sql": "SELECT S.Shop_ID, S.Shop_Details \nFROM Shops AS S \nJOIN Tourist_Attractions AS T ON S.Shop_ID = T.Tourist_Attraction_ID \nWHERE T.How_to_Get_There = 'walk'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5931", "db_id": "cre_Theme_park", "question": "Which tourist attractions does the visitor with detail 'Vincent' visit?", "rationale": ["Identify the relevant tables: We need to find tourist attractions visited by a specific visitor, so we will use the Visits, Visitors, and Tourist_Attractions tables.", "Join the Visits table with the Visitors table on Tourist_ID to filter visits by the visitor named 'Vincent'.", "Join the resulting table with the Tourist_Attractions table to get the names of the attractions visited.", "Filter the results where the Tourist_Details in the Visitors table matches 'Vincent'.", "Select the Name of the tourist attractions from the final joined table."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT T2.Name FROM Visits AS T1 JOIN Visitors AS T3 ON T1.Tourist_ID = T3.Tourist_ID JOIN Tourist_Attractions AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID WHERE T3.Tourist_Details = 'Vincent';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5932", "db_id": "cre_Theme_park", "question": "Show the tourist attractions visited by the tourist whose detail is 'Vincent'.", "rationale": ["Identify the tables needed: Tourist_Attractions, Visits, and Visitors.", "We need to find tourist attractions visited by a specific tourist, so we will join the Visits table with the Tourist_Attractions table on the Tourist_Attraction_ID.", "Next, we join the Visitors table to filter by the tourist whose details are 'Vincent'.", "Select the relevant columns from the Tourist_Attractions table such as Name, Description, Opening_Hours, and Other_Details.", "Construct the SQL query using the identified tables and conditions."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT T2.Name, T2.Description, T2.Opening_Hours, T2.Other_Details \nFROM Tourist_Attractions AS T2 \nJOIN Visits AS V ON T2.Tourist_Attraction_ID = V.Tourist_Attraction_ID \nJOIN Visitors AS T1 ON V.Tourist_ID = T1.Tourist_ID \nWHERE T1.Tourist_Details = 'Vincent';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5941", "db_id": "cre_Theme_park", "question": "Show the details of the top 3 most expensive hotels.", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "To find the most expensive hotels, we need to order the results by the 'price_range' column in descending order.", "We want to limit the results to the top 3 hotels, so we will use the LIMIT clause with a value of 3.", "Construct the SQL query using SELECT to get all columns from the 'Hotels' table, order by 'price_range' in descending order, and limit the results to 3."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average price range of hotels from the 'Hotels' table that meet specific criteria. The placeholders in the WHERE clause represent the star rating code and whether pets are allowed, allowing users to specify their desired conditions.\",\n        \"virtual_table\": \"SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "Determine the relevant columns needed for the output; in this case, we want all details of the hotels.", "To find the most expensive hotels, we need to order the results by the 'price_range' column in descending order.", "Limit the results to the top three entries to get the three most expensive hotels."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average price range of hotels from the 'Hotels' table that meet specific criteria. The placeholders in the WHERE clause represent the star rating code and whether pets are allowed, allowing users to specify their desired conditions.\",\n        \"virtual_table\": \"SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5944", "db_id": "cre_Theme_park", "question": "What are the details and star ratings of the three hotels with the lowest price ranges?", "rationale": ["Identify the relevant table: The Hotels table contains the details and star ratings of hotels.", "Select the required columns: We need 'other_hotel_details' and 'star_rating_code' from the Hotels table.", "Order the results: To find the hotels with the lowest price ranges, we will order the results by 'price_range' in ascending order.", "Limit the results: Since we only want the three hotels with the lowest price ranges, we will limit the results to 3."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT other_hotel_details, star_rating_code FROM Hotels ORDER BY price_range ASC LIMIT 3", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average price range of hotels from the 'Hotels' table that meet specific criteria. The placeholders in the WHERE clause represent the star rating code and whether pets are allowed, allowing users to specify their desired conditions.\",\n        \"virtual_table\": \"SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["The user wants to know the transportation method most people choose to get to tourist attractions.", "The hint provided describes a virtual table that links street markets to tourist attractions based on the instructions on how to reach them.", "The virtual table suggests using a JOIN between the Street_Markets and Tourist_Attractions tables on the Market_ID and Tourist_Attraction_ID respectively.", "The WHERE clause in the virtual table allows for filtering based on the How_to_Get_There column, which indicates the transportation methods.", "I will use 'public transport' and 'walking' as common transportation methods in the WHERE clause to find the relevant street markets."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN Tourist_Attractions AS T2 ON T1.Market_ID = T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There = 'public transport' OR T2.How_to_Get_There = 'walking'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant table: The question pertains to transportation methods used to reach tourist attractions, which is found in the 'Tourist_Attractions' table under the column 'How_to_Get_There'.", "Count the occurrences of each transportation method: We need to group the results by 'How_to_Get_There' and count how many times each method is mentioned.", "Order the results: To find the most frequently used method, we will order the results in descending order based on the count of occurrences.", "Limit the results: Since we only want the most used method, we will limit the results to 1."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Method_Count \nFROM Tourist_Attractions \nGROUP BY How_to_Get_There \nORDER BY Method_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5955", "db_id": "cre_Theme_park", "question": "Show the names and ids of tourist attractions that are visited at most once.", "rationale": ["Identify the relevant table: Tourist_Attractions contains the names and IDs of tourist attractions.", "Determine the criteria: We need to find attractions that are visited at most once.", "Use the Visits table to count the number of visits per attraction: We can group by Tourist_Attraction_ID and count the number of unique Tourist_IDs.", "Filter the attractions based on the count: We want those attractions where the count is less than or equal to 1.", "Construct the SQL query using a subquery to filter out attractions that have more than one visit."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attraction_ID, Name FROM Tourist_Attractions WHERE Tourist_Attraction_ID NOT IN (SELECT Tourist_Attraction_ID FROM Visits GROUP BY Tourist_Attraction_ID HAVING COUNT(Tourist_ID) > 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5956", "db_id": "cre_Theme_park", "question": "What are the names and ids of the tourist attractions that are visited at most once?", "rationale": ["Identify the relevant table: The question pertains to tourist attractions and their visit counts, so we will focus on the 'Tourist_Attractions' and 'Visits' tables.", "Determine the criteria: We need to find tourist attractions that have been visited at most once. This means we need to count the number of visits for each attraction.", "Use a subquery: We can use a subquery to count the number of visits for each 'Tourist_Attraction_ID' in the 'Visits' table and filter those that have a count greater than 1.", "Select the desired columns: We want to retrieve the 'Tourist_Attraction_ID' and 'Name' from the 'Tourist_Attractions' table for those attractions that meet our criteria.", "Construct the final SQL query: Combine the main query with the subquery to filter out attractions that have been visited more than once."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attraction_ID, Name FROM Tourist_Attractions WHERE Tourist_Attraction_ID NOT IN (SELECT Tourist_Attraction_ID FROM Visits GROUP BY Tourist_Attraction_ID HAVING COUNT(Tourist_ID) > 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["Identify the relevant tables: Tourist_Attractions and Features, as we need to find attractions based on their features.", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions with their features.", "Join the resulting table with the Features table to access the feature details.", "Filter the results where the feature details are either 'parking' or 'shopping'.", "Select the names of the tourist attractions that meet the criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT Tourist_Attractions.Name \nFROM Tourist_Attractions \nJOIN Tourist_Attraction_Features ON Tourist_Attractions.Tourist_Attraction_ID = Tourist_Attraction_Features.Tourist_Attraction_ID \nJOIN Features ON Tourist_Attraction_Features.Feature_ID = Features.Feature_ID \nWHERE Features.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table on the Tourist_Attraction_ID to link attractions with their features.", "Join the resulting table with the Features table on Feature_ID to get the details of the features.", "Filter the results where the Feature_Details are either 'parking' or 'shopping'.", "Select the Name of the tourist attractions that meet the criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT T.Name \nFROM Tourist_Attractions AS T \nJOIN Tourist_Attraction_Features AS F ON T.Tourist_Attraction_ID = F.Tourist_Attraction_ID \nJOIN Features AS D ON F.Feature_ID = D.Feature_ID \nWHERE D.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5963", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions Vincent and Marcelle visit?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Visits, and Visitors are needed to find the names of tourist attractions visited by specific tourists.", "Join the Visits table with the Tourist_Attractions table on the Tourist_Attraction_ID to link visits to attractions.", "Join the Visitors table with the Visits table on Tourist_ID to link visits to tourists.", "Filter the results where the Tourist_Details in the Visitors table match 'Vincent' or 'Marcelle'.", "Select the Name of the tourist attractions from the Tourist_Attractions table."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT TA.Name \nFROM Tourist_Attractions AS TA \nJOIN Visits AS V ON TA.Tourist_Attraction_ID = V.Tourist_Attraction_ID \nJOIN Visitors AS T ON V.Tourist_ID = T.Tourist_ID \nWHERE T.Tourist_Details IN ('Vincent', 'Marcelle');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5985", "db_id": "game_1", "question": "Which game type has most number of games?", "rationale": ["Identify the table that contains the game types, which is the 'Video_Games' table.", "We need to group the results by the game type (GType) to count how many games belong to each type.", "Use the COUNT function to count the number of games in each genre.", "Order the results in descending order so that the game type with the most games appears first.", "Limit the results to 1 to get only the game type with the highest count."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType FROM Video_Games GROUP BY GType ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the types or genres of video games from the 'Video_Games' table, grouped by their type. The placeholder in the LIMIT clause allows the user to specify the maximum number of genres to retrieve, sorted by the number of games in each genre in descending order.\",\n        \"virtual_table\": \"SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\",\n        \"virtual_table\": \"SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5988", "db_id": "game_1", "question": "What is the type with the fewest games?", "rationale": ["Identify the table that contains the types of video games, which is the 'Video_Games' table.", "We need to group the results by the 'GType' column to count how many games belong to each type.", "Use the COUNT function to count the number of games for each type.", "Order the results in ascending order (ASC) so that the type with the fewest games appears first.", "Limit the results to only one entry using LIMIT 1 to get the type with the fewest games."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType FROM Video_Games GROUP BY GType ORDER BY COUNT(*) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the types or genres of video games from the 'Video_Games' table, grouped by their type. The placeholder in the LIMIT clause allows the user to specify the maximum number of genres to retrieve, sorted by the number of games in each genre in descending order.\",\n        \"virtual_table\": \"SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\",\n        \"virtual_table\": \"SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6001", "db_id": "game_1", "question": "How many students play sports?", "rationale": ["The question asks for the number of students who play sports.", "To find this, we need to count the unique students in the 'Student' table who have entries in the 'SportsInfo' table.", "We can achieve this by using a subquery that selects all 'StuID' from the 'SportsInfo' table, which indicates that those students are involved in sports.", "Finally, we use the COUNT function to count the total number of unique students that match this criteria."], "gold_sql": "SELECT count(DISTINCT StuID) FROM Sportsinfo", "source_tables": ["sportsinfo"], "pred_sql": "SELECT COUNT(*) FROM Student WHERE StuID IN (SELECT StuID FROM SportsInfo)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\",\n        \"virtual_table\": \"SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6003", "db_id": "game_1", "question": "List ids for all student who are on scholarship.", "rationale": ["The user wants to list the IDs of students who are on a sports scholarship.", "We need to query the SportsInfo table because it contains information about students participating in sports and their scholarship status.", "We will select the 'StuID' column from the SportsInfo table.", "We will filter the results using a WHERE clause to include only those students who are on a scholarship, which is indicated by the 'OnScholarship' column being equal to 'Yes'."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6004", "db_id": "game_1", "question": "What are the ids for all sporty students who are on scholarship?", "rationale": ["Identify the relevant table: SportsInfo contains information about students involved in sports.", "Determine the criteria: We need to find students who are on a sports scholarship, which is indicated by the 'OnScholarship' column.", "Select the appropriate column: We want the unique identifiers of these students, which is the 'StuID' column.", "Construct the SQL query: Use a SELECT statement to retrieve 'StuID' from 'SportsInfo' where 'OnScholarship' is 'Yes'."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\",\n        \"virtual_table\": \"SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6006", "db_id": "game_1", "question": "What are the last names for all scholarship students?", "rationale": ["Identify the relevant table: We need to find students who are on a sports scholarship, which is stored in the SportsInfo table.", "Determine the condition: We are looking for students who have 'OnScholarship' marked as 'Yes'.", "Select the relevant columns: We need the last names of these students, which are in the Student table under the column 'LName'.", "Use a subquery: To find the last names, we will use a subquery to get the StuID of students who are on a scholarship from the SportsInfo table.", "Combine the results: The main query will select the last names from the Student table where the StuID matches those from the subquery."], "gold_sql": "SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT LName FROM Student WHERE StuID IN (SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6010", "db_id": "game_1", "question": "What is the total number of all football games played by scholarship students?", "rationale": ["Identify the relevant table: SportsInfo contains information about sports participation.", "Determine the specific sport: The question asks about football games, so we will filter by SportName = 'Football'.", "Check for scholarship status: We need to include only those students who are on a sports scholarship, so we filter by OnScholarship = 'Yes'.", "Use the SUM function to calculate the total number of games played by these students.", "Construct the SQL query using the identified filters and aggregation."], "gold_sql": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  'Football' AND onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT sum(GamesPlayed) FROM SportsInfo WHERE SportName = 'Football' AND OnScholarship = 'Yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\",\n        \"virtual_table\": \"SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6014", "db_id": "game_1", "question": "What are the ids of all students along with how many sports and games did they play?", "rationale": ["We need to retrieve the student IDs along with the count of sports and games they play.", "Start by selecting the 'StuID' from the 'Student' table.", "To get the count of sports played by each student, we can create a subquery that counts the number of entries in the 'SportsInfo' table grouped by 'StuID'.", "Next, we need to count the number of games played by each student from the 'Plays_Games' table, which can also be done using a subquery that counts entries grouped by 'StuID'.", "Since not all students may participate in sports or play games, we will use LEFT JOINs to ensure all students are included in the final result even if they have zero counts for sports or games.", "Finally, we will use COALESCE to replace any NULL values with 0 for students who do not participate in sports or play games."], "gold_sql": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID", "source_tables": ["sportsinfo"], "pred_sql": "SELECT S.StuID, COALESCE(SP.sports_count, 0) AS sports_count, COALESCE(GP.games_count, 0) AS games_count\nFROM Student S\nLEFT JOIN (\n    SELECT StuID, COUNT(*) AS sports_count\n    FROM SportsInfo\n    GROUP BY StuID\n) SP ON S.StuID = SP.StuID\nLEFT JOIN (\n    SELECT StuID, COUNT(*) AS games_count\n    FROM Plays_Games\n    GROUP BY StuID\n) GP ON S.StuID = GP.StuID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\",\n        \"virtual_table\": \"SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6019", "db_id": "game_1", "question": "Which sport has most number of students on scholarship?", "rationale": ["We need to find out which sport has the most number of students on scholarship.", "To do this, we will query the SportsInfo table where the OnScholarship column indicates 'Yes'.", "We will group the results by SportName to count the number of students for each sport.", "Using COUNT(*) will give us the total number of students for each sport on scholarship.", "Finally, we will order the results in descending order based on the count and limit the result to 1 to get the sport with the most students."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName, COUNT(*) AS NumberOfStudents\nFROM SportsInfo\nWHERE OnScholarship = 'Yes'\nGROUP BY SportName\nORDER BY NumberOfStudents DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\",\n        \"virtual_table\": \"SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6020", "db_id": "game_1", "question": "What is the sport with the most scholarship students?", "rationale": ["Identify the relevant table: SportsInfo contains information about students involved in sports and their scholarship status.", "Filter the records to include only those students who are on a sports scholarship by using the condition 'OnScholarship = 'Yes' in the WHERE clause.", "Group the results by SportName to aggregate the total number of games played for each sport.", "Use the SUM function to calculate the total number of games played for each sport.", "Order the results in descending order based on the total number of games played to find the sport with the most scholarship students.", "Limit the results to 1 to get only the sport with the highest total games played."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName, SUM(GamesPlayed) AS TotalGamesPlayed\nFROM SportsInfo\nWHERE OnScholarship = 'Yes'\nGROUP BY SportName\nORDER BY TotalGamesPlayed DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\",\n        \"virtual_table\": \"SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6024", "db_id": "game_1", "question": "What are the student ids for those on scholarship in major number 600?", "rationale": ["Identify the requirement: We need to find student IDs of those who are on a sports scholarship and have a specific major (number 600).", "Check the SportsInfo table for students on scholarship: We will filter the SportsInfo table where OnScholarship is 'Yes'.", "Check the Student table for students with Major number 600: We will filter the Student table where Major is '600'.", "Combine the two conditions: We need to find student IDs that are present in both conditions, which means we will use a subquery to filter the StuID from the Student table based on the Major and then check against the SportsInfo table for the scholarship status."], "gold_sql": "SELECT StuID FROM Student WHERE major  =  600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes' AND StuID IN (SELECT StuID FROM Student WHERE Major = '600')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6025", "db_id": "game_1", "question": "Show student ids who are female and play football.", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for student information and the 'SportsInfo' table for sports participation.", "We need to filter students based on gender, specifically females, which is found in the 'Sex' column of the 'Student' table.", "We also need to filter students who play football, which is found in the 'SportName' column of the 'SportsInfo' table.", "To get the student IDs, we will select 'StuID' from the 'Student' table.", "We will join the 'Student' table with the 'SportsInfo' table on 'StuID' to combine the relevant information.", "The final SQL query will include a WHERE clause to filter for female students and those who play football."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT Student.StuID FROM Student JOIN SportsInfo ON Student.StuID = SportsInfo.StuID WHERE Student.Sex = 'Female' AND SportsInfo.SportName = 'Football';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\",\n        \"virtual_table\": \"SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6026", "db_id": "game_1", "question": "What are the ids of all female students who play football?", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for student information and the 'SportsInfo' table for sports participation.", "We need to find female students, so we will filter the 'Student' table by the 'Sex' column where it equals 'Female'.", "We also need to filter for students who play football, which is found in the 'SportName' column of the 'SportsInfo' table.", "To get the ids of these students, we will select the 'StuID' from the 'Student' table.", "We will join the 'Student' table with the 'SportsInfo' table on 'StuID' to combine the information from both tables."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN SportsInfo ON Student.StuID = SportsInfo.StuID \nWHERE Student.Sex = 'Female' AND SportsInfo.SportName = 'Football';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\",\n        \"virtual_table\": \"SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6028", "db_id": "game_1", "question": "What are the ids of all male students who do not play football?", "rationale": ["Identify the requirement: We need the IDs of all male students who do not play football.", "To find male students, we will filter the Student table where Sex = 'Male'.", "To exclude students who play football, we will use a subquery that selects StuID from the SportsInfo table where SportName = 'Football'.", "We will use the NOT IN clause to ensure that we only get male students whose IDs are not in the list of students who play football."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male' AND StuID NOT IN (SELECT StuID FROM SportsInfo WHERE SportName = 'Football')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\",\n        \"virtual_table\": \"SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6060", "db_id": "customers_and_addresses", "question": "Find the average order quantity per order.", "rationale": ["Identify the relevant table: The 'Order_Items' table contains the 'order_quantity' which we need to average.", "We need to calculate the average order quantity per order, so we will use the AVG() function.", "To get the average per order, we will group the results by 'order_id' to ensure we are averaging the quantities for each specific order."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "pred_sql": "SELECT AVG(order_quantity) AS average_order_quantity FROM Order_Items GROUP BY order_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6071", "db_id": "customers_and_addresses", "question": "What are the details of all products?", "rationale": ["The user wants to retrieve details of all products.", "To get all details from the 'Products' table, we can use a simple SELECT statement.", "Using 'SELECT *' will return all columns from the 'Products' table."], "gold_sql": "SELECT DISTINCT product_details FROM products", "source_tables": ["products"], "pred_sql": "SELECT * FROM Products;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6075", "db_id": "customers_and_addresses", "question": "Find the detail of products whose detail contains the word \"Latte\" or the word \"Americano\"", "rationale": ["Identify the table to query: The question asks for product details, which are stored in the 'Products' table.", "Determine the condition: The details should contain either the word 'Latte' or 'Americano'.", "Use the SQL LIKE operator to filter results based on the presence of these words in the 'product_details' column.", "Construct the SQL SELECT statement to retrieve 'product_details' from the 'Products' table with the specified conditions."], "gold_sql": "SELECT product_details FROM products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'", "source_tables": ["products"], "pred_sql": "SELECT product_details FROM Products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: We need to find the city with the most customers, so we will use the Customer_Addresses and Addresses tables.", "Join the tables: We will join Customer_Addresses with Addresses on the address_id to get the city information for each customer.", "Count distinct customers: We will count the distinct customer_id for each city to avoid counting the same customer multiple times if they have multiple addresses.", "Group by city: We will group the results by city to aggregate the customer counts for each city.", "Order by customer count: We will order the results in descending order based on the customer count to find the city with the most customers.", "Limit the results: We will limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(DISTINCT customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6086", "db_id": "customers_and_addresses", "question": "Find the city where the most customers live.", "rationale": ["To find the city where the most customers live, we need to count the number of customers associated with each city.", "The relevant tables are 'Customer_Addresses' which links customers to their addresses, and 'Addresses' which contains the city information.", "We will perform a JOIN between 'Customer_Addresses' and 'Addresses' on the address_id to get the city for each customer.", "Next, we will use GROUP BY to group the results by city and COUNT to count the number of customers in each city.", "To find the city with the most customers, we will order the results in descending order based on the customer count.", "Finally, we will limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6097", "db_id": "customers_and_addresses", "question": "Which contact channel has been used by the customer with name \"Tillman Ernser\"?", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "We need to find the contact channels associated with a specific customer, so we will join these two tables on the customer_id.", "We will filter the results based on the customer's name, which is 'Tillman Ernser'.", "Using SELECT DISTINCT ensures that we get unique contact channels without duplicates."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT DISTINCT channel_code FROM Customers AS t1 JOIN Customer_Contact_Channels AS t2 ON t1.customer_id = t2.customer_id WHERE t1.customer_name = 'Tillman Ernser'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\",\n        \"virtual_table\": \"SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "Join the Customers table with the Customer_Contact_Channels table on customer_id to link customers with their contact channels.", "Filter the results to only include the customer named 'Tillman Ernser'.", "Select the 'active_to_date' from the Customer_Contact_Channels table.", "Order the results by 'active_to_date' in descending order to get the latest date.", "Limit the results to 1 to get only the latest contact channel's active to date."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT t2.active_to_date FROM Customers AS t1 JOIN Customer_Contact_Channels AS t2 ON t1.customer_id = t2.customer_id WHERE t1.customer_name = 'Tillman Ernser' ORDER BY t2.active_to_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\",\n        \"virtual_table\": \"SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["To find the average time span of contact channels, we need to calculate the duration for each contact channel.", "The duration can be calculated by subtracting the 'active_from_date' from the 'active_to_date'.", "In SQLite, we can use the 'julianday' function to convert date strings into Julian day numbers, which allows us to perform arithmetic on dates.", "We will then use the AVG function to calculate the average of these durations.", "The final SQL query selects the average duration from the 'Customer_Contact_Channels' table."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_time_span FROM Customer_Contact_Channels;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\",\n        \"virtual_table\": \"SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6103", "db_id": "customers_and_addresses", "question": "What is the channel code and contact number of the customer contact channel that was active for the longest time?", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the channel_code and contact_number.", "Determine the requirement: We need the channel code and contact number of the customer contact channel that was active for the longest time.", "To find the longest active channel, we need to calculate the duration of activity for each channel using active_from_date and active_to_date.", "Use the ORDER BY clause to sort the results based on the duration of activity in descending order.", "Limit the results to 1 to get only the channel that was active for the longest time."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT channel_code, contact_number FROM Customer_Contact_Channels ORDER BY (julianday(active_to_date) - julianday(active_from_date)) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\",\n        \"virtual_table\": \"SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6108", "db_id": "customers_and_addresses", "question": "Find the name of the customer who made the order of the largest amount of goods.", "rationale": ["Identify the relevant tables: Customers, Customer_Orders, and Order_Items are needed to find the customer who made the largest order.", "Join the Customers table with Customer_Orders on customer_id to link customers to their orders.", "Join the resulting table with Order_Items on order_id to access the quantities of items ordered.", "Group the results by customer_id to aggregate the total quantity of items ordered by each customer.", "Use SUM(oi.order_quantity) to calculate the total amount of goods ordered by each customer.", "Order the results in descending order based on the total quantity ordered to find the customer with the largest order.", "Limit the results to 1 to get only the top customer."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)", "source_tables": ["customer_orders", "customers", "order_items"], "pred_sql": "SELECT c.customer_name\nFROM Customers c\nJOIN Customer_Orders co ON c.customer_id = co.customer_id\nJOIN Order_Items oi ON co.order_id = oi.order_id\nGROUP BY c.customer_id\nORDER BY SUM(oi.order_quantity) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6123", "db_id": "customers_and_addresses", "question": "What is the total number of products that are in orders with status \"Cancelled\"?", "rationale": ["Identify the relevant tables: We need to look at the 'Customer_Orders' table for order status and the 'Order_Items' table for product details.", "We need to count the distinct products that are associated with orders that have a status of 'Cancelled'.", "Join the 'Customer_Orders' table with the 'Order_Items' table on 'order_id' to link orders with their respective products.", "Filter the results where the 'order_status' is 'Cancelled'.", "Use COUNT(DISTINCT oi.product_id) to get the total number of unique products in cancelled orders."], "gold_sql": "SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_status  =  'Cancelled'", "source_tables": ["customer_orders", "order_items"], "pred_sql": "SELECT COUNT(DISTINCT oi.product_id) AS total_products\nFROM Customer_Orders co\nJOIN Order_Items oi ON co.order_id = oi.order_id\nWHERE co.order_status = 'Cancelled';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6130", "db_id": "customers_and_addresses", "question": "What is the most frequently ordered product? Tell me the detail of the product", "rationale": ["Identify the tables involved: We need to look at the 'Order_Items' table to find out which products were ordered and the 'Products' table to get the details of those products.", "Join the 'Order_Items' table with the 'Products' table on the product_id to access product details for each order.", "Group the results by product_id to count how many times each product has been ordered.", "Order the results in descending order based on the count of orders to find the most frequently ordered product.", "Limit the results to 1 to get only the most frequently ordered product."], "gold_sql": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT t2.product_details FROM Order_Items AS t1 JOIN Products AS t2 ON t1.product_id = t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["Identify the tables involved: We need to retrieve product information, so we will use the 'Products' table. We also need to consider the 'Order_Items' table to get the order quantities.", "Join the 'Order_Items' table with the 'Products' table on the product_id to access product details along with their order quantities.", "Group the results by product_id to aggregate the order quantities for each product.", "Use SUM to calculate the total order quantity for each product.", "Order the results in descending order based on the total order quantity to find the product with the largest quantity.", "Limit the results to 1 to get only the product with the largest total order quantity."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT t2.product_id, t2.product_details FROM Order_Items AS t1 JOIN Products AS t2 ON t1.product_id = t2.product_id GROUP BY t1.product_id ORDER BY SUM(t1.order_quantity) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6132", "db_id": "customers_and_addresses", "question": "What are the name and ID of the product bought the most.", "rationale": ["Identify the tables involved: We need to look at the 'Order_Items' table to find out how many times each product was ordered and the 'Products' table to get the product details.", "Join the 'Order_Items' table with the 'Products' table on the product_id to access product details along with order information.", "Group the results by product_id to aggregate the order counts for each product.", "Order the results by the count of orders in descending order to find the most bought product.", "Limit the results to 1 to get only the top product that was bought the most."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT t2.product_id, t2.product_details FROM Order_Items AS t1 JOIN Products AS t2 ON t1.product_id = t2.product_id GROUP BY t1.product_id ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The question asks for addresses, so we will use the Addresses table.", "Determine the filtering criteria: We need to find addresses in two specific cities (East Julianaside and Gleasonmouth) and their corresponding states (Texas and Arizona).", "Construct the SQL query: We will use a SELECT statement to retrieve all columns from the Addresses table where the city and state match the specified criteria. We will use the OR operator to combine the two conditions for the different cities and states."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "\n"}
{"sample_id": "train.6155", "db_id": "music_4", "question": "What are the category of music festivals with result \"Awarded\"?", "rationale": ["Identify the relevant table: The question pertains to music festivals and their results, so we will focus on the 'music_festival' table.", "Determine the required columns: We need the 'Category' column from the 'music_festival' table.", "Specify the condition: We are interested in records where the 'Result' is 'Awarded'.", "Construct the SQL query: Using the SELECT statement to retrieve the 'Category' where the 'Result' matches 'Awarded'."], "gold_sql": "SELECT Category FROM music_festival WHERE RESULT  =  'Awarded'", "source_tables": ["music_festival"], "pred_sql": "SELECT Category FROM music_festival WHERE Result = 'Awarded'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the categories of awards or recognitions from the 'music_festival' table based on a specific result. The placeholder in the WHERE clause represents the outcome of the festival participation.\",\n        \"virtual_table\": \"SELECT Category FROM music_festival WHERE RESULT  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\",\n        \"virtual_table\": \"SELECT T1.Date_of_ceremony FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6167", "db_id": "music_4", "question": "Please show the songs that have result \"nominated\" at music festivals.", "rationale": ["Identify the relevant tables: music_festival, volume, and artist.", "We need to find songs that have the result 'nominated' in the music_festival table.", "Join the music_festival table with the volume table on the Volume column to get the song identifiers.", "Join the resulting table with the artist table on Artist_ID to get the artist details.", "Select the song identifier, famous title, and artist name where the result is 'nominated'."], "gold_sql": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  'Nominated'", "source_tables": ["music_festival", "volume"], "pred_sql": "SELECT v.Song, a.Famous_Title, a.Artist \nFROM music_festival AS mf \nJOIN volume AS v ON mf.Volume = v.Volume_ID \nJOIN artist AS a ON v.Artist_ID = a.Artist_ID \nWHERE mf.Result = 'nominated';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the categories of awards or recognitions from the 'music_festival' table based on a specific result. The placeholder in the WHERE clause represents the outcome of the festival participation.\",\n        \"virtual_table\": \"SELECT Category FROM music_festival WHERE RESULT  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\",\n        \"virtual_table\": \"SELECT T1.Date_of_ceremony FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6180", "db_id": "music_4", "question": "Return the famous release date for the oldest artist.", "rationale": ["Identify the table that contains the artist's age and release date, which is the 'artist' table.", "To find the oldest artist, we need to sort the artists by their age in ascending order.", "We will select the 'Famous_Release_date' of the artist with the minimum age.", "Using 'ORDER BY Age ASC' will allow us to get the oldest artist at the top of the result set.", "Finally, we will limit the result to 1 to get only the oldest artist's famous release date."], "gold_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1", "source_tables": ["artist"], "pred_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\",\n        \"virtual_table\": \"SELECT T1.Date_of_ceremony FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6185", "db_id": "music_4", "question": "Please show the categories of the music festivals with count more than 1.", "rationale": ["Identify the table of interest: music_festival, which contains the categories of awards or recognitions.", "We need to count the occurrences of each category in the music_festival table.", "Use GROUP BY to group the results by Category.", "Use HAVING to filter the groups to only include those with a count greater than 1."], "gold_sql": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*)  >  1", "source_tables": ["music_festival"], "pred_sql": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the categories of awards or recognitions from the 'music_festival' table based on a specific result. The placeholder in the WHERE clause represents the outcome of the festival participation.\",\n        \"virtual_table\": \"SELECT Category FROM music_festival WHERE RESULT  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\",\n        \"virtual_table\": \"SELECT T1.Date_of_ceremony FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6187", "db_id": "music_4", "question": "What is the song in the volume with the maximum weeks on top?", "rationale": ["Identify the table that contains the song information, which is the 'volume' table.", "Determine that we need to find the maximum number of weeks a song has been on top, which requires a subquery to get the maximum value from the 'Weeks_on_Top' column.", "Construct the main query to select the 'Song' from the 'volume' table where the 'Weeks_on_Top' matches the maximum value obtained from the subquery."], "gold_sql": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT Song FROM volume WHERE Weeks_on_Top = (SELECT MAX(Weeks_on_Top) FROM volume)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\",\n        \"virtual_table\": \"SELECT T1.Date_of_ceremony FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6195", "db_id": "music_4", "question": "What is the issue date of the volume with the minimum weeks on top?", "rationale": ["Identify the table that contains the issue date and weeks on top, which is the 'volume' table.", "To find the issue date of the volume with the minimum weeks on top, we need to first determine the minimum value of 'Weeks_on_Top' in the 'volume' table.", "We can use a subquery to find the minimum weeks on top: (SELECT MIN(Weeks_on_Top) FROM volume).", "Once we have the minimum weeks on top, we can select the 'Issue_Date' from the 'volume' table where 'Weeks_on_Top' matches this minimum value."], "gold_sql": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT Issue_Date FROM volume WHERE Weeks_on_Top = (SELECT MIN(Weeks_on_Top) FROM volume)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\",\n        \"virtual_table\": \"SELECT T1.Date_of_ceremony FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["Identify the relevant tables: We need to find the match ID from the 'match' table and filter it based on the competition name.", "Use the 'hosting_city' table to link matches to their hosting cities, but since we are only interested in the competition, we will focus on the 'match' table.", "We need to filter the matches by the competition name '1994 FIFA World Cup qualification'.", "To get the match ID, we will select 'Match_ID' from the 'match' table where the competition matches the specified name."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "pred_sql": "SELECT match.Match_ID FROM match JOIN hosting_city ON match.Match_ID = hosting_city.Match_ID WHERE hosting_city.Year = '1994' AND match.Competition = (SELECT Competition FROM match WHERE Competition = '1994 FIFA World Cup qualification')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n        \"virtual_table\": \"SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6274", "db_id": "city_record", "question": "Which city has hosted the most events?", "rationale": ["Identify the tables involved: We need to find cities that have hosted matches, so we will use the 'city' and 'hosting_city' tables.", "Join the tables: We will join the 'city' table with the 'hosting_city' table on the City_ID and Host_City columns to link cities with their hosted matches.", "Group by host city: We will group the results by the Host_City to count how many matches each city has hosted.", "Order by count: We will order the results in descending order based on the count of matches hosted to find the city with the most events.", "Limit the results: Finally, we will limit the results to 1 to get only the city that has hosted the most events."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN hosting_city AS T2 ON T1.City_ID = T2.Host_City GROUP BY T2.Host_City ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n        \"virtual_table\": \"SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables: 'city' for city names and 'temperature' for temperature data.", "We need to find the city with the highest temperature in February, so we will select the 'City' and 'Feb' columns.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Order the results by the February temperature in descending order to get the highest temperature at the top.", "Limit the results to 1 to get only the city with the highest temperature."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT City, Feb FROM city JOIN temperature ON city.City_ID = temperature.City_ID ORDER BY Feb DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n        \"virtual_table\": \"SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6287", "db_id": "city_record", "question": "In February, which city marks the highest temperature?", "rationale": ["Identify the relevant tables: We need data from the 'city' table for city names and the 'temperature' table for February temperatures.", "Join the 'city' table with the 'temperature' table on the City_ID to get the temperature data associated with each city.", "Select the city name and February temperature from the joined tables.", "Order the results by February temperature in descending order to get the highest temperature at the top.", "Limit the results to 1 to get only the city with the highest temperature in February."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT City, Feb FROM city JOIN temperature ON city.City_ID = temperature.City_ID ORDER BY Feb DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n        \"virtual_table\": \"SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access city names along with their temperature data.", "Use a WHERE clause to filter cities based on the condition that the temperature in March is lower than in July or higher than in October.", "Select the 'City' column from the resulting joined table."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City \nFROM city AS c \nJOIN temperature AS t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Jul OR t.Mar > t.Oct;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6289", "db_id": "city_record", "question": "Which cities' temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access city names along with their temperature data.", "Use a WHERE clause to filter cities based on the condition that the temperature in March is lower than in July or higher than in October."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City \nFROM city AS c \nJOIN temperature AS t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Jul OR t.Mar > t.Oct;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6292", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in Dec and which have never been host cities.", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables, and we also need to ensure that the cities have never hosted matches, which involves the 'hosting_city' table.", "Join the 'city' and 'temperature' tables on 'City_ID' to access temperature data for each city.", "Filter the results to include only those cities where the average temperature in March (t.Mar) is lower than in December (t.Dec).", "To find cities that have never hosted matches, use a subquery that selects all 'Host_City' from the 'hosting_city' table and exclude these from the main query using NOT IN.", "Select the city names from the filtered results."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City FROM city AS c JOIN temperature AS t ON c.City_ID = t.City_ID WHERE t.Mar < t.Dec AND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n        \"virtual_table\": \"SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables to find cities with specific temperature conditions, and the 'hosting_city' table to filter out host cities.", "Join the 'city' and 'temperature' tables on 'City_ID' to access temperature data for each city.", "Use a WHERE clause to filter cities where the average temperature in March is lower than in December.", "Use a subquery to exclude cities that have hosted matches by checking against the 'hosting_city' table, specifically the 'Host_City' column."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City FROM city AS c JOIN temperature AS t ON c.City_ID = t.City_ID WHERE t.Mar < t.Dec AND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n        \"virtual_table\": \"SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6298", "db_id": "city_record", "question": "Please give me a list of cities whose regional population is over 8000000 or under 5000000.", "rationale": ["Identify the relevant table: The 'city' table contains the 'Regional_Population' column.", "Determine the conditions for filtering: We need cities with a population greater than 8,000,000 or less than 5,000,000.", "Construct the SQL query: Use a SELECT statement to retrieve the 'City' names from the 'city' table where the population meets the specified conditions."], "gold_sql": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000", "source_tables": ["city"], "pred_sql": "SELECT City FROM city WHERE Regional_Population > 8000000 OR Regional_Population < 5000000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6313", "db_id": "e_government", "question": "What is the name of the party form that is most common?", "rationale": ["Identify the relevant tables: Party_Forms and Forms are needed to get the form names.", "Join the Party_Forms table with the Forms table on the form_id to access the form names.", "Group the results by form_name to count how many times each form appears in Party_Forms.", "Use COUNT(*) to count the occurrences of each form name.", "Order the results in descending order based on the count to find the most common form.", "Limit the results to 1 to get only the most common party form."], "gold_sql": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["forms", "party_forms"], "pred_sql": "SELECT form_name, COUNT(*) as form_count \nFROM Party_Forms \nJOIN Forms ON Party_Forms.form_id = Forms.form_id \nGROUP BY form_name \nORDER BY form_count DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6329", "db_id": "e_government", "question": "What are the names of the services that have never been used?", "rationale": ["Identify the relevant table: The question asks about services, so we will focus on the Services table.", "Determine the condition: We need to find services that have never been used, which means we need to check for services that do not have any entries in the Party_Services table.", "Construct the subquery: We will create a subquery that selects all service_ids from the Party_Services table, as these represent services that have been used.", "Use the NOT IN clause: In the main query, we will select service names from the Services table where the service_id is not in the list of used service_ids from the subquery."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "pred_sql": "SELECT service_name FROM Services WHERE service_id NOT IN (SELECT service_id FROM Party_Services);", "hint": "\n"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table: The question asks for cities and states, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' for cities and 'state_province_county' for states.", "Use DISTINCT to avoid duplicate entries: Since we want unique city and state combinations, we will use the DISTINCT keyword.", "Construct the SQL query: Combine the selected columns and table into a valid SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6342", "db_id": "e_government", "question": "Which state can address \"6862 Kaitlyn Knolls\" possibly be in?", "rationale": ["Identify the relevant table: The question pertains to addresses, so we will use the 'Addresses' table.", "Determine the specific column needed: We need to find the 'state_province_county' for the address '6862 Kaitlyn Knolls'.", "Construct the SQL query: We will select distinct states from the Addresses table where the line_1_number_building matches '6862 Kaitlyn Knolls'."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT state_province_county FROM Addresses WHERE line_1_number_building = '6862 Kaitlyn Knolls';", "hint": "\n"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the tables involved: Organizations, Organization_Contact_Individuals, and Individuals.", "Determine the relationship between these tables: Organizations are linked to Organization_Contact_Individuals through organization_id, and Organization_Contact_Individuals are linked to Individuals through individual_id.", "Select the last name of individuals from the Individuals table (individual_last_name).", "Join the Organizations table with Organization_Contact_Individuals and then with Individuals to get the required data.", "The query should return the last names of individuals who have contacted organizations."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "pred_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id = t2.organization_id JOIN individuals AS t3 ON t2.individual_id = t3.individual_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of individuals who have contacted a specific organization. The organization is identified by its name, and the results are ordered by the end date of the contact period, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the organization name and the number of results to display.\",\n        \"virtual_table\": \"SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY t2.date_contact_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6371", "db_id": "flight_company", "question": "What are the names and types of the companies that have ever operated a flight?", "rationale": ["Identify the relevant tables: We need information from the 'operate_company' table for company names and types, and the 'flight' table to find which companies have operated flights.", "Determine the relationship: The 'flight' table has a foreign key 'company_id' that links to the 'id' in the 'operate_company' table. This means we can join these two tables on this key.", "Select the required columns: We need to select the 'name' and 'Type' columns from the 'operate_company' table.", "Use DISTINCT: Since we want to avoid duplicate entries for companies that may have operated multiple flights, we will use DISTINCT in our SELECT statement."], "gold_sql": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id", "source_tables": ["flight", "operate_company"], "pred_sql": "SELECT DISTINCT operate_company.name, operate_company.Type \nFROM operate_company \nJOIN flight ON operate_company.id = flight.company_id;", "hint": "\n"}
{"sample_id": "train.6375", "db_id": "flight_company", "question": "What is the id, name and IATA code of the airport that had most number of flights?", "rationale": ["Identify the relevant tables: 'airport' and 'flight'.", "We need to find the airport with the most flights, so we will join the 'airport' table with the 'flight' table using the foreign key relationship (airport.id = flight.airport_id).", "Select the required columns: 'id', 'name', and 'IATA' from the 'airport' table.", "Group the results by the airport's id, name, and IATA code to aggregate the flight counts.", "Count the number of flights for each airport using COUNT(flight.id).", "Order the results in descending order based on the count of flights to get the airport with the most flights at the top.", "Limit the results to 1 to get only the airport with the highest number of flights."], "gold_sql": "SELECT T1.id ,  T1.name ,  T1.IATA FROM airport AS T1 JOIN flight AS T2 ON T1.id  =  T2.airport_id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airport", "flight"], "pred_sql": "SELECT airport.id, airport.name, airport.IATA\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nGROUP BY airport.id, airport.name, airport.IATA\nORDER BY COUNT(flight.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6381", "db_id": "flight_company", "question": "How many companies operates airlines in each airport?", "rationale": ["Identify the relevant tables: airport, operate_company, and flight.", "We need to count the number of airline companies operating at each airport.", "Join the airport table with the flight table on airport.id and flight.airport_id.", "Join the resulting table with the operate_company table on flight.company_id and operate_company.id.", "Filter the results to include only those companies that are of type 'airline'.", "Group the results by airport name to get the count of airline companies for each airport."], "gold_sql": "SELECT T3.id ,  count(*) FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id JOIN airport AS T3 ON T2.airport_id  =  T3.id GROUP BY T3.id", "source_tables": ["airport", "flight", "operate_company"], "pred_sql": "SELECT airport.name AS Airport_Name, COUNT(operate_company.id) AS Number_of_Airline_Companies\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nJOIN operate_company ON flight.company_id = operate_company.id\nWHERE operate_company.Type = 'airline'\nGROUP BY airport.name;", "hint": "\n"}
{"sample_id": "train.6517", "db_id": "wine_1", "question": "What is the name of the highest rated wine?", "rationale": ["Identify the table that contains the wine names and their scores, which is the 'wine' table.", "To find the highest rated wine, we need to sort the wines by their score in descending order.", "We will use the ORDER BY clause to sort the results by the 'Score' column.", "To get only the highest rated wine, we will limit the results to 1 using the LIMIT clause."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n        \"virtual_table\": \"SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n        \"virtual_table\": \"SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6518", "db_id": "wine_1", "question": "Give the name of the wine with the highest score.", "rationale": ["Identify the table that contains the wine names and their scores, which is the 'wine' table.", "To find the wine with the highest score, we need to sort the results by the 'Score' column in descending order.", "Using 'ORDER BY Score DESC' will arrange the wines from highest to lowest score.", "To get only the top result (the wine with the highest score), we use 'LIMIT 1' to restrict the output to a single entry.", "The final SQL query selects the 'Name' of the wine from the 'wine' table, orders it by score in descending order, and limits the result to one."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n        \"virtual_table\": \"SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n        \"virtual_table\": \"SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6520", "db_id": "wine_1", "question": "What is the winery at which the wine with the highest score was made?", "rationale": ["Identify the table that contains the winery information, which is the 'wine' table.", "To find the winery of the wine with the highest score, we need to select the 'Winery' column from the 'wine' table.", "We need to determine the highest score, which can be done using a subquery that selects the maximum score from the 'wine' table.", "The final query will select the winery where the score matches the maximum score found in the subquery."], "gold_sql": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Winery FROM wine WHERE Score = (SELECT MAX(Score) FROM wine)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n        \"virtual_table\": \"SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n        \"virtual_table\": \"SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6533", "db_id": "wine_1", "question": "List the names of all distinct wines that are made of red color grape.", "rationale": ["Identify the tables involved: 'grapes' and 'wine'.", "Determine the relationship between the tables: 'grapes.Grape' is linked to 'wine.Grape'.", "Focus on the requirement: list distinct names of wines made from red color grapes.", "Use the provided virtual table structure to form the SQL query.", "Replace the placeholder in the virtual table with 'red' to filter for red grapes."], "gold_sql": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape = T2.Grape WHERE T1.Color = 'red'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n        \"virtual_table\": \"SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6544", "db_id": "wine_1", "question": "Give the names and scores of wines made from white grapes.", "rationale": ["Identify the tables involved: 'grapes' and 'wine'.", "Determine the columns needed: 'Name' and 'Score' from the 'wine' table.", "Establish the relationship between the tables: join 'grapes' and 'wine' on the 'Grape' column.", "Filter the results to include only white grapes by adding a WHERE clause that specifies T1.Color = 'white'.", "Construct the SQL query using the identified elements."], "gold_sql": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT T2.Name, T2.Score FROM grapes AS T1 JOIN wine AS T2 ON T1.Grape = T2.Grape WHERE T1.Color = 'white'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n        \"virtual_table\": \"SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6547", "db_id": "wine_1", "question": "Find the the grape whose white color grapes are used to produce wines with scores higher than 90.", "rationale": ["Identify the relevant tables: 'grapes' for grape varieties and 'wine' for wine details.", "We need to find grapes that are white in color, so we will filter the 'grapes' table by the 'Color' column.", "We also need to filter wines that have a score greater than 90, which requires joining the 'grapes' and 'wine' tables on the 'Grape' column.", "The final output should be distinct grape names that meet both conditions: being white and associated with wines scored above 90."], "gold_sql": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White' AND T2.score  >  90", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape = T2.Grape WHERE T1.Color = 'white' AND T2.Score > 90;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n        \"virtual_table\": \"SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6550", "db_id": "wine_1", "question": "What are the names of wines made from red grapes and with prices above 50?", "rationale": ["Identify the relevant tables: 'grapes' for grape varieties and 'wine' for wine details.", "Determine the necessary columns: we need the 'Name' of the wine from the 'wine' table.", "Establish the join condition: we join 'grapes' and 'wine' on the 'Grape' column since it is common to both tables.", "Set the filtering criteria: we want wines made from 'red' grapes and with a price greater than 50.", "Construct the SQL query using the identified elements and conditions."], "gold_sql": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red' AND T2.price  >  50", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT T2.Name FROM grapes AS T1 JOIN wine AS T2 ON T1.Grape = T2.Grape WHERE T1.Color = 'red' AND T2.Price > 50", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n        \"virtual_table\": \"SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n        \"virtual_table\": \"SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6558", "db_id": "wine_1", "question": "What are the distinct names of wines with prices higher than any wine from John Anthony winery.", "rationale": ["Identify the requirement: We need distinct names of wines with prices higher than any wine from John Anthony winery.", "To find wines with prices higher than those from John Anthony, we need to use a subquery to get the maximum price of wines from that winery.", "The subquery will select the maximum price from the 'wine' table where the winery is 'John Anthony'.", "The main query will select distinct names from the 'wine' table where the price is greater than the result of the subquery."], "gold_sql": "SELECT DISTINCT Name FROM WINE WHERE Price  >  (SELECT min(Price) FROM wine WHERE Winery  =  'John Anthony')", "source_tables": ["wine"], "pred_sql": "SELECT DISTINCT T2.Name FROM wine AS T2 WHERE T2.Price > (SELECT MAX(T3.Price) FROM wine AS T3 WHERE T3.Winery = 'John Anthony')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n        \"virtual_table\": \"SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n        \"virtual_table\": \"SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6566", "db_id": "wine_1", "question": "Give the color of the grape whose wine products have the highest average price?", "rationale": ["Identify the tables involved: 'grapes' for grape color and 'wine' for wine prices.", "Join the 'grapes' table with the 'wine' table on the grape variety.", "Group the results by grape color to calculate the average price of wines for each color.", "Use AVG function to compute the average price of wines for each grape color.", "Order the results in descending order based on the average price to find the highest.", "Limit the results to 1 to get only the color of the grape with the highest average price."], "gold_sql": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT 1", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT g.Color\nFROM grapes g\nJOIN wine w ON g.Grape = w.Grape\nGROUP BY g.Color\nORDER BY AVG(CAST(w.Price AS REAL)) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n        \"virtual_table\": \"SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6588", "db_id": "wine_1", "question": "Which 3 wineries produce the most wines made from white grapes?", "rationale": ["Identify the relevant tables: 'wine' and 'grapes'.", "We need to filter wines made from white grapes, so we will join the 'wine' table with the 'grapes' table on the grape variety.", "Use a WHERE clause to filter for grapes where Color = 'white'.", "To find out which wineries produce the most wines, we will group the results by Winery and count the number of wines for each winery.", "Order the results in descending order based on the count of wines produced.", "Limit the results to the top 3 wineries."], "gold_sql": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  'White' GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT Winery, COUNT(*) AS WineCount FROM wine JOIN grapes ON wine.Grape = grapes.Grape WHERE grapes.Color = 'white' GROUP BY Winery ORDER BY WineCount DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n        \"virtual_table\": \"SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n        \"virtual_table\": \"SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6597", "db_id": "wine_1", "question": "Find the county where produces the most number of wines with score higher than 90.", "rationale": ["We need to find the county that produces the most wines with a score higher than 90.", "To do this, we will join the 'appellations' table with the 'wine' table on the 'Appelation' column.", "We will filter the results to include only those wines where the 'Score' is greater than 90.", "Next, we will group the results by 'County' to count the number of wines produced in each county.", "Finally, we will order the results in descending order based on the count of wines and limit the output to 1 to get the county with the highest count."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1", "source_tables": ["wine", "appellations"], "pred_sql": "SELECT a.County, COUNT(w.No) AS WineCount\nFROM appellations AS a\nJOIN wine AS w ON a.Appelation = w.Appelation\nWHERE w.Score > 90\nGROUP BY a.County\nORDER BY WineCount DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n        \"virtual_table\": \"SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n        \"virtual_table\": \"SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6626", "db_id": "driving_school", "question": "Show the detail of vehicle with id 1.", "rationale": ["Identify the table that contains vehicle details, which is the Vehicles table.", "Determine the specific vehicle we want to retrieve details for, which is identified by vehicle_id '1'.", "Construct a SQL SELECT statement to retrieve all columns from the Vehicles table where the vehicle_id matches '1'."], "gold_sql": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;", "source_tables": ["vehicles"], "pred_sql": "SELECT * FROM Vehicles WHERE vehicle_id = '1';", "hint": "\n"}
{"sample_id": "train.6650", "db_id": "driving_school", "question": "How many staff live in state Georgia?", "rationale": ["Identify the relevant tables: Staff and Addresses.", "Determine the relationship between the tables: Staff has a foreign key (staff_address_id) that links to Addresses (address_id).", "We need to count the number of staff members, so we will use the COUNT() function.", "Filter the results to only include staff members who live in Georgia by using a WHERE clause on the state_province_county column in the Addresses table."], "gold_sql": "SELECT count(*) FROM Addresses WHERE state_province_county = 'Georgia';", "source_tables": ["addresses"], "pred_sql": "SELECT COUNT(*) AS staff_count \nFROM Staff \nJOIN Addresses ON Staff.staff_address_id = Addresses.address_id \nWHERE Addresses.state_province_county = 'Georgia';", "hint": "\n"}
{"sample_id": "train.6665", "db_id": "driving_school", "question": "What is the status code, phone number, and email address of the customer whose last name is Kohler or whose first name is Marina?", "rationale": ["Identify the relevant table: The question pertains to customer information, so we will use the Customers table.", "Determine the required columns: The question asks for the status code, phone number, and email address of the customer.", "Construct the SELECT statement: We will select customer_status_code, phone_number, and email_address from the Customers table.", "Add the WHERE clause: We need to filter the results to include customers whose last name is 'Kohler' or whose first name is 'Marina'.", "Combine all parts to form the complete SQL query."], "gold_sql": "SELECT customer_status_code ,  cell_mobile_phone_number ,  email_address FROM Customers WHERE first_name = 'Marina' OR last_name  =  'Kohler'", "source_tables": ["customers"], "pred_sql": "SELECT customer_status_code, phone_number, email_address \nFROM Customers \nWHERE last_name = 'Kohler' OR first_name = 'Marina';", "hint": "\n"}
{"sample_id": "train.6676", "db_id": "driving_school", "question": "How many lessons taken by customer with first name as Rylan and last name as Goodwin were completed?", "rationale": ["Identify the relevant tables: Lessons and Customers.", "We need to count the number of lessons, so we will use the COUNT() function.", "We need to filter lessons based on the customer's first name and last name, which are in the Customers table.", "Join the Lessons table with the Customers table on the customer_id field to access customer details for filtering.", "Add a WHERE clause to filter for the specific customer (first name 'Rylan' and last name 'Goodwin').", "Also, filter for completed lessons by checking the lesson_status_code in the Lessons table.", "Construct the final SQL query using these elements."], "gold_sql": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = 'Rylan' AND T2.last_name = 'Goodwin' AND T1.lesson_status_code = 'Completed';", "source_tables": ["lessons", "customers"], "pred_sql": "SELECT COUNT(*) AS completed_lessons_count\nFROM Lessons\nJOIN Customers ON Lessons.customer_id = Customers.customer_id\nWHERE Customers.first_name = 'Rylan' AND Customers.last_name = 'Goodwin' AND Lessons.lesson_status_code = 'completed';", "hint": "\n"}
{"sample_id": "train.6688", "db_id": "driving_school", "question": "Which city does has most number of customers?", "rationale": ["Identify the tables involved: Customers and Addresses.", "Determine the relationship between the tables: Customers have a foreign key linking to Addresses via customer_address_id.", "Join the Customers table with the Addresses table on the customer_address_id and address_id columns.", "Group the results by city to count the number of customers in each city.", "Order the results in descending order based on the count of customers to find the city with the most customers.", "Limit the results to 1 to get only the city with the highest number of customers."], "gold_sql": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "customers"], "pred_sql": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities where customers are located, derived from the 'Customers' and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.6711", "db_id": "driving_school", "question": "What are the last names that are used by customers and staff?", "rationale": ["Identify the tables that contain last names: Customers and Staff.", "Use the SELECT statement to retrieve last names from both tables.", "Use DISTINCT to ensure unique last names are returned.", "Combine the results from both tables using UNION to get a single list of last names."], "gold_sql": "SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff", "source_tables": ["staff", "customers"], "pred_sql": "SELECT DISTINCT last_name FROM Customers UNION SELECT DISTINCT last_name FROM Staff;", "hint": "\n"}
{"sample_id": "train.6714", "db_id": "driving_school", "question": "What is the id and detail of the vehicle used in lessons for most of the times?", "rationale": ["Identify the relevant tables: We need to look at the 'Lessons' table to find out which vehicles are used in lessons.", "We need to group the results by 'vehicle_id' to count how many times each vehicle is used in lessons.", "Use the COUNT function to count the number of lessons for each vehicle.", "Order the results in descending order based on the count of lessons to find the vehicle used most frequently.", "Limit the results to 1 to get only the vehicle used in lessons the most times."], "gold_sql": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["lessons", "vehicles"], "pred_sql": "SELECT vehicle_id, vehicle_details\nFROM Lessons\nGROUP BY vehicle_id\nORDER BY COUNT(lesson_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the table that contains faculty information, which is the 'Faculty' table.", "Determine the relevant column for faculty identifiers, which is 'FacID'.", "Identify the column that indicates gender, which is 'Sex'.", "Formulate a SQL query to select 'FacID' from the 'Faculty' table where 'Sex' is equal to 'Male'."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "pred_sql": "SELECT FacID FROM Faculty WHERE Sex = 'Male'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The results are ordered by the number of faculty members in each building in descending order, and the placeholder allows the user to specify the maximum number of buildings to return.\",\n        \"virtual_table\": \"SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6734", "db_id": "activity_1", "question": "What are the first name and last name of all the instructors?", "rationale": ["Identify the table that contains the first and last names of instructors, which is the 'Faculty' table.", "Construct a SQL SELECT statement to retrieve the 'Fname' and 'Lname' columns from the 'Faculty' table.", "Since there are no specific conditions or filters mentioned in the query, we will select all records from the 'Faculty' table."], "gold_sql": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  'Instructor'", "source_tables": ["faculty"], "pred_sql": "SELECT Fname, Lname FROM Faculty;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct last names of faculty members who participate in specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities of interest.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6737", "db_id": "activity_1", "question": "Which building has most faculty members?", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their building.", "Count the number of faculty members in each building: Use COUNT(*) to count faculty members grouped by the building column.", "Group the results by building: Use GROUP BY Building to aggregate the counts for each building.", "Order the results by the count of faculty members in descending order: Use ORDER BY COUNT(*) DESC to get the buildings with the most faculty members at the top.", "Limit the results to only the top building: Use LIMIT 1 to return only the building with the most faculty members."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(*) as FacultyCount FROM Faculty GROUP BY Building ORDER BY FacultyCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The results are ordered by the number of faculty members in each building in descending order, and the placeholder allows the user to specify the maximum number of buildings to return.\",\n        \"virtual_table\": \"SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\",\n        \"virtual_table\": \"SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\",\n        \"virtual_table\": \"SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID\"\n    }\n}\n"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their rank and gender.", "Filter for assistant professors: We need to focus on faculty members with the rank of 'Assistant Professor'.", "Group by gender: We want to count the number of assistant professors by their gender (Sex).", "Construct the SQL query: Use SELECT to get the gender and count, apply WHERE to filter by rank, and GROUP BY to aggregate the results by gender."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) AS NumberOfProfessors \nFROM Faculty \nWHERE Rank = 'Assistant Professor' \nGROUP BY Sex;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n        \"virtual_table\": \"SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n        \"virtual_table\": \"SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID\"\n    }\n}\n"}
{"sample_id": "train.6748", "db_id": "activity_1", "question": "How many male and female assistant professors do we have?", "rationale": ["Identify the relevant table: We need to focus on the Faculty table since we are interested in faculty members and their ranks.", "Filter for the specific rank: We are looking for assistant professors, so we will add a WHERE clause to filter the results by Rank = 'Assistant Professor'.", "Group by gender: To get the count of male and female assistant professors, we will group the results by the Sex column.", "Count the number of faculty members: We will use COUNT(*) to count the number of faculty members in each gender group."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) as Count FROM Faculty WHERE Rank = 'Assistant Professor' GROUP BY Sex;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n        \"virtual_table\": \"SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n        \"virtual_table\": \"SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the tables needed: We need to find the advisor of a specific student, so we will use the 'Faculty' and 'Student' tables.", "Determine the relationship: The 'Student' table has a column 'Advisor' that links to the 'FacID' in the 'Faculty' table, indicating which faculty member is the advisor for each student.", "Filter for the specific student: We need to filter the 'Student' table for the student named Linda Smith, which requires checking both the first name and last name columns.", "Select the required fields: We need to select the first name and last name of the faculty member who is the advisor for Linda Smith.", "Construct the SQL query: Combine all these elements into a SQL query that joins the 'Faculty' and 'Student' tables, applies the necessary filters, and selects the desired fields."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT F.Fname, F.Lname \nFROM Faculty F \nJOIN Student S ON F.FacID = S.Advisor \nWHERE S.Fname = 'Linda' AND S.LName = 'Smith';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n        \"virtual_table\": \"SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID\"\n    }\n}\n"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["The query needs to find students whose advisors are faculty members.", "To do this, we will join the Faculty table with the Student table on the advisor relationship.", "The Faculty table has the unique identifier for faculty members (FacID) and the Student table has the advisor field that references this ID.", "We will select the student IDs (StuID) from the Student table where there is a matching advisor in the Faculty table."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID = T2.Advisor", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n        \"virtual_table\": \"SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n        \"virtual_table\": \"SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6752", "db_id": "activity_1", "question": "Which students have professors as their advisors? Find their student ids.", "rationale": ["Identify the relevant tables: Faculty and Student.", "Determine the relationship: Faculty members are advisors to students, indicated by the 'Advisor' field in the Student table.", "Join the Faculty table with the Student table on the condition that the Faculty's FacID matches the Student's Advisor.", "Select the student IDs (StuID) from the resulting joined table."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID = T2.Advisor;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n        \"virtual_table\": \"SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n        \"virtual_table\": \"SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The results are ordered by the number of faculty members in each building in descending order, and the placeholder allows the user to specify the maximum number of buildings to return.\",\n        \"virtual_table\": \"SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the relevant tables: We need to retrieve student information, specifically their first and last names, and we need to filter based on their advisor.", "The Student table contains the first name (Fname) and last name (LName) of students, and it also has a column for Advisor which links to the Faculty table.", "To find students advised by Michael Goodrich, we first need to find the Faculty ID (FacID) of Michael Goodrich from the Faculty table.", "We can use a subquery to select the FacID of Michael Goodrich from the Faculty table where Fname is 'Michael' and LName is 'Goodrich'.", "Finally, we will use this FacID in the WHERE clause of our main query to filter students who have this advisor."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Fname, LName FROM Student WHERE Advisor = (SELECT StuID FROM Faculty WHERE Fname = 'Michael' AND LName = 'Goodrich')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct last names of faculty members who participate in specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities of interest.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6756", "db_id": "activity_1", "question": "What are the faculty id and the number of students each faculty has?", "rationale": ["Identify the tables involved: Faculty and Student.", "Determine the relationship: Faculty members are advisors to students, which is represented by the 'Advisor' field in the Student table.", "We need to count the number of students for each faculty member, so we will use a COUNT function.", "Join the Faculty table with the Student table on the condition that the Faculty's FacID matches the Student's Advisor.", "Group the results by FacID to get the count of students for each faculty member."], "gold_sql": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID", "source_tables": ["faculty", "student"], "pred_sql": "SELECT T1.FacID, count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID = T2.Advisor GROUP BY T1.FacID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n        \"virtual_table\": \"SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n        \"virtual_table\": \"SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\",\n        \"virtual_table\": \"SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID\"\n    }\n}\n"}
{"sample_id": "train.6758", "db_id": "activity_1", "question": "How many students are advised by each rank of faculty? List the rank and the number of students.", "rationale": ["Identify the tables involved: Faculty and Student.", "Determine the relationship: Faculty members advise students, indicated by the advisor field in the Student table.", "Join the Faculty table with the Student table on the advisor relationship (Faculty.FacID = Student.advisor).", "Select the rank of faculty members and count the number of students for each rank.", "Group the results by faculty rank to get the count of students advised by each rank."], "gold_sql": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank", "source_tables": ["faculty", "student"], "pred_sql": "SELECT T1.rank, COUNT(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID = T2.advisor GROUP BY T1.rank", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n        \"virtual_table\": \"SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n        \"virtual_table\": \"SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6761", "db_id": "activity_1", "question": "Show the ids for all the faculty members who have at least 2 students.", "rationale": ["We need to find faculty members who have at least 2 students assigned to them as advisors.", "To do this, we will join the Faculty table with the Student table on the advisor relationship (Faculty.FacID = Student.Advisor).", "Next, we will group the results by the faculty member's ID (T1.FacID) to count the number of students for each faculty member.", "Finally, we will use the HAVING clause to filter the groups to only include those with a count of students greater than or equal to 2."], "gold_sql": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  2", "source_tables": ["faculty", "student"], "pred_sql": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID = T2.Advisor GROUP BY T1.FacID HAVING COUNT(T2.StuID) >= 2", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n        \"virtual_table\": \"SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n        \"virtual_table\": \"SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6777", "db_id": "activity_1", "question": "Show the names of all the activities Mark Giuliano participates in.", "rationale": ["Identify the tables involved: Activity, Participates_in, and Student.", "We need to find activities that a specific student (Mark Giuliano) participates in.", "Join the Activity table with the Participates_in table on actid to link activities with student participation.", "Join the resulting table with the Student table on stuid to filter by the specific student.", "Use a WHERE clause to specify the first name as 'Mark' and last name as 'Giuliano'.", "Select the activity_name from the final joined table."], "gold_sql": "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  'Mark' AND T1.lname  =  'Giuliano'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT A.activity_name \nFROM Activity AS A \nJOIN Participates_in AS P ON A.actid = P.actid \nJOIN Student AS S ON P.stuid = S.StuID \nWHERE S.Fname = 'Mark' AND S.LName = 'Giuliano';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\",\n        \"virtual_table\": \"SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\",\n        \"virtual_table\": \"SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID\"\n    }\n}\n"}
{"sample_id": "train.6779", "db_id": "activity_1", "question": "Show the first and last name of all the faculty members who participated in some activity, together with the number of activities they participated in.", "rationale": ["Identify the tables needed: Faculty and Faculty_Participates_in.", "We need to select the first name (Fname) and last name (Lname) of faculty members from the Faculty table.", "We also need to count the number of activities each faculty member participated in, which is represented by the actid in the Faculty_Participates_in table.", "Join the Faculty table with the Faculty_Participates_in table on the FacID to link faculty members with their activities.", "Group the results by FacID to aggregate the count of activities for each faculty member."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname, F.Lname, COUNT(FP.actid) AS num_activities\nFROM Faculty AS F\nJOIN Faculty_Participates_in AS FP ON F.FacID = FP.FacID\nGROUP BY F.FacID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\",\n        \"virtual_table\": \"SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\",\n        \"virtual_table\": \"SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID\"\n    }\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: We need to find students who participate in activities, so we will use the 'Participates_in' table to get student IDs and the 'Student' table to filter by age.", "Join the 'Participates_in' table with the 'Student' table on the student ID to access student details along with their participation in activities.", "Apply a filter to select only those students whose age is less than 20.", "Select the student IDs from the resulting dataset."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT P.stuid FROM Participates_in AS P JOIN Student AS S ON P.stuid = S.StuID WHERE S.Age < 20;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\",\n        \"virtual_table\": \"SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\",\n        \"virtual_table\": \"SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID\"\n    }\n}\n"}
{"sample_id": "train.6797", "db_id": "activity_1", "question": "Find the first names of professors who are not playing Canoeing or Kayaking.", "rationale": ["Identify the main goal: Find first names of professors not participating in Canoeing or Kayaking.", "To achieve this, we need to select first names from the Faculty table.", "We will use a subquery to find faculty members who are participating in Canoeing or Kayaking.", "The subquery will join Faculty, Faculty_Participates_in, and Activity tables to filter based on activity names.", "The main query will select first names from Faculty where their FacID is not in the list returned by the subquery."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty AS F \nWHERE F.FacID NOT IN (\n    SELECT T2.FacID \n    FROM Faculty AS T1 \n    JOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID \n    JOIN Activity AS T3 ON T2.actid = T3.actid \n    WHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the distinct last names of faculty members who participate in specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities of interest.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the main table to query from, which is the Faculty table to get the first names of professors.", "We need to exclude professors who participate in Canoeing or Kayaking activities.", "To do this, we will create a subquery that selects the FacID of faculty members who participate in either Canoeing or Kayaking.", "The subquery joins the Faculty table with Faculty_Participates_in and Activity tables to filter based on activity names.", "The main query selects the first names of faculty members whose FacID is not in the result of the subquery."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty AS F \nWHERE F.FacID NOT IN (\n    SELECT T2.FacID \n    FROM Faculty AS T1 \n    JOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID \n    JOIN Activity AS T3 ON T2.actid = T3.actid \n    WHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct last names of faculty members who participate in specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities of interest.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6799", "db_id": "activity_1", "question": "Find the first names of the faculty members who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables involved: Faculty, Faculty_Participates_in, and Activity.", "We need to find the first names of faculty members, so we will select the 'Fname' column from the Faculty table.", "To find faculty members participating in specific activities, we will join the Faculty table with the Faculty_Participates_in table on the FacID column.", "Next, we will join the result with the Activity table on the actid column to access activity names.", "We will filter the results based on the activity names 'Canoeing' and 'Kayaking' using a WHERE clause with an OR condition."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT DISTINCT T1.Fname FROM Faculty AS T1 JOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID JOIN Activity AS T3 ON T2.actid = T3.actid WHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct last names of faculty members who participate in specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities of interest.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables involved: We need to find student IDs from the Participates_in table and match them with activities in the Activity table.", "Determine the relationship: The Participates_in table has a foreign key actid that links to the Activity table's actid.", "Filter the activities: We are specifically looking for students who participate in 'Canoeing' and 'Kayaking'.", "Construct the SQL query: Use a SELECT statement to retrieve student IDs, join the Participates_in table with the Activity table on actid, and filter the results based on the activity names."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT p.stuid \nFROM Participates_in p \nJOIN Activity a ON p.actid = a.actid \nWHERE a.activity_name IN ('Canoeing', 'Kayaking');", "hint": "\n"}
{"sample_id": "train.6825", "db_id": "flight_4", "question": "Find the number of routes operated by American Airlines.", "rationale": ["Identify the relevant tables: We need to use the 'routes' table to count the number of routes and the 'airlines' table to filter by airline name.", "Join the 'routes' table with the 'airlines' table on the airline ID (alid) to access the airline names associated with each route.", "Use a WHERE clause to filter the results specifically for 'American Airlines'.", "Count the total number of routes that match this condition using COUNT(*) function."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT COUNT(*) FROM routes AS T1 JOIN airlines AS T2 ON T1.alid = T2.alid WHERE T2.name = 'American Airlines'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    }\n}\n"}
{"sample_id": "train.6826", "db_id": "flight_4", "question": "How many routes does American Airlines operate?", "rationale": ["Identify the relevant table: The 'routes' table contains information about the routes operated by airlines.", "Determine the specific airline: The question asks about 'American Airlines'.", "Count the number of routes: Use the COUNT() function to count the number of entries in the 'routes' table for American Airlines.", "Construct the SQL query: Use a SELECT statement with COUNT() and a WHERE clause to filter for American Airlines."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT COUNT(*) AS route_count FROM routes WHERE airline = 'American Airlines';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n        \"virtual_table\": \"SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6831", "db_id": "flight_4", "question": "Find the name, city, and country of the airport that has the highest latitude.", "rationale": ["Identify the relevant table: The 'airports' table contains the information about airports including their names, cities, and countries.", "Determine the criteria for selection: We need to find the airport with the highest latitude, which is represented by the 'y' coordinate in the airports table.", "Construct the SQL query: We will select the name, city, and country from the airports table, ordering the results by the 'y' coordinate in descending order to get the highest latitude first.", "Limit the results to 1 to get only the airport with the highest latitude."], "gold_sql": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT 1", "source_tables": ["airports"], "pred_sql": "SELECT name, city, country FROM airports ORDER BY y DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    }\n}\n"}
{"sample_id": "train.6834", "db_id": "flight_4", "question": "What is the name and city of the airport that the most routes end at?", "rationale": ["Identify the destination airport from the routes table by joining it with the airports table on the destination airport ID (dst_apid).", "Select the name and city of the airport from the airports table.", "Group the results by the airport ID to count the number of routes that end at each airport.", "Order the results in descending order based on the count of routes to find the airport with the most routes ending at it.", "Limit the results to 1 to get only the airport with the highest count."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT T1.name, T1.city FROM airports AS T1 JOIN routes AS T2 ON T1.apid = T2.dst_apid GROUP BY T1.apid ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n        \"virtual_table\": \"SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    }\n}\n"}
{"sample_id": "train.6838", "db_id": "flight_4", "question": "What is the name and city of the airport from most of the routes start?", "rationale": ["We need to find the airport that most routes start from, which means we need to count the number of routes originating from each airport.", "To do this, we will join the 'airports' table with the 'routes' table on the source airport ID (src_apid).", "We will select the name and city of the airport from the 'airports' table.", "We will group the results by the airport name to get the count of routes for each airport.", "Finally, we will order the results by the count of routes in descending order and limit the result to 1 to get the airport with the most routes starting from it."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT T1.name, T1.city FROM airports AS T1 JOIN routes AS T2 ON T1.apid = T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n        \"virtual_table\": \"SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6841", "db_id": "flight_4", "question": "Which countries has the most number of airlines?", "rationale": ["The question asks for the countries with the most number of airlines.", "To find this, we need to count the number of airlines grouped by their country of origin.", "The relevant table for this information is the 'airlines' table, which contains a 'country' column and an 'alid' column that uniquely identifies each airline.", "We can use the SQL COUNT function to count the number of airlines for each country.", "We will group the results by the 'country' column to get the count for each country.", "Finally, we will order the results in descending order based on the count to show the countries with the most airlines at the top."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country, count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\",\n        \"virtual_table\": \"SELECT country ,  count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n        \"virtual_table\": \"SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6842", "db_id": "flight_4", "question": "What is the name of the country with the most number of home airlines?", "rationale": ["The question asks for the country with the most number of home airlines.", "To find this, we need to count the number of airlines grouped by their country.", "We can use the virtual table provided in the hint that summarizes the number of airlines by country: 'SELECT country, count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC'.", "To get only the country with the highest count, we will add a LIMIT clause to return just one result."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\",\n        \"virtual_table\": \"SELECT country ,  count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n        \"virtual_table\": \"SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6858", "db_id": "flight_4", "question": "What are the cities that have more than 2 airports sorted by number of airports?", "rationale": ["The question asks for cities with more than 2 airports, which means we need to count the number of airports in each city.", "We will use the `airports` table to get the city and count the number of airports per city.", "We will group the results by city to get the count of airports in each city.", "To filter the cities that have more than 2 airports, we will use the HAVING clause with COUNT(*) > 2.", "Finally, we will sort the results by the number of airports in descending order."], "gold_sql": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)", "source_tables": ["airports"], "pred_sql": "SELECT city, COUNT(*) as airport_count \nFROM airports \nGROUP BY city \nHAVING COUNT(*) > 2 \nORDER BY airport_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\",\n        \"virtual_table\": \"SELECT country ,  count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC\"\n    }\n}\n"}
{"sample_id": "train.6862", "db_id": "flight_4", "question": "For each  airport name, how many routes start at that airport, ordered from most to least?", "rationale": ["The task is to count the number of routes starting at each airport and order them from most to least.", "To achieve this, we need to join the 'airports' table with the 'routes' table on the source airport ID (src_apid).", "We will use the COUNT function to count the number of routes for each airport.", "We will group the results by the airport name to get the count for each individual airport.", "Finally, we will order the results in descending order based on the count of routes."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC", "source_tables": ["airports", "routes"], "pred_sql": "SELECT count(*), T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid = T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n        \"virtual_table\": \"SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6867", "db_id": "flight_4", "question": "For each country and airline name, how many routes are there?", "rationale": ["We need to count the number of routes for each country and airline name.", "To achieve this, we will join the 'airlines' table with the 'routes' table on the airline ID (alid).", "Next, we will group the results by country and airline name to get the count of routes for each combination.", "We will also include the country information from the 'airlines' table in our SELECT statement.", "Finally, we will order the results by country and airline name for better readability."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT a.country, al.name, COUNT(r.rid) AS route_count \nFROM airlines AS al \nJOIN routes AS r ON al.alid = r.alid \nJOIN airports AS ap ON r.src_apid = ap.apid \nGROUP BY a.country, al.name \nORDER BY a.country, al.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\",\n        \"virtual_table\": \"SELECT country ,  count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6868", "db_id": "flight_4", "question": "What is the total number of routes for each country and airline in that country?", "rationale": ["We need to find the total number of routes for each country and airline.", "To do this, we will join the 'routes' table with the 'airlines' table on the airline ID (alid).", "We will select the country from the airlines table and the airline name from the routes table.", "We will count the number of routes for each airline in each country using COUNT(*).", "We will group the results by country and airline to get the total routes per airline in each country.", "Finally, we will order the results by country and total routes in descending order."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT a.country, r.airline, COUNT(*) AS total_routes \nFROM routes r \nJOIN airlines a ON r.alid = a.alid \nGROUP BY a.country, r.airline \nORDER BY a.country, total_routes DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\",\n        \"virtual_table\": \"SELECT country ,  count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    }\n}\n"}
{"sample_id": "train.6873", "db_id": "flight_4", "question": "Find the number of routes that have destination John F Kennedy International Airport.", "rationale": ["Identify the relevant table: The 'routes' table contains information about routes including destination airports.", "Determine the condition: We need to filter the routes where the destination airport name is 'John F Kennedy International Airport'.", "Construct the SQL query: Use the COUNT function to count the number of routes that meet the specified condition."], "gold_sql": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'", "source_tables": ["airports", "routes"], "pred_sql": "SELECT count(*) FROM routes WHERE dst_ap = 'John F Kennedy International Airport'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6880", "db_id": "flight_4", "question": "What is the name of the airline with the most routes?", "rationale": ["We need to find the airline with the most routes, which involves counting the number of routes associated with each airline.", "To achieve this, we will join the 'airlines' table with the 'routes' table on the airline ID (alid).", "We will group the results by the airline name to count the number of routes for each airline.", "Next, we will order the results in descending order based on the count of routes to get the airline with the most routes at the top.", "Finally, we will limit the results to just one entry to get the name of the airline with the most routes."], "gold_sql": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid = T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n        \"virtual_table\": \"SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6883", "db_id": "flight_4", "question": "Find the busiest destination airport that runs most number of routes in China.", "rationale": ["Identify the destination airports in China by filtering the airports table for the country 'China'.", "Join the airports table with the routes table on the destination airport ID to count the number of routes for each destination airport.", "Group the results by the airport name to aggregate the count of routes for each airport.", "Order the results in descending order based on the count of routes to find the busiest destination airport.", "Limit the results to 1 to get only the busiest destination airport."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT T1.name, COUNT(*) as route_count \nFROM airports AS T1 \nJOIN routes AS T2 ON T1.apid = T2.dst_apid \nWHERE T1.country = 'China' \nGROUP BY T1.name \nORDER BY route_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n        \"virtual_table\": \"SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    }\n}\n"}
{"sample_id": "train.6884", "db_id": "flight_4", "question": "What is the name of the airport that is the destination of the most number of routes that start in China?", "rationale": ["Identify the destination airport names from the 'airports' table.", "Join the 'routes' table to link the destination airport IDs with their names.", "Filter the results to only include routes that start from airports in China by joining the 'airports' table again to get the source airport country.", "Group the results by destination airport name to count the number of routes for each destination.", "Order the results in descending order based on the count of routes to find the most popular destination.", "Limit the results to return only the top result, which is the destination airport with the most routes from China."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid = T2.dst_apid JOIN airports AS T3 ON T2.src_apid = T3.apid WHERE T3.country = 'China' GROUP BY T1.name ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n        \"virtual_table\": \"SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    }\n}\n"}
{"sample_id": "train.6980", "db_id": "culture_company", "question": "Show all publishers which do not have a book in 1989.", "rationale": ["Identify the requirement to find publishers without books in 1989.", "Use a subquery to find all publishers that have published books in 1989.", "Select distinct publishers from the 'book_club' table.", "Filter out those publishers who are in the list obtained from the subquery."], "gold_sql": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  1989", "source_tables": ["book_club"], "pred_sql": "SELECT DISTINCT publisher FROM book_club WHERE publisher NOT IN (SELECT DISTINCT Publisher FROM book_club WHERE Year = '1989')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of publishers from the 'book_club' table, grouped by the publisher's name. The results are ordered by the number of books published by each publisher in descending order, with a limit on the number of publishers returned based on a specified number.\",\n        \"virtual_table\": \"SELECT publisher FROM book_club GROUP BY publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6990", "db_id": "culture_company", "question": "Show all director names who have a movie in the year 1999 or 2000.", "rationale": ["Identify the table that contains the information about movies, which is the 'movie' table.", "Determine the relevant column that contains the director's names, which is 'Director'.", "Identify the column that contains the year of release, which is 'Year'.", "We need to filter the results to include only those movies released in the years 1999 or 2000.", "Use the SQL 'SELECT DISTINCT' statement to ensure that each director's name is listed only once, even if they directed multiple movies in those years."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6991", "db_id": "culture_company", "question": "Which directors had a movie in either 1999 or 2000?", "rationale": ["Identify the relevant table: The question pertains to directors and movies, so we will focus on the 'movie' table.", "Determine the columns needed: We need the 'Director' column to answer the question about which directors had movies in specific years.", "Filter the results: We need to filter the movies based on the years 1999 and 2000.", "Use the DISTINCT keyword: Since a director may have multiple movies in these years, we use DISTINCT to ensure each director is listed only once.", "Construct the SQL query: Combine all these elements into a SQL SELECT statement that retrieves distinct directors from the movie table where the year is either 1999 or 2000."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6996", "db_id": "culture_company", "question": "Show the movie titles and book titles for all companies in China.", "rationale": ["Identify the tables involved: culture_company, movie, and book_club.", "Determine the columns needed: movie titles from the movie table and book titles from the book_club table.", "Establish relationships between the tables using JOINs: culture_company to movie and culture_company to book_club.", "Filter the results to only include companies based in China using a WHERE clause."], "gold_sql": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  'China'", "source_tables": ["culture_company", "movie", "book_club"], "pred_sql": "SELECT movie.Title AS Movie_Title, book_club.Book_Title AS Book_Title\nFROM culture_company\nJOIN movie ON culture_company.movie_id = movie.movie_id\nJOIN book_club ON culture_company.book_club_id = book_club.book_club_id\nWHERE culture_company.Company_name = 'China';", "hint": "\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant tables: We need to find the car model with the minimum horsepower, so we will use the 'car_names' and 'cars_data' tables.", "Join the tables: We will join 'car_names' with 'cars_data' on the 'MakeId' to access horsepower data for each car model.", "Order by horsepower: We will order the results by the 'Horsepower' column in ascending order to get the model with the minimum horsepower at the top.", "Limit the results: Since we only want the model with the minimum horsepower, we will limit the results to 1."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model FROM car_names JOIN cars_data ON car_names.MakeId = cars_data.Id ORDER BY cars_data.Horsepower ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table that have a weight less than the average weight of all cars in the 'cars_data' table. The query uses a subquery to calculate the average weight, ensuring that only lighter models are selected.\",\n        \"virtual_table\": \"SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.103", "db_id": "car_1", "question": "Which distinct car models are the produced after 1980?", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data.", "We need to select distinct car models, so we will use SELECT DISTINCT.", "Join the model_list table with the car_names table on the model column to get the corresponding car names.", "Then, join the resulting table with the cars_data table on the MakeId to filter by manufacturing year.", "Apply a WHERE clause to filter for cars manufactured after 1980."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "pred_sql": "SELECT DISTINCT T1.Model FROM model_list AS T1 JOIN car_names AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id WHERE T3.Year > 1980;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.106", "db_id": "car_1", "question": "What is the name of each continent and how many car makers are there in each one?", "rationale": ["Identify the relevant tables: continents, countries, and car_makers.", "We need to count the number of car makers for each continent, so we will use the COUNT function.", "Join the continents table with the countries table on the ContId and Continent columns.", "Then, join the resulting table with the car_makers table on the CountryId and Country columns.", "Group the results by continent to get the count of car makers for each continent."], "gold_sql": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;", "source_tables": ["countries", "car_makers", "continents"], "pred_sql": "SELECT c.Continent, COUNT(cm.Id) AS CarMakerCount\nFROM continents c\nJOIN countries co ON c.ContId = co.Continent\nJOIN car_makers cm ON co.CountryId = cm.Country\nGROUP BY c.Continent;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: We need to get the acceleration data for a specific car model, which involves the 'cars_data' and 'car_names' tables.", "Determine the relationship: The 'cars_data' table contains the acceleration information, while the 'car_names' table links car makes and models.", "Filter by the specific car make and model: We need to filter the results to only include the 'amc hornet sportabout'.", "Construct the SQL query: Join the 'cars_data' and 'car_names' tables on their respective identifiers and apply the necessary filters to get the desired acceleration value."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT T1.Accelerate FROM cars_data AS T1 JOIN car_names AS T2 ON T1.Id = T2.MakeId WHERE T2.Model = 'hornet sportabout' AND T2.Make = 'amc';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table that have a weight less than the average weight of all cars in the 'cars_data' table. The query uses a subquery to calculate the average weight, ensuring that only lighter models are selected.\",\n        \"virtual_table\": \"SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the relevant tables: We need to find car makers based in France, so we will use the 'car_makers' and 'countries' tables.", "Determine the relationship: The 'car_makers' table has a foreign key 'Country' that references 'countries.CountryId'. We will join these two tables on this key.", "Filter for France: We need to filter the results to only include car makers from France, which is done by adding a WHERE clause that checks if 'countries.CountryName' is 'France'.", "Count distinct car makers: We want to count the number of unique car makers, so we will use COUNT(DISTINCT car_makers.Id) to get the total number of distinct car makers in France."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(DISTINCT car_makers.Id) AS NumberOfCarMakers\nFROM car_makers\nJOIN countries ON car_makers.Country = countries.CountryId\nWHERE countries.CountryName = 'France';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.114", "db_id": "car_1", "question": "What is the number of makers of care in France?", "rationale": ["Identify the relevant tables: We need to find the number of car makers in France, so we will use the 'car_makers' and 'countries' tables.", "Determine the relationship: The 'car_makers' table has a foreign key 'Country' that references 'countries.CountryId'. We need to join these two tables on this key.", "Filter for France: We need to filter the results to only include car makers based in France. This is done by checking the 'CountryName' in the 'countries' table.", "Count distinct makers: We want the count of unique car makers, so we will use COUNT(DISTINCT car_makers.Id) to get the number of unique makers in France."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(DISTINCT car_makers.Id) AS NumberOfMakers\nFROM car_makers\nJOIN countries ON car_makers.Country = countries.CountryId\nWHERE countries.CountryName = 'France';", "hint": "\n"}
{"sample_id": "dev.115", "db_id": "car_1", "question": "How many car models are produced in the usa?", "rationale": ["Identify the relevant tables: We need to find car models produced in the USA, so we will use the 'model_list', 'car_makers', and 'countries' tables.", "Join the tables: We will join 'model_list' with 'car_makers' on the Maker ID, and then join 'car_makers' with 'countries' on the Country ID to filter by country.", "Filter by country: We will add a WHERE clause to filter for countries where CountryName is 'USA'.", "Count distinct models: We will use COUNT(DISTINCT T1.Model) to count the unique car models produced in the USA."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "pred_sql": "SELECT COUNT(DISTINCT T1.Model) AS NumberOfModels FROM model_list AS T1 JOIN car_makers AS T2 ON T1.Maker = T2.Id JOIN countries AS T3 ON T2.Country = T3.CountryId WHERE T3.CountryName = 'USA';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the relevant tables: countries, car_makers, and continents.", "We need to filter countries that are in Europe, so we will join the countries table with the continents table to get the ContId for Europe.", "Next, we will join the car_makers table to the countries table to find out how many car manufacturers are in each country.", "We will group the results by country name to count the number of car manufacturers per country.", "Finally, we will use the HAVING clause to filter out countries that have at least 3 car manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName\nFROM countries AS c\nJOIN car_makers AS cm ON c.CountryId = cm.Country\nWHERE c.Continent = (SELECT ContId FROM continents WHERE Continent = 'Europe')\nGROUP BY c.CountryName\nHAVING COUNT(cm.Id) >= 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the relevant tables: 'cars_data' for horsepower and cylinders, and 'car_names' for the make of the car.", "We need to find the maximum horsepower, so we will use the MAX() function on the 'Horsepower' column from the 'cars_data' table.", "We need to filter the results to only include cars with 3 cylinders, which will be done using a WHERE clause.", "To get the make of the car models, we will join the 'cars_data' table with the 'car_names' table on the appropriate foreign key relationship.", "The final query will select the maximum horsepower and the corresponding make of the car models with 3 cylinders."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(cars_data.Horsepower) AS MaxHorsepower, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Cylinders = 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.133", "db_id": "car_1", "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.", "rationale": ["Identify the relevant tables: 'car_names' for car models and 'cars_data' for MPG.", "Join the 'car_names' table with the 'cars_data' table on the MakeId to access MPG data for each model.", "Order the results by MPG in descending order to find the model that saves the most gasoline.", "Limit the results to 1 to get only the top model with the maximum MPG."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model FROM car_names JOIN cars_data ON car_names.MakeId = cars_data.Id ORDER BY cars_data.MPG DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["Identify the tables involved: We need to get information from the 'car_makers' and 'model_list' tables.", "Determine the relationship: The 'model_list' table has a foreign key 'Maker' that references the 'Id' in the 'car_makers' table.", "Select the required fields: We need the 'Id' and 'Maker' from the 'car_makers' table.", "Group the results: We will group by 'car_makers.Id' and 'car_makers.Maker' to count the number of models for each maker.", "Filter the results: We will use HAVING to filter out makers with more than 3 models."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "SELECT car_makers.Id, car_makers.Maker \nFROM car_makers \nJOIN model_list ON car_makers.Id = model_list.Maker \nGROUP BY car_makers.Id, car_makers.Maker \nHAVING COUNT(model_list.ModelId) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.158", "db_id": "car_1", "question": "For a volvo model, how many cylinders does the version with least accelerate have?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car models.", "Join 'cars_data' and 'car_names' on the MakeId to link car specifications with their respective models.", "Filter the results to only include cars where the model is 'volvo'.", "Order the results by the 'Accelerate' column in ascending order to find the version with the least acceleration time.", "Limit the results to 1 to get only the top result, which will be the version with the least acceleration time."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT T1.Cylinders FROM cars_data AS T1 JOIN car_names AS T2 ON T1.Id = T2.MakeId WHERE T2.Model = 'volvo' ORDER BY T1.Accelerate ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table that have a weight less than the average weight of all cars in the 'cars_data' table. The query uses a subquery to calculate the average weight, ensuring that only lighter models are selected.\",\n        \"virtual_table\": \"SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.160", "db_id": "car_1", "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?", "rationale": ["Identify the requirement: We need to count the number of cars with an acceleration time greater than the maximum horsepower.", "To find the maximum horsepower, we can use a subquery that selects the maximum value from the 'Horsepower' column in the 'cars_data' table.", "Next, we need to count the number of entries in the 'cars_data' table where the 'accelerate' value is greater than the result of the subquery.", "The final SQL query combines these two steps: it counts the number of cars with an acceleration greater than the maximum horsepower found."], "gold_sql": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "source_tables": ["cars_data"], "pred_sql": "SELECT COUNT(*) FROM cars_data WHERE accelerate > (SELECT MAX(Horsepower) FROM cars_data);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car models.", "We need to filter the cars based on the number of cylinders, specifically those with 4 cylinders.", "Join the 'cars_data' table with the 'car_names' table on the appropriate foreign key (Id and MakeId).", "Select the 'Model' and 'Horsepower' columns from the joined tables.", "Order the results by 'Horsepower' in descending order to get the model with the largest horsepower at the top.", "Limit the results to 1 to get only the top model."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower FROM cars_data AS cd JOIN car_names AS cn ON cd.Id = cn.MakeId WHERE cd.Cylinders = 4 ORDER BY Horsepower DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.166", "db_id": "car_1", "question": "For all of the 4 cylinder cars, which model has the most horsepower?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car models.", "We need to filter the cars based on the number of cylinders, specifically looking for 4-cylinder cars.", "Join the 'cars_data' table with the 'car_names' table on the appropriate foreign key (Id = MakeId) to access both horsepower and model name.", "Order the results by horsepower in descending order to find the model with the most horsepower.", "Limit the results to 1 to get only the top model."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower FROM cars_data AS T1 JOIN car_names AS T2 ON T1.Id = T2.MakeId WHERE T1.Cylinders = 4 ORDER BY Horsepower DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.168", "db_id": "car_1", "question": "Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?", "rationale": ["Identify the minimum horsepower from the cars_data table using a subquery.", "Select the make ids and names from the car_names table where the make id is not equal to the minimum horsepower.", "Additionally, filter the results to include only those cars that have less than 4 cylinders."], "gold_sql": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  4;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT MakeId, Model FROM car_names WHERE MakeId NOT IN (SELECT Id FROM cars_data WHERE Horsepower = (SELECT MIN(Horsepower) FROM cars_data)) AND MakeId IN (SELECT Id FROM cars_data WHERE Cylinders < 4);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table that have a weight less than the average weight of all cars in the 'cars_data' table. The query uses a subquery to calculate the average weight, ensuring that only lighter models are selected.\",\n        \"virtual_table\": \"SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["Identify the relevant tables: car_makers, model_list, car_names, and cars_data.", "Join the car_makers table with model_list to get the models produced by each maker.", "Join the model_list with car_names to link models to their respective makes.", "Join car_names with cars_data to count the number of cars produced for each make.", "Group the results by car maker's Id and Maker name to aggregate data for each maker.", "Use HAVING clause to filter makers that produce at least 2 distinct models and have more than 3 cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker \nFROM car_makers AS cm \nJOIN model_list AS ml ON cm.Id = ml.Maker \nJOIN car_names AS cn ON ml.Model = cn.Model \nJOIN cars_data AS cd ON cn.MakeId = cd.Id \nGROUP BY cm.Id, cm.Maker \nHAVING COUNT(DISTINCT ml.Model) >= 2 AND COUNT(cd.Id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n        \"virtual_table\": \"SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.180", "db_id": "flight_2", "question": "What country is Jetblue Airways affiliated with?", "rationale": ["Identify the relevant table: The 'airlines' table contains information about airlines, including their country affiliation.", "Determine the specific airline of interest: The user is asking about 'Jetblue Airways'.", "Construct the SQL query to select the 'Country' column from the 'airlines' table where the 'Airline' column matches 'Jetblue Airways'."], "gold_sql": "SELECT Country FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "pred_sql": "SELECT Country FROM airlines WHERE Airline = 'Jetblue Airways';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.194", "db_id": "flight_2", "question": "Give the airline with abbreviation 'UAL'.", "rationale": ["Identify the relevant table: The 'airlines' table contains the abbreviation for each airline.", "Formulate the query: We need to select the 'Abbreviation' column from the 'airlines' table where the abbreviation matches 'UAL'.", "Construct the SQL query: The final SQL query is constructed to retrieve the abbreviation for the specified airline."], "gold_sql": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  'UAL'", "source_tables": ["airlines"], "pred_sql": "SELECT Abbreviation FROM airlines WHERE Abbreviation = 'UAL';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists unique airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The placeholder in the LIMIT clause represents the maximum number of airport codes to return.\",\n        \"virtual_table\": \"SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.214", "db_id": "flight_2", "question": "Give the number of Jetblue Airways flights.", "rationale": ["Identify the relevant table: The 'flights' table contains information about the flights, including the airline name.", "Determine the specific airline of interest: The user is interested in 'Jetblue Airways'.", "Construct the SQL query to count the number of flights for 'Jetblue Airways': Use the COUNT() function to count the rows in the 'flights' table where the Airline column matches 'Jetblue Airways'."], "gold_sql": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = 'JetBlue Airways'", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT COUNT(*) FROM flights WHERE Airline = 'Jetblue Airways';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.225", "db_id": "flight_2", "question": "What is the code of airport that has the highest number of flights?", "rationale": ["Identify the relevant tables: 'airports' and 'flights'.", "We need to find the airport code with the highest number of flights, which involves counting the number of flights associated with each airport.", "Join the 'airports' table with the 'flights' table on the condition that the airport code is either a source or destination airport.", "Group the results by airport code to aggregate the flight counts for each airport.", "Order the results in descending order based on the count of flights to get the airport with the highest number of flights at the top.", "Limit the results to 1 to get only the airport code with the highest number of flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT T1.AirportCode FROM airports AS T1 JOIN flights AS T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists unique airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The placeholder in the LIMIT clause represents the maximum number of airport codes to return.\",\n        \"virtual_table\": \"SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.227", "db_id": "flight_2", "question": "What is the code of airport that has fewest number of flights?", "rationale": ["Identify the relevant tables: 'airports' and 'flights'.", "We need to find the airport code with the fewest number of flights, which means we will be counting the number of flights associated with each airport.", "Join the 'airports' table with the 'flights' table on the condition that the airport code is either a source or destination airport.", "Group the results by airport code to aggregate the flight counts for each airport.", "Order the results by the count of flights in ascending order to get the airport with the fewest flights at the top.", "Limit the results to 1 to get only the airport code with the fewest number of flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT T1.AirportCode FROM airports AS T1 JOIN flights AS T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) ASC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists unique airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The placeholder in the LIMIT clause represents the maximum number of airport codes to return.\",\n        \"virtual_table\": \"SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.229", "db_id": "flight_2", "question": "Which airline has most number of flights?", "rationale": ["Identify the relevant tables: 'airlines' and 'flights'.", "We need to find the airline with the most flights, so we will join the 'airlines' table with the 'flights' table on the airline identifier.", "Group the results by airline name to count the number of flights for each airline.", "Order the results in descending order based on the count of flights to get the airline with the most flights at the top.", "Limit the results to 1 to get only the airline with the highest number of flights."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT T1.Airline FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.232", "db_id": "flight_2", "question": "What is the abbreviation of the airilne has the fewest flights and what country is it in?", "rationale": ["Identify the airline with the fewest flights by counting the number of flights for each airline in the 'flights' table.", "Use a subquery to select the airline with the minimum count of flights, ordering by count in ascending order and limiting the result to 1.", "Join this result with the 'airlines' table to get the abbreviation and country of that airline.", "Select the 'Abbreviation' and 'Country' columns from the 'airlines' table based on the identified airline."], "gold_sql": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT A.Abbreviation, A.Country FROM airlines AS A JOIN (SELECT T1.Airline FROM flights AS T1 GROUP BY T1.Airline ORDER BY COUNT(*) ASC LIMIT 1) AS B ON A.Airline = B.Airline;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists unique airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The placeholder in the LIMIT clause represents the maximum number of airport codes to return.\",\n        \"virtual_table\": \"SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.244", "db_id": "flight_2", "question": "Which airlines have less than 200 flights?", "rationale": ["Identify the relevant tables: 'airlines' and 'flights'.", "Join the 'airlines' table with the 'flights' table on the airline identifier (uid).", "Group the results by airline name to aggregate the number of flights per airline.", "Use the HAVING clause to filter airlines that have less than 200 flights."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT T1.Airline FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING COUNT(T2.FlightNo) < 200;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.258", "db_id": "flight_2", "question": "Which airports do not have departing or arriving flights?", "rationale": ["Identify the airports from the 'airports' table that do not have any associated flights.", "Use a subquery to find all airport codes that are either source or destination airports in the 'flights' table.", "The subquery selects airport codes from the 'airports' table that are linked to the 'flights' table via the SourceAirport and DestAirport columns.", "The main query selects airport codes and names from the 'airports' table where the airport code is not in the list of airport codes returned by the subquery."], "gold_sql": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)", "source_tables": ["airports", "flights"], "pred_sql": "SELECT AirportCode, AirportName FROM airports WHERE AirportCode NOT IN (SELECT T1.AirportCode FROM airports AS T1 JOIN flights AS T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists unique airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The placeholder in the LIMIT clause represents the maximum number of airport codes to return.\",\n        \"virtual_table\": \"SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.308", "db_id": "cre_Doc_Template_Mgt", "question": "Count the number of documents that use the PPT template type.", "rationale": ["Identify the tables involved: We need to count documents, so we will use the 'Documents' table.", "We need to filter documents based on the template type, which is found in the 'Templates' table.", "Join the 'Documents' table with the 'Templates' table on the 'Template_ID' column to link documents to their respective templates.", "Apply a WHERE clause to filter for the specific template type code 'PPT'.", "Use COUNT(*) to count the number of documents that meet the criteria."], "gold_sql": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'", "source_tables": ["templates", "documents"], "pred_sql": "SELECT COUNT(*) FROM Documents AS D JOIN Templates AS T ON D.Template_ID = T.Template_ID WHERE T.Template_Type_Code = 'PPT'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\",\n        \"virtual_table\": \"SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of documents associated with each template from the 'Documents' table. The placeholder in the SELECT clause represents the unique identifier of the template, while the count function aggregates the total number of documents linked to each template.\",\n        \"virtual_table\": \"SELECT template_id ,  count(*) FROM Documents GROUP BY template_id\"\n    }\n}\n"}
{"sample_id": "dev.311", "db_id": "cre_Doc_Template_Mgt", "question": "What is the id and type code for the template used by the most documents?", "rationale": ["We need to find the template used by the most documents, which requires counting the number of documents associated with each template.", "The hint provides a virtual table that counts the number of documents for each template, which we can use to get the count of documents per template.", "We will join this count with the Templates table to get the corresponding Template_ID and Template_Type_Code.", "Finally, we will order the results by the document count in descending order and limit the result to 1 to get the template with the most documents."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT T1.Template_ID, T1.Template_Type_Code FROM Templates AS T1 JOIN (SELECT Template_ID, COUNT(*) as Document_Count FROM Documents GROUP BY Template_ID) AS T2 ON T1.Template_ID = T2.Template_ID ORDER BY T2.Document_Count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\",\n        \"virtual_table\": \"SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of documents associated with each template from the 'Documents' table. The placeholder in the SELECT clause represents the unique identifier of the template, while the count function aggregates the total number of documents linked to each template.\",\n        \"virtual_table\": \"SELECT template_id ,  count(*) FROM Documents GROUP BY template_id\"\n    }\n}\n"}
{"sample_id": "dev.312", "db_id": "cre_Doc_Template_Mgt", "question": "Return the id and type code of the template that is used for the greatest number of documents.", "rationale": ["The task is to find the template ID and type code that is associated with the greatest number of documents.", "To achieve this, we need to count the number of documents for each template. This can be done using a subquery that groups the Documents table by Template_ID and counts the occurrences.", "Next, we need to join this result with the Templates table to get the corresponding Template_Type_Code for each Template_ID.", "Finally, we need to filter the results to only include the template(s) that have the maximum document count. This requires another subquery to find the maximum count from the previous aggregation."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT T.template_id, T.template_type_code \nFROM Templates AS T \nJOIN (SELECT template_id, COUNT(*) AS doc_count \n      FROM Documents \n      GROUP BY template_id) AS D \nON T.template_id = D.template_id \nWHERE D.doc_count = (SELECT MAX(doc_count) \n                     FROM (SELECT template_id, COUNT(*) AS doc_count \n                           FROM Documents \n                           GROUP BY template_id))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\",\n        \"virtual_table\": \"SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of documents associated with each template from the 'Documents' table. The placeholder in the SELECT clause represents the unique identifier of the template, while the count function aggregates the total number of documents linked to each template.\",\n        \"virtual_table\": \"SELECT template_id ,  count(*) FROM Documents GROUP BY template_id\"\n    }\n}\n"}
{"sample_id": "dev.341", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template type codes and the number of documents using each type.", "rationale": ["The query needs to show all template type codes and the number of documents associated with each type.", "We start by selecting the template type code from the Ref_Template_Types table.", "To count the number of documents for each template type, we need to join the Templates table on the Template_Type_Code.", "Next, we join the Documents table on the Template_ID to link documents to their respective templates.", "We use a LEFT JOIN to ensure that we include all template types even if there are no associated documents.", "Finally, we group the results by the template type code and count the number of Document_IDs for each group."], "gold_sql": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code", "source_tables": ["templates", "documents"], "pred_sql": "SELECT R.template_type_code, COUNT(D.Document_ID) AS document_count \nFROM Ref_Template_Types AS R \nJOIN Templates AS T ON R.template_type_code = T.template_type_code \nLEFT JOIN Documents AS D ON T.template_id = D.template_id \nGROUP BY R.template_type_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\",\n        \"virtual_table\": \"SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of documents associated with each template from the 'Documents' table. The placeholder in the SELECT clause represents the unique identifier of the template, while the count function aggregates the total number of documents linked to each template.\",\n        \"virtual_table\": \"SELECT template_id ,  count(*) FROM Documents GROUP BY template_id\"\n    }\n}\n"}
{"sample_id": "dev.346", "db_id": "cre_Doc_Template_Mgt", "question": "What are the codes of template types that are not used for any document?", "rationale": ["Identify the template types from the 'Ref_Template_Types' table.", "Use a LEFT JOIN to connect 'Ref_Template_Types' with a subquery that counts documents associated with each template type.", "The subquery selects the template type code and counts the number of documents linked to each template type by joining 'Templates' and 'Documents'.", "Group the results of the subquery by template type code to get the count of documents for each template type.", "In the main query, filter for template types where the document count is NULL, indicating that no documents are associated with those template types."], "gold_sql": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id", "source_tables": ["templates", "documents"], "pred_sql": "SELECT R.Template_Type_Code \nFROM Ref_Template_Types AS R \nLEFT JOIN (SELECT T1.Template_Type_Code, COUNT(*) AS Document_Count \n            FROM Templates AS T1 \n            JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \n            GROUP BY T1.Template_Type_Code) AS DocCount \nON R.Template_Type_Code = DocCount.Template_Type_Code \nWHERE DocCount.Document_Count IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\",\n        \"virtual_table\": \"SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of documents associated with each template from the 'Documents' table. The placeholder in the SELECT clause represents the unique identifier of the template, while the count function aggregates the total number of documents linked to each template.\",\n        \"virtual_table\": \"SELECT template_id ,  count(*) FROM Documents GROUP BY template_id\"\n    }\n}\n"}
{"sample_id": "dev.361", "db_id": "cre_Doc_Template_Mgt", "question": "Show paragraph details for paragraph with text 'Korea ' .", "rationale": ["Identify the table that contains paragraph details, which is the 'Paragraphs' table.", "Determine the column that holds the text content of the paragraph, which is 'Paragraph_Text'.", "Formulate a SQL query to select all columns from the 'Paragraphs' table where 'Paragraph_Text' matches the specified text 'Korea '."], "gold_sql": "select other_details from paragraphs where paragraph_text like 'korea'", "source_tables": ["paragraphs"], "pred_sql": "SELECT * FROM Paragraphs WHERE Paragraph_Text = 'Korea ';", "hint": "\n"}
{"sample_id": "dev.367", "db_id": "cre_Doc_Template_Mgt", "question": "Show all document ids and the number of paragraphs in each document. Order by document id.", "rationale": ["The query needs to show all document IDs and the number of paragraphs in each document.", "To achieve this, we need to join the 'Documents' table with the 'Paragraphs' table on the 'Document_ID' field.", "We will use the COUNT function to count the number of paragraphs for each document.", "We will group the results by 'Document_ID' to get the count for each document separately.", "Finally, we will order the results by 'Document_ID' to meet the requirement of ordering."], "gold_sql": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id", "source_tables": ["paragraphs"], "pred_sql": "SELECT Document_ID, COUNT(Paragraph_ID) AS Number_of_Paragraphs \nFROM Documents \nJOIN Paragraphs ON Documents.Document_ID = Paragraphs.Document_ID \nGROUP BY Documents.Document_ID \nORDER BY Documents.Document_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of documents associated with each template from the 'Documents' table. The placeholder in the SELECT clause represents the unique identifier of the template, while the count function aggregates the total number of documents linked to each template.\",\n        \"virtual_table\": \"SELECT template_id ,  count(*) FROM Documents GROUP BY template_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\",\n        \"virtual_table\": \"SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code\"\n    }\n}\n"}
{"sample_id": "dev.439", "db_id": "wta_1", "question": "Find the highest rank of losers in all matches.", "rationale": ["We need to find the highest rank of losers in all matches.", "To do this, we will join the 'matches' table with the 'rankings' table on the loser_id and player_id respectively.", "We will group the results by loser_id to get the minimum ranking for each loser.", "Finally, we will take the minimum of these rankings to find the highest rank among all losers."], "gold_sql": "SELECT min(loser_rank) FROM matches", "source_tables": ["matches"], "pred_sql": "SELECT MIN(ranking) AS highest_rank FROM (SELECT loser_id, MIN(ranking) AS ranking FROM matches JOIN rankings ON matches.loser_id = rankings.player_id GROUP BY loser_id) AS loser_ranks;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\",\n        \"virtual_table\": \"SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name\"\n    }\n}\n"}
{"sample_id": "dev.458", "db_id": "wta_1", "question": "What are the full names of all left handed players, in order of birth date?", "rationale": ["Identify the relevant table: The 'players' table contains the information about players, including their names and handedness.", "Select the required columns: We need the full names of the players, which can be constructed by concatenating 'first_name' and 'last_name'.", "Filter for left-handed players: We will add a WHERE clause to filter the results to only include players whose 'hand' is 'left'.", "Order the results: We need to order the results by 'birth_date', so we will add an ORDER BY clause using the 'birth_date' column."], "gold_sql": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date", "source_tables": ["players"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name\nFROM players\nWHERE hand = 'left'\nORDER BY birth_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\",\n        \"virtual_table\": \"SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name\"\n    }\n}\n"}
{"sample_id": "dev.464", "db_id": "wta_1", "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?", "rationale": ["Identify the relevant tables: We need data from the 'matches', 'players', and 'rankings' tables.", "Determine the necessary columns: We need the winner's name from the 'players' table and the ranking points from the 'rankings' table.", "Count the number of matches won by each player: This can be done by counting the occurrences of each winner in the 'matches' table.", "Group the results by winner's name to get the total matches won for each player.", "Join the 'matches' table with the 'players' table to get the winner's name and with the 'rankings' table to get their ranking points.", "Order the results by the count of matches won in descending order to find the player with the most wins.", "Limit the results to 1 to get only the top player."], "gold_sql": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["matches"], "pred_sql": "SELECT winner_name, COUNT(*) AS match_count, r.ranking_points \nFROM matches m \nJOIN players p ON m.winner_id = p.player_id \nJOIN rankings r ON p.player_id = r.player_id \nGROUP BY winner_name, r.ranking_points \nORDER BY match_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\",\n        \"virtual_table\": \"SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name\"\n    }\n}\n"}
{"sample_id": "dev.471", "db_id": "wta_1", "question": "Find the total ranking points for each player and their first name.", "rationale": ["The query needs to find the total ranking points for each player along with their first name.", "We will select the first name from the 'players' table and the sum of ranking points from the 'rankings' table.", "To combine data from both tables, we will use a JOIN operation on the player_id column, which is common in both tables.", "We will group the results by the first name to ensure we get the total ranking points for each player individually."], "gold_sql": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name", "source_tables": ["rankings", "players"], "pred_sql": "SELECT SUM(ranking_points) AS total_ranking_points, T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\",\n        \"virtual_table\": \"SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name\"\n    }\n}\n"}
{"sample_id": "dev.479", "db_id": "wta_1", "question": "Find the total number of tours for each ranking date.", "rationale": ["The task is to find the total number of tours for each ranking date.", "We need to select the 'ranking_date' from the 'rankings' table.", "To count the number of tours for each ranking date, we will use the COUNT() function on the 'tours' column.", "We will group the results by 'ranking_date' to get the total tours for each date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(tours) AS total_tours FROM rankings GROUP BY ranking_date", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\",\n        \"virtual_table\": \"SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name\"\n    }\n}\n"}
{"sample_id": "dev.480", "db_id": "wta_1", "question": "How many total tours were there for each ranking date?", "rationale": ["The question asks for the total number of tours for each ranking date.", "We need to select the 'ranking_date' from the 'rankings' table.", "To count the distinct tours for each ranking date, we will use the COUNT function with DISTINCT on the 'tours' column.", "We will group the results by 'ranking_date' to get the count for each date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(DISTINCT tours) AS total_tours\nFROM rankings\nGROUP BY ranking_date;", "hint": "\n"}
{"sample_id": "dev.533", "db_id": "student_transcripts_tracking", "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to join the Students table with the Student_Enrolment table to get student details along with their enrolment information.", "To find students enrolled in 2 different degree programs in the same semester, we will join the Student_Enrolment table with itself (self-join) on the student_id and ensure that the degree_program_id is different for both records.", "We will filter the results to ensure that both records belong to the same semester by checking that their semester_id is equal.", "We will group the results by student_id and use HAVING to count distinct degree_program_ids, ensuring it equals 2, which indicates enrolment in 2 different programs.", "Finally, we will select the required fields: first_name, middle_name, last_name, and student_id."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Student_Enrolment se2 ON s.student_id = se2.student_id\nWHERE se.degree_program_id != se2.degree_program_id\nAND se.semester_id = se2.semester_id\nGROUP BY s.student_id\nHAVING COUNT(DISTINCT se.degree_program_id) = 2;", "hint": "\n"}
{"sample_id": "dev.536", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs.", "We need to select the first, middle, and last names of students, so we will select s.first_name, s.middle_name, and s.last_name from the Students table.", "To find out which students are enrolled in a Bachelors program, we need to join the Students table with the Student_Enrolment table on student_id.", "Next, we join the Student_Enrolment table with the Degree_Programs table on degree_program_id to filter for Bachelors programs.", "We use a WHERE clause to filter Degree_Programs where the degree_summary_name contains 'Bachelors'."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name \nFROM Students s \nJOIN Student_Enrolment se ON s.student_id = se.student_id \nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id \nWHERE dp.degree_summary_name LIKE '%Bachelors%';", "hint": "\n"}
{"sample_id": "dev.537", "db_id": "student_transcripts_tracking", "question": "Find the kind of program which most number of students are enrolled in?", "rationale": ["Identify the relevant tables: We need to find the degree programs and the number of students enrolled in each program, so we will use the Student_Enrolment and Degree_Programs tables.", "Join the tables: We will join the Student_Enrolment table with the Degree_Programs table on the degree_program_id to associate each enrolment with its corresponding program.", "Count the number of students: We will use COUNT() to count the number of student enrolments for each degree program.", "Group by degree program: We will group the results by the degree_summary_name to get the count of students for each program.", "Order the results: We will order the results in descending order based on the student count to find out which program has the most students enrolled.", "Limit the results: Finally, we will limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_summary_name, COUNT(se.student_enrolment_id) AS student_count\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nGROUP BY dp.degree_summary_name\nORDER BY student_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["Identify the relevant tables: Degree_Programs and Student_Enrolment.", "We need to find the degree program with the most students enrolled, so we will join these two tables on the degree_program_id.", "We will group the results by degree_program_id and degree_summary_name to count the number of students enrolled in each program.", "Use COUNT(se.student_id) to count the number of students for each program.", "Order the results in descending order based on the count of students to get the program with the most enrollments at the top.", "Limit the results to 1 to get only the program with the highest enrollment."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_program_id, dp.degree_summary_name\nFROM Degree_Programs dp\nJOIN Student_Enrolment se ON dp.degree_program_id = se.degree_program_id\nGROUP BY dp.degree_program_id, dp.degree_summary_name\nORDER BY COUNT(se.student_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to count the number of enrollments for each student, so we will join the Students table with the Student_Enrolment table on the student_id.", "Use COUNT() function to count the number of enrollments for each student.", "Group the results by student_id to aggregate the counts for each student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Limit the results to 1 to get only the top student."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name, COUNT(se.student_enrolment_id) AS number_of_enrollments\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id\nORDER BY number_of_enrollments DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["Identify the relevant tables: Courses and Student_Enrolment_Courses are needed to find course names and their enrollments.", "Join the Courses table with the Student_Enrolment_Courses table on the course_id to link courses with their enrollments.", "Group the results by course name to aggregate the number of enrollments for each course.", "Order the results in descending order based on the count of enrollments to find the most enrolled course.", "Limit the results to 1 to get only the course with the highest number of enrollments."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of course names from the 'Courses' table that are associated with student enrolments. The results are grouped by course name and ordered by the number of enrolments in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of course names to return.\",\n        \"virtual_table\": \"SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant tables: Students and Addresses.", "We need to find students who have a permanent address in North Carolina, so we will join the Students table with the Addresses table on the permanent_address_id.", "Filter the results to include only those students whose state_province_county is 'North Carolina'.", "Next, we need to ensure that these students have not registered in any degree programs. This can be done by checking if their student_id is not present in the Student_Enrolment table.", "Construct the SQL query using a subquery to filter out students who are enrolled in any degree programs."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "select t1.last_name from students as t1 join addresses as t2 on t1.permanent_address_id = t2.address_id where t2.state_province_county = 'North Carolina' and t1.student_id not in (select student_id from student_enrolment)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\",\n        \"virtual_table\": \"select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile number.\",\n        \"virtual_table\": \"select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table: The question pertains to student information, specifically the mobile phone number, which is found in the 'Students' table.", "Determine the necessary columns: We need the 'cell_mobile_number' column for the output.", "Filter criteria: The student is identified by their first name 'Timmothy' and last name 'Ward'.", "Construct the SQL query using a SELECT statement to retrieve the mobile number from the 'Students' table where the first and last names match."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "select cell_mobile_number from Students where first_name = 'Timmothy' and last_name = 'Ward';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\",\n        \"virtual_table\": \"select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile number.\",\n        \"virtual_table\": \"select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["Identify the relevant tables: We need to use the 'Addresses' table to get address details and the 'Students' table to count the number of students at each address.", "Join the 'Addresses' table with the 'Students' table on the current address ID to associate students with their addresses.", "Group the results by address ID to count how many students are associated with each address.", "Order the results in descending order based on the count of students to find the address with the most students.", "Limit the results to 1 to get only the address with the highest count of students."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT a.address_id, a.line_1, a.line_2, a.line_3\nFROM Addresses a\nJOIN Students s ON s.current_address_id = a.address_id\nGROUP BY a.address_id\nORDER BY COUNT(s.student_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\",\n        \"virtual_table\": \"select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile number.\",\n        \"virtual_table\": \"select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.576", "db_id": "student_transcripts_tracking", "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?", "rationale": ["Identify the relevant tables: Student_Enrolment and Degree_Programs.", "We need to find semesters that had both Masters and Bachelors students enrolled.", "Join the Student_Enrolment table with the Degree_Programs table on the degree_program_id.", "Filter the results to include only those degree programs that are either 'Masters' or 'Bachelors'.", "Group the results by semester_id to aggregate the data for each semester.", "Use HAVING clause to ensure that both degree types (Masters and Bachelors) are present in the results."], "gold_sql": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT DISTINCT se.semester_id\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nWHERE dp.degree_summary_name IN ('Masters', 'Bachelors')\nGROUP BY se.semester_id\nHAVING COUNT(DISTINCT dp.degree_summary_name) = 2;", "hint": "\n"}
{"sample_id": "dev.580", "db_id": "student_transcripts_tracking", "question": "What other details can you tell me about students in reverse alphabetical order?", "rationale": ["The question asks for 'other details' about students, which corresponds to the 'other_student_details' column in the Students table.", "To retrieve this information, we will select the 'other_student_details' column from the Students table.", "The question specifies that the results should be in reverse alphabetical order, which means we need to order the results by the last name and first name of the students in descending order.", "Thus, the SQL query will select 'other_student_details' from the Students table and order the results by 'last_name' and 'first_name' in descending order."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "pred_sql": "SELECT other_student_details FROM Students ORDER BY last_name DESC, first_name DESC;", "hint": "\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve information about a section, we need to select all columns from the Sections table.", "We will use a WHERE clause to filter the results to only include the section where the section_name is 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT * FROM Sections WHERE section_name = 'h';", "hint": "\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries and their government forms.", "Determine the specific requirement: We need to count the number of countries with a government form of 'Republic'.", "Construct the SQL query: Use the COUNT function to count the rows in the 'country' table where the GovernmentForm is 'Republic'."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(*) FROM country WHERE GovernmentForm = 'Republic';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.730", "db_id": "world_1", "question": "What is the average GNP and total population in all nations whose government is US territory?", "rationale": ["Identify the required data: average GNP and total population of countries with a specific government form.", "Refer to the provided hint about the virtual table that summarizes average GNP and total population based on government form.", "Use the template from the hint: SELECT avg(GNP), sum(Population) FROM country WHERE GovernmentForm = [PLACEHOLDER-TYPE:STRING].", "Replace the placeholder with 'US territory' to specify the type of government we are interested in."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT avg(GNP), sum(Population) FROM country WHERE GovernmentForm = 'US territory'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.734", "db_id": "world_1", "question": "How many type of governments are in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and continent.", "Determine the specific requirement: We need to find out how many types of governments are present in Africa.", "Use the DISTINCT keyword: To count the unique types of governments, we will use the DISTINCT keyword in our SQL query.", "Filter by continent: We will add a WHERE clause to filter the results to only include countries in Africa.", "Construct the SQL query: Combine all these elements to form the final SQL query."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Continent = 'Africa'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their form of government and continent.", "Determine the specific requirement: We need to find out how many different forms of governments exist in Africa.", "Use the DISTINCT keyword: To get unique forms of government, we will use the DISTINCT keyword in our SQL query.", "Filter by continent: We will add a WHERE clause to filter the results to only include countries in Africa."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Continent = 'Africa'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.742", "db_id": "world_1", "question": "Which continent has the most diverse languages?", "rationale": ["To determine which continent has the most diverse languages, we need to count the distinct languages spoken in each continent.", "We can achieve this by joining the 'countrylanguage' table with the 'country' table on the CountryCode.", "We will group the results by continent and count the distinct languages for each continent.", "Finally, we will order the results by the count of distinct languages in descending order and limit the output to 1 to get the continent with the most diverse languages."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT Continent, COUNT(DISTINCT Language) AS LanguageCount FROM countrylanguage AS CL JOIN country AS C ON CL.CountryCode = C.Code GROUP BY Continent ORDER BY LanguageCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY Percentage DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.743", "db_id": "world_1", "question": "Which continent speaks the most languages?", "rationale": ["To find out which continent speaks the most languages, we need to count the distinct languages spoken in each continent.", "We will join the 'country' table with the 'countrylanguage' table on the country code to get the languages associated with each country.", "We will group the results by continent and count the distinct languages for each continent using COUNT(DISTINCT Language).", "Finally, we will order the results by the count of languages in descending order and limit the result to 1 to get the continent with the most languages."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT Continent, COUNT(DISTINCT Language) AS LanguageCount FROM country AS c JOIN countrylanguage AS cl ON c.Code = cl.CountryCode GROUP BY Continent ORDER BY LanguageCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY Percentage DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.746", "db_id": "world_1", "question": "What are the names of nations speak both English and French?", "rationale": ["Identify the countries that speak English by querying the countrylanguage table for 'English'.", "Identify the countries that speak French by querying the countrylanguage table for 'French'.", "Use the intersection of the two sets of country codes to find countries that speak both languages.", "Select the names of these countries from the country table using the identified country codes."], "gold_sql": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'French'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT Name FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English') AND Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'French');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY Percentage DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["Identify the tables needed: We need data from the 'country' and 'countrylanguage' tables.", "Determine the relationship: The 'country' table is linked to the 'countrylanguage' table through the 'CountryCode'.", "Filter for official languages: We need to filter the results to include only those languages that are official, which is indicated by 'IsOfficial' being 'T'.", "Specify the languages of interest: We are interested in countries where either English or Dutch is an official language.", "Use DISTINCT to avoid duplicate country names in the result set."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT c.Name \nFROM country AS c \nJOIN countrylanguage AS cl ON c.Code = cl.CountryCode \nWHERE cl.Language IN ('English', 'Dutch') AND cl.IsOfficial = 'T';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY Percentage DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the countries that do not use English as an official language.", "Use the provided virtual table to find the country codes of countries where English is an official language.", "Use the EXCEPT clause to exclude these country codes from the total population query.", "Sum the population of the remaining countries that do not have English as an official language."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(Population) FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'T')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY Percentage DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.767", "db_id": "world_1", "question": "How many people live in countries that do not speak English?", "rationale": ["Identify the requirement: We need to find the total population of countries that do not speak English.", "Use the countrylanguage table to find the country codes of countries where English is spoken.", "We can use a subquery to select the CountryCode from countrylanguage where Language is 'English'.", "To find countries that do not speak English, we can use the NOT IN clause with the result of the subquery.", "Finally, we sum the population of countries that are not in the list of countries that speak English by using the SUM function on the Population column in the country table."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(Population) FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY Percentage DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.783", "db_id": "world_1", "question": "Return the codes of countries that do not speak English and do not have Republics for governments.", "rationale": ["Identify the requirement to find country codes that do not speak English and do not have Republics for governments.", "To find countries that do not speak English, we can use a subquery to select country codes from the countrylanguage table where the language is 'English'.", "We will use the NOT IN clause to exclude these country codes from our main query.", "Next, we need to filter out countries that have 'Republic' in their government form. This can be done using the NOT LIKE clause.", "Combine both conditions in the main query that selects from the country table, ensuring we get the country codes that meet both criteria."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English') AND GovernmentForm NOT LIKE '%Republic%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY Percentage DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.784", "db_id": "world_1", "question": "Which cities are in European countries where English is not the official language?", "rationale": ["Identify the relevant tables: We need to use the 'city' and 'country' tables to find cities in European countries, and the 'countrylanguage' table to check the official languages.", "Filter for European countries: We can filter the countries by checking if their continent is 'Europe'.", "Exclude countries where English is an official language: We can use a subquery to exclude countries where English is an official language. This is done by selecting the CountryCode from the 'countrylanguage' table where IsOfficial is 'T' and Language is 'English'.", "Join the tables: We need to join the 'city' table with the 'country' table on the CountryCode to get the names of cities in those countries.", "Select the city names: Finally, we select the names of the cities that meet these criteria."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT c.Name FROM city c JOIN country co ON c.CountryCode = co.Code WHERE co.Continent = 'Europe' AND co.Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE IsOfficial = 'T' AND Language = 'English');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and populations of cities from the 'city' table that have a specific language spoken, as indicated in the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name, while the placeholder in the LIMIT clause specifies the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.785", "db_id": "world_1", "question": "What are the names of cities in Europe for which English is not the official language?", "rationale": ["Identify the countries in Europe by filtering the 'country' table based on the 'Region' column.", "Use a subquery to get the CountryCodes of countries in Europe.", "Use another subquery to get the CountryCodes of countries where English is an official language.", "Combine these two subqueries to filter out cities in Europe where English is not an official language.", "Select the names of the cities from the 'city' table that match the criteria."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT Name FROM city WHERE CountryCode IN (SELECT CountryCode FROM country WHERE Region = 'Europe') AND CountryCode NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'T');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and populations of cities from the 'city' table that have a specific language spoken, as indicated in the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name, while the placeholder in the LIMIT clause specifies the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.788", "db_id": "world_1", "question": "What are the name, independence year, and surface area of the country with the smallest population?", "rationale": ["Identify the required fields: Name, Independence Year (IndepYear), and Surface Area from the country table.", "Determine the condition to find the country with the smallest population, which involves using a subquery to get the minimum population.", "Construct the SQL query to select the specified fields from the country table where the population matches the minimum population found in the subquery."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the required fields: Name, year of independence (IndepYear), and surface area (SurfaceArea) from the country table.", "Determine the condition to find the country with the lowest population, which involves using a subquery to get the minimum population from the country table.", "Construct the main query to select the desired fields from the country table where the population matches the minimum population found in the subquery."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["Identify the tables needed: We need data from the 'country' table for country names and from the 'countrylanguage' table for languages spoken in those countries.", "Join the 'country' table with the 'countrylanguage' table on the country code to associate each country with its languages.", "Group the results by country name to count the number of languages spoken in each country.", "Use the COUNT function to count the number of languages for each country.", "Filter the results using HAVING to only include countries that speak more than 2 languages."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Name, COUNT(cl.Language) AS LanguageCount \nFROM country c \nJOIN countrylanguage cl ON c.Code = cl.CountryCode \nGROUP BY c.Name \nHAVING COUNT(cl.Language) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY Percentage DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.796", "db_id": "world_1", "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.", "rationale": ["Identify the columns needed: GovernmentForm and total population.", "Filter countries based on the condition that their average life expectancy is greater than 72.", "Use the SUM function to calculate the total population for each government form.", "Group the results by GovernmentForm to get the total population for each type of government."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) \nFROM country \nWHERE LifeExpectancy > 72 \nGROUP BY GovernmentForm;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the columns needed: GovernmentForm and Population from the country table.", "Filter the results based on the condition that LifeExpectancy must be greater than 72.", "Group the results by GovernmentForm to get the total population for each government form."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) \nFROM country \nWHERE LifeExpectancy > 72 \nGROUP BY GovernmentForm;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.801", "db_id": "world_1", "question": "Return the names and surface areas of the 5 largest countries.", "rationale": ["The task is to return the names and surface areas of the 5 largest countries.", "To find the largest countries, we need to order the countries by their surface area in descending order.", "We will select the 'Name' and 'SurfaceArea' columns from the 'country' table.", "To limit the results to only the top 5 largest countries, we will use the LIMIT clause with a value of 5."], "gold_sql": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5", "source_tables": ["country"], "pred_sql": "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.810", "db_id": "world_1", "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?", "rationale": ["Identify the required data: total population and average area of countries in North America with an area greater than 3000.", "Use the 'country' table to access the necessary columns: Population and SurfaceArea.", "Filter the results by specifying the continent as 'North America' and the SurfaceArea condition (> 3000).", "Use aggregate functions: sum() for total population and avg() for average area.", "Construct the SQL query using the SELECT statement with the appropriate conditions."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT sum(Population) AS TotalPopulation, avg(SurfaceArea) AS AverageArea FROM country WHERE Continent = 'North America' AND SurfaceArea > 3000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.811", "db_id": "world_1", "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .", "rationale": ["Identify the continent of interest, which is North America.", "Determine the criteria for filtering countries, which is a surface area greater than 3000.", "Use the 'country' table to sum the population and calculate the average surface area for the specified continent and criteria.", "Construct the SQL query to select the total population and average surface area from the 'country' table with the appropriate WHERE clause."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT sum(Population) AS TotalPopulation, avg(SurfaceArea) AS AverageSurfaceArea FROM country WHERE Continent = 'North America' AND SurfaceArea > 3000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the relevant table: The 'city' table contains the population data we need.", "Determine the columns to select: We want the 'Name' and 'Population' of the cities.", "Specify the condition for population: We need to filter cities where the population is between 160000 and 900000.", "Construct the SQL query using the SELECT statement with the appropriate WHERE clause."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT Name, Population FROM city WHERE Population BETWEEN 160000 AND 900000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and populations of cities from the 'city' table that have a specific language spoken, as indicated in the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name, while the placeholder in the LIMIT clause specifies the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.921", "db_id": "dog_kennels", "question": "Find the average age of the dogs who went through treatments.", "rationale": ["Identify the goal: Calculate the average age of dogs that have received treatments.", "Determine the relevant tables: The 'Dogs' table contains the age of the dogs, and the 'Treatments' table links dogs to their treatments.", "Use a subquery to find all dog_ids from the 'Treatments' table, as these are the dogs that have undergone treatments.", "In the main query, select the average age from the 'Dogs' table where the dog_id is in the list obtained from the subquery."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id\"\n    }\n}\n"}
{"sample_id": "dev.924", "db_id": "dog_kennels", "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to find dogs that have not cost their owners more than 1000 for treatment.", "To do this, we will use a subquery to calculate the total treatment cost for each dog.", "The subquery will select dog_id from Treatments, grouping by dog_id and filtering with HAVING to only include those with a total cost greater than 1000.", "The main query will select the names of dogs whose dog_id is not in the result of the subquery."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT name FROM Dogs WHERE dog_id NOT IN (SELECT dog_id FROM Treatments GROUP BY dog_id HAVING SUM(cost_of_treatment) > 1000)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id\"\n    }\n}\n"}
{"sample_id": "dev.937", "db_id": "dog_kennels", "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.", "rationale": ["We need to find the owner who spent the most on treatments for their dogs.", "To do this, we will join the Owners table with the Dogs table using the owner_id to link them.", "Next, we will join the Treatments table with the Dogs table using the dog_id to link treatments to specific dogs.", "We will then group the results by owner_id and last_name to aggregate the treatment costs for each owner.", "Using SUM, we will calculate the total cost of treatments for each owner.", "Finally, we will order the results in descending order based on the total treatment cost and limit the results to 1 to get the owner who spent the most."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT O.owner_id, O.last_name\nFROM Owners AS O\nJOIN Dogs AS D ON O.owner_id = D.owner_id\nJOIN Treatments AS T ON D.dog_id = T.dog_id\nGROUP BY O.owner_id, O.last_name\nORDER BY SUM(T.cost_of_treatment) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id\"\n    }\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "We need to find professionals who have administered treatments, so we will join the Professionals table with the Treatments table on the professional_id.", "We want to count the number of distinct treatment types each professional has done, so we will use COUNT(DISTINCT t.treatment_type_code).", "To ensure we only get professionals who have done at least two types of treatments, we will use the HAVING clause with a condition that the count is greater than or equal to 2.", "Finally, we will select the professional_id and cell_number from the Professionals table."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT p.professional_id, p.cell_number\nFROM Professionals p\nJOIN Treatments t ON p.professional_id = t.professional_id\nGROUP BY p.professional_id\nHAVING COUNT(DISTINCT t.treatment_type_code) >= 2;", "hint": "\n"}
{"sample_id": "dev.943", "db_id": "dog_kennels", "question": "Find the id and cell phone of the professionals who operate two or more types of treatments.", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "We need to find professionals who operate two or more types of treatments, so we will join the Professionals table with the Treatments table on the professional_id.", "We will select the professional_id and cell_number from the Professionals table.", "To find professionals who operate multiple treatment types, we will group the results by professional_id.", "We will use the HAVING clause to filter groups that have a count of distinct treatment_type_code greater than or equal to 2."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT p.professional_id, p.cell_number\nFROM Professionals p\nJOIN Treatments t ON p.professional_id = t.professional_id\nGROUP BY p.professional_id\nHAVING COUNT(DISTINCT t.treatment_type_code) >= 2;", "hint": "\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["Identify the tables needed: Owners and Dogs.", "Determine the fields to select: first_name and last_name from Owners, size_code from Dogs.", "Establish the relationship between the tables: Owners and Dogs are linked by owner_id.", "Construct the SQL query using a JOIN to combine the relevant fields from both tables."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT T1.first_name, T1.last_name, T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    }\n}\n"}
{"sample_id": "dev.954", "db_id": "dog_kennels", "question": "List the names of the dogs of the rarest breed and the treatment dates of them.", "rationale": ["Identify the tables needed: Dogs, Breeds, and Treatments.", "We need to list dog names and treatment dates, so we will select 'name' from Dogs and 'date_of_treatment' from Treatments.", "Join the Dogs table with the Breeds table to filter by breed.", "Join the Treatments table to get the treatment dates for each dog.", "To find the rarest breed, we will use a subquery that counts the number of dogs per breed and orders them by count in ascending order, limiting the result to 1 to get the rarest breed.", "The final query will select the names of dogs and their treatment dates where the breed matches the rarest breed found in the subquery."], "gold_sql": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT D.name, T.date_of_treatment \nFROM Dogs AS D \nJOIN Breeds AS B ON D.breed_code = B.breed_code \nJOIN Treatments AS T ON D.dog_id = T.dog_id \nWHERE B.breed_name = (SELECT B2.breed_name \n                      FROM Breeds AS B2 \n                      JOIN Dogs AS D2 ON B2.breed_code = D2.breed_code \n                      GROUP BY B2.breed_name \n                      ORDER BY COUNT(D2.dog_id) ASC \n                      LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id\"\n    }\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need the arriving and departing dates of dogs, which are in the Dogs table.", "We need to filter the dogs that have gone through treatments, which can be identified by the dog_id in the Treatments table.", "Use a subquery to select dog_ids from the Treatments table and filter the Dogs table based on these ids.", "Select the date_arrived and date_departed columns from the Dogs table."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT date_arrived, date_departed FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id\"\n    }\n}\n"}
{"sample_id": "dev.960", "db_id": "dog_kennels", "question": "List the last name of the owner owning the youngest dog.", "rationale": ["Identify the tables involved: Owners and Dogs.", "We need to find the last name of the owner, so we will select 'last_name' from the Owners table.", "We need to join the Owners table with the Dogs table based on the owner_id.", "To find the youngest dog, we need to filter the results based on the age of the dogs.", "We can use a subquery to find the minimum age of dogs in the Dogs table.", "The final query will select the last name of the owner whose dog has the minimum age."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id WHERE T2.age = (SELECT min(age) FROM Dogs)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    }\n}\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["We need to find distinct combinations of breed types and size types for dogs.", "To achieve this, we will select the breed names from the Breeds table and the size descriptions from the Sizes table.", "The Dogs table will be used to link the breeds and sizes to the specific dogs.", "We will perform JOIN operations between the Dogs table and the Breeds table on the breed_code, and between the Dogs table and the Sizes table on the size_code.", "Finally, we will use DISTINCT to ensure that we only get unique combinations of breed names and size descriptions."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT B.breed_name, S.size_description \nFROM Dogs AS D \nJOIN Breeds AS B ON D.breed_code = B.breed_code \nJOIN Sizes AS S ON D.size_code = S.size_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    }\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["Identify the required information: professional's first name and treatment description.", "Determine the relevant tables: Professionals and Treatment_Types.", "Recognize that the Treatments table links Professionals and Treatment_Types through their respective IDs.", "Use JOIN statements to connect the tables based on the foreign key relationships.", "Select the desired columns from the joined tables."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT Professionals.first_name, Treatment_Types.treatment_type_description\nFROM Treatments\nJOIN Professionals ON Treatments.professional_id = Professionals.professional_id\nJOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code;", "hint": "\n"}
