{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["We need to find out which course has the most number of registered students.", "To do this, we will use the 'Student_Course_Registrations' table, which contains the relationship between students and courses.", "We will count the number of students registered for each course using COUNT(student_id).", "We will group the results by course_id to get the count for each course.", "To find the course with the most registrations, we will order the results in descending order by the count of students (student_count).", "Finally, we will limit the results to 1 to get only the course with the highest number of registered students."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT course_id, COUNT(student_id) AS student_count\nFROM Student_Course_Registrations\nGROUP BY course_id\nORDER BY student_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\"\n}\n"}
{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["The question asks for the IDs of students who attended some courses.", "To find this information, we need to look at the 'Student_Course_Attendance' table, which records attendance of students for various courses.", "We need to select the 'student_id' from this table.", "Since we want unique student IDs, we will use the DISTINCT keyword to avoid duplicates."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["The question asks for the IDs of all students who have attended at least one course.", "To find this information, we need to look at the 'Student_Course_Attendance' table, which records the attendance of students for various courses.", "We will select the 'student_id' from this table.", "Since we want unique student IDs, we will use the DISTINCT keyword to ensure that each student ID is only listed once, even if they attended multiple courses."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["Identify the relevant tables: Candidates and Student_Course_Attendance.", "We need to find the candidate who most recently accessed a course, which implies looking for the latest attendance record.", "The Student_Course_Attendance table contains the student_id and date_of_attendance, so we will order this table by date_of_attendance in descending order to get the most recent attendance.", "We will limit the results to 1 to get only the most recent record.", "Next, we will use the student_id from the most recent attendance to find the corresponding candidate_id in the Candidates table.", "The final query will select the candidate_id from Candidates where the candidate_id matches the student_id from the most recent attendance."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT candidate_id FROM Candidates WHERE candidate_id IN (SELECT student_id FROM Student_Course_Attendance ORDER BY date_of_attendance DESC LIMIT 1)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.77", "db_id": "student_assessment", "question": "What is detail of the student who registered the most number of courses?", "rationale": ["Identify the relevant tables: Students and Student_Course_Registrations.", "Join the Students table with the Student_Course_Registrations table on student_id to link students with their course registrations.", "Group the results by student_id to aggregate the number of courses each student has registered for.", "Count the number of course registrations for each student using COUNT(scr.course_id).", "Order the results in descending order based on the count of course registrations to find the student with the most registrations.", "Limit the results to 1 to get only the student who registered for the most courses."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT s.student_id, s.student_details \nFROM Students s \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nGROUP BY s.student_id \nORDER BY COUNT(scr.course_id) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\"\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["Identify the tables involved: Courses and Student_Course_Registrations.", "We need to count the number of students registered for each course, which requires a join between Courses and Student_Course_Registrations.", "Use a LEFT JOIN to ensure all courses are included, even those with no registrations.", "Select the course_id and course_name from the Courses table, and count the student_id from the Student_Course_Registrations table to get the number of students registered for each course.", "Group the results by course_id and course_name to aggregate the student counts correctly."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT Courses.course_id, COUNT(Student_Course_Registrations.student_id) AS student_count, Courses.course_name \nFROM Courses \nLEFT JOIN Student_Course_Registrations ON Courses.course_id = Student_Course_Registrations.course_id \nGROUP BY Courses.course_id, Courses.course_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\"\n}\n"}
{"sample_id": "train.90", "db_id": "student_assessment", "question": "What are the ids of the students who registered for course 301 most recently?", "rationale": ["Identify the relevant table: Student_Course_Registrations contains the information about student registrations for courses.", "Filter the records to only include those where the course_id is '301'.", "Order the results by registration_date in descending order to get the most recent registration first.", "Limit the results to 1 to get only the most recent student registration for course 301."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["We need to find distinct cities of addresses associated with students.", "To do this, we will need to join the Addresses table with the People_Addresses table to link addresses to people.", "Next, we will join the resulting table with the Students table to filter for only those people who are students.", "Finally, we will select the distinct cities from the Addresses table."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "pred_sql": "SELECT DISTINCT a.city\nFROM Addresses a\nJOIN People_Addresses pa ON a.address_id = pa.address_id\nJOIN Students s ON pa.person_id = s.student_id;", "hint": "\n"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["We need to find students who registered for courses but did not attend any.", "To do this, we will use a LEFT JOIN between the Students table and the Student_Course_Registrations table to get all students who have registered for courses.", "Next, we will perform another LEFT JOIN with the Student_Course_Attendance table to check if these students attended any courses.", "In the WHERE clause, we will filter for students who have a registration (scr.student_id IS NOT NULL) but do not have any attendance records (sca.student_id IS NULL).", "Finally, we will select the relevant details from the Students table."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "pred_sql": "SELECT s.student_id, s.student_details \nFROM Students s \nLEFT JOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nLEFT JOIN Student_Course_Attendance sca ON scr.student_id = sca.student_id AND scr.course_id = sca.course_id \nWHERE scr.student_id IS NOT NULL AND sca.student_id IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\"\n}\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant table: 'Student_Course_Registrations' contains the registration details of students for courses.", "Filter the records to only include those where the course_id corresponds to the course 'Statistics'.", "To find the course_id for 'Statistics', a subquery is used to select it from the 'Courses' table.", "Finally, order the results by the 'registration_date' to get the students in the order they registered."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant table: 'Student_Course_Registrations' contains the information about student registrations for courses.", "Filter the registrations to only include those for the course 'Statistics'.", "Select the 'student_id' from the filtered results.", "Order the results by 'registration_date' to get the ids in the order of registration."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.123", "db_id": "bike_1", "question": "For each zip code, return the average mean temperature of August there.", "rationale": ["Identify the relevant table: The 'weather' table contains the temperature data and zip codes.", "Determine the required fields: We need the 'zip_code' and the average of 'mean_temperature_f'.", "Filter the data for August: We will filter the records where the date falls between '2023-08-01' and '2023-08-31'.", "Group the results by zip code: To get the average temperature for each zip code, we will use GROUP BY on 'zip_code'.", "Calculate the average: Use the AVG() function to compute the average mean temperature for each zip code."], "gold_sql": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE '8/%' GROUP BY zip_code", "source_tables": ["weather"], "pred_sql": "SELECT zip_code, AVG(mean_temperature_f) AS average_mean_temperature\nFROM weather\nWHERE date BETWEEN '2023-08-01' AND '2023-08-31'\nGROUP BY zip_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\"\n}\n"}
{"sample_id": "train.135", "db_id": "bike_1", "question": "Which bike traveled the most often in zip code 94002?", "rationale": ["Identify the relevant table: The 'trip' table contains information about bike trips, including the bike ID and zip code.", "Filter trips by zip code: We need to focus on trips that started in the zip code 94002, so we will add a WHERE clause to filter by zip_code.", "Count the number of trips for each bike: We will use the COUNT function to count how many times each bike_id appears in the filtered results.", "Group the results by bike_id: To get the count of trips for each bike, we will use GROUP BY bike_id.", "Order the results: We want to find the bike that traveled the most often, so we will order the results in descending order based on the trip count.", "Limit the results to one: Since we only want the bike that traveled the most often, we will use LIMIT 1 to get the top result."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id, COUNT(*) AS trip_count\nFROM trip\nWHERE zip_code = '94002'\nGROUP BY bike_id\nORDER BY trip_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.136", "db_id": "bike_1", "question": "What is the id of the bike that traveled the most in 94002?", "rationale": ["Identify the relevant table: The 'trip' table contains information about bike trips, including the bike identifier and the duration of each trip.", "Filter trips by zip code: We need to focus on trips that started in the zip code '94002'.", "Sort trips by duration: To find the bike that traveled the most, we will sort the trips in descending order based on the duration.", "Select the bike_id: We want to retrieve the bike identifier for the trip with the longest duration.", "Limit the results: Since we only need the bike that traveled the most, we will limit the results to 1."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id\nFROM trip\nWHERE zip_code = '94002'\nORDER BY duration DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.143", "db_id": "bike_1", "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?", "rationale": ["We need to select the names and ids of stations.", "The relevant tables are 'station' and 'status'.", "We will join the 'station' table with the 'status' table on the station id.", "We need to calculate the average number of bikes available at each station, which requires grouping by the station id.", "We will use the HAVING clause to filter for stations with an average of more than 14 bikes available.", "Additionally, we need to check if the installation date of the station falls in December, which can be done using the strftime function to extract the month from the installation_date."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT s.name, s.id \nFROM station s \nJOIN status st ON s.id = st.station_id \nGROUP BY s.id \nHAVING AVG(st.bikes_available) > 14 OR strftime('%m', s.installation_date) = '12';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\"\n}\n"}
{"sample_id": "train.144", "db_id": "bike_1", "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "rationale": ["Identify the relevant tables: 'station' and 'status'.", "We need to retrieve the names and ids of stations, so we will select 's.name' and 's.id' from the 'station' table.", "To find stations with more than 14 bikes available on average, we will join the 'station' table with the 'status' table on 'station.id' and 'status.station_id'.", "We will group the results by 's.id' to calculate the average number of bikes available for each station.", "We will use the HAVING clause to filter the results where the average number of bikes available is greater than 14.", "Additionally, we need to check if the station was installed in December, which can be done by checking if 's.installation_date' contains '-12-' (indicating December).", "Combine the conditions in the HAVING clause using OR to meet either of the criteria."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT s.name, s.id \nFROM station s \nJOIN status st ON s.id = st.station_id \nGROUP BY s.id \nHAVING AVG(st.bikes_available) > 14 \n   OR s.installation_date LIKE '%-12-%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\"\n}\n"}
{"sample_id": "train.145", "db_id": "bike_1", "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?", "rationale": ["Identify the relevant table: The question pertains to cloud cover rates, which are found in the 'weather' table.", "Filter by zip code: We need to focus on records where the zip code is 94107.", "Group by cloud cover: To find the most common cloud cover rates, we will group the results by the 'cloud_cover' column.", "Count occurrences: We will count how many times each cloud cover rate appears using COUNT(cloud_cover).", "Order results: To find the most common rates, we will order the results in descending order based on the count.", "Limit results: Finally, we will limit the results to the top 3 most common cloud cover rates."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "pred_sql": "SELECT cloud_cover, COUNT(cloud_cover) AS count\nFROM weather\nWHERE zip_code = 94107\nGROUP BY cloud_cover\nORDER BY count DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\"\n}\n"}
{"sample_id": "train.161", "db_id": "bike_1", "question": "For each trip, return its ending station's installation date.", "rationale": ["Identify the relevant tables: We need data from the 'trip' table for the trips and the 'station' table for the installation dates of the ending stations.", "Determine the relationship: The 'end_station_id' in the 'trip' table corresponds to the 'id' in the 'station' table.", "Construct the SQL query: We will select the 'installation_date' from the 'station' table and join it with the 'trip' table on the 'end_station_id' to get the installation date for each trip's ending station."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.installation_date \nFROM trip t \nJOIN station s ON t.end_station_id = s.id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.162", "db_id": "bike_1", "question": "What is the installation date for each ending station on all the trips?", "rationale": ["Identify the relevant tables: We need data from the 'trip' table for the ending stations and the 'station' table for the installation dates.", "Determine the columns needed: We need the 'installation_date' from the 'station' table and the 'end_station_name' from the 'trip' table.", "Establish the relationship: The 'end_station_id' in the 'trip' table corresponds to the 'id' in the 'station' table, which allows us to join these two tables.", "Construct the SQL query: Use a SELECT statement to retrieve the installation date and end station name, and perform an INNER JOIN between the 'trip' and 'station' tables based on the station IDs."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.installation_date, t.end_station_name \nFROM trip t \nJOIN station s ON t.end_station_id = s.id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.163", "db_id": "bike_1", "question": "Which trip started from the station with the largest dock count? Give me the trip id.", "rationale": ["Identify the relevant tables: We need to look at the 'trip' table for trip details and the 'station' table for dock counts.", "Determine the relationship: The 'trip' table has a 'start_station_id' that corresponds to the 'id' in the 'station' table.", "Find the station with the largest dock count: We can use a subquery to find the maximum dock count from the 'station' table.", "Join the tables: We will join the 'trip' table with the 'station' table on the 'start_station_id' and 'id' fields.", "Select the trip id: Finally, we will select the 'id' from the 'trip' table where the dock count matches the maximum dock count found in the subquery."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "pred_sql": "SELECT trip.id \nFROM trip \nJOIN station ON trip.start_station_id = station.id \nWHERE station.dock_count = (SELECT MAX(dock_count) FROM station);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.165", "db_id": "bike_1", "question": "Count the number of trips that did not end in San Francisco city.", "rationale": ["Identify the requirement to count trips that did not end in San Francisco.", "To achieve this, we need to filter trips based on their end station.", "We will use a subquery to find all station IDs that are located in San Francisco.", "The subquery will select the 'id' from the 'station' table where the 'city' is 'San Francisco'.", "The main query will count all trips where the 'end_station_id' is not in the list of IDs returned by the subquery."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) AS trip_count \nFROM trip \nWHERE end_station_id NOT IN (\n    SELECT id \n    FROM station \n    WHERE city = 'San Francisco'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.166", "db_id": "bike_1", "question": "How many trips did not end in San Francisco?", "rationale": ["Identify the relevant table: The 'trip' table contains information about trips, including the end station name.", "Determine the condition: We need to count trips that did not end in San Francisco, which means we will filter the results where the 'end_station_name' is not equal to 'San Francisco'.", "Use the COUNT function: To get the total number of trips that meet the condition, we will use the COUNT(*) function.", "Construct the SQL query: Combine the SELECT statement with the FROM clause and the WHERE condition to form the complete SQL query."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != 'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) AS trip_count \nFROM trip \nWHERE end_station_name != 'San Francisco';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.167", "db_id": "bike_1", "question": "In zip code 94107, on which day neither Fog nor Rain was not observed?", "rationale": ["Identify the relevant table: The question pertains to weather conditions, so we will use the 'weather' table.", "Filter by zip code: We need to focus on records where the zip code is 94107.", "Exclude specific weather events: We need to ensure that the events do not include 'Fog' or 'Rain'.", "Select distinct dates: We want to find unique dates that meet the criteria, so we will use SELECT DISTINCT to avoid duplicates."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT date FROM weather WHERE zip_code = 94107 AND events NOT LIKE '%Fog%' AND events NOT LIKE '%Rain%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\"\n}\n"}
{"sample_id": "train.168", "db_id": "bike_1", "question": "On which day has it neither been foggy nor rained in the zip code of 94107?", "rationale": ["Identify the relevant table: The 'weather' table contains the necessary information about weather conditions including precipitation and events.", "Filter by zip code: We need to focus on the records where the zip code is 94107.", "Check for no rain: We will filter out any records where precipitation_inches is greater than 0, indicating rain.", "Check for no fog: We will also filter out any records where events indicate fog (assuming events = 0 means no weather events).", "Combine these conditions in the WHERE clause to get the desired dates."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT date FROM weather WHERE zip_code = 94107 AND precipitation_inches = 0 AND events = 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\"\n}\n"}
{"sample_id": "train.183", "db_id": "bike_1", "question": "List all the cities in a decreasing order of each city's stations' highest latitude.", "rationale": ["We need to list all the cities from the 'station' table.", "To find the highest latitude for each city, we will use the MAX function on the 'lat' column.", "We will group the results by 'city' to ensure we get the highest latitude for each city.", "Finally, we will order the results in decreasing order of the highest latitude using ORDER BY clause."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, MAX(lat) AS highest_latitude\nFROM station\nGROUP BY city\nORDER BY highest_latitude DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.184", "db_id": "bike_1", "question": "For each city, list their names in decreasing order by their highest station latitude.", "rationale": ["We need to select the city and name of the stations from the 'station' table.", "The requirement is to list the names of the stations for each city.", "To meet the requirement of ordering by the highest latitude, we will use the 'lat' column from the 'station' table.", "We will order the results in decreasing order, which is achieved by using 'ORDER BY lat DESC'."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, name FROM station ORDER BY lat DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.189", "db_id": "bike_1", "question": "For each station, return its longitude and the average duration of trips that started from the station.", "rationale": ["We need to select the longitude of each station and the average duration of trips that started from that station.", "The 'station' table contains the longitude information, while the 'trip' table contains the duration of trips and the starting station ID.", "To get the average duration of trips for each station, we will join the 'station' table with the 'trip' table on the station ID.", "We will use the AVG() function to calculate the average duration of trips for each station.", "Finally, we will group the results by the station ID to ensure we get the average duration for each individual station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.long, AVG(t.duration) AS average_duration\nFROM station s\nJOIN trip t ON s.id = t.start_station_id\nGROUP BY s.id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.190", "db_id": "bike_1", "question": "For each start station id, what is its name, longitude and average duration of trips started there?", "rationale": ["Identify the relevant tables: 'trip' for trip details and 'station' for station details.", "We need to select the start station id, station name, longitude, and average duration of trips.", "Join the 'trip' table with the 'station' table on the start station id to get the station details.", "Use the AVG() function to calculate the average duration of trips for each start station.", "Group the results by start station id, station name, and longitude to get the average duration for each station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT trip.start_station_id, station.name, station.long, AVG(trip.duration) AS average_duration\nFROM trip\nJOIN station ON trip.start_station_id = station.id\nGROUP BY trip.start_station_id, station.name, station.long;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.192", "db_id": "bike_1", "question": "For each end station id, what is its name, latitude, and minimum duration for trips ended there?", "rationale": ["Identify the relevant tables: 'station' for station details and 'trip' for trip details.", "We need to select the end station id, name, latitude, and the minimum duration of trips that ended at each station.", "Join the 'station' table with the 'trip' table on the end station id to get the necessary details.", "Use the MIN() function to find the minimum duration of trips for each end station.", "Group the results by the end station id, name, and latitude to aggregate the minimum duration correctly."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.id AS end_station_id, s.name, s.lat, MIN(t.duration) AS min_duration\nFROM station s\nJOIN trip t ON s.id = t.end_station_id\nGROUP BY s.id, s.name, s.lat;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.196", "db_id": "bike_1", "question": "What are all the different zip codes that have a maximum dew point that was always below 70?", "rationale": ["We need to find all distinct zip codes where the maximum dew point was always below 70.", "To do this, we can select distinct zip codes from the weather table.", "We will use a subquery to filter out any zip codes that have a maximum dew point of 70 or above.", "The subquery selects zip codes from the weather table where the max_dew_point_f is greater than or equal to 70.", "The main query then selects distinct zip codes that are not in the result of the subquery."], "gold_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT zip_code \nFROM weather \nWHERE zip_code NOT IN (\n    SELECT zip_code \n    FROM weather \n    WHERE max_dew_point_f >= 70\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\"\n}\n"}
{"sample_id": "train.205", "db_id": "bike_1", "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.", "rationale": ["We need to find zip codes where the average mean humidity is below 70 and at least 100 trips took place.", "To achieve this, we will join the 'trip' table with the 'weather' table on the date of the trip and the date of the weather report.", "We will group the results by 'zip_code' to calculate the average mean humidity and count the number of trips for each zip code.", "The HAVING clause will filter the results to only include those zip codes where the average mean humidity is less than 70 and the count of trips is at least 100."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code FROM trip\nJOIN weather ON trip.start_date LIKE weather.date || '%'\nGROUP BY zip_code\nHAVING AVG(mean_humidity) < 70 AND COUNT(trip.id) >= 100;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\"\n}\n"}
{"sample_id": "train.206", "db_id": "bike_1", "question": "What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?", "rationale": ["Identify the relevant tables: We need to use the 'trip' table to count the number of trips per zip code and the 'weather' table to calculate the average mean humidity per zip code.", "We need to group the results by zip code to calculate the average mean humidity and count the number of trips for each zip code.", "Use the HAVING clause to filter the results: we want zip codes with at least 100 trips and an average mean humidity below 70.", "Select the zip_code from the trip table, group by zip_code, and apply the necessary conditions in the HAVING clause."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code\nFROM trip\nGROUP BY zip_code\nHAVING COUNT(id) >= 100 AND AVG(mean_humidity) < 70;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\"\n}\n"}
{"sample_id": "train.304", "db_id": "product_catalog", "question": "What are the attribute data types with more than 3 attribute definitions?", "rationale": ["Identify the table that contains the attribute definitions, which is 'Attribute_Definitions'.", "We need to select the 'attribute_data_type' from this table.", "To find the data types with more than 3 definitions, we will group the results by 'attribute_data_type'.", "We will use the HAVING clause to filter groups that have a count of 'attribute_id' greater than 3."], "gold_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  3", "source_tables": ["attribute_definitions"], "pred_sql": "SELECT attribute_data_type\nFROM Attribute_Definitions\nGROUP BY attribute_data_type\nHAVING COUNT(attribute_id) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\"\n}\n"}
{"sample_id": "train.316", "db_id": "product_catalog", "question": "Find the entry names of the catalog with the attribute that have the most entries.", "rationale": ["Identify the relevant tables: We need to find entry names from the 'Catalog_Contents' table that are associated with additional attributes in the 'Catalog_Contents_Additional_Attributes' table.", "Join the tables: We will join 'Catalog_Contents' and 'Catalog_Contents_Additional_Attributes' on 'catalog_entry_id' to link entries with their attributes.", "Group by entry names: We will group the results by 'catalog_entry_name' to count how many attributes each entry has.", "Count the attributes: Use COUNT() to count the number of entries for each catalog entry name.", "Order the results: We will order the results in descending order based on the count of attributes to find the entry with the most attributes.", "Limit the results: Finally, we will limit the results to 1 to get the entry name with the most attributes."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT cc.catalog_entry_name\nFROM Catalog_Contents cc\nJOIN Catalog_Contents_Additional_Attributes cca ON cc.catalog_entry_id = cca.catalog_entry_id\nGROUP BY cc.catalog_entry_name\nORDER BY COUNT(cca.catalog_entry_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\"\n}\n"}
{"sample_id": "train.317", "db_id": "product_catalog", "question": "What is the entry name of the most expensive catalog (in USD)?", "rationale": ["Identify the relevant tables: We need to find the catalog entry name and the price in USD, so we will use the Catalog_Contents and Catalogs tables.", "Join the Catalog_Contents table with the Catalogs table on the catalog_id to access the catalog information.", "Order the results by price_in_dollars in descending order to get the most expensive catalog entry.", "Limit the results to 1 to get only the most expensive entry."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1", "source_tables": ["catalog_contents"], "pred_sql": "SELECT cc.catalog_entry_name\nFROM Catalog_Contents cc\nJOIN Catalogs c ON cc.catalog_level_number = c.catalog_id\nORDER BY CAST(cc.price_in_dollars AS REAL) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\"\n}\n"}
{"sample_id": "train.330", "db_id": "product_catalog", "question": "What are the names of catalog entries with level number 8?", "rationale": ["Identify the table that contains the catalog entry names, which is the 'Catalog_Contents' table.", "Determine the relevant column for filtering, which is 'catalog_level_number'.", "Specify the level number we are interested in, which is '8'.", "Construct the SQL query to select 'catalog_entry_name' from 'Catalog_Contents' where 'catalog_level_number' equals '8'."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  '8'", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE catalog_level_number = '8';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\"\n}\n"}
{"sample_id": "train.331", "db_id": "product_catalog", "question": "Find the names of the products with length smaller than 3 or height greater than 5.", "rationale": ["Identify the table that contains product information, which is the Catalog_Contents table.", "Determine the relevant columns needed for the query: catalog_entry_name for product names, length for the length condition, and height for the height condition.", "Construct the SELECT statement to retrieve the catalog_entry_name from the Catalog_Contents table.", "Add a WHERE clause to filter products based on the conditions: length smaller than 3 or height greater than 5."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name \nFROM Catalog_Contents \nWHERE length < 3 OR height > 5;", "hint": "\n"}
{"sample_id": "train.332", "db_id": "product_catalog", "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.", "rationale": ["Identify the relevant table: The question asks about catalog contents, which are stored in the 'Catalog_Contents' table.", "Determine the relevant columns: We need the 'catalog_entry_name' and the 'length' of the catalog contents.", "Formulate the condition: The question specifies that we are interested in lengths that are either below 3 or above 5.", "Construct the SQL query: We will select the 'catalog_entry_name' from 'Catalog_Contents' where the 'length' meets the specified conditions."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE length < 3 OR length > 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\"\n}\n"}
{"sample_id": "train.338", "db_id": "product_catalog", "question": "On which days more than one revisions were made on catalogs.", "rationale": ["Identify the relevant table: The question pertains to revisions of catalogs, so we will focus on the 'Catalogs' table.", "Determine the columns needed: We need the 'date_of_publication' to group the revisions by date and 'date_of_latest_revision' to count the number of revisions.", "Group the results: We will group the results by 'date_of_publication' to count how many revisions occurred on each date.", "Count the revisions: Use COUNT() to count the number of revisions for each publication date.", "Filter the results: Use HAVING to filter the results to only include dates where the count of revisions is greater than one."], "gold_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1", "source_tables": ["catalogs"], "pred_sql": "SELECT date_of_publication, COUNT(date_of_latest_revision) AS revision_count\nFROM Catalogs\nGROUP BY date_of_publication\nHAVING revision_count > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\"\n}\n"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flight origins and destinations.", "Determine the required information: We need the origins of flights that are headed to Honolulu.", "Construct the SQL query: Use SELECT to get distinct origins from the flight table where the destination is 'Honolulu'."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT DISTINCT origin FROM flight WHERE destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the required columns: We need the 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We want flights that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query: Use a SELECT statement to retrieve the specified columns from the 'flight' table with the appropriate WHERE clause."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their prices.", "Determine the columns needed: We need the 'price' column to calculate the average price.", "Specify the conditions: We want flights that originate from 'LA' and have 'Honolulu' as their destination.", "Use the AVG() function: This function will calculate the average of the 'price' column for the filtered results."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT AVG(price) AS average_price FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["Identify the tables needed: We need data from the 'aircraft' table for aircraft names and the 'flight' table for counting flights.", "We will use a LEFT JOIN to connect the 'aircraft' table with the 'flight' table on the aircraft ID (aid) since we want to include all aircraft even if they have no flights.", "Select the aircraft name from the 'aircraft' table and count the flight numbers from the 'flight' table, grouping by aircraft ID and name to get the number of flights for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT a.name, COUNT(f.flno) AS number_of_flights\nFROM aircraft a\nLEFT JOIN flight f ON a.aid = f.aid\nGROUP BY a.aid, a.name;", "hint": "\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables involved: We need information from the 'aircraft' table for aircraft names and the 'flight' table for counting flights.", "We need to count the number of flights for each aircraft, which suggests using a COUNT function.", "To relate the two tables, we will use a LEFT JOIN on the 'aid' column, which is common to both tables.", "We will group the results by the aircraft ID ('aid') to ensure we get a count of flights for each aircraft.", "Select the aircraft name and the count of flights, labeling the count as 'flight_count'."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT a.name, COUNT(f.flno) AS flight_count\nFROM aircraft a\nLEFT JOIN flight f ON a.aid = f.aid\nGROUP BY a.aid;", "hint": "\n"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["Identify the main table to query from, which is the 'employee' table to get employee names.", "We need to find employees who are not certified to fly a specific aircraft, in this case, the 'Boeing 737-800'.", "To find certified employees, we will use the 'certificate' table and join it with the 'aircraft' table to filter by aircraft name.", "The subquery will select employee IDs (eid) from the 'certificate' table where the associated aircraft is 'Boeing 737-800'.", "The main query will select names from the 'employee' table where the employee ID is not in the list of IDs returned by the subquery."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.name \nFROM employee e \nWHERE e.eid NOT IN (\n    SELECT c.eid \n    FROM certificate c \n    JOIN aircraft a ON c.aid = a.aid \n    WHERE a.name = 'Boeing 737-800'\n);", "hint": "\n"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["We need to find the name of the aircraft with the fewest number of certificates held by employees.", "To do this, we will join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid).", "We will group the results by the aircraft ID to count the number of certificates for each aircraft.", "Next, we will order the results by the count of certificates in ascending order to get the aircraft with the fewest certificates at the top.", "Finally, we will limit the results to just one entry to get the aircraft with the fewest certificates."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nORDER BY COUNT(c.eid) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.432", "db_id": "flight_1", "question": "What are the names of the aircraft that the least people are certified to fly?", "rationale": ["We need to find the names of aircraft with the least number of certified pilots.", "To do this, we will join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid).", "We will group the results by the aircraft ID to count how many employees are certified for each aircraft.", "We will use the HAVING clause to filter the results to only include those aircraft that have the minimum count of certified employees.", "To find the minimum count, we will use a subquery that counts the number of certifications for each aircraft and selects the minimum count from that result."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nHAVING COUNT(c.eid) = (\n    SELECT MIN(cert_count)\n    FROM (\n        SELECT COUNT(eid) AS cert_count\n        FROM certificate\n        GROUP BY aid\n    ) AS counts\n);", "hint": "\n"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["Identify the relevant tables: employee, certificate, and aircraft.", "We need to find employees who have certificates to fly aircraft with a distance greater than 5000.", "Join the employee table with the certificate table on employee ID (eid) and then join with the aircraft table on aircraft ID (aid).", "Filter the results to include only those aircraft where the distance is greater than 5000.", "Group the results by employee ID to count the number of certificates each employee has.", "Order the results by the count of certificates in descending order to find the employee with the most certificates.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.salary, e.name \nFROM employee e \nJOIN certificate c ON e.eid = c.eid \nJOIN aircraft a ON c.aid = a.aid \nWHERE a.distance > 5000 \nGROUP BY e.eid \nORDER BY COUNT(c.aid) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The question asks for all the different food allergies, which implies we need to retrieve unique allergy names.", "We will use the 'Allergy' column from the 'Allergy_Type' table to get the list of allergies.", "Using SELECT DISTINCT will ensure that we only get unique allergy names without duplicates."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Allergy_Type;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.452", "db_id": "allergy_1", "question": "How many animal type allergies exist?", "rationale": ["Identify the relevant table: Allergy_Type contains the allergy types.", "Determine the specific allergy type we are interested in: 'Animal'.", "Use COUNT(DISTINCT Allergy) to count the unique allergies of the specified type.", "Construct the SQL query to select the count from the Allergy_Type table where the AllergyType is 'Animal'."], "gold_sql": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  'animal'", "source_tables": ["allergy_type"], "pred_sql": "SELECT COUNT(DISTINCT Allergy) AS Animal_Allergy_Count \nFROM Allergy_Type \nWHERE AllergyType = 'Animal';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["Identify the relevant table: The Allergy_Type table contains the allergy names and their types.", "Count the number of allergies for each type: Use COUNT(Allergy) to count how many allergies belong to each AllergyType.", "Group the results by AllergyType: Use GROUP BY AllergyType to aggregate the counts for each type.", "Order the results by the count in descending order: Use ORDER BY AllergyCount DESC to get the types with the most allergies first.", "Limit the results to the top entry: Use LIMIT 1 to get only the allergy type with the highest count."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(Allergy) AS AllergyCount \nFROM Allergy_Type \nGROUP BY AllergyType \nORDER BY AllergyCount DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["Identify the relevant tables: Allergy_Type and Has_Allergy.", "We need to find the least common allergy type, which requires counting occurrences of each allergy in the Has_Allergy table.", "Group the results by Allergy to count how many students have each allergy.", "Order the results by the count in ascending order to find the least common allergy.", "Limit the results to 1 to get only the least common allergy.", "Join the result with the Allergy_Type table to get the corresponding AllergyType for the least common allergy."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType FROM Allergy_Type WHERE Allergy IN (SELECT Allergy FROM Has_Allergy GROUP BY Allergy ORDER BY COUNT(*) ASC LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student names, which is the 'Student' table.", "To get the full names, we need to concatenate the 'Fname' and 'LName' columns.", "Use the SQL SELECT statement to retrieve the concatenated names from the 'Student' table."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName FROM Student;", "hint": "\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the table needed: The 'Student' table contains the information about students, including their gender and unique identifiers.", "Determine the condition: We need to filter the students based on their gender, specifically for male students.", "Construct the SQL query: Use a SELECT statement to retrieve the 'StuID' from the 'Student' table where the 'Sex' column equals 'Male'."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the majors, which is the 'Student' table.", "We need to group the results by the 'Major' column to count how many students are in each major.", "Use the COUNT function to count the number of students (StuID) for each major.", "Order the results in descending order based on the count of students to find the largest major.", "Limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(StuID) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major and ordered by the number of students in each major in descending order. The placeholder in the LIMIT clause represents the maximum number of majors to return.\"\n}\n"}
{"sample_id": "train.502", "db_id": "allergy_1", "question": "Give the advisor with the most students.", "rationale": ["Identify the relevant table: The 'Student' table contains the 'Advisor' and 'StuID' columns needed for this query.", "Count the number of students for each advisor: Use COUNT(StuID) to count the number of students associated with each advisor.", "Group the results by advisor: Use GROUP BY Advisor to aggregate the student counts for each advisor.", "Order the results: Use ORDER BY StudentCount DESC to sort the advisors by the number of students in descending order.", "Limit the results to the top advisor: Use LIMIT 1 to return only the advisor with the most students."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(StuID) AS StudentCount\nFROM Student\nGROUP BY Advisor\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of academic advisors from the 'Student' table, grouped by the advisor's name. The results are ordered by the number of students assigned to each advisor in descending order, with a limit on the number of advisors returned, specified by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["Identify the relevant tables: We need to find information about students and their allergies, so we will use the Has_Allergy table which links students to their allergies.", "Determine the specific allergy: The question asks about students with cat allergies, so we will filter for 'cat' in the Allergy column.", "Count the distinct students: We need to count how many unique students have this allergy, which means we will use COUNT(DISTINCT StuID) to avoid counting the same student multiple times if they have multiple entries.", "Construct the SQL query: We will select the count from the Has_Allergy table where the Allergy is 'cat'."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(DISTINCT Has_Allergy.StuID) AS StudentCount\nFROM Has_Allergy\nWHERE Allergy = 'cat';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the relevant tables: We need to find students with cat allergies, so we will use the Has_Allergy table.", "Count the unique students: We want to count how many distinct students have the allergy, so we will use COUNT(DISTINCT StuID).", "Filter by allergy type: We need to filter the results to only include those with 'cat' allergies, which we can do in the WHERE clause.", "Construct the SQL query: Combine the elements into a complete SQL query that counts the distinct student IDs from the Has_Allergy table where the allergy is 'cat'."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(DISTINCT Has_Allergy.StuID) AS StudentCount\nFROM Has_Allergy\nWHERE Allergy = 'cat';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["We need to count the number of female students with specific allergies (milk or eggs).", "To do this, we will join the Student table with the Has_Allergy table on the StuID column, which is the unique identifier for students.", "We will filter the results to include only female students by adding a condition in the WHERE clause: Student.Sex = 'Female'.", "Next, we will specify the allergies we are interested in, which are 'Milk' and 'Eggs', using the IN clause in the WHERE condition: Has_Allergy.Allergy IN ('Milk', 'Eggs').", "Finally, we will use COUNT(DISTINCT Student.StuID) to ensure we count each student only once, even if they have multiple allergies."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Student.Sex = 'Female' \nAND Has_Allergy.Allergy IN ('Milk', 'Eggs');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.514", "db_id": "allergy_1", "question": "Which allergy is the most common?", "rationale": ["Identify the relevant tables: We need to look at the 'Has_Allergy' table to find out which allergies are present.", "Count the occurrences of each allergy: We will use the COUNT function to count how many times each allergy appears in the 'Has_Allergy' table.", "Group the results by allergy: We will use GROUP BY to group the results by the 'Allergy' column.", "Order the results by count: To find the most common allergy, we will order the results in descending order based on the count of allergies.", "Limit the results to one: We will use LIMIT 1 to get only the most common allergy."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT Allergy, COUNT(*) as AllergyCount\nFROM Has_Allergy\nGROUP BY Allergy\nORDER BY AllergyCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["We need to find students who have allergies to both milk and cat.", "To do this, we will join the Student table with the Has_Allergy table twice: once for each allergy.", "The first join (HA1) will filter for students with a milk allergy, and the second join (HA2) will filter for students with a cat allergy.", "We will select the last name (LName) and age (Age) of these students.", "The final SQL query will include the necessary SELECT, FROM, and JOIN clauses, along with the appropriate WHERE conditions."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.LName, S.Age \nFROM Student S \nJOIN Has_Allergy HA1 ON S.StuID = HA1.StuID \nJOIN Has_Allergy HA2 ON S.StuID = HA2.StuID \nWHERE HA1.Allergy = 'milk' AND HA2.Allergy = 'cat';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the required information: last names and ages of students with specific allergies (milk and cat).", "Determine the relevant tables: Student and Has_Allergy, since we need student details and their allergies.", "Join the Student table with the Has_Allergy table on the StuID to link students with their allergies.", "Filter the results to include only those students who have both allergies (milk and cat).", "Use the IN clause to specify the allergies of interest.", "Group the results by student ID to ensure we can count the distinct allergies for each student.", "Use HAVING to ensure that only students with both allergies are included in the final result."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Student.LName, Student.Age \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat') \nGROUP BY Student.StuID \nHAVING COUNT(DISTINCT Has_Allergy.Allergy) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.523", "db_id": "allergy_1", "question": "Find the first name and gender of the student who has allergy to milk but not cat.", "rationale": ["We need to find students who have an allergy to milk but not to cat.", "First, we will select the first name and gender of the students from the Student table.", "We will join the Has_Allergy table to find students with specific allergies.", "We will also join the Allergy_Type table to filter by the specific allergy names (milk and cat).", "We will use a WHERE clause to filter for students who have an allergy to milk.", "To ensure they do not have an allergy to cat, we will use a subquery that selects students with a cat allergy and exclude them from our main query using NOT IN."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.Fname, S.Sex \nFROM Student S \nJOIN Has_Allergy HA1 ON S.StuID = HA1.StuID \nJOIN Allergy_Type AT1 ON HA1.Allergy = AT1.Allergy \nWHERE AT1.Allergy = 'milk' \nAND S.StuID NOT IN (\n    SELECT HA2.StuID \n    FROM Has_Allergy HA2 \n    JOIN Allergy_Type AT2 ON HA2.Allergy = AT2.Allergy \n    WHERE AT2.Allergy = 'cat'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.524", "db_id": "allergy_1", "question": "What are the first name and gender of the students who have allergy to milk but can put up with cats?", "rationale": ["Identify the required fields: first name and gender of students.", "Determine the relevant tables: Student and Has_Allergy.", "Join the Student table with the Has_Allergy table on StuID to link students with their allergies.", "Filter the results to include only those students who have an allergy to 'milk'.", "Add a condition to exclude students who have an allergy to 'cats' using a subquery that selects StuIDs from Has_Allergy where the allergy is 'cats'."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Student.Fname, Student.Sex \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy = 'milk' \nAND Student.StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'cats'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the tables needed: We need to get student information (age) and their allergies, so we will use the Student, Has_Allergy, and Allergy_Type tables.", "Join the tables: We will join the Student table with the Has_Allergy table on StuID, and then join the Has_Allergy table with the Allergy_Type table on Allergy.", "Filter the allergies: We need to filter the allergies to only include those that are of type 'food' or 'animal'.", "Calculate the average age: We will use the AVG function on the Age column from the Student table, ensuring to cast it to an integer for accurate calculation."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT AVG(CAST(S.Age AS INTEGER)) AS Average_Age\nFROM Student S\nJOIN Has_Allergy HA ON S.StuID = HA.StuID\nJOIN Allergy_Type AT ON HA.Allergy = AT.Allergy\nWHERE AT.AllergyType IN ('food', 'animal');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["We need to find students who are not allergic to any type of food.", "To do this, we will first identify students who have food allergies by joining the Has_Allergy table with the Allergy_Type table.", "We will filter the allergies to only include those that are categorized as 'Food'.", "Next, we will select the unique student IDs (StuID) from this result set.", "Finally, we will select the full names (first name and last name) of students from the Student table whose StuID is not in the list of students with food allergies."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName \nFROM Student \nWHERE StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    JOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy \n    WHERE AllergyType = 'Food'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["Identify the relevant tables: Student, Has_Allergy, and Allergy_Type.", "We need to count the number of male students, so we will filter the Student table by Sex = 'M'.", "We need to find students with allergies, so we will join the Has_Allergy table on StuID.", "To filter for food allergies, we will join the Allergy_Type table on Allergy and filter by AllergyType = 'Food'.", "Finally, we will use COUNT(DISTINCT s.StuID) to get the number of unique male students with food allergies."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT COUNT(DISTINCT s.StuID) \nFROM Student s \nJOIN Has_Allergy ha ON s.StuID = ha.StuID \nJOIN Allergy_Type at ON ha.Allergy = at.Allergy \nWHERE s.Sex = 'M' AND at.AllergyType = 'Food';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables involved: We need to get student information and their allergies, so we will use the Student and Has_Allergy tables.", "Determine the columns needed: We need the first names (Fname) and city codes (city_code) of the students.", "Establish the relationship: We will join the Student table with the Has_Allergy table on the StuID column, which is common to both tables.", "Filter the results: We need to filter the allergies to only include 'milk' and 'cat'.", "Use DISTINCT to ensure we only get unique combinations of first names and city codes."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT Student.Fname, Student.city_code \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["Identify the tables needed: We need data from the Student and Has_Allergy tables.", "Determine the columns to select: We want distinct first names (Fname) and city codes (city_code) of students.", "Establish the relationship between tables: Use a JOIN to connect Student and Has_Allergy on StuID.", "Filter the results: We need to include only those students who have allergies to either 'milk' or 'cat'.", "Use the DISTINCT keyword to ensure that the results are unique."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT Student.Fname, Student.city_code \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["We need to find the names of the countries and the average invoice size.", "The relevant table for this information is the 'invoices' table, which contains the 'billing_country' and 'total' columns.", "To calculate the average invoice size for each country, we will use the AVG() function on the 'total' column.", "We will group the results by 'billing_country' to get the average for each country.", "To get the top countries by average invoice size, we will order the results in descending order and limit the output to the top 10 countries."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size\nFROM invoices\nGROUP BY billing_country\nORDER BY average_invoice_size DESC\nLIMIT 10;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["Identify the relevant table: invoices, which contains billing information.", "We need to count the number of invoices for each state, so we will use the COUNT() function.", "To group the results by state, we will use the GROUP BY clause on the billing_state column.", "The final query will select the billing_state and the count of invoices for that state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["We need to find the states with the most invoices, which means we will be counting the number of invoices per state.", "The relevant table for this information is the 'invoices' table, which contains a 'billing_state' column.", "To get the count of invoices per state, we will use the COUNT() function and group the results by 'billing_state'.", "Finally, we will order the results in descending order to show the states with the most invoices at the top."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state\nORDER BY invoice_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.568", "db_id": "store_1", "question": "What is the number of invoices and total money billed in them from CA?", "rationale": ["Identify the relevant table: invoices, which contains information about invoices including their total amounts and billing details.", "Determine the required information: the number of invoices and the total amount billed.", "Use COUNT(*) to count the total number of invoices and SUM(total) to calculate the total amount billed.", "Filter the results to only include invoices from California (CA) by adding a WHERE clause that specifies billing_state = 'CA'."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS number_of_invoices, SUM(total) AS total_billed FROM invoices WHERE billing_state = 'CA';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the table that contains the required information: The 'employees' table has the email and phone number of employees.", "Determine the specific employee: The question asks for Astrid Gruber, so we need to filter the results based on the first name 'Astrid' and last name 'Gruber'.", "Construct the SQL query: We will select the 'email' and 'phone' columns from the 'employees' table where the first name is 'Astrid' and the last name is 'Gruber'."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the street address of employees from the 'employees' table based on their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the employee being queried.\"\n}\n"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["Identify the relevant table: The 'customers' table contains information about customers, including their state.", "Determine the condition: We need to count customers specifically from California, so we will filter the results where the 'state' column equals 'California'.", "Construct the SQL query: Use the COUNT() function to count the number of customers that meet the condition, and select from the 'customers' table."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) AS customer_count FROM customers WHERE state = 'California';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: We need to find employees and customers, so we will use the 'employees' and 'customers' tables.", "Join the tables: We will join the 'employees' table with the 'customers' table on the 'support_rep_id' to link customers to their respective support representatives.", "Group by employee: We will group the results by employee ID to count the number of customers each employee supports.", "Count customers: We will use COUNT(c.id) to count the number of customers for each employee.", "Order the results: We will order the results in descending order based on the count of customers supported.", "Limit the results: We will limit the results to 1 to get the employee who supports the most customers."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees who report to a specific manager from the 'employees' table. The placeholders in the WHERE clause represent the first and last names of the manager.\"\n}\n"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["Identify the relevant tables: invoices and customers.", "Determine the relationship between invoices and customers: invoices have a customer_id that links to the customers table.", "Filter the customers table to find the specific customer 'Luca Mancini' using first_name and last_name.", "Count the number of invoices associated with 'Luca Mancini' by using COUNT(*) and joining the invoices and customers tables."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "pred_sql": "SELECT COUNT(*) AS order_count \nFROM invoices \nJOIN customers ON invoices.customer_id = customers.id \nWHERE customers.first_name = 'Luca' AND customers.last_name = 'Mancini';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["Identify the track 'Balls to the Wall' in the tracks table.", "Join the tracks table with the albums table using the album_id foreign key.", "Select the title of the album that corresponds to the identified track."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT albums.title FROM albums JOIN tracks ON albums.id = tracks.album_id WHERE tracks.name = 'Balls to the Wall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\"\n}\n"}
{"sample_id": "train.626", "db_id": "store_1", "question": "What is the name of all tracks in the album named Balls to the Wall?", "rationale": ["Identify the relevant tables: 'tracks' and 'albums'.", "We need to find tracks that belong to a specific album, so we will join the 'tracks' table with the 'albums' table using the foreign key relationship (tracks.album_id = albums.id).", "The condition specifies that we are looking for albums with the title 'Balls to the Wall'.", "Select the 'name' column from the 'tracks' table to get the names of the tracks in that album."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN albums ON tracks.album_id = albums.id \nWHERE albums.title = 'Balls to the Wall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\"\n}\n"}
{"sample_id": "train.630", "db_id": "store_1", "question": "What are the names of all Rock tracks that are stored on MPEG audio files?", "rationale": ["Identify the relevant tables: tracks, media_types, and genres.", "We need to find tracks that are of the genre 'Rock' and are stored in 'MPEG audio' format.", "Join the tracks table with media_types on media_type_id to filter by media type.", "Join the tracks table with genres on genre_id to filter by genre.", "Use a WHERE clause to specify that the genre name must be 'Rock' and the media type name must be 'MPEG audio'.", "Select the name of the tracks that meet these criteria."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN media_types ON tracks.media_type_id = media_types.id \nJOIN genres ON tracks.genre_id = genres.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG audio';", "hint": "\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the tables involved: tracks, genres, and media_types.", "We need to select the track names from the tracks table.", "To filter tracks by genre, we join the tracks table with the genres table on genre_id.", "To filter tracks by media type, we join the tracks table with the media_types table on media_type_id.", "We apply the conditions to filter for the 'Rock' genre and 'MPEG' media type."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN genres ON tracks.genre_id = genres.id \nJOIN media_types ON tracks.media_type_id = media_types.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG';", "hint": "\n"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["Identify the relevant tables: tracks, invoice_lines, invoices, and customers are needed to find the tracks bought by a specific customer.", "Join the tables: We need to join tracks with invoice_lines to get the track details associated with each invoice, then join invoice_lines with invoices to link to the customer, and finally join invoices with customers to filter by the customer's name.", "Filter by customer name: Use a WHERE clause to specify that we are looking for tracks bought by the customer with first name 'Dean' and last name 'Peeters'.", "Select the track names: The final output should be the names of the tracks that match the criteria."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN invoice_lines ON tracks.id = invoice_lines.track_id \nJOIN invoices ON invoice_lines.invoice_id = invoices.id \nJOIN customers ON invoices.customer_id = customers.id \nWHERE customers.first_name = 'Dean' AND customers.last_name = 'Peeters';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\"\n}\n"}
{"sample_id": "train.686", "db_id": "customers_card_transactions", "question": "What are the full names of customers who do not have any accounts?", "rationale": ["We need to find customers who do not have any accounts.", "To do this, we will select the full names of customers from the Customers table.", "The full name can be constructed by concatenating the first name and last name of the customer.", "We will filter the customers by checking if their customer_id is not present in the Accounts table.", "The subquery will select all customer_ids from the Accounts table, and we will use this in the NOT IN clause to exclude those customers."], "gold_sql": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nWHERE customer_id NOT IN (\n    SELECT customer_id\n    FROM Accounts\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\"\n}\n"}
{"sample_id": "train.688", "db_id": "customers_card_transactions", "question": "What are the full names of customers who have accounts?", "rationale": ["Identify the tables needed: Customers and Accounts.", "We need to join these tables on the customer_id to find customers with accounts.", "Select the full names of customers, which requires concatenating first and last names.", "Use the JOIN clause to combine the Customers and Accounts tables based on the customer_id.", "Group the results by customer_id to ensure we get unique customers."], "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\"\n}\n"}
{"sample_id": "train.704", "db_id": "customers_card_transactions", "question": "Return the full name and phone of the customer who has card number 4560596484842.", "rationale": ["Identify the required information: full name and phone number of the customer.", "The full name can be constructed by concatenating the first name and last name from the Customers table.", "The phone number is directly available in the Customers table.", "To link the customer with their card, a join between the Customers table and the Customers_Cards table is necessary using the customer_id.", "The specific card number to filter the results is provided in the query: '4560596484842'.", "Construct the SQL query using SELECT to retrieve the full name and phone number, applying the necessary JOIN and WHERE clauses."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.card_number  =  '4560596484842'", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name, customer_phone \nFROM Customers \nJOIN Customers_Cards ON Customers.customer_id = Customers_Cards.customer_id \nWHERE Customers_Cards.card_number = '4560596484842';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\"\n}\n"}
{"sample_id": "train.717", "db_id": "customers_card_transactions", "question": "What is the customer id, first and last name with least number of accounts.", "rationale": ["We need to find the customer with the least number of accounts.", "To do this, we will join the 'Customers' table with the 'Accounts' table on the 'customer_id'.", "We will group the results by customer ID, first name, and last name to count the number of accounts each customer has.", "We will order the results by the count of accounts in ascending order to get the customer with the least number of accounts at the top.", "Finally, we will limit the results to 1 to get only the customer with the least number of accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name \nFROM Customers c \nJOIN Accounts a ON c.customer_id = a.customer_id \nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name \nORDER BY COUNT(a.account_id) ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\"\n}\n"}
{"sample_id": "train.718", "db_id": "customers_card_transactions", "question": "Return the id and full name of the customer who has the fewest accounts.", "rationale": ["We need to find the customer with the fewest accounts.", "To do this, we can summarize the number of accounts associated with each customer using a subquery that counts the accounts grouped by customer_id.", "Next, we join this summary with the Customers table to get the customer details.", "We select the customer_id and concatenate the first and last name to get the full name of the customer.", "Finally, we order the results by the account count in ascending order and limit the result to 1 to get the customer with the fewest accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nJOIN (SELECT customer_id, COUNT(*) AS account_count\n      FROM Accounts\n      GROUP BY customer_id) AS account_summary\nON c.customer_id = account_summary.customer_id\nORDER BY account_count ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\"\n}\n"}
{"sample_id": "train.721", "db_id": "customers_card_transactions", "question": "What is the card type code with most number of cards?", "rationale": ["Identify the relevant table: The 'Customers_Cards' table contains the card type codes and card IDs.", "Count the number of cards for each card type code: Use COUNT(card_id) to get the total number of cards for each type.", "Group the results by card type code: Use GROUP BY card_type_code to aggregate the counts for each type.", "Order the results by the count in descending order: Use ORDER BY card_count DESC to get the most frequent card type at the top.", "Limit the results to only the top entry: Use LIMIT 1 to return only the card type code with the most cards."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "pred_sql": "SELECT card_type_code, COUNT(card_id) AS card_count \nFROM Customers_Cards \nGROUP BY card_type_code \nORDER BY card_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table summarizes the different types of cards issued to customers, displaying the card type codes from the 'Customers_Cards' table. The results are grouped by card type code and ordered by the frequency of each type, allowing the user to specify a limit on the number of types returned.\"\n}\n"}
{"sample_id": "train.735", "db_id": "customers_card_transactions", "question": "Show the number of transaction types.", "rationale": ["Identify the table to query: Financial_Transactions contains the transaction types.", "Determine the required output: We need to count the number of each transaction type.", "Use the COUNT() function to aggregate the number of transactions for each type.", "Group the results by transaction_type to get the count for each distinct type."], "gold_sql": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, COUNT(*) AS transaction_count \nFROM Financial_Transactions \nGROUP BY transaction_type;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions associated with each account from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account identifier, while the count function aggregates the total number of transactions for each account.\"\n}\n"}
{"sample_id": "train.743", "db_id": "customers_card_transactions", "question": "What is the transaction type that has processed the greatest total amount in transactions?", "rationale": ["We need to find the transaction type that has the greatest total amount in transactions.", "To do this, we will select the 'transaction_type' and the sum of 'transaction_amount' from the 'Financial_Transactions' table.", "We will group the results by 'transaction_type' to aggregate the amounts for each type.", "Next, we will order the results in descending order based on the total amount to get the highest total at the top.", "Finally, we will limit the results to 1 to get only the transaction type with the greatest total amount."], "gold_sql": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, SUM(transaction_amount) AS total_amount\nFROM Financial_Transactions\nGROUP BY transaction_type\nORDER BY total_amount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions associated with each account from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account identifier, while the count function aggregates the total number of transactions for each account.\"\n}\n"}
{"sample_id": "train.893", "db_id": "insurance_fnol", "question": "What are the customer phone numbers under the policy \"Life Insurance\"?", "rationale": ["Identify the relevant tables: Available_Policies for customer phone numbers and Services for policy names.", "Join the Available_Policies table with Customers_Policies to link policies to customers.", "Join the Services table to filter for the specific policy type 'Life Insurance'.", "Select the Customer_Phone from the resulting joined tables where the policy name matches 'Life Insurance'."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "pred_sql": "SELECT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nJOIN Services s ON s.Service_ID = cp.Policy_ID \nWHERE s.Service_name = 'Life Insurance';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\"\n}\n"}
{"sample_id": "train.895", "db_id": "insurance_fnol", "question": "Which policy type has the most records in the database?", "rationale": ["We need to find out which policy type has the most records in the database.", "To do this, we will query the 'Available_Policies' table, focusing on the 'policy_type_code' column.", "We will use the COUNT function to count the occurrences of each policy type.", "We will group the results by 'policy_type_code' to aggregate the counts for each type.", "To find the most common policy type, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one record to get the top policy type."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "pred_sql": "SELECT policy_type_code, COUNT(*) as policy_count \nFROM Available_Policies \nGROUP BY policy_type_code \nORDER BY policy_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\"\n}\n"}
{"sample_id": "train.897", "db_id": "insurance_fnol", "question": "What are all the customer phone numbers under the most popular policy type?", "rationale": ["Identify the relevant tables: Available_Policies for policy details and Customers_Policies for customer associations.", "Determine the most popular policy type by counting occurrences of each policy type in Available_Policies and ordering them by count.", "Use a subquery to find the most popular policy type, limiting the result to the top one.", "Join the Available_Policies table with Customers_Policies to link customers to their policies.", "Select distinct customer phone numbers associated with the most popular policy type."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nJOIN (\n    SELECT policy_type_code, COUNT(*) as policy_count \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    ORDER BY policy_count DESC \n    LIMIT 1\n) AS most_popular_policy ON ap.policy_type_code = most_popular_policy.policy_type_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\"\n}\n"}
{"sample_id": "train.898", "db_id": "insurance_fnol", "question": "Find the phone numbers of customers using the most common policy type among the available policies.", "rationale": ["Identify the tables involved: Customers, Customers_Policies, and Available_Policies.", "We need to find the phone numbers of customers, so we will select 'Customer_Phone' from the Customers table.", "To link customers with their policies, we will join the Customers table with the Customers_Policies table on 'Customer_ID'.", "Next, we will join the Customers_Policies table with the Available_Policies table on 'Policy_ID' to access the policy type information.", "To find the most common policy type, we will create a subquery that groups the policies by 'policy_type_code', counts their occurrences, and orders them in descending order, limiting the result to the top one.", "Finally, we will filter the main query to only include customers whose policies match the most common policy type found in the subquery."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT c.Customer_Phone \nFROM Customers c \nJOIN Customers_Policies cp ON c.Customer_ID = cp.Customer_ID \nJOIN Available_Policies ap ON cp.Policy_ID = ap.Policy_ID \nWHERE ap.policy_type_code = (\n    SELECT policy_type_code \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\"\n}\n"}
{"sample_id": "train.1060", "db_id": "match_season", "question": "Show the players from college UCLA.", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their college.", "Determine the condition: We need to filter players based on their college, specifically those who attended UCLA.", "Use a subquery: Since the 'player' table does not directly contain college information, we will use a subquery to find the teams associated with UCLA from the 'match_season' table.", "Construct the subquery: The subquery will select 'Team_id' from 'match_season' where 'College' is 'UCLA'.", "Combine the main query and subquery: The main query will select 'Player' from the 'player' table where the 'Team' is in the result of the subquery."], "gold_sql": "SELECT Player FROM match_season WHERE College  =  'UCLA'", "source_tables": ["match_season"], "pred_sql": "SELECT Player FROM player WHERE Team IN (SELECT Team_id FROM match_season WHERE College = 'UCLA');", "hint": "\n"}
{"sample_id": "train.1082", "db_id": "match_season", "question": "Show the season, the player, and the name of the team that players belong to.", "rationale": ["Identify the required columns: season, player, and team name.", "The season and player information is available in the 'match_season' table.", "The team name can be obtained from the 'team' table, which is linked to 'match_season' through the Team identifier.", "Use a JOIN operation to combine 'match_season' and 'team' tables based on the Team identifier.", "Construct the SELECT statement to retrieve the desired columns from the joined tables."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "pred_sql": "SELECT match_season.Season, match_season.Player, team.Name \nFROM match_season \nJOIN team ON match_season.Team = team.Team_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of match seasons, including the season name, player name, and the corresponding team name. The data is retrieved from the 'match_season' table, which is joined with the 'team' table to associate each player with their respective team using the team identifier.\"\n}\n"}
{"sample_id": "train.1092", "db_id": "match_season", "question": "Show the country names and the corresponding number of players.", "rationale": ["We need to show the country names and the corresponding number of players.", "To achieve this, we will select the 'Country_name' from the 'country' table.", "We will count the number of players associated with each country, which requires joining the 'country' table with the 'match_season' table to link players to their respective countries.", "Next, we will join the 'match_season' table with the 'player' table to get the player information.", "Finally, we will group the results by 'Country_name' to get the count of players for each country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "pred_sql": "SELECT c.Country_name, COUNT(p.Player_ID) AS Number_of_Players\nFROM country c\nJOIN match_season ms ON c.Country_id = ms.Country\nJOIN player p ON ms.Team = p.Team\nGROUP BY c.Country_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct official native languages of countries represented by players in a specific position during matches. The placeholder in the WHERE clause represents the player's position.\"\n}\n"}
{"sample_id": "train.1098", "db_id": "match_season", "question": "Show the top 3 most common colleges of players in match seasons.", "rationale": ["We need to find the top 3 most common colleges of players in match seasons.", "To do this, we will use the 'match_season' table, which contains a column for 'College'.", "We will count the occurrences of each college using COUNT(*) and group the results by 'College'.", "To get the most common colleges, we will order the results in descending order based on the count of players from each college.", "Finally, we will limit the results to the top 3 colleges."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as College_Count\nFROM match_season\nGROUP BY College\nORDER BY College_Count DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\"\n}\n"}
{"sample_id": "train.1099", "db_id": "match_season", "question": "What are the three colleges from which the most players are from?", "rationale": ["Identify the relevant table: The 'match_season' table contains the 'College' column and player information.", "We need to count the number of players from each college, so we will use the COUNT() function.", "Group the results by 'College' to aggregate the player counts for each college.", "Order the results in descending order based on the player count to get the colleges with the most players at the top.", "Limit the results to the top three colleges using LIMIT 3."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as Player_Count \nFROM match_season \nGROUP BY College \nORDER BY Player_Count DESC \nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.1107", "db_id": "match_season", "question": "Return the names of countries that have players that play the Forward position, as well as players who play the Defender position.", "rationale": ["We need to return the names of countries that have players in specific positions (Forward and Defender).", "To achieve this, we will join the 'country' table with the 'match_season' table on the country identifier.", "We will filter the results based on the player's position using the WHERE clause, specifying that we want players in either the 'Forward' or 'Defender' positions.", "Finally, we will select distinct country names to avoid duplicates in the results."], "gold_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "pred_sql": "SELECT DISTINCT c.Country_name \nFROM country c \nJOIN match_season ms ON c.Country_id = ms.Country \nWHERE ms.Position IN ('Forward', 'Defender');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct official native languages of countries represented by players in a specific position during matches. The placeholder in the WHERE clause represents the player's position.\"\n}\n"}
{"sample_id": "train.1109", "db_id": "match_season", "question": "Return the colleges that have players who play the Midfielder position, as well as players who play the Defender position.", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players, their positions, and the colleges they attended.", "Determine the required positions: We need to filter players who play either 'Midfielder' or 'Defender'.", "Use the SELECT statement to retrieve the 'College' column from the 'match_season' table.", "Apply a WHERE clause to filter the results based on the specified positions using the IN operator.", "Use DISTINCT to ensure that each college is listed only once in the results."], "gold_sql": "SELECT College FROM match_season WHERE POSITION  =  'Midfielder' INTERSECT SELECT College FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "pred_sql": "SELECT DISTINCT College \nFROM match_season \nWHERE Position IN ('Midfielder', 'Defender');", "hint": "\n"}
{"sample_id": "train.1222", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with type code \"Duplex\"?", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for apartment type.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to link bookings to their respective apartments.", "Filter the results to only include apartments with the type code 'Duplex'.", "Select the booking_start_date and booking_end_date from the joined tables."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  'Duplex'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartment_Bookings ab \nJOIN Apartments a ON ab.apt_id = a.apt_id \nWHERE a.apt_type_code = 'Duplex';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\"\n}\n"}
{"sample_id": "train.1224", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with more than 2 bedrooms?", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to access both booking dates and bedroom count.", "Filter the results to include only those apartments that have more than 2 bedrooms by using a WHERE clause."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartment_Bookings ab \nJOIN Apartments a ON ab.apt_id = a.apt_id \nWHERE a.bedroom_count > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\"\n}\n"}
{"sample_id": "train.1225", "db_id": "apartment_rentals", "question": "Find the booking start date and end date for the apartments that have more than two bedrooms.", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to access both booking information and apartment details.", "Filter the results to include only those apartments that have more than two bedrooms by using a WHERE clause with the condition 'a.bedroom_count > 2'.", "Select the booking start date and end date from the results."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartment_Bookings ab \nJOIN Apartments a ON ab.apt_id = a.apt_id \nWHERE a.bedroom_count > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\"\n}\n"}
{"sample_id": "train.1229", "db_id": "apartment_rentals", "question": "Which apartments have bookings with status code \"Confirmed\"? Return their apartment numbers.", "rationale": ["Identify the relevant tables: Apartments and Apartment_Bookings.", "We need to find apartments that have bookings with a specific status code, which is 'Confirmed'.", "Join the Apartments table with the Apartment_Bookings table on the apt_id to link apartments with their bookings.", "Filter the results to include only those bookings where the booking_status_code is 'Confirmed'.", "Select the apt_number from the filtered results to return the apartment numbers."], "gold_sql": "SELECT DISTINCT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  'Confirmed'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT a.apt_number \nFROM Apartments a \nJOIN Apartment_Bookings ab ON a.apt_id = ab.apt_id \nWHERE ab.booking_status_code = 'Confirmed';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\"\n}\n"}
{"sample_id": "train.1232", "db_id": "apartment_rentals", "question": "Show the guest first names, start dates, and end dates of all the apartment bookings.", "rationale": ["Identify the required fields: guest first names, booking start dates, and booking end dates.", "Determine the relevant tables: Guests for guest information and Apartment_Bookings for booking details.", "Establish the relationship between the tables: Guests are linked to Apartment_Bookings through guest_id.", "Construct the SQL SELECT statement to retrieve the desired fields from the joined tables."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT Guests.guest_first_name, Apartment_Bookings.booking_start_date, Apartment_Bookings.booking_end_date\nFROM Apartment_Bookings\nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\"\n}\n"}
{"sample_id": "train.1234", "db_id": "apartment_rentals", "question": "Show the start dates and end dates of all the apartment bookings made by guests with gender code \"Female\".", "rationale": ["Identify the relevant tables: Apartment_Bookings and Guests.", "Determine the columns needed: booking_start_date and booking_end_date from Apartment_Bookings.", "Establish the relationship between the tables: Apartment_Bookings is linked to Guests through guest_id.", "Filter the results to include only those bookings made by guests with gender code 'Female'.", "Construct the SQL query using SELECT to retrieve the required columns, JOIN to connect the tables, and WHERE to apply the filter."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  'Female'", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT Apartment_Bookings.booking_start_date, Apartment_Bookings.booking_end_date \nFROM Apartment_Bookings \nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id \nWHERE Guests.gender_code = 'Female';", "hint": "\n"}
{"sample_id": "train.1238", "db_id": "apartment_rentals", "question": "Show the facility codes of apartments with more than 4 bedrooms.", "rationale": ["Identify the relevant tables: We need to look at the 'Apartments' table for bedroom counts and the 'Apartment_Facilities' table for facility codes.", "Join the 'Apartments' table with the 'Apartment_Facilities' table on the 'apt_id' to link apartments with their facilities.", "Filter the results to include only those apartments that have more than 4 bedrooms by using a WHERE clause.", "Select the distinct facility codes from the joined tables to avoid duplicates in the results."], "gold_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "source_tables": ["apartments", "apartment_facilities"], "pred_sql": "SELECT DISTINCT af.facility_code \nFROM Apartments a \nJOIN Apartment_Facilities af ON a.apt_id = af.apt_id \nWHERE a.bedroom_count > 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\"\n}\n"}
{"sample_id": "train.1256", "db_id": "apartment_rentals", "question": "Show the top 3 apartment type codes sorted by the average number of rooms in descending order.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of rooms.", "Select the columns needed: We need the apartment type code (apt_type_code) and the average number of rooms (AVG(room_count)).", "Group the results: We will group the results by apt_type_code to calculate the average number of rooms for each type.", "Order the results: We will order the results in descending order based on the average number of rooms.", "Limit the results: We will limit the output to the top 3 apartment type codes."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, AVG(room_count) AS average_rooms\nFROM Apartments\nGROUP BY apt_type_code\nORDER BY average_rooms DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\"\n}\n"}
{"sample_id": "train.1258", "db_id": "apartment_rentals", "question": "Show the apartment type code that has the largest number of total rooms, together with the number of bathrooms and number of bedrooms.", "rationale": ["Identify the relevant columns needed: apt_type_code, room_count, bathroom_count, and bedroom_count from the Apartments table.", "Use the GROUP BY clause to group the results by apt_type_code to aggregate the data for each apartment type.", "Use the MAX function to find the maximum number of rooms for each apartment type.", "Order the results in descending order based on the maximum number of rooms to get the apartment type with the largest number of total rooms at the top.", "Limit the results to 1 to get only the apartment type with the largest number of total rooms."], "gold_sql": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, MAX(room_count) AS max_rooms, bathroom_count, bedroom_count \nFROM Apartments \nGROUP BY apt_type_code \nORDER BY max_rooms DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\"\n}\n"}
{"sample_id": "train.1261", "db_id": "apartment_rentals", "question": "Which apartment type code appears the most often?", "rationale": ["Identify the relevant table: The Apartments table contains the apt_type_code which we need to analyze.", "Count the occurrences of each apartment type code: We will use COUNT(*) to count how many times each apt_type_code appears.", "Group the results by apt_type_code: This is done using GROUP BY to aggregate the counts for each type code.", "Order the results by the count in descending order: This allows us to see which type code appears the most often at the top of the results.", "Limit the results to the top entry: Using LIMIT 1 ensures we only get the most frequently occurring apartment type code."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, COUNT(*) AS type_count \nFROM Apartments \nGROUP BY apt_type_code \nORDER BY type_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\"\n}\n"}
{"sample_id": "train.1262", "db_id": "apartment_rentals", "question": "Show the most common apartment type code among apartments with more than 1 bathroom.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of bathrooms.", "Filter apartments: We need to filter apartments that have more than 1 bathroom, which is done using the WHERE clause.", "Group by apartment type: To find the most common apartment type, we group the results by the apt_type_code.", "Count occurrences: We count the number of apartments for each type code using COUNT(*).", "Order results: We order the results in descending order based on the count to get the most common type first.", "Limit results: Finally, we limit the results to 1 to get only the most common apartment type code."], "gold_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, COUNT(*) as type_count \nFROM Apartments \nWHERE bathroom_count > 1 \nGROUP BY apt_type_code \nORDER BY type_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\"\n}\n"}
{"sample_id": "train.1272", "db_id": "apartment_rentals", "question": "Show the apartment numbers of apartments with unit status availability of both 0 and 1.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment numbers we want to retrieve.", "Determine the condition for availability: We need to check the availability status from the View_Unit_Status table, which indicates if an apartment is available or not.", "Use a subquery to filter apartments: We will use a subquery to select apt_id from View_Unit_Status where available_yn is either '0' or '1'.", "Join the results: The main query will select apt_number from Apartments where the apt_id is in the results of the subquery."], "gold_sql": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1", "source_tables": ["view_unit_status", "apartments"], "pred_sql": "SELECT apt_number FROM Apartments WHERE apt_id IN (SELECT apt_id FROM View_Unit_Status WHERE available_yn IN ('0', '1'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\"\n}\n"}
{"sample_id": "train.1294", "db_id": "soccer_1", "question": "How many leagues are there in England?", "rationale": ["Identify the relevant table: League.", "Determine the column that contains the country name: name.", "Use the COUNT() function to count the number of records where the name is 'England'."], "gold_sql": "SELECT count(*) FROM Country AS T1 JOIN League AS T2 ON T1.id  =  T2.country_id WHERE T1.name  =  'England'", "source_tables": ["country", "league"], "pred_sql": "SELECT COUNT(*) FROM League WHERE name = 'England';", "hint": "\n"}
{"sample_id": "train.1303", "db_id": "soccer_1", "question": "List all of the player ids with a height of at least 180cm and an overall rating higher than 85.", "rationale": ["Identify the relevant table: The 'Player' table contains player ids and height information.", "Determine the conditions: We need players with a height of at least 180cm and an overall rating higher than 85.", "Use a subquery: To find players with an overall rating higher than 85, we will query the 'Player_Attributes' table for player_api_ids that meet this criterion.", "Combine the conditions: We will select player ids from the 'Player' table where the height condition is met and the player_api_id is in the results of the subquery."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE overall_rating  >  85", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT id FROM Player WHERE height >= 180 AND player_api_id IN (SELECT player_api_id FROM Player_Attributes WHERE overall_rating > 85)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of players from the 'Player' table who have an overall skill rating higher than the average overall rating of all players recorded in the 'Player_Attributes' table. The query uses a subquery to calculate the average overall rating and filters the results accordingly.\"\n}\n"}
{"sample_id": "train.1304", "db_id": "soccer_1", "question": "List all of the ids for left-footed players with a height between 180cm and 190cm.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to filter players based on their height, which is in the Player table.", "We also need to filter players based on their preferred foot, which is in the Player_Attributes table.", "The height condition is that it should be between 180cm and 190cm.", "The preferred foot condition is that it should be 'left'.", "We will use a subquery to find the player_api_ids of left-footed players from the Player_Attributes table.", "Finally, we will select the ids of players from the Player table who meet both conditions."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 AND height  <=  190 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE preferred_foot  =  'left'", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT Player.id \nFROM Player \nWHERE Player.height BETWEEN 180 AND 190 \nAND Player.player_api_id IN (\n    SELECT Player_Attributes.player_api_id \n    FROM Player_Attributes \n    WHERE Player_Attributes.preferred_foot = 'left'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of players from the 'Player' table who have the highest overall skill rating recorded in the 'Player_Attributes' table. The query joins the 'Player' and 'Player_Attributes' tables based on the player's API identifier and filters the results to only include players whose dribbling attribute matches the maximum overall rating found in the 'Player_Attributes' table.\"\n}\n"}
{"sample_id": "train.1306", "db_id": "soccer_1", "question": "List the names and birthdays of the top five players in terms of potential.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to retrieve player names and birthdays, so we will select 'player_name' and 'birthday' from the Player table.", "To get the potential ratings, we will join the Player table with the Player_Attributes table on 'player_api_id'.", "We will order the results by the 'potential' column in descending order to get the top players.", "Finally, we will limit the results to the top five players."], "gold_sql": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT 5", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT player.player_name, player.birthday\nFROM Player AS player\nJOIN Player_Attributes AS attributes ON player.player_api_id = attributes.player_api_id\nORDER BY attributes.potential DESC\nLIMIT 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of players from the 'Player' table who have the highest overall skill rating recorded in the 'Player_Attributes' table. The query joins the 'Player' and 'Player_Attributes' tables based on the player's API identifier and filters the results to only include players whose dribbling attribute matches the maximum overall rating found in the 'Player_Attributes' table.\"\n}\n"}
{"sample_id": "train.1511", "db_id": "insurance_and_eClaims", "question": "Which type of policy is most frequently used? Give me the policy type code.", "rationale": ["To find the most frequently used policy type, we need to count the occurrences of each policy type code in the Policies table.", "We will use the COUNT function to count how many times each Policy_Type_Code appears.", "We will group the results by Policy_Type_Code to aggregate the counts for each type.", "To determine which policy type is the most frequently used, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one entry to get the most frequently used policy type."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(*) as Frequency\nFROM Policies\nGROUP BY Policy_Type_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\"\n}\n"}
{"sample_id": "train.1513", "db_id": "insurance_and_eClaims", "question": "Find all the policy types that are used by more than 2 customers.", "rationale": ["Identify the relevant table: The 'Policies' table contains the 'Policy_Type_Code' and 'Customer_ID' which are needed for the query.", "We need to find policy types used by more than 2 customers, so we will group by 'Customer_ID' and count the distinct customers.", "Use a subquery to count the number of customers for each policy type and filter those with a count greater than 2.", "Finally, select the 'Policy_Type_Code' from the 'Policies' table where the customer count condition is met."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code\nFROM Policies\nWHERE Customer_ID IN (\n    SELECT Customer_ID\n    FROM Policies\n    GROUP BY Customer_ID\n    HAVING COUNT(DISTINCT Customer_ID) > 2\n)\nGROUP BY Policy_Type_Code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\"\n}\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["Identify the relevant table: The 'Claim_Headers' table contains the 'Amount_Paid' column which is needed for the calculations.", "Determine the required calculations: We need to calculate the total amount paid and the average amount paid.", "Construct the SQL query: Use the SUM() function to calculate the total amount and the AVG() function to calculate the average amount from the 'Amount_Paid' column in the 'Claim_Headers' table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\"\n}\n"}
{"sample_id": "train.1518", "db_id": "insurance_and_eClaims", "question": "How much amount in total were claimed in the most recently created document?", "rationale": ["Identify the relevant tables: We need to look at the 'Claim_Headers' table for the amount claimed and the 'Claims_Documents' table to find the most recently created document.", "Determine the relationship: The 'Claim_Headers' table is linked to the 'Claims_Documents' table through the 'Claim_ID'.", "Find the most recent document: We need to filter the claims based on the maximum 'Created_Date' from the 'Claims_Documents' table.", "Calculate the total amount claimed: We will sum the 'Amount_Claimed' from the 'Claim_Headers' table for the claims associated with the most recent document."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT SUM(ch.Amount_Claimed) AS Total_Claimed\nFROM Claim_Headers ch\nJOIN Claims_Documents cd ON ch.Claim_Header_ID = cd.Claim_ID\nWHERE cd.Created_Date = (SELECT MAX(Created_Date) FROM Claims_Documents);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\"\n}\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Claim_Headers for claims, Policies for linking claims to customers, and Customers for customer details.", "Join the Claim_Headers table with the Policies table on Policy_ID to associate claims with their respective policies.", "Join the resulting table with the Customers table on Customer_ID to retrieve customer details.", "Use a subquery to find the maximum amount paid from the Claim_Headers table.", "Filter the results to only include the customer(s) associated with the claim that has the maximum amount paid."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details \nFROM Claim_Headers ch \nJOIN Policies p ON ch.Policy_ID = p.Policy_ID \nJOIN Customers c ON p.Customer_ID = c.Customer_ID \nWHERE ch.Amount_Paid = (SELECT MAX(Amount_Paid) FROM Claim_Headers)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\"\n}\n"}
{"sample_id": "train.1521", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the minimum amount of payment in one claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers.", "Join the Customers table with the Policies table using Customer_ID to link customers to their policies.", "Join the resulting table with the Claim_Headers table using Policy_ID to link claims to the policies.", "Use a subquery to find the minimum Amount_Paid from the Claim_Headers table.", "Filter the results to only include the customer(s) associated with the claim that has the minimum Amount_Paid."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID \nWHERE ch.Amount_Paid = (SELECT MIN(Amount_Paid) FROM Claim_Headers);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\"\n}\n"}
{"sample_id": "train.1531", "db_id": "insurance_and_eClaims", "question": "Find the names of the customers who have an deputy policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Filter the Policies table for those with a Policy_Type_Code of 'deputy'.", "To ensure we get the most recent policy, use a subquery to find the maximum Start_Date for each customer.", "Join the Customers table with the Policies table on Customer_ID and apply the filters."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Policy_Type_Code = 'deputy' \nAND Policies.Start_Date = (SELECT MAX(Start_Date) FROM Policies WHERE Customer_ID = Customers.Customer_ID);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\"\n}\n"}
{"sample_id": "train.1533", "db_id": "insurance_and_eClaims", "question": "Find the names of customers who either have an deputy policy or uniformed policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find customers with specific policy types, so we will join the Customers table with the Policies table on Customer_ID.", "The condition for the policies is that the Policy_Type_Code should be either 'deputy' or 'uniformed'.", "We will select distinct customer details to avoid duplicates in the results."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy' OR t1.policy_type_code  =  'Uniform'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT DISTINCT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nWHERE p.Policy_Type_Code IN ('deputy', 'uniformed')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\"\n}\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find the customer associated with the most recently started policy, so we will join the Customers table with the Policies table on Customer_ID.", "To find the most recent policy, we will use a subquery to get the maximum Start_Date from the Policies table.", "The main query will select the Customer_ID and Customer_Details from the Customers table where the Start_Date matches the maximum Start_Date found in the subquery."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Start_Date = (SELECT MAX(Start_Date) FROM Policies);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\"\n}\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "Determine the columns needed: account_id, account_name, and other_account_details from Accounts.", "Establish the relationship between Accounts and Customers using the customer_id foreign key.", "Filter the results to include only those accounts associated with the customer whose first name is 'Meaghan'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Accounts.account_id, Accounts.account_name, Accounts.other_account_details \nFROM Accounts \nJOIN Customers ON Accounts.customer_id = Customers.customer_id \nWHERE Customers.customer_first_name = 'Meaghan';", "hint": "\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to retrieve account details for a specific customer, so we will join the Customers table with the Accounts table using the customer_id.", "The query should filter the results based on the customer's first name (Meaghan) and last name (Keeling).", "Select the account_name and other_account_details from the Accounts table."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Accounts.account_name, Accounts.other_account_details \nFROM Customers \nJOIN Accounts ON Customers.customer_id = Accounts.customer_id \nWHERE Customers.customer_first_name = 'Meaghan' AND Customers.customer_last_name = 'Keeling';", "hint": "\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "Determine the columns needed: full names (first and last) from Customers and account name from Accounts.", "Join the Customers table with the Accounts table on the customer_id field to link customers with their accounts.", "Filter the results to include only those accounts with the name '900'.", "Use string concatenation to create the full name from first and last names."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nJOIN Accounts ON Customers.customer_id = Accounts.customer_id\nWHERE Accounts.account_name = '900';", "hint": "\n"}
{"sample_id": "train.1568", "db_id": "customers_and_invoices", "question": "Return the id and full name of the customer with the most accounts.", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to join these tables on the customer_id to link customers with their accounts.", "We will group the results by customer_id to count the number of accounts each customer has.", "We will order the results by the count of accounts in descending order to find the customer with the most accounts.", "Finally, we will limit the results to 1 to get only the top customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id\nORDER BY COUNT(a.account_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1579", "db_id": "customers_and_invoices", "question": "How many transaction does each account have? Show the number and account id.", "rationale": ["Identify the relevant table: Financial_Transactions contains the transaction data and account_id.", "Use the COUNT function to count the number of transactions for each account.", "Group the results by account_id to get the count for each account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT account_id, COUNT(transaction_id) AS transaction_count\nFROM Financial_Transactions\nGROUP BY account_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\"\n}\n"}
{"sample_id": "train.1589", "db_id": "customers_and_invoices", "question": "Show the account name, id and the number of transactions for each account.", "rationale": ["We need to select the account name and account id from the Accounts table.", "We also need to count the number of transactions for each account, which is stored in the Financial_Transactions table.", "To get the number of transactions per account, we will perform a LEFT JOIN between the Accounts table and the Financial_Transactions table on the account_id.", "We will use the COUNT function to count the transaction_id from the Financial_Transactions table, which gives us the number of transactions for each account.", "Finally, we will group the results by account_id and account_name to ensure we get the count for each unique account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "pred_sql": "SELECT a.account_name, a.account_id, COUNT(ft.transaction_id) AS number_of_transactions\nFROM Accounts a\nLEFT JOIN Financial_Transactions ft ON a.account_id = ft.account_id\nGROUP BY a.account_id, a.account_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\"\n}\n"}
{"sample_id": "train.1599", "db_id": "customers_and_invoices", "question": "Show the invoice number and the number of transactions for each invoice.", "rationale": ["We need to retrieve the invoice number and the number of transactions for each invoice.", "The 'Invoices' table contains the invoice numbers, so we will select 'invoice_number' from this table.", "To count the number of transactions associated with each invoice, we will join the 'Financial_Transactions' table on the 'invoice_number'.", "We will use a LEFT JOIN to ensure we include all invoices even if there are no transactions associated with them.", "We will use the COUNT function to count the number of transaction IDs for each invoice number.", "Finally, we will group the results by 'invoice_number' to get the count for each individual invoice."], "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"], "pred_sql": "SELECT Invoices.invoice_number, COUNT(Financial_Transactions.transaction_id) AS number_of_transactions\nFROM Invoices\nLEFT JOIN Financial_Transactions ON Invoices.invoice_number = Financial_Transactions.invoice_number\nGROUP BY Invoices.invoice_number;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\"\n}\n"}
{"sample_id": "train.1602", "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?", "rationale": ["We need to find the invoice number and invoice date for the invoice with the greatest number of transactions.", "To do this, we will first identify the order_id that has the maximum number of transactions. This can be done by counting the number of entries in the Invoice_Line_Items table grouped by order_id.", "We will order these counts in descending order and limit the result to the top entry to get the order_id with the most transactions.", "Once we have the order_id, we can then query the Invoices table to get the corresponding invoice_number and invoice_date for that order_id."], "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"], "pred_sql": "SELECT invoice_number, invoice_date \nFROM Invoices \nWHERE order_id = (\n    SELECT order_id \n    FROM Invoice_Line_Items \n    GROUP BY order_id \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\"\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["We need to retrieve the order ids and the number of items in each order.", "The 'Orders' table contains the order ids, and the 'Order_Items' table contains the items associated with each order.", "To get the number of items per order, we can use a JOIN between 'Orders' and 'Order_Items' on the order_id.", "We will use the COUNT function to count the number of items (order_item_id) for each order.", "Finally, we will group the results by order_id to get the count for each individual order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT Orders.order_id, COUNT(Order_Items.order_item_id) AS number_of_items\nFROM Orders\nJOIN Order_Items ON Orders.order_id = Order_Items.order_id\nGROUP BY Orders.order_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\"\n}\n"}
{"sample_id": "train.2049", "db_id": "party_people", "question": "Show all ministers who do not belong to Progress Party.", "rationale": ["Identify the relevant tables: We need to look at the 'member' table to get the names of the ministers and the 'party' table to filter out those belonging to the 'Progress Party'.", "Join the 'member' table with the 'party' table on the 'Party_ID' to associate members with their respective parties.", "Use a WHERE clause to filter out members whose party name is 'Progress Party'.", "Select distinct member names to avoid duplicates in the result."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT DISTINCT m.Member_Name \nFROM member m \nJOIN party p ON m.Party_ID = p.Party_ID \nWHERE p.Party_name != 'Progress Party';", "hint": "\n"}
{"sample_id": "train.2058", "db_id": "party_people", "question": "How many members are in each party?", "rationale": ["Identify the tables involved: We need to count members in each party, so we will use the 'party' and 'member' tables.", "Determine the relationship: The 'member' table has a foreign key 'Party_ID' that links to the 'party' table's 'Party_ID'.", "Select the necessary columns: We need the party name from the 'party' table and the count of members from the 'member' table.", "Use COUNT() function: To count the number of members in each party, we will use the COUNT() function on 'Member_ID'.", "Group the results: We will group the results by 'Party_name' to get the count of members for each party.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT party.Party_name, COUNT(member.Member_ID) AS Member_Count\nFROM party\nLEFT JOIN member ON party.Party_ID = member.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of party events associated with a specific region and event name. It joins the 'region', 'party', and 'party_events' tables to filter the results based on the specified region name and event name. The placeholders in the WHERE clause represent the region's name and the event's name.\"\n}\n"}
{"sample_id": "train.2071", "db_id": "party_people", "question": "Show party names and the number of events for each party.", "rationale": ["We need to retrieve the names of the parties and the count of events associated with each party.", "To do this, we will select the 'Party_name' from the 'party' table.", "We will also count the 'Event_ID' from the 'party_events' table to get the number of events for each party.", "Since a party may not have any events, we will use a LEFT JOIN between the 'party' and 'party_events' tables on the 'Party_ID'.", "Finally, we will group the results by 'Party_name' to get the count of events for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT party.Party_name, COUNT(party_events.Event_ID) AS Number_of_Events\nFROM party\nLEFT JOIN party_events ON party.Party_ID = party_events.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of party events associated with a specific region and event name. It joins the 'region', 'party', and 'party_events' tables to filter the results based on the specified region name and event name. The placeholders in the WHERE clause represent the region's name and the event's name.\"\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the relevant tables: region, party, and party_events.", "Determine the relationship between the tables: region is linked to party via Region_ID, and party is linked to party_events via Party_ID.", "Filter the results based on the region name 'United Kingdom' and the event name 'Annual Meeting'.", "Use COUNT(*) to count the number of events that match the criteria."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT COUNT(*) AS Annual_Meeting_Count\nFROM region r\nJOIN party p ON r.Region_ID = p.Region_ID\nJOIN party_events pe ON p.Party_ID = pe.Party_ID\nWHERE r.Region_name = 'United Kingdom' AND pe.Event_Name = 'Annual Meeting';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of party events associated with a specific region and event name. It joins the 'region', 'party', and 'party_events' tables to filter the results based on the specified region name and event name. The placeholders in the WHERE clause represent the region's name and the event's name.\"\n}\n"}
{"sample_id": "train.2176", "db_id": "formula_1", "question": "What are the names and years of all races that had a driver with the last name Lewis?", "rationale": ["Identify the tables needed: races, results, and drivers.", "We need to get the names and years of races, so we will select 'races.name' and 'races.year'.", "To find races with a driver named Lewis, we need to join the 'races' table with the 'results' table on 'raceId', and then join the 'results' table with the 'drivers' table on 'driverId'.", "The condition to filter the results is that the driver's surname must be 'Lewis'.", "Construct the SQL query using the SELECT statement with the necessary JOINs and WHERE clause."], "gold_sql": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = 'Lewis'", "source_tables": ["results", "drivers", "races"], "pred_sql": "SELECT races.name, races.year \nFROM races \nJOIN results ON races.raceId = results.raceId \nJOIN drivers ON results.driverId = drivers.driverId \nWHERE drivers.surname = 'Lewis';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\"\n}\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the tables needed: 'drivers', 'results', and 'races'.", "We need to find drivers who participated in the Australian Grand Prix, so we will join the 'drivers' table with the 'results' table and then with the 'races' table to filter by the race name.", "Use a subquery to find drivers who participated in the Chinese Grand Prix and exclude them from the main query.", "Select the first and last names of the drivers who meet the criteria."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.forename, d.surname \nFROM drivers d \nJOIN results r ON d.driverId = r.driverId \nJOIN races ra ON r.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' \nAND d.driverId NOT IN (\n    SELECT driverId \n    FROM results r2 \n    JOIN races rb ON r2.raceId = rb.raceId \n    WHERE rb.name = 'Chinese Grand Prix'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\"\n}\n"}
{"sample_id": "train.2183", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who was in position 1 as standing and won?", "rationale": ["We need to find distinct forenames of drivers who were in position 1 in the standings and have won races.", "To achieve this, we will select the 'forename' column from the 'drivers' table.", "We will join the 'drivers' table with the 'driverStandings' table on the 'driverId' column to access the standings information for each driver.", "In the WHERE clause, we will filter for drivers who have a position of 1 and have more than 0 wins."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.wins > 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\"\n}\n"}
{"sample_id": "train.2185", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["We need to find distinct forenames of drivers who won in position 1 in the standings and had more than 20 points.", "The relevant table for driver information is 'drivers', which contains the 'forename' column.", "The 'driverStandings' table contains the 'position' and 'points' columns, which are necessary for our conditions.", "We will join the 'drivers' table with the 'driverStandings' table on the 'driverId' to access both driver names and their standings.", "The WHERE clause will filter for drivers who are in position 1 and have more than 20 points.", "Finally, we will select distinct forenames to ensure no duplicates are returned."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\"\n}\n"}
{"sample_id": "train.2186", "db_id": "formula_1", "question": "What are the first names of the different drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["We need to find the first names of drivers who won in position 1 as driver standing and had more than 20 points.", "To achieve this, we will select the distinct first names from the 'drivers' table.", "We will join the 'drivers' table with the 'driverStandings' table on the driverId to access the standings information.", "In the WHERE clause, we will filter for drivers who have a position of 1 and points greater than 20."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\"\n}\n"}
{"sample_id": "train.2189", "db_id": "formula_1", "question": "What are the numbers of races for each constructor id?", "rationale": ["We need to find the number of races for each constructor id.", "The relevant table for this information is 'constructorResults', which links constructors to races.", "We will use the COUNT() function to count the number of races (raceId) for each constructorId.", "We will group the results by constructorId to get the count for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(raceId) AS number_of_races\nFROM constructorResults\nGROUP BY constructorId;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the official names of constructors from the 'constructors' table who are from a specific nationality and have scored more points than a specified threshold in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.\"\n}\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the relevant table: We need to retrieve constructor names from the 'constructors' table.", "Filter by nationality: We are specifically looking for constructors from Japan, so we will add a condition for nationality = 'Japanese'.", "Determine the points condition: We need to find constructors that have earned more than 5 points, which requires checking the 'constructorStandings' table.", "Use a subquery: We will use a subquery to find constructorIds from the 'constructorStandings' table where points > 5.", "Combine conditions: The main query will select names from the 'constructors' table where the nationality is Japanese and the constructorId is in the list of constructorIds from the subquery."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT name FROM constructors WHERE nationality = 'Japanese' AND constructorId IN (SELECT constructorId FROM constructorStandings WHERE points > 5);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the official names of constructors from the 'constructors' table who are from a specific nationality and have scored more points than a specified threshold in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.\"\n}\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races, lapTimes, and circuits are needed to get the fastest lap speed for the Monaco Grand Prix in 2008.", "Join the races table with lapTimes on raceId to access the fastest lap speeds for each race.", "Join the circuits table to filter for the Monaco Grand Prix by its name.", "Add a WHERE clause to filter for the year 2008 and the specific race name 'Monaco Grand Prix'.", "Use the AVG() function to calculate the average of the fastest lap speeds from the lapTimes table."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(lapTimes.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races\nJOIN lapTimes ON races.raceId = lapTimes.raceId\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE circuits.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\"\n}\n"}
{"sample_id": "train.2221", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["Identify the relevant tables: We need to find the maximum fastest lap speed for a specific race, which involves the 'results' and 'races' tables.", "Determine the conditions: The race name is 'Monaco Grand Prix' and the year is 2008.", "Join the tables: We need to join the 'results' table with the 'races' table on the raceId to access the race name and year.", "Select the maximum fastest lap speed: Use the MAX function on the 'fastestLapSpeed' column from the 'results' table, applying the conditions from the 'races' table."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(fastestLapSpeed) AS max_fastest_lap_speed \nFROM results \nJOIN races ON results.raceId = races.raceId \nWHERE races.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\"\n}\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races, lapTimes, and circuits are needed to find the fastest lap speed for the Monaco Grand Prix in 2008.", "Use the races table to filter for the Monaco Grand Prix in 2008 by joining it with the circuits table on circuitId and applying the appropriate WHERE conditions.", "Join the lapTimes table to access the fastest lap speed data, linking it to the races table using raceId.", "Select the maximum fastest lap speed from the lapTimes table where the conditions for the Monaco Grand Prix in 2008 are met."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(lapTimes.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races\nJOIN lapTimes ON races.raceId = lapTimes.raceId\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE circuits.name = 'Monaco' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\"\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["We need to select the race names and the maximum fastest lap speed for races after 2004.", "The relevant tables are 'races' for race names and 'lapTimes' for fastest lap speeds.", "We will join the 'races' table with the 'lapTimes' table on the raceId to get the necessary data.", "We will filter the results to include only races that occurred after the year 2004 using the WHERE clause.", "To find the maximum fastest lap speed for each race, we will use the MAX() function and group the results by race name.", "Finally, we will order the results by year to meet the requirement of the query."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races r\nJOIN lapTimes l ON r.raceId = l.raceId\nWHERE r.year > 2004\nGROUP BY r.name\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\"\n}\n"}
{"sample_id": "train.2225", "db_id": "formula_1", "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to get race names and fastest lap speeds.", "Join the races table with results to link races with their results.", "Join the results table with lapTimes to access the fastest lap speeds for each race.", "Filter the results to include only races held after the year 2004 using a WHERE clause.", "Group the results by race name to calculate the average fastest lap speed for each race.", "Select the race name and the average fastest lap speed, and order the results by year."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name AS race_name, AVG(l.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN lapTimes l ON r.raceId = l.raceId\nWHERE r.year > 2004\nGROUP BY r.name\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\"\n}\n"}
{"sample_id": "train.2226", "db_id": "formula_1", "question": "What is the average fastest lap speed for races held after 2004, for each race, ordered by year?", "rationale": ["Identify the relevant tables: 'races' for race information and 'lapTimes' for fastest lap speeds.", "We need to calculate the average fastest lap speed, so we will use the AVG() function on the 'fastestLapSpeed' column from the 'lapTimes' table.", "Join the 'races' table with the 'lapTimes' table on the 'raceId' to correlate races with their lap times.", "Filter the results to include only races held after the year 2004 using the WHERE clause.", "Group the results by year and race name to calculate the average for each race.", "Order the final results by year to present them in chronological order."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.year, r.name, AVG(l.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races r\nJOIN lapTimes l ON r.raceId = l.raceId\nWHERE r.year > 2004\nGROUP BY r.year, r.name\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\"\n}\n"}
{"sample_id": "train.2243", "db_id": "machine_repair", "question": "What is the starting year of the oldest technicians?", "rationale": ["Identify the relevant table: The question pertains to technicians, so we will focus on the 'technician' table.", "Determine the required information: We need the starting year of the oldest technician.", "Use the MIN function: To find the oldest starting year, we can use the MIN function on the 'Starting_Year' column.", "Construct the SQL query: The SQL query will select the minimum starting year from the technician table."], "gold_sql": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT MIN(Starting_Year) AS Oldest_Starting_Year FROM technician;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of technicians who are assigned to repair tasks for machines that have a value point greater than a specified threshold. The placeholders in the WHERE clause represent the minimum value points for filtering the machines.\"\n}\n"}
{"sample_id": "train.2248", "db_id": "machine_repair", "question": "What are the teams with the most technicians?", "rationale": ["Identify the relevant table: The 'technician' table contains information about technicians and their teams.", "Group by team: We need to group the results by the 'Team' column to count the number of technicians in each team.", "Count technicians: Use the COUNT() function to count the number of technicians for each team.", "Order the results: We want the teams with the most technicians, so we will order the results in descending order based on the count of technicians."], "gold_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT Team, COUNT(technician_id) AS technician_count\nFROM technician\nGROUP BY Team\nORDER BY technician_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of technician teams from the 'technician' table, grouped by their team identifier. The results are ordered by the number of technicians in each team in descending order, and the placeholder allows for limiting the number of teams returned.\"\n}\n"}
{"sample_id": "train.2258", "db_id": "machine_repair", "question": "What are the names of the technicians  and how many machines are they assigned to repair?", "rationale": ["Identify the relevant tables: technician, repair_assignment, and machine.", "We need to select the technician's name and count the number of machines assigned to each technician.", "Join the technician table with the repair_assignment table on technician_id to link technicians with their assigned repairs.", "Join the repair_assignment table with the machine table on Machine_ID to access machine details.", "Use COUNT() to count the number of machines assigned to each technician.", "Group the results by technician's name to get the count for each technician."], "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name", "source_tables": ["repair_assignment", "technician"], "pred_sql": "SELECT technician.Name, COUNT(repair_assignment.Machine_ID) AS machine_count\nFROM technician\nJOIN repair_assignment ON technician.technician_id = repair_assignment.technician_id\nJOIN machine ON repair_assignment.Machine_ID = machine.Machine_ID\nWHERE machine.value_points > ?\nGROUP BY technician.Name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of technicians who are assigned to repair tasks for machines that have a value point greater than a specified threshold. The placeholders in the WHERE clause represent the minimum value points for filtering the machines.\"\n}\n"}
{"sample_id": "train.2328", "db_id": "csu_1", "question": "Find all the campuses opened in 1958.", "rationale": ["Identify the relevant table: The 'Campuses' table contains information about the campuses, including the year they were opened.", "Determine the specific condition: We need to find campuses that were opened in the year 1958.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' names from the 'Campuses' table where the 'Year' is '1958'."], "gold_sql": "SELECT campus FROM campuses WHERE YEAR  =  1958", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE Year = '1958';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\"\n}\n"}
{"sample_id": "train.2334", "db_id": "csu_1", "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.", "rationale": ["Identify the relevant table: The 'Campuses' table contains the information about campus names and their locations.", "Determine the filtering criteria: We need to find campuses located in either 'Northridge, Los Angeles' or 'San Francisco, San Francisco'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' names from the 'Campuses' table where the 'Location' matches either of the specified locations."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE (Location = 'Northridge, Los Angeles' OR Location = 'San Francisco, San Francisco');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\"\n}\n"}
{"sample_id": "train.2350", "db_id": "csu_1", "question": "Which campus has the most faculties in year 2003?", "rationale": ["Identify the relevant tables: 'Campuses' for campus names and 'faculty' for faculty data.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Filter the results to only include records for the year 2003.", "Order the results by the number of faculty members in descending order to find the campus with the most faculty.", "Limit the results to 1 to get only the campus with the highest number of faculty."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT c.Campus, f.Faculty \nFROM Campuses c \nJOIN faculty f ON c.Id = f.Campus \nWHERE f.Year = 2003 \nORDER BY f.Faculty DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\"\n}\n"}
{"sample_id": "train.2356", "db_id": "csu_1", "question": "report the total number of degrees granted between 1998 and 2002.", "rationale": ["Identify the relevant table: The 'degrees' table contains information about degrees awarded.", "Determine the relevant columns: We need to count the total number of degrees, so we will use COUNT(*) to get the total.", "Set the condition for the years: We need to filter the records to include only those between 1998 and 2002, which can be done using a WHERE clause with a BETWEEN condition.", "Construct the SQL query: Combine the SELECT statement with the COUNT function and the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT COUNT(*) AS TotalDegrees\nFROM degrees\nWHERE Year BETWEEN '1998' AND '2002';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\"\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: 'degrees' for degrees awarded and 'Campuses' for campus information.", "We need to filter degrees awarded after the year 2000, so we will use a WHERE clause to specify this condition.", "We also need to focus on campuses located in Orange County, adding another condition to the WHERE clause.", "To get the total number of degrees for each campus, we will use the COUNT function and group the results by campus name.", "Finally, we will join the 'degrees' table with the 'Campuses' table on the campus identifier to get the campus names along with the degree counts."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT Campuses.Campus, COUNT(degrees.Degrees) AS TotalDegrees\nFROM degrees\nJOIN Campuses ON degrees.Campus = Campuses.Id\nWHERE degrees.Year > '2000' AND Campuses.County = 'Orange'\nGROUP BY Campuses.Campus;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\"\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant table for total enrollments, which is the 'enrollments' table.", "Determine the conditions specified in the query: total enrollment must be greater than 400 and full-time equivalent enrollment must be greater than 200.", "Specify the year of interest, which is 1956.", "Construct the SQL SELECT statement to retrieve the 'Campus' from the 'enrollments' table that meets the specified conditions."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT Campus FROM enrollments WHERE TotalEnrollment_AY > 400 AND FTE_AY > 200 AND Year = '1956';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\"\n}\n"}
{"sample_id": "train.2363", "db_id": "csu_1", "question": "What campus started in year 1956, has more than 200 full time students, and more than 400 students enrolled?", "rationale": ["Identify the relevant tables: Campuses and enrollments.", "We need to filter campuses based on the year 1956, which is in the Campuses table.", "We also need to check for conditions on full-time students and total enrollments, which are in the enrollments table.", "Join the Campuses table with the enrollments table on the campus identifier.", "Apply the filters for year, full-time students, and total enrollments in the WHERE clause."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT c.Campus \nFROM Campuses c \nJOIN enrollments e ON c.Id = e.Campus \nWHERE c.Year = '1956' \nAND e.FTE_AY > '200' \nAND e.TotalEnrollment_AY > '400';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\"\n}\n"}
{"sample_id": "train.2366", "db_id": "csu_1", "question": "List the campuses in Los Angeles county.", "rationale": ["Identify the relevant table: The 'Campuses' table contains information about campuses, including their location and county.", "Determine the filtering criteria: We need to filter campuses based on the county, specifically 'Los Angeles'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' names from the 'Campuses' table where the 'County' is 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\"\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: 'degrees' for degrees conferred and 'Campuses' for campus names.", "Join the 'degrees' table with the 'Campuses' table on the campus identifier to access campus names.", "Filter the results to only include records for 'San Jose State University' and the year 2000.", "Use the SUM function to calculate the total number of degrees conferred for the specified campus and year."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(Degrees) AS TotalDegrees\nFROM degrees d\nJOIN Campuses c ON d.Campus = c.Id\nWHERE c.Campus = 'San Jose State University' AND d.Year = '2000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\"\n}\n"}
{"sample_id": "train.2374", "db_id": "csu_1", "question": "What is the number of faculty lines in campus \"Long Beach State University\" in 2002?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to filter by campus name.", "Filter the results to only include records for 'Long Beach State University' and the year 2002.", "Select the 'Faculty' column to get the number of faculty lines for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2002 AND T2.campus  =  'Long Beach State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Faculty FROM faculty INNER JOIN Campuses ON faculty.Campus = Campuses.Id WHERE Campuses.Campus = 'Long Beach State University' AND faculty.Year = 2002;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\"\n}\n"}
{"sample_id": "train.2376", "db_id": "csu_1", "question": "How many faculty lines are there in \"San Francisco State University\" in year 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "We need to count the number of faculty lines for a specific campus and year.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to filter by campus name.", "Apply the WHERE clause to filter for 'San Francisco State University' and the year 2004.", "Use COUNT(*) to get the total number of faculty lines that meet the criteria."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) AS FacultyCount \nFROM faculty f \nJOIN Campuses c ON f.Campus = c.Id \nWHERE c.Campus = 'San Francisco State University' AND f.Year = 2004;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\"\n}\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant table for faculty data, which is the 'faculty' table.", "Determine the specific campus of interest, which is 'San Francisco State University'.", "Use a subquery to find the 'Id' of 'San Francisco State University' from the 'Campuses' table.", "Filter the faculty data for the year 2004.", "Select the 'Faculty' column to get the number of faculty lines for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Faculty FROM faculty WHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Francisco State University') AND Year = 2004;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\"\n}\n"}
{"sample_id": "train.2381", "db_id": "csu_1", "question": "How many faculty members did the university that conferred the most degrees in 2002 have?", "rationale": ["Identify the year of interest, which is 2002, to filter the degrees awarded.", "Join the 'faculty' table with the 'degrees' table on the campus identifier to correlate faculty members with the degrees awarded.", "Filter the results to only include records from the year 2002 in the degrees table.", "Order the results by the number of degrees awarded in descending order to find the campus that conferred the most degrees.", "Limit the results to 1 to get the campus with the highest number of degrees awarded in that year and retrieve the corresponding faculty count."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty f \nJOIN degrees d ON f.Campus = d.Campus \nWHERE d.Year = '2002' \nORDER BY d.Degrees DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\"\n}\n"}
{"sample_id": "train.2382", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the least number of degrees in year 2001?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'degrees' for degree data.", "We need to find the campus that conferred the least number of degrees in the year 2001, so we will filter the 'degrees' table by the year 2001.", "Join the 'faculty' table with the 'degrees' table on the campus identifier to correlate faculty data with degree data.", "We will also join the 'Campuses' table to ensure we have the correct campus information.", "Group the results by campus to count the number of degrees awarded for each campus in 2001.", "Order the campuses by the count of degrees in ascending order to find the campus with the least degrees awarded.", "Limit the results to 1 to get only the campus with the least degrees awarded.", "Finally, count the number of faculty lines for that specific campus."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(f.Faculty) AS FacultyCount\nFROM faculty f\nJOIN degrees d ON f.Campus = d.Campus\nJOIN Campuses c ON f.Campus = c.Id\nWHERE d.Year = '2001'\nGROUP BY c.Id\nORDER BY COUNT(d.Degrees) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\"\n}\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the relevant tables: 'faculty' for faculty members and 'degrees' for the number of degrees awarded.", "Join the 'faculty' table with the 'degrees' table on the 'Campus' column to correlate faculty data with degree data.", "Filter the results to only include records from the year 2001 using the WHERE clause.", "Order the results by the number of degrees awarded in ascending order to find the campus with the least degrees awarded.", "Limit the results to 1 to get only the campus with the least degrees awarded."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty f \nJOIN degrees d ON f.Campus = d.Campus \nWHERE d.Year = '2001' \nORDER BY d.Degrees ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\"\n}\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "We need to sum the number of undergraduates, so we will use the SUM function on the 'Undergraduate' column.", "To filter the results for San Jose State, we need to find the corresponding 'Id' from the 'Campuses' table where the 'Campus' name matches 'San Jose State'.", "The final SQL query will select the total number of undergraduates from the 'discipline_enrollments' table for the specific campus identified."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT SUM(Undergraduate) AS Total_Undergraduates \nFROM discipline_enrollments \nWHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Jose State');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\"\n}\n"}
{"sample_id": "train.2397", "db_id": "candidate_poll", "question": "Return the poll resource associated with the most candidates.", "rationale": ["Identify the table to query: The 'candidate' table contains the relevant data about poll sources and candidates.", "Determine the goal: We need to find the poll source associated with the most candidates.", "Use GROUP BY to group the results by 'Poll_Source' to count how many candidates are associated with each source.", "Use COUNT(Candidate_ID) to count the number of candidates for each poll source.", "Order the results in descending order to get the poll source with the highest count first.", "Limit the results to 1 to get only the top poll source."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source\nFROM candidate\nGROUP BY Poll_Source\nORDER BY COUNT(Candidate_ID) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of poll sources from the 'candidate' table, grouped by the source and ordered by the number of occurrences. The placeholder in the LIMIT clause allows the user to specify the maximum number of poll sources to retrieve.\"\n}\n"}
{"sample_id": "train.2405", "db_id": "candidate_poll", "question": "Return the poll source corresponding to the candidate who has the oppose rate.", "rationale": ["Identify the relevant table: The 'candidate' table contains the 'Poll_Source' and 'Oppose_rate' columns.", "Determine the condition: We need to find candidates who have an 'Oppose_rate', which implies that we are looking for records where 'Oppose_rate' is not null.", "Construct the SQL query: We will select the 'Poll_Source' from the 'candidate' table where the 'Oppose_rate' is not null."], "gold_sql": "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source FROM candidate WHERE Oppose_rate IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of poll sources from the 'candidate' table, grouped by the source and ordered by the number of occurrences. The placeholder in the LIMIT clause allows the user to specify the maximum number of poll sources to retrieve.\"\n}\n"}
{"sample_id": "train.2417", "db_id": "candidate_poll", "question": "For each sex, what is the name and sex of the candidate with the oppose rate for their sex?", "rationale": ["Identify the relevant tables: 'people' and 'candidate'.", "Determine the columns needed: 'Name' and 'Sex' from 'people', and 'Oppose_rate' from 'candidate'.", "Join the 'people' table with the 'candidate' table on 'People_ID'.", "Filter the results to ensure we are considering candidates based on their sex.", "Order the results by the 'Oppose_rate' in descending order to find the candidates with the highest oppose rates for each sex."], "gold_sql": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex", "source_tables": ["candidate", "people"], "pred_sql": "SELECT p.Name, p.Sex, c.Oppose_rate \nFROM people p \nJOIN candidate c ON p.People_ID = c.People_ID \nWHERE p.Sex IS NOT NULL \nORDER BY c.Oppose_rate DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the gender distribution of candidates based on their support rates. It joins the 'people' and 'candidate' tables on the 'People_ID' field, grouping the results by gender and ordering them by the average unsure rate of the candidates. The placeholder in the LIMIT clause allows for specifying the number of results to return.\"\n}\n"}
{"sample_id": "train.2434", "db_id": "movie_1", "question": "Find the titles of all movies directed by steven spielberg.", "rationale": ["Identify the relevant table: The 'Movie' table contains the information about movies, including their titles and directors.", "Determine the condition: We need to filter the movies directed by 'steven spielberg'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'title' from the 'Movie' table where the 'director' matches 'steven spielberg'."], "gold_sql": "SELECT title FROM Movie WHERE director = 'Steven Spielberg'", "source_tables": ["movie"], "pred_sql": "SELECT title FROM Movie WHERE director = 'steven spielberg';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\"\n}\n"}
{"sample_id": "train.2461", "db_id": "movie_1", "question": "What are the different names of all reviewers whose ratings do not have a date field?", "rationale": ["We need to find the names of reviewers whose ratings do not have a date field.", "This means we are looking for records in the Rating table where the ratingDate is NULL.", "To get the names of the reviewers, we will join the Reviewer table with the Rating table on the rID field.", "We will select distinct names from the Reviewer table where the corresponding rating in the Rating table has a NULL date."], "gold_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  'null'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nWHERE Rating.ratingDate IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\"\n}\n"}
{"sample_id": "train.2476", "db_id": "movie_1", "question": "Find the names of all reviewers who rated Gone with the Wind.", "rationale": ["Identify the tables involved: Reviewer, Rating, and Movie.", "We need to find the names of reviewers, so we will select the 'name' column from the Reviewer table.", "To link the reviewers to their ratings, we will join the Rating table on the 'rID' column.", "Next, we need to link the ratings to the movies, so we will join the Movie table on the 'mID' column.", "Finally, we will filter the results to only include ratings for the movie titled 'Gone with the Wind' using a WHERE clause."], "gold_sql": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  'Gone with the Wind'", "source_tables": ["rating", "movie", "reviewer"], "pred_sql": "SELECT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nJOIN Movie ON Rating.mID = Movie.mID \nWHERE Movie.title = 'Gone with the Wind';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\"\n}\n"}
{"sample_id": "train.2483", "db_id": "movie_1", "question": "What are the names of all the reviewers and movie names?", "rationale": ["We need to retrieve the names of all reviewers and the titles of movies they rated.", "To do this, we will join the Reviewer table with the Rating table on the reviewer ID (rID).", "Next, we will join the resulting table with the Movie table on the movie ID (mID) to get the movie titles.", "The final SQL query will select the reviewer names and movie titles from the joined tables."], "gold_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "source_tables": ["movie", "reviewer"], "pred_sql": "SELECT Reviewer.name, Movie.title \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nJOIN Movie ON Rating.mID = Movie.mID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\"\n}\n"}
{"sample_id": "train.2495", "db_id": "movie_1", "question": "For each director, how many reviews have they received?", "rationale": ["We need to find out how many reviews each director has received.", "To do this, we will join the 'Movie' table with the 'Rating' table on the movie ID (mID).", "We will use a LEFT JOIN to ensure we include directors who may not have any ratings.", "We will select the director's name and count the number of ratings (rID) associated with each director.", "Finally, we will group the results by the director's name to get the count of reviews for each director."], "gold_sql": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT Movie.director, COUNT(Rating.rID) AS review_count \nFROM Movie \nLEFT JOIN Rating ON Movie.mID = Rating.mID \nGROUP BY Movie.director;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the total number of ratings grouped by each director's name.\"\n}\n"}
{"sample_id": "train.2500", "db_id": "movie_1", "question": "What are the names and years of the movies that has the top 3 highest rating star?", "rationale": ["We need to find the names and years of movies with the top 3 highest ratings.", "To do this, we will first calculate the average rating for each movie using the Rating table.", "We will group the results by movie identifier (mID) and order them by the average rating in descending order to get the highest ratings first.", "We will limit the results to the top 3 movies based on their average ratings.", "Next, we will join this result with the Movie table to get the titles and years of these top-rated movies.", "Finally, we will select the title and year from the joined result."], "gold_sql": "SELECT T2.title ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID ORDER BY T1.stars DESC LIMIT 3", "source_tables": ["rating", "movie"], "pred_sql": "SELECT Movie.title, Movie.year \nFROM Movie \nJOIN (SELECT mID, AVG(stars) AS avg_rating \n      FROM Rating \n      GROUP BY mID \n      ORDER BY avg_rating DESC \n      LIMIT 3) AS TopRatedMovies \nON Movie.mID = TopRatedMovies.mID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.2502", "db_id": "movie_1", "question": "For each director, return the director's name together with the title of the movie they directed that received the highest rating among all of their movies, and the value of that rating. Ignore movies whose director is NULL.", "rationale": ["We need to find the highest-rated movie for each director.", "First, we will join the Movie and Rating tables on the movie ID (mID).", "We will filter out any movies where the director is NULL.", "Next, we will group the results by director and movie title to aggregate the ratings.", "To find the highest rating for each movie, we will use the MAX function on the stars column.", "Finally, we will use a HAVING clause to ensure we only return the movie with the highest rating for each director."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT m.director, m.title, MAX(r.stars) AS highest_rating\nFROM Movie m\nJOIN Rating r ON m.mID = r.mID\nWHERE m.director IS NOT NULL\nGROUP BY m.director, m.title\nHAVING r.stars = (SELECT MAX(stars) FROM Rating WHERE mID = m.mID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the total number of ratings grouped by each director's name.\"\n}\n"}
{"sample_id": "train.2503", "db_id": "movie_1", "question": "For each director, what are the titles and ratings for all the movies they reviewed?", "rationale": ["We need to retrieve the titles of movies and the names of reviewers along with the ratings they gave.", "To do this, we will join the Movie, Rating, and Reviewer tables based on their relationships: Rating.mID with Movie.mID and Rating.rID with Reviewer.rID.", "The SELECT statement will include Movie.title, Reviewer.name, and Rating.stars to get the required information.", "Finally, we will order the results by the reviewer's name and the movie title for better readability."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT Movie.title, Reviewer.name, Rating.stars \nFROM Movie \nJOIN Rating ON Movie.mID = Rating.mID \nJOIN Reviewer ON Rating.rID = Reviewer.rID \nORDER BY Reviewer.name, Movie.title;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\"\n}\n"}
{"sample_id": "train.2505", "db_id": "movie_1", "question": "For each reviewer id, what is the title and rating for the movie with the smallest rating?", "rationale": ["We need to find the title and rating for the movie with the smallest rating for each reviewer.", "Start by selecting the reviewer ID from the Reviewer table.", "Join the Rating table to get the ratings associated with each reviewer.", "To find the movie with the smallest rating for each reviewer, we can use a subquery that selects the minimum stars rating for each reviewer.", "Join the Movie table to get the title of the movie associated with the minimum rating.", "Finally, we order the results by reviewer ID to group the results accordingly."], "gold_sql": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID", "source_tables": ["rating", "movie"], "pred_sql": "SELECT r.rID, m.title, r2.stars \nFROM Reviewer r \nJOIN Rating r1 ON r.rID = r1.rID \nJOIN Rating r2 ON r1.mID = r2.mID \nJOIN Movie m ON r1.mID = m.mID \nWHERE r2.stars = (SELECT MIN(stars) FROM Rating WHERE rID = r.rID) \nORDER BY r.rID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\"\n}\n"}
{"sample_id": "train.2507", "db_id": "movie_1", "question": "For each director, what is the title and score of their most poorly rated movie?", "rationale": ["We need to find the title and score of the most poorly rated movie for each director.", "To do this, we will join the Movie and Rating tables on the movie ID (mID).", "We will group the results by director and movie title to aggregate the ratings.", "We will use the MIN function to find the lowest rating for each movie.", "To ensure we only get the most poorly rated movie for each director, we will use a HAVING clause that compares the lowest rating of each movie to the overall minimum rating for that director.", "Finally, we will order the results by director to make it easier to read."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT m.title, MIN(r.stars) AS lowest_rating, m.director \nFROM Movie m \nJOIN Rating r ON m.mID = r.mID \nGROUP BY m.director, m.title \nHAVING lowest_rating = (SELECT MIN(stars) \n                       FROM Rating r2 \n                       JOIN Movie m2 ON r2.mID = m2.mID \n                       WHERE m2.director = m.director) \nORDER BY m.director;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the total number of ratings grouped by each director's name.\"\n}\n"}
{"sample_id": "train.2508", "db_id": "movie_1", "question": "What is the name of the movie that is rated by most of times?", "rationale": ["Identify the goal: We need to find the name of the movie that has been rated the most times.", "Understand the schema: We have a Movie table with movie titles and a Rating table that links movies to their ratings.", "Use the Rating table to count how many times each movie has been rated. This can be done by grouping the ratings by mID and counting the occurrences.", "Order the results by the count of ratings in descending order to get the movie with the highest count at the top.", "Limit the results to 1 to get only the top-rated movie.", "Join this result back to the Movie table to get the title of the movie corresponding to the mID."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title FROM Movie WHERE mID IN (SELECT mID FROM Rating GROUP BY mID ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.2509", "db_id": "movie_1", "question": "What is the name of the movie that has been reviewed the most?", "rationale": ["To find the movie that has been reviewed the most, we need to count the number of reviews for each movie.", "We will use the Rating table to count the number of ratings (reviews) for each movie identified by mID.", "We will join the Rating table with the Movie table to get the title of each movie corresponding to its mID.", "We will group the results by the movie title to aggregate the count of reviews for each movie.", "We will order the results in descending order based on the count of reviews to get the most reviewed movie at the top.", "Finally, we will limit the results to 1 to get only the top movie that has been reviewed the most."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT Movie.title\nFROM Rating\nJOIN Movie ON Rating.mID = Movie.mID\nGROUP BY Movie.title\nORDER BY COUNT(Rating.rID) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\"\n}\n"}
{"sample_id": "train.2517", "db_id": "movie_1", "question": "What are the ids of all moviest hat have not been reviewed by Britanny Harris?", "rationale": ["Identify the unique movie identifiers from the 'Rating' table that have not been rated by the reviewer 'Britanny Harris'.", "To achieve this, we need to select all movie IDs from the Movie table.", "We will use a subquery to find all movie IDs that have been rated by 'Britanny Harris'.", "This subquery will first find the reviewer ID (rID) for 'Britanny Harris' from the Reviewer table.", "Then, we will use this rID to find all mIDs from the Rating table that correspond to the ratings given by 'Britanny Harris'.", "Finally, we will select all mIDs from the Movie table that are not in the list of mIDs returned by the subquery."], "gold_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT mID FROM Movie WHERE mID NOT IN (SELECT mID FROM Rating WHERE rID IN (SELECT rID FROM Reviewer WHERE name = 'Britanny Harris'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\"\n}\n"}
{"sample_id": "train.2518", "db_id": "movie_1", "question": "Find the average rating star for each movie that received at least 2 ratings.", "rationale": ["We need to find the average rating star for each movie that received at least 2 ratings.", "To do this, we will join the 'Movie' table with the 'Rating' table on the movie identifier (mID).", "We will select the movie title and calculate the average of the stars given in the ratings using AVG(Rating.stars).", "We will group the results by the movie identifier (Movie.mID) to ensure we get the average rating for each movie.", "To filter the results to only include movies that have received at least 2 ratings, we will use the HAVING clause with COUNT(Rating.rID) >= 2."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2", "source_tables": ["rating"], "pred_sql": "SELECT Movie.title, AVG(Rating.stars) AS average_rating\nFROM Movie\nJOIN Rating ON Movie.mID = Rating.mID\nGROUP BY Movie.mID\nHAVING COUNT(Rating.rID) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.2528", "db_id": "movie_1", "question": "What are the names of reviewers who had rated 3 star and 4 star?", "rationale": ["We need to find the names of reviewers who rated movies with 3 stars and 4 stars.", "To do this, we will join the Reviewer table with the Rating table using the rID column, which is the common identifier between these two tables.", "We will then filter the results to include only those ratings that are either 3 or 4 stars using the WHERE clause with the IN operator.", "Finally, we will select the distinct names of the reviewers to avoid duplicates in the result."], "gold_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nWHERE Rating.stars IN ('3', '4');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\"\n}\n"}
{"sample_id": "train.2530", "db_id": "movie_1", "question": "What are the names of movies that get 3 star and 4 star?", "rationale": ["Identify the tables involved: Movie and Rating.", "We need to find movie titles, so we will select the 'title' column from the Movie table.", "To filter movies based on ratings, we will join the Movie table with the Rating table on the movie identifier (mID).", "We need to filter the ratings to include only those that are 3 stars or 4 stars, which can be done using a WHERE clause with the IN operator.", "Finally, we use DISTINCT to ensure that we only get unique movie titles in the result."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "source_tables": ["rating", "movie"], "pred_sql": "SELECT DISTINCT Movie.title \nFROM Movie \nJOIN Rating ON Movie.mID = Rating.mID \nWHERE Rating.stars IN ('3', '4');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.2576", "db_id": "inn_1", "question": "Find the most popular room in the hotel. The most popular room is the room that had seen the largest number of reservations.", "rationale": ["Identify the tables involved: Rooms and Reservations.", "Determine the relationship between the tables: Reservations.Room is a foreign key that references Rooms.RoomId.", "To find the most popular room, we need to count the number of reservations for each room.", "Use a JOIN to combine data from Rooms and Reservations based on the RoomId.", "Group the results by Rooms.RoomId to aggregate the reservation counts for each room.", "Order the results by the count of reservations in descending order to get the most popular room at the top.", "Limit the results to 1 to get only the most popular room."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservation_count\nFROM Rooms\nJOIN Reservations ON Rooms.RoomId = Reservations.Room\nGROUP BY Rooms.RoomId\nORDER BY reservation_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.2577", "db_id": "inn_1", "question": "Which room has the largest number of reservations?", "rationale": ["Identify the tables involved: Rooms and Reservations.", "We need to find the room with the largest number of reservations, which means we need to count the number of reservations for each room.", "Join the Rooms table with the Reservations table on the RoomId to get the relevant data.", "Use COUNT() to count the number of reservations for each room.", "Group the results by the RoomId to aggregate the counts for each room.", "Order the results by the count of reservations in descending order to get the room with the most reservations at the top.", "Limit the results to 1 to get only the room with the largest number of reservations."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservation_count\nFROM Rooms\nJOIN Reservations ON Rooms.RoomId = Reservations.Room\nGROUP BY Rooms.RoomId\nORDER BY reservation_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.2578", "db_id": "inn_1", "question": "How many kids stay in the rooms reserved by ROY SWEAZY?", "rationale": ["Identify the relevant tables: Reservations contains the information about guests and their reservations, including the number of kids.", "We need to sum the number of kids for reservations made by the guest with the first name 'ROY' and last name 'SWEAZY'.", "Use the SUM function to calculate the total number of kids from the 'Kids' column in the Reservations table.", "Filter the results using a WHERE clause to match the specified first and last names."], "gold_sql": "SELECT kids FROM Reservations WHERE FirstName = 'ROY' AND LastName  =  'SWEAZY';", "source_tables": ["reservations"], "pred_sql": "SELECT SUM(Kids) AS TotalKids\nFROM Reservations\nWHERE FirstName = 'ROY' AND LastName = 'SWEAZY';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\"\n}\n"}
{"sample_id": "train.2582", "db_id": "inn_1", "question": "Which room has the highest rate? List the room's full name, rate, check in and check out date.", "rationale": ["Identify the relevant tables: Rooms and Reservations.", "Determine the columns needed: roomName from Rooms, Rate, CheckIn, and CheckOut from Reservations.", "Join the Rooms and Reservations tables on the RoomId and Room columns respectively to access the necessary data.", "Use a subquery to find the maximum rate from the Reservations table.", "Filter the results to only include the room(s) with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, Reservations.Rate, Reservations.CheckIn, Reservations.CheckOut \nFROM Rooms \nJOIN Reservations ON Rooms.RoomId = Reservations.Room \nWHERE Reservations.Rate = (SELECT MAX(Rate) FROM Reservations);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\"\n}\n"}
{"sample_id": "train.2583", "db_id": "inn_1", "question": "Return the name, rate, check in and check out date for the room with the highest rate.", "rationale": ["Identify the required fields: room name, rate, check-in date, and check-out date.", "Determine the tables involved: Rooms and Reservations.", "Establish the relationship between the tables using the foreign key: Reservations.Room = Rooms.RoomId.", "Use a JOIN to combine data from both tables based on the relationship.", "To find the room with the highest rate, use a subquery to select the maximum rate from the Reservations table.", "Filter the results to only include the room(s) with this maximum rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, Reservations.Rate, Reservations.CheckIn, Reservations.CheckOut \nFROM Rooms \nJOIN Reservations ON Rooms.RoomId = Reservations.Room \nWHERE Reservations.Rate = (SELECT MAX(Rate) FROM Reservations);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\"\n}\n"}
{"sample_id": "train.2589", "db_id": "inn_1", "question": "Find the total number of king beds available.", "rationale": ["Identify the relevant table: Rooms.", "Determine the column that contains the bed type: bedType.", "Filter the rows to only include those with 'king' in the bedType column.", "Sum the number of beds in the filtered rows to get the total number of king beds available."], "gold_sql": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT SUM(beds) AS TotalKingBeds FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\"\n}\n"}
{"sample_id": "train.2590", "db_id": "inn_1", "question": "List the names and decor of rooms that have a king bed. Sort the list by their price.", "rationale": ["Identify the relevant table: Rooms.", "Determine the columns needed: roomName and decor.", "Filter the results to include only rooms with a king bed by using a WHERE clause: bedType = 'king'.", "Sort the results by the base price of the rooms in ascending order using ORDER BY basePrice."], "gold_sql": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName, decor FROM Rooms WHERE bedType = 'king' ORDER BY basePrice;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.2594", "db_id": "inn_1", "question": "What is the decor of room Recluse and defiance?", "rationale": ["Identify the relevant table: Rooms.", "Determine the columns needed: decor and roomName.", "Filter the results to only include the rooms named 'Recluse' and 'defiance'.", "Construct the SQL query to select the decor for the specified room names."], "gold_sql": "SELECT decor FROM Rooms WHERE roomName  =  'Recluse and defiance';", "source_tables": ["rooms"], "pred_sql": "SELECT decor FROM Rooms WHERE roomName IN ('Recluse', 'defiance');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.2604", "db_id": "inn_1", "question": "Find the first and last names of people who payed more than the rooms' base prices.", "rationale": ["Identify the tables involved: Reservations and Rooms.", "Determine the columns needed: FirstName and LastName from Reservations, and basePrice from Rooms.", "Establish the relationship between the two tables using the foreign key: Reservations.Room = Rooms.RoomId.", "Formulate the condition to filter results: Rate from Reservations must be greater than basePrice from Rooms.", "Construct the SQL query using SELECT to retrieve the required columns, JOIN to combine the tables, and WHERE to apply the condition."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT r.FirstName, r.LastName\nFROM Reservations r\nJOIN Rooms rm ON r.Room = rm.RoomId\nWHERE r.Rate > rm.basePrice;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\"\n}\n"}
{"sample_id": "train.2609", "db_id": "inn_1", "question": "How many rooms have a king bed?", "rationale": ["Identify the table to query: Rooms.", "Determine the relevant column for bed type: bedType.", "Filter the results to only include rooms with a king bed by using a WHERE clause.", "Count the number of rooms that meet the criteria using COUNT(*) function."], "gold_sql": "SELECT count(*) FROM Rooms WHERE bedType  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT COUNT(*) FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\"\n}\n"}
{"sample_id": "train.2612", "db_id": "inn_1", "question": "Find the name of the room with the maximum occupancy.", "rationale": ["Identify the table to query: The 'Rooms' table contains the information about room names and their maximum occupancy.", "Determine the requirement: We need to find the room name with the maximum occupancy.", "Use a subquery to find the maximum occupancy: We can use a subquery to get the maximum value of the 'maxOccupancy' column from the 'Rooms' table.", "Select the room name: Finally, we select the 'roomName' from the 'Rooms' table where the 'maxOccupancy' matches the maximum value found in the subquery."], "gold_sql": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE maxOccupancy = (SELECT MAX(maxOccupancy) FROM Rooms);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\"\n}\n"}
{"sample_id": "train.2621", "db_id": "inn_1", "question": "What is the average minimum and price of the rooms for each different decor.", "rationale": ["Identify the relevant columns needed for the query: 'decor' from the Rooms table and 'basePrice' for calculating average and minimum prices.", "Use the AVG() function to calculate the average price of rooms for each decor type.", "Use the MIN() function to find the minimum price of rooms for each decor type.", "Group the results by the 'decor' column to get the average and minimum prices for each unique decor type.", "Construct the SQL query using the SELECT statement to retrieve the desired information from the Rooms table."], "gold_sql": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;", "source_tables": ["rooms"], "pred_sql": "SELECT decor, AVG(basePrice) AS averagePrice, MIN(basePrice) AS minimumPrice \nFROM Rooms \nGROUP BY decor;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.2628", "db_id": "inn_1", "question": "List the name of rooms with king or queen bed.", "rationale": ["Identify the table to query: The 'Rooms' table contains the information about room names and bed types.", "Determine the columns needed: We need the 'roomName' column to list the names of the rooms.", "Specify the condition: We are interested in rooms that have either 'king' or 'queen' beds.", "Use the SQL SELECT statement to retrieve the desired data from the 'Rooms' table, applying the WHERE clause to filter by bed types."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE bedType IN ('king', 'queen');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\"\n}\n"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["We need to find the name of each room and the number of reservations made for each room.", "To achieve this, we will select the 'roomName' from the 'Rooms' table.", "We will also count the number of reservations associated with each room, which can be done using the COUNT function on the 'Code' column from the 'Reservations' table.", "Since a room may not have any reservations, we will use a LEFT JOIN to include all rooms even if they have zero reservations.", "The join condition will be based on the 'RoomId' from the 'Rooms' table matching the 'Room' from the 'Reservations' table.", "Finally, we will group the results by 'roomName' to get the count of reservations for each room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservation_count\nFROM Rooms\nLEFT JOIN Reservations ON Rooms.RoomId = Reservations.Room\nGROUP BY Rooms.roomName;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\"\n}\n"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["Identify the table needed: The question asks for details of trucks, so we will use the 'Trucks' table.", "Select all columns: We need all details, so we will use SELECT *.", "Order by license number: The question specifies to order the results by the truck's license number, so we will add ORDER BY truck_licence_number."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "pred_sql": "SELECT * FROM Trucks ORDER BY truck_licence_number;", "hint": "\n"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to find customer names, so we will select 'customer_name' from the Customers table.", "To filter customers based on their address, we need to join the Customers table with the Customer_Addresses table using 'customer_id'.", "Next, we join the Customer_Addresses table with the Addresses table using 'address_id' to access the state information.", "Finally, we apply a WHERE clause to filter out customers whose state is 'California'."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT customer_name \nFROM Customers c \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nJOIN Addresses a ON ca.address_id = a.address_id \nWHERE a.state_province_county != 'California';", "hint": "\n"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["Identify the relevant tables: Delivery_Routes, Delivery_Route_Locations, and Order_Deliveries are needed to find the route with the highest number of deliveries.", "Join Delivery_Routes with Delivery_Route_Locations on route_id to link routes with their locations.", "Join the result with Order_Deliveries on location_code to associate deliveries with their respective routes.", "Group the results by route_name to count the number of deliveries for each route.", "Order the results in descending order based on the count of deliveries to find the route with the highest number.", "Limit the results to 1 to get only the top route."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "pred_sql": "SELECT route_name\nFROM Delivery_Routes\nJOIN Delivery_Route_Locations ON Delivery_Routes.route_id = Delivery_Route_Locations.route_id\nJOIN Order_Deliveries ON Delivery_Route_Locations.location_code = Order_Deliveries.location_code\nGROUP BY route_name\nORDER BY COUNT(Order_Deliveries.actual_order_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3175", "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["Identify the relevant tables: PROFESSOR and CLASS are needed to find professors teaching a specific class.", "We need to count the number of distinct professors, so we will use COUNT(DISTINCT p.EMP_NUM).", "Join the PROFESSOR table with the CLASS table on the condition that the professor's employee number matches the professor number in the CLASS table.", "Filter the results to only include classes with the CLASS_CODE 'ACCT-211'."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) AS professor_count \nFROM PROFESSOR p \nJOIN CLASS c ON p.EMP_NUM = c.PROF_NUM \nWHERE c.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\"\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: PROFESSOR, DEPARTMENT, and CLASS are needed to find professors teaching a specific class.", "Join the PROFESSOR table with the DEPARTMENT table on DEPT_CODE to get the department information for each professor.", "Join the resulting table with the CLASS table on the CRS_CODE to link professors to the classes they teach.", "Filter the results to only include classes with the CLASS_CODE 'ACCT-211'.", "Count the distinct EMP_NUM from the PROFESSOR table to get the number of unique professors teaching that class."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) AS professor_count\nFROM PROFESSOR p\nJOIN DEPARTMENT d ON p.DEPT_CODE = d.DEPT_CODE\nJOIN CLASS c ON p.DEPT_CODE = c.CRS_CODE\nWHERE c.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\"\n}\n"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["Identify the relevant tables: CLASS, PROFESSOR, EMPLOYEE, and COURSE.", "We need to retrieve the first names and date of birth of professors, so we will select EMPLOYEE.EMP_FNAME and EMPLOYEE.EMP_DOB.", "Join the CLASS table with the PROFESSOR table on the condition that CLASS.PROF_NUM matches PROFESSOR.EMP_NUM to get the professors for each class.", "Join the PROFESSOR table with the EMPLOYEE table on PROFESSOR.EMP_NUM to access the first names and date of birth of the professors.", "Join the CLASS table with the COURSE table on CLASS.CRS_CODE to filter the results for the specific course ACCT-211.", "Add a WHERE clause to filter the results to only include the course with CRS_CODE 'ACCT-211'."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, EMPLOYEE.EMP_DOB \nFROM CLASS \nJOIN PROFESSOR ON CLASS.PROF_NUM = PROFESSOR.EMP_NUM \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nWHERE COURSE.CRS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3188", "db_id": "college_1", "question": "Where is the history department?", "rationale": ["Identify the relevant table for department information, which is the DEPARTMENT table.", "We need to find the location of the History department, so we will select the DEPT_NAME and DEPT_ADDRESS columns.", "To filter for the History department, we will use a WHERE clause to specify that DEPT_NAME should be 'History'."], "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"], "pred_sql": "SELECT DEPT_NAME, DEPT_ADDRESS FROM DEPARTMENT WHERE DEPT_NAME = 'History';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the relevant table: The question asks for locations associated with a specific school code, which is found in the DEPARTMENT table.", "Select the appropriate column: The DEPT_ADDRESS column contains the addresses of the departments, which represent the locations of the school.", "Apply a filter: Use a WHERE clause to filter the results to only include departments that belong to the school with the code 'BUS'.", "Use DISTINCT to ensure that each location is listed only once, even if multiple departments share the same address."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.\"\n}\n"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["We need to find the total credit hours offered by each department.", "The relevant tables for this query are COURSE and DEPARTMENT, as well as CLASS to link courses to classes.", "We will join the COURSE table with the DEPARTMENT table on the DEPT_CODE to get the department information for each course.", "Next, we will join the CLASS table to the COURSE table on the CRS_CODE to link classes to their respective courses.", "We will use the SUM function to aggregate the total credit hours (CRS_CREDIT) for each department.", "Finally, we will group the results by DEPARTMENT.DEPT_CODE to get the total credit hours for each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, SUM(CAST(COURSE.CRS_CREDIT AS INTEGER)) AS TOTAL_CREDIT\nFROM COURSE\nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE\nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\"\n}\n"}
{"sample_id": "train.3202", "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["The question asks for the total credits offered by each department.", "To find this information, we need to look at the 'COURSE' table, which contains the 'CRS_CREDIT' column that indicates the number of credit hours for each course.", "We will group the results by 'DEPT_CODE' to aggregate the total credits for each department.", "The SQL query will use the SUM function to calculate the total credits for each department code."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT DEPT_CODE, SUM(CRS_CREDIT) AS TOTAL_CREDITS\nFROM COURSE\nGROUP BY DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\"\n}\n"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["We need to find the school with the smallest number of professors.", "To do this, we will count the number of professors associated with each school.", "Professors are linked to departments, and departments are linked to schools through the SCHOOL_CODE.", "We will join the DEPARTMENT and PROFESSOR tables on the DEPT_CODE to get the count of professors per school.", "We will group the results by SCHOOL_CODE and count the number of professors for each school.", "Finally, we will order the results by the count of professors in ascending order and limit the result to 1 to get the school with the smallest number of professors."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "pred_sql": "SELECT SCHOOL_CODE, COUNT(PROF_NUM) AS PROFESSOR_COUNT \nFROM DEPARTMENT \nJOIN PROFESSOR ON DEPARTMENT.DEPT_CODE = PROFESSOR.DEPT_CODE \nGROUP BY SCHOOL_CODE \nORDER BY PROFESSOR_COUNT ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\"\n}\n"}
{"sample_id": "train.3215", "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["We need to find the number of professors with a Ph.D. degree in each department.", "The relevant tables are PROFESSOR and DEPARTMENT, as we need to count professors and group them by department.", "We will join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE column to associate professors with their respective departments.", "We will filter the results to include only those professors whose highest degree is 'Ph.D.' using a WHERE clause.", "Finally, we will group the results by DEPARTMENT.DEPT_CODE and count the number of professors in each group using COUNT()."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, COUNT(PROFESSOR.EMP_NUM) AS PH_D_COUNT\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nWHERE PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D.'\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\"\n}\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["Identify the relevant table: The STUDENT table contains information about students, including their department codes.", "Determine the required output: We need to count the number of students for each department.", "Use the COUNT() function to aggregate the number of students (STU_NUM) for each department (DEPT_CODE).", "Group the results by DEPT_CODE to get the count for each department.", "Construct the SQL query using SELECT, COUNT(), and GROUP BY clauses."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPT_CODE, COUNT(STU_NUM) AS student_count FROM STUDENT GROUP BY DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students grouped by their department codes from the 'student' table. The placeholder in the SELECT statement represents the department code for which the count of students is being aggregated.\"\n}\n"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["We need to find the total number of hours completed by students in each department.", "The relevant table for student credit hours is the STUDENT table, which contains the column STU_HRS for total credit hours.", "We also need to group these results by department, which is represented in the DEPARTMENT table with the DEPT_CODE column.", "To get the total hours per department, we will use the SUM function on the STU_HRS column and group the results by DEPT_CODE.", "We will join the STUDENT table with the DEPARTMENT table on the DEPT_CODE to associate students with their respective departments."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, SUM(STUDENT.STU_HRS) AS TOTAL_HOURS\nFROM STUDENT\nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\"\n}\n"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["Identify the relevant tables: COURSE, CLASS, and DEPARTMENT.", "Join the COURSE and CLASS tables on CRS_CODE to link courses with their respective classes.", "Join the resulting table with the DEPARTMENT table on DEPT_CODE to associate courses with their departments.", "Use SUM to calculate the total credit hours for each department by grouping the results by DEPT_CODE.", "Order the results in descending order based on the total credits to find the department with the most credits.", "Limit the results to 1 to get only the department with the highest total credits."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, SUM(COURSE.CRS_CREDIT) AS TOTAL_CREDITS\nFROM COURSE\nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE\nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE\nORDER BY TOTAL_CREDITS DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\"\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the relevant tables: STUDENT, ENROLL, and CLASS are needed to find the first names of students enrolled in a specific class.", "The STUDENT table contains the first names of students (STU_FNAME).", "The ENROLL table links students to classes they are enrolled in via STU_NUM and CLASS_CODE.", "The CLASS table contains the class code (CLASS_CODE) to filter for the specific class 'ACCT-211'.", "Join the ENROLL table with STUDENT on STU_NUM to get student details, and join with CLASS on CLASS_CODE to filter by the class code.", "Select the first names of students from the resulting joined tables where the class code matches 'ACCT-211'."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["Identify the tables needed: STUDENT for student names, ENROLL for enrollment details, and CLASS for class information.", "We need to find students enrolled in a specific class (ACCT-211) and who received a specific grade (C).", "Join the STUDENT table with the ENROLL table on the student number (STU_NUM) to get enrollment details for each student.", "Join the ENROLL table with the CLASS table on the class code (CLASS_CODE) to filter by the specific class (ACCT-211).", "Add a WHERE clause to filter for the class code 'ACCT-211' and the grade 'C'.", "Select the first names of the students from the STUDENT table."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211' AND ENROLL.ENROLL_GRADE = 'C';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\"\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["We need to find the department with the most students enrolled.", "First, we will create a virtual table that counts the number of students in each department by grouping the 'STUDENT' table by 'DEPT_CODE'.", "Next, we will join this virtual table with the 'DEPARTMENT' table to get the department names corresponding to the department codes.", "We will order the results by the count of students in descending order to get the department with the highest count at the top.", "Finally, we will limit the results to 1 to get only the department with the most students."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME\nFROM DEPARTMENT\nJOIN (\n    SELECT DEPT_CODE, COUNT(STU_NUM) AS student_count\n    FROM STUDENT\n    GROUP BY DEPT_CODE\n) AS dept_student_count ON DEPARTMENT.DEPT_CODE = dept_student_count.DEPT_CODE\nORDER BY student_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students grouped by their department codes from the 'student' table. The placeholder in the SELECT statement represents the department code for which the count of students is being aggregated.\"\n}\n"}
{"sample_id": "train.3257", "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["Identify the relevant table: The CLASS table contains information about class schedules, including the room where classes are held.", "Determine the specific column needed: We need the CRS_CODE column from the CLASS table, which represents the course code.", "Filter the results: We want to find classes that are specifically held in room 'KLR209'.", "Use the SELECT statement to retrieve the distinct course codes from the CLASS table where the CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE\nFROM CLASS\nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\"\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about class locations, including the CLASS_ROOM column.", "Determine the specific condition: We need to filter the results to only include classes held in room 'KLR209'.", "Select the desired output: We want the unique course codes (CRS_CODE) associated with the classes in that room.", "Construct the SQL query: Use SELECT DISTINCT to get unique course codes from the CLASS table where the CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE \nFROM CLASS \nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\"\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed since we want student names and their grades.", "Determine the relationship: STUDENT is related to ENROLL through the STU_NUM column.", "Select the required fields: We need the first name of the students, which is in the STUDENT table (STU_FNAME).", "Filter the results: We want only those students who received a grade of 'C', which is specified in the ENROLL table (ENROLL_GRADE).", "Construct the SQL query using a JOIN to combine STUDENT and ENROLL on the STU_NUM field, and apply the WHERE clause to filter by grade 'C'."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["We need to find the first names of professors who do not teach a class.", "To do this, we will use the EMPLOYEE table to get the first names of professors.", "We will join the PROFESSOR table to link professors with their employee records.", "Next, we will perform a LEFT JOIN with the CLASS table to find any classes taught by the professors.", "By using a LEFT JOIN, we can identify professors who do not have any corresponding entries in the CLASS table.", "Finally, we will filter the results where CLASS.CLASS_CODE is NULL, indicating that the professor does not teach any class."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM EMPLOYEE \nLEFT JOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nLEFT JOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CLASS_CODE IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["We need to find the first names of professors who are not teaching any classes.", "To do this, we will use the EMPLOYEE table to get the first names of professors.", "We will perform a LEFT JOIN between the EMPLOYEE table and the PROFESSOR table to include all employees and their corresponding professor details.", "Next, we will perform another LEFT JOIN with the CLASS table to find out if these professors are teaching any classes.", "In the WHERE clause, we will check for NULL values in CLASS.CLASS_CODE, which indicates that the professor is not teaching any classes."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM EMPLOYEE \nLEFT JOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nLEFT JOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CLASS_CODE IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors and their highest degrees.", "Determine the criteria: We need to count professors who have either a Ph.D. or a Masters degree.", "Construct the SQL query: Use the COUNT function to count the number of professors meeting the criteria, filtering with a WHERE clause for the degrees."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) AS NumberOfProfessors\nFROM PROFESSOR\nWHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, and COURSE.", "We need to find the first name of the professor, which is in the EMPLOYEE table.", "The CLASS table contains the class information, including the professor's ID (PROF_NUM).", "The COURSE table contains the course codes (CRS_CODE) we are interested in: 'CIS-220' and 'QM-261'.", "We will join the CLASS table with the EMPLOYEE table on the professor's ID to get the professor's first name.", "We will also join the CLASS table with the COURSE table to filter by the specific course codes.", "Use a WHERE clause to specify that we want courses with the codes 'CIS-220' and 'QM-261'."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM CLASS \nJOIN EMPLOYEE ON CLASS.PROF_NUM = EMPLOYEE.EMP_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nWHERE COURSE.CRS_CODE IN ('CIS-220', 'QM-261');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["We need to find the first names of students enrolled in classes from specific departments: Accounting and Computer Info. Systems.", "To achieve this, we will join several tables: STUDENT, ENROLL, CLASS, COURSE, and DEPARTMENT.", "The STUDENT table contains the first names of students, while the ENROLL table links students to the classes they are taking.", "The CLASS table provides information about the classes, and the COURSE table gives details about the courses associated with those classes.", "The DEPARTMENT table contains the names of the departments, which we will filter to include only 'Accounting' and 'Computer Info. Systems'.", "We will use a SELECT statement to retrieve the distinct first names of students who meet these criteria."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME IN ('Accounting', 'Computer Info. Systems');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3308", "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["Identify the required information: first names and office locations of professors.", "Determine the relevant tables: PROFESSOR for office details, EMPLOYEE for first names, and DEPARTMENT for department names.", "Join the PROFESSOR table with the EMPLOYEE table to get the first names of professors.", "Join the PROFESSOR table with the DEPARTMENT table to filter for the history department.", "Add a condition to filter professors who have a Ph.D."], "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'History' \nAND PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3319", "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["Identify the tables needed: STUDENT for student names and ENROLL for enrollment details including grades.", "Join the STUDENT table with the ENROLL table on the student identifier (STU_NUM) to link students with their grades.", "Filter the results to include only those students who received either an 'A' or a 'C' grade by using a WHERE clause with the IN operator.", "Select the distinct first and last names of the students to avoid duplicates in the result."], "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME, S.STU_LNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nWHERE E.ENROLL_GRADE IN ('A', 'C');", "hint": "\n"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, PROFESSOR, COURSE, and DEPARTMENT.", "We need to retrieve the first names of professors and their highest degree, so we will select EMPLOYEE.EMP_FNAME and PROFESSOR.PROF_HIGH_DEGREE.", "Join the CLASS table with the PROFESSOR table on the professor's employee number (PROF_NUM).", "Join the PROFESSOR table with the EMPLOYEE table to get the first names of the professors.", "Join the CLASS table with the COURSE table to link classes to their respective courses.", "Join the COURSE table with the DEPARTMENT table to filter by the Computer Information Systems department.", "Use a WHERE clause to specify that we only want professors from the Computer Information Systems department."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_HIGH_DEGREE \nFROM CLASS \nJOIN PROFESSOR ON CLASS.PROF_NUM = PROFESSOR.EMP_NUM \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'Computer Information Systems';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: CLASS, COURSE, and DEPARTMENT.", "We need to find the department name, so we will select DEPARTMENT.DEPT_NAME.", "The class description is in the COURSE table, so we will filter based on COURSE.CRS_DESCRIPTION.", "To link the tables, we will join CLASS and COURSE on CLASS.CRS_CODE = COURSE.CRS_CODE.", "Next, we will join COURSE and DEPARTMENT on COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE.", "Finally, we will add a WHERE clause to filter for descriptions that contain the word 'Statistics'."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME \nFROM CLASS \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE COURSE.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\"\n}\n"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["Identify the relevant table: The question asks about competition types and countries, which are found in the 'competition' table.", "Select the required columns: We need to select 'Competition_type' and 'Country' from the 'competition' table.", "Use DISTINCT to avoid duplicate entries: Since we want unique combinations of competition types and countries, we will use the DISTINCT keyword.", "Order the results: Although the hint suggests ordering by occurrences, the question does not specify a particular order, so we will order by 'Competition_type' for clarity."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT Competition_type, Country FROM competition ORDER BY Competition_type;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\"\n}\n"}
{"sample_id": "train.3355", "db_id": "sports_competition", "question": "Please show the names and the players of clubs.", "rationale": ["Identify the tables needed: 'club' for club names and 'player' for player names.", "Determine the relationship between the tables: 'player' has a foreign key 'Club_ID' that references 'club'.", "Use a JOIN operation to combine data from both tables based on the 'Club_ID'.", "Select the desired columns: the name of the club and the name of the player."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "pred_sql": "SELECT c.name AS club_name, p.name AS player_name \nFROM club c \nJOIN player p ON c.Club_ID = p.Club_ID;", "hint": "\n"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "We need to find the positions of players, so we will select the 'Position' column from the 'player' table.", "To find the average number of points scored by each position, we will use the AVG() function on the 'Points' column.", "We need to group the results by 'Position' to calculate the average points for each position.", "Finally, we will filter the results to include only those positions where the average points scored is greater than 20 using the HAVING clause."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "pred_sql": "SELECT Position\nFROM player\nGROUP BY Position\nHAVING AVG(Points) > 20;", "hint": "\n"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant column for player positions, which is 'Position'.", "Identify the column that contains the points scored by players, which is 'Points'.", "Formulate the condition to filter players based on their points: greater than 20 or less than 10.", "Construct the SQL SELECT statement to retrieve the 'Position' of players that meet the specified conditions."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player WHERE Points > 20 OR Points < 10;", "hint": "\n"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about different competitions, including their type and country.", "Filter for tournament competitions: We need to focus on competitions of type 'tournament'.", "Group by country: To find out how many tournaments each country participated in, we will group the results by the 'Country' column.", "Count the number of tournaments: We will use the COUNT function to count the number of tournaments for each country.", "Order the results: We will order the results in descending order based on the count of tournaments to find the country with the most tournaments.", "Limit the results: Since we only want the country with the most tournaments, we will limit the results to 1."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country, COUNT(*) AS Tournament_Count\nFROM competition\nWHERE Competition_type = 'tournament'\nGROUP BY Country\nORDER BY Tournament_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\"\n}\n"}
{"sample_id": "train.3384", "db_id": "sports_competition", "question": "what is the name of the country that participated in the most tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about the competitions, including the type and country.", "Filter for tournament competitions: We need to focus on competitions of type 'tournament'.", "Group by country: To find out how many tournaments each country participated in, we will group the results by the 'Country' column.", "Count the occurrences: We will count the number of tournaments for each country using COUNT(*) in the SELECT statement.", "Order by count in descending order: To find the country with the most tournaments, we will order the results by the count in descending order.", "Limit the results: We only need the top result, so we will use LIMIT 1 to get the country with the most tournaments."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country FROM competition WHERE Competition_type = 'tournament' GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\"\n}\n"}
{"sample_id": "train.3388", "db_id": "sports_competition", "question": "What are the countries that have never participated in any friendly-type competitions?", "rationale": ["We need to find countries that have never participated in friendly-type competitions.", "To do this, we will select distinct countries from the competition table.", "We will perform a LEFT JOIN with the competition_result table to check for any participation in friendly competitions.", "We will filter the results to only include competitions of type 'friendly'.", "To ensure we only get countries that have never participated, we will check that both Club_ID_1 and Club_ID_2 are NULL in the competition_result table."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT c.Country \nFROM competition c \nLEFT JOIN competition_result cr ON c.Competition_ID = cr.Competition_ID \nWHERE c.Competition_type = 'friendly' \nAND cr.Club_ID_1 IS NULL \nAND cr.Club_ID_2 IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\"\n}\n"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["Identify the relevant table: The 'employees' table contains the necessary information about employees' names and salaries.", "Determine the required fields: We need to select the 'FIRST_NAME', 'LAST_NAME', and 'SALARY' columns from the 'employees' table.", "Apply the condition: We need to filter the results to include only those employees whose salary is below 6000, which can be done using a WHERE clause.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME, LAST_NAME, SALARY FROM employees WHERE SALARY < 6000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\"\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department id.", "To get the full name, we can concatenate the first and last names of the employees.", "We need to filter employees whose first name does not contain the letter 'M'.", "The SQL query will select from the 'employees' table and apply the necessary conditions."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT CONCAT(e.FIRST_NAME, ' ', e.LAST_NAME) AS FULL_NAME, e.HIRE_DATE, e.SALARY, e.DEPARTMENT_ID \nFROM employees e \nWHERE e.FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate the FIRST_NAME and LAST_NAME fields from the employees table.", "The hire date and salary are directly taken from the employees table.", "The department number is represented by the DEPARTMENT_ID from the employees table.", "Filter the employees whose first name does not contain the letter 'M' using the NOT LIKE operator.", "Sort the results in ascending order by the department number (DEPARTMENT_ID).", "Construct the SQL query using the SELECT statement with the identified fields, the FROM clause to specify the employees table, the WHERE clause for filtering, and the ORDER BY clause for sorting."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE, e.SALARY, e.DEPARTMENT_ID \nFROM employees e \nWHERE e.FIRST_NAME NOT LIKE '%M%' \nORDER BY e.DEPARTMENT_ID ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department id.", "To create the full name, concatenate the first and last names using '||'.", "Filter employees whose first name does not contain the letter 'M' using the NOT LIKE operator.", "Order the results by department id in ascending order.", "Construct the SQL SELECT statement with the identified fields and conditions."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE, e.SALARY, e.DEPARTMENT_ID\nFROM employees e\nWHERE e.FIRST_NAME NOT LIKE '%M%'\nORDER BY e.DEPARTMENT_ID ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The 'jobs' table contains job titles and salary information.", "Determine the condition: We need to find jobs with salaries over 9000, which refers to the 'MAX_SALARY' column in the 'jobs' table.", "Construct the SQL query: We will select the 'JOB_TITLE' from the 'jobs' table where 'MAX_SALARY' is greater than 9000."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE FROM jobs WHERE MAX_SALARY > 9000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\"\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The question asks for job titles and salary ranges, which are found in the 'jobs' table.", "Select the required columns: We need to select 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY' from the 'jobs' table.", "Apply the filter condition: The question specifies that we need jobs with a maximum salary between 12000 and 18000, so we will use a WHERE clause to filter the results based on 'MAX_SALARY'.", "Construct the SQL query: Combine the selected columns, the table name, and the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY \nFROM jobs \nWHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\"\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["We need to retrieve the employee IDs and the final dates of employment for each employee.", "The relevant table for employment history is 'job_history', which contains the 'EMPLOYEE_ID' and 'END_DATE' columns.", "To get the last job end date for each employee, we can use the MAX function on the 'END_DATE' column.", "We will group the results by 'EMPLOYEE_ID' to ensure we get the latest end date for each employee."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT EMPLOYEE_ID, MAX(END_DATE) AS LAST_JOB_END_DATE\nFROM job_history\nGROUP BY EMPLOYEE_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the employee's unique identifier, while the MAX function is used to retrieve the latest end date for each employee's job history.\"\n}\n"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["We need to display the average salary of employees for each department who gets a commission percentage.", "To calculate the average salary, we will use the AVG() function on the SALARY column from the employees table.", "We need to filter employees who have a commission percentage, so we will use a WHERE clause to check if COMMISSION_PCT is not NULL.", "To group the results by department, we will join the employees table with the departments table on the DEPARTMENT_ID column and use GROUP BY on the DEPARTMENT_ID.", "Finally, we will select the DEPARTMENT_ID and the calculated average salary in the SELECT clause."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, AVG(e.SALARY) AS average_salary\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nWHERE e.COMMISSION_PCT IS NOT NULL\nGROUP BY d.DEPARTMENT_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\"\n}\n"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["Identify the table needed: The 'employees' table contains salary and commission percentage information.", "Determine the condition: We need to filter employees whose commission percentage is not null.", "Calculate the average salary: Use the AVG() function to compute the average salary of the filtered employees."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT AVG(SALARY) AS average_salary\nFROM employees\nWHERE COMMISSION_PCT IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\"\n}\n"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["Identify the relevant tables: countries and locations.", "Determine the columns needed: COUNTRY_ID from countries and the count of cities from locations.", "Establish the relationship between countries and locations using the COUNTRY_ID foreign key.", "Use a JOIN to combine the countries and locations tables based on the COUNTRY_ID.", "Use COUNT to count the number of cities for each country.", "Group the results by COUNTRY_ID to get the count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT countries.COUNTRY_ID, COUNT(locations.CITY) AS number_of_cities\nFROM countries\nJOIN locations ON countries.COUNTRY_ID = locations.COUNTRY_ID\nGROUP BY countries.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["Identify the tables needed: 'countries' for country information and 'locations' for city information.", "Determine the relationship between the tables: 'locations' has a foreign key 'COUNTRY_ID' that links to 'countries'.", "Use a JOIN to combine 'countries' and 'locations' on 'COUNTRY_ID'.", "Count the number of cities (from 'locations') for each country (from 'countries').", "Group the results by 'COUNTRY_ID' to get the count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT c.COUNTRY_ID, COUNT(l.CITY) AS CITY_COUNT\nFROM countries c\nJOIN locations l ON c.COUNTRY_ID = l.COUNTRY_ID\nGROUP BY c.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["We need to retrieve detailed information about jobs from the 'jobs' table.", "The condition specifies that we are interested in jobs done by employees who currently earn a salary of 12000 or more.", "To find these employees, we will query the 'employees' table for those with a salary >= 12000.", "Next, we need to find the job history of these employees, which is stored in the 'job_history' table.", "We will select the JOB_ID from the 'job_history' table where the EMPLOYEE_ID matches those from the previous step.", "Finally, we will use the JOB_IDs obtained from the job history to filter the 'jobs' table and retrieve the detailed information about those jobs."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "pred_sql": "SELECT j.* FROM jobs j WHERE j.JOB_ID IN (SELECT jh.JOB_ID FROM job_history jh WHERE jh.EMPLOYEE_ID IN (SELECT e.EMPLOYEE_ID FROM employees e WHERE e.SALARY >= 12000));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\"\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the main requirement: Retrieve all information about employees who are managers.", "To find employees who are managers, we need to check the 'MANAGER_ID' field in the 'employees' table.", "We will use a subquery to get distinct 'MANAGER_ID's from the 'employees' table.", "We need to join the 'employees' table with the 'departments' table to get department names, and with the 'locations' table to get city and state/province information.", "The final query will select all columns from the 'employees' table along with the department name, city, and state/province from the joined tables."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT e.*, d.DEPARTMENT_NAME, l.CITY, l.STATE_PROVINCE \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE e.EMPLOYEE_ID IN (SELECT DISTINCT MANAGER_ID FROM employees WHERE MANAGER_ID IS NOT NULL);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["Identify the departments from the 'departments' table.", "Join the 'departments' table with the 'employees' table on the DEPARTMENT_ID to associate employees with their respective departments.", "Use a subquery to find managers who manage 4 or more employees by grouping the employees by MANAGER_ID and counting the number of EMPLOYEE_IDs for each manager, filtering with HAVING COUNT(EMPLOYEE_ID) >= 4.", "Filter the main query to only include departments where the MANAGER_ID is in the list of managers identified in the subquery.", "Select the unique DEPARTMENT_IDs from the filtered results."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nWHERE e.MANAGER_ID IN (\n    SELECT MANAGER_ID\n    FROM employees\n    GROUP BY MANAGER_ID\n    HAVING COUNT(EMPLOYEE_ID) >= 4\n) \nGROUP BY d.DEPARTMENT_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\"\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find distinct department IDs where a manager oversees 4 or more employees.", "To do this, we will join the 'departments' table with the 'employees' table on the DEPARTMENT_ID.", "We will group the results by DEPARTMENT_ID to count the number of employees in each department.", "Using the COUNT function, we will filter the groups to only include those with 4 or more employees using the HAVING clause."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_ID\nHAVING COUNT(e.EMPLOYEE_ID) >= 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["Identify the relevant table: The 'employees' table contains the information about employees, including their salaries.", "Determine the conditions: We need to find employees with salaries above the minimum salary and below 2500.", "Use a subquery to find the minimum salary: The minimum salary can be found in the 'jobs' table, so we will use a subquery to get that value.", "Construct the SQL query: We will select all columns from the 'employees' table where the salary is greater than the minimum salary and less than 2500."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "pred_sql": "SELECT * FROM employees WHERE SALARY > (SELECT MIN_SALARY FROM jobs) AND SALARY < 2500;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\"\n}\n"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["Identify the tables needed: employees and departments.", "We need to find employees in the same department as Clara, so we will join the employees table with itself to compare departments.", "The first join will be between the employees table (aliased as e) and the departments table (aliased as d) to get department information.", "The second join will be with the employees table again (aliased as c) to find Clara's department.", "We will select the full name (concatenation of FIRST_NAME and LAST_NAME) and HIRE_DATE of employees in the same department as Clara.", "The WHERE clause will filter the results to only include employees from the same department as the employee with FIRST_NAME 'Clara'."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN employees c ON d.DEPARTMENT_ID = c.DEPARTMENT_ID \nWHERE c.FIRST_NAME = 'Clara';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the tables needed: We need the 'employees' table to get employee names and hire dates, and the 'departments' table to filter employees by department.", "Join the 'employees' table with the 'departments' table to link employees to their respective departments.", "We need to find the department of the employee named Clara. This requires a self-join on the 'employees' table to reference Clara's department while excluding her from the results.", "Select the full names (concatenation of first and last names) and hire dates of employees who are in the same department as Clara, ensuring Clara herself is not included in the results."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nJOIN employees c ON d.DEPARTMENT_ID = c.DEPARTMENT_ID\nWHERE c.FIRST_NAME = 'Clara' AND e.EMPLOYEE_ID != c.EMPLOYEE_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["We need to display the employee number and name for employees working in departments with any employee whose name contains 'T'.", "First, we will select the employee ID, first name, and last name from the 'employees' table.", "To find the relevant departments, we will join the 'employees' table with the 'departments' table on the DEPARTMENT_ID.", "Next, we need to filter the departments based on the condition that there exists at least one employee in those departments whose first or last name contains 'T'.", "We can achieve this by using a subquery that selects the DEPARTMENT_ID from the 'employees' table where the first or last name contains 'T'.", "Finally, we will use the IN clause to filter the departments in the main query based on the results of the subquery."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "pred_sql": "SELECT e1.EMPLOYEE_ID, e1.FIRST_NAME, e1.LAST_NAME \nFROM employees e1 \nJOIN departments d ON e1.DEPARTMENT_ID = d.DEPARTMENT_ID \nWHERE d.DEPARTMENT_ID IN (\n    SELECT e2.DEPARTMENT_ID \n    FROM employees e2 \n    WHERE e2.FIRST_NAME LIKE '%T%' OR e2.LAST_NAME LIKE '%T%'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\"\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the main table to query: 'employees' for employee details.", "Select the columns needed: 'EMPLOYEE_ID' and 'JOB_ID'.", "Establish the condition for filtering: salary must be less than a certain value.", "Determine the value to compare against: the minimum salary of employees with the job title 'MK_MAN'.", "Use a subquery to find the minimum salary from the 'employees' table joined with the 'jobs' table where the job title is 'MK_MAN'.", "Combine the main query and the subquery to form the complete SQL statement."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID FROM employees WHERE SALARY < (SELECT MIN(SALARY) FROM employees JOIN jobs ON employees.JOB_ID = jobs.JOB_ID WHERE JOB_TITLE = 'MK_MAN')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.\"\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department id for each department with more than 2 employees.", "To do this, we will join the 'employees' table with the 'departments' table on the DEPARTMENT_ID.", "We will use the SUM function to calculate the total salaries for each department.", "We will group the results by DEPARTMENT_ID to get the total salaries per department.", "To filter the departments that have more than 2 employees, we will use the HAVING clause with COUNT function."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, SUM(e.SALARY) AS total_salaries\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_ID\nHAVING COUNT(e.EMPLOYEE_ID) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To get the full name, we can concatenate the first name and last name using the '||' operator.", "We will select from the 'employees' table and filter the results to only include those employees whose salary is equal to the maximum salary in their respective department.", "To find the maximum salary for each department, we can use a subquery that selects the maximum salary from the 'employees' table, grouped by department ID. This subquery will be correlated with the outer query using the department ID."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                   FROM employees \n                   WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\"\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the tables needed: employees, departments, and locations.", "We need to retrieve the full names of employees, which requires concatenating their first and last names.", "The city of the employees is located in the locations table, which is linked to the departments table.", "Join the employees table with the departments table on DEPARTMENT_ID to get department information.", "Join the departments table with the locations table on LOCATION_ID to get the city information.", "Filter the results to include only those employees whose first names contain the letter 'Z' using the LIKE operator."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, l.CITY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE e.FIRST_NAME LIKE '%Z%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["We need to display the full name of the employee, which consists of their first and last names. This can be achieved by concatenating the 'FIRST_NAME' and 'LAST_NAME' columns from the 'employees' table.", "We also need to retrieve the name of the country where the employee is currently working. This information is stored in the 'countries' table.", "To get the country name, we need to join the 'employees' table with the 'departments' table using the 'DEPARTMENT_ID' column, as each employee belongs to a department.", "Next, we join the 'departments' table with the 'locations' table using the 'LOCATION_ID' column, since each department is associated with a location.", "Finally, we join the 'locations' table with the 'countries' table using the 'COUNTRY_ID' column to get the country name.", "We will filter the results to only include the employee with the specified 'EMPLOYEE_ID' using a WHERE clause."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT employees.FIRST_NAME || ' ' || employees.LAST_NAME AS full_name, countries.COUNTRY_NAME \nFROM employees \nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID \nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID \nJOIN countries ON locations.COUNTRY_ID = countries.COUNTRY_ID \nWHERE employees.EMPLOYEE_ID = ?;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["Identify the tables needed: 'departments' for department names and 'employees' for employee counts.", "Use a LEFT JOIN to connect 'departments' and 'employees' on the DEPARTMENT_ID column, ensuring all departments are included even if they have no employees.", "Select the department name from the 'departments' table and count the number of employees from the 'employees' table using COUNT function.", "Group the results by department name to get the count of employees per department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["We need to retrieve the department names and the count of employees in each department.", "To do this, we will join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' column.", "We will select the 'DEPARTMENT_NAME' from the 'departments' table and use the COUNT function to count the number of 'EMPLOYEE_ID' from the 'employees' table.", "Since some departments may not have any employees, we will use a LEFT JOIN to ensure all departments are included in the result.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count of employees for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS EMPLOYEE_COUNT\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["We need to display the full name (first and last name) and salary of employees.", "To get the full name, we will concatenate the FIRST_NAME and LAST_NAME from the employees table.", "We need to join the employees table with the departments table to access department information.", "Next, we need to join the departments table with the locations table to filter by city.", "We will filter the results where the city is 'London'.", "Finally, we will select the concatenated full name and salary from the resulting joined tables."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID\nWHERE l.CITY = 'London';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["We need to retrieve the full names and salaries of employees.", "The full name can be constructed by concatenating the first and last names of employees.", "To get the employees' information, we will use the 'employees' table.", "We need to join the 'departments' table to link employees to their respective departments.", "Next, we will join the 'locations' table to filter the results based on the city, which is 'London'.", "The final SQL query will select the concatenated full name and salary from the relevant tables."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3532", "db_id": "music_1", "question": "Find the id of the song that lasts the longest.", "rationale": ["Identify the table that contains the song information, which is the 'song' table.", "To find the song that lasts the longest, we need to sort the songs by their duration in descending order.", "We will select the 'f_id' of the song, which is the unique identifier for the file associated with the song.", "To get only the longest song, we will limit the results to 1 after ordering them by duration."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT f_id FROM song ORDER BY duration DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their duration and the artist's name.", "Determine the requirement: We need to find the names of artists who sang the shortest song.", "Use a subquery to find the minimum duration: We can use a subquery to find the shortest duration from the 'song' table.", "Filter the results: We will filter the main query to return the artist names where the duration matches the minimum duration found in the subquery."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "pred_sql": "SELECT artist_name FROM song WHERE duration = (SELECT MIN(duration) FROM song);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["Identify the table that contains the relevant data: the 'song' table holds information about songs, including their duration.", "Determine the specific condition needed: we need to count songs with a duration of 4 minutes, which is represented as '4:00'.", "Construct the SQL query to count the number of songs that meet this condition using the COUNT() function and a WHERE clause to filter by duration."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "pred_sql": "SELECT COUNT(*) FROM song WHERE duration = '4:00';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3549", "db_id": "music_1", "question": "What is the average rating of songs produced by female artists?", "rationale": ["Identify the tables needed: We need the 'song' table to get the ratings and the 'artist' table to filter by gender.", "Join the 'song' table with the 'artist' table on the 'artist_name' column to access the gender of the artists.", "Filter the results to include only female artists by adding a WHERE clause that checks if artist.gender = 'female'.", "Use the AVG() function to calculate the average rating of the songs produced by female artists."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "pred_sql": "SELECT AVG(song.rating) AS average_rating\nFROM song\nJOIN artist ON song.artist_name = artist.artist_name\nWHERE artist.gender = 'female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["We need to find the file format that is used by the most files.", "To do this, we will select the 'formats' column from the 'files' table.", "We will count the number of occurrences of each format using COUNT(*) and alias it as 'file_count'.", "To get the count for each format, we will group the results by the 'formats' column using GROUP BY.", "To find the most used format, we will order the results in descending order based on 'file_count' using ORDER BY file_count DESC.", "Finally, we will limit the results to only the top entry using LIMIT 1."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(*) as file_count \nFROM files \nGROUP BY formats \nORDER BY file_count DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3556", "db_id": "music_1", "question": "What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?", "rationale": ["Identify the table that contains the file information, which is the 'files' table.", "We need to select the 'f_id' column from the 'files' table.", "The condition specifies that the format must be 'mp4', so we will use the LIKE operator to filter formats that contain 'mp4'.", "The resolution must be smaller than 1000, so we will use a condition to check if the resolution is less than 1000. Since resolution is stored as text, we will cast it to an integer for comparison.", "Combine the selected column and conditions to form the complete SQL query."], "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"], "pred_sql": "SELECT f_id FROM files WHERE formats LIKE '%mp4%' AND CAST(resolution AS INTEGER) < 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["Identify the relevant tables: 'artist' and 'song' are needed to find the country of origin of female artists who produced songs in Bangla.", "The 'artist' table contains the 'country' and 'gender' columns, while the 'song' table contains the 'artist_name' and 'languages' columns.", "To find the country of female artists, we need to join the 'artist' table with the 'song' table on the 'artist_name' column.", "We filter the results to include only female artists by using the condition 'artist.gender = 'female'',' and we also filter for songs that have 'Bangla' in their 'languages' column using 'song.languages LIKE '%Bangla%'.", "The final query selects the 'country' from the 'artist' table based on the specified conditions."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.country \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE artist.gender = 'female' AND song.languages LIKE '%Bangla%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["Identify the relevant table: The 'artist' table contains information about artists, including their gender and country.", "Filter for female artists: We need to select artists where the gender is 'female'.", "Identify the language criteria: We need to find artists who have sung songs in the Bangla language.", "Use a subquery: To find artists who have sung in Bangla, we can use a subquery on the 'song' table to filter artists based on the 'languages' column.", "Select distinct countries: Finally, we want to select distinct countries from the filtered list of female artists."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT DISTINCT country FROM artist WHERE gender = 'female' AND artist_name IN (SELECT artist_name FROM song WHERE languages LIKE '%Bangla%');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["Identify the relevant tables: We need information from the 'artist' table for gender and name, and from the 'song' table for resolution.", "Join the 'artist' and 'song' tables on the common column 'artist_name' to link artists with their songs.", "To find the song with the smallest resolution, we need to use a subquery that selects the minimum resolution from the 'song' table.", "The main query will select the gender and name of the artist where the song's resolution matches the minimum resolution found in the subquery."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.gender, artist.artist_name \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.resolution = (SELECT MIN(resolution) FROM song)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\"\n}\n"}
{"sample_id": "train.3567", "db_id": "music_1", "question": "For each file format, return the number of artists who released songs in that format.", "rationale": ["We need to count the number of distinct artists for each file format.", "The relevant tables are 'files' and 'song' since we need to access the file formats and the artists associated with the songs.", "We will join the 'files' table with the 'song' table on the 'f_id' column to link songs to their respective files.", "We will group the results by the 'formats' column from the 'files' table to get the count of artists for each format.", "Finally, we will use COUNT(DISTINCT artist_name) to ensure we count each artist only once per format."], "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(DISTINCT artist_name) AS artist_count\nFROM files\nJOIN song ON files.f_id = song.f_id\nGROUP BY formats;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3576", "db_id": "music_1", "question": "What are the names and genders of all artists who released songs in the month of March?", "rationale": ["Identify the tables needed: We need information from the 'artist' table for names and genders, and the 'song' table for release dates.", "We will join the 'artist' table with the 'song' table on the common column 'artist_name'.", "We need to filter the results to only include songs released in March. In SQLite, we can extract the month from the 'releasedate' using the strftime function.", "The condition for March is to check if the month extracted from 'releasedate' equals '03'.", "Construct the SQL query to select the artist names and genders from the joined tables with the specified condition."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.gender \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE strftime('%m', song.releasedate) = '03';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["We need to find out the languages used in songs, which is a column in the 'song' table.", "To determine which languages are used most often, we can count the occurrences of each language in the 'song' table.", "We will use the COUNT() function to count the number of songs for each language.", "We will group the results by the 'languages' column to get the count for each distinct language.", "Finally, we will order the results in descending order to show the most frequently used languages at the top."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "pred_sql": "SELECT languages, COUNT(*) as language_count\nFROM song\nGROUP BY languages\nORDER BY language_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3590", "db_id": "music_1", "question": "What are the names of all male British artists?", "rationale": ["Identify the relevant table: The 'artist' table contains information about artists, including their names, countries, and genders.", "Determine the conditions: We need to filter artists based on two conditions: they must be from Britain and they must be male.", "Construct the SQL query: Use a SELECT statement to retrieve the 'artist_name' from the 'artist' table where the 'country' is 'Britain' and the 'gender' is 'male'."], "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"], "pred_sql": "SELECT artist_name FROM artist WHERE country = 'Britain' AND gender = 'male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3598", "db_id": "music_1", "question": "What is the average rating and resolution of all bangla songs?", "rationale": ["Identify the relevant table: The 'song' table contains the information about songs, including their ratings and resolutions.", "Determine the specific genre: The question asks for Bangla songs, so we will filter the results based on the genre.", "Calculate the average rating: We will use the AVG() function to calculate the average rating of the Bangla songs.", "Calculate the average resolution: Similarly, we will use the AVG() function to calculate the average resolution of the Bangla songs.", "Construct the SQL query: Combine the above elements into a single SQL query that selects the average rating and resolution for Bangla songs."], "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"], "pred_sql": "SELECT AVG(s.rating) AS average_rating, AVG(s.resolution) AS average_resolution \nFROM song s \nWHERE s.genre_is = 'Bangla';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\"\n}\n"}
{"sample_id": "train.3599", "db_id": "music_1", "question": "What are the maximum and minimum resolution of songs whose duration is 3 minutes?", "rationale": ["Identify the relevant table: The 'song' table contains the resolution and duration of songs.", "Determine the condition: We need songs with a duration of 3 minutes, which is represented as '3:00'.", "Select the maximum and minimum resolution: Use the MAX() and MIN() functions to get the highest and lowest resolution values respectively.", "Construct the SQL query: Combine the SELECT statement with the FROM clause and the WHERE condition to filter the results."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "pred_sql": "SELECT MAX(resolution) AS max_resolution, MIN(resolution) AS min_resolution \nFROM song \nWHERE duration = '3:00';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\"\n}\n"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["Identify the relevant table: The 'song' table contains the necessary columns for duration, resolution, and languages.", "Determine the required aggregations: We need to find the maximum duration and resolution for songs, which can be achieved using the MAX() function.", "Group the results by languages: To get the maximum values for each language, we will use the GROUP BY clause on the 'languages' column.", "Order the results: The results should be ordered by languages for better readability, which can be done using the ORDER BY clause."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "pred_sql": "SELECT languages, MAX(duration) AS max_duration, MAX(resolution) AS max_resolution\nFROM song\nGROUP BY languages\nORDER BY languages;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["Identify the relevant tables: We need to use the 'song' table to get the duration and rating of songs, and the 'genre' table to group the songs by genre.", "Determine the required fields: We need the genre name, the shortest duration of songs, and the lowest rating of songs.", "Use aggregate functions: To find the shortest duration, we will use MIN(song.duration), and for the lowest rating, we will use MIN(song.rating).", "Join the tables: We need to join the 'song' table with the 'genre' table on the genre name to access the genre information for each song.", "Group the results: We will group the results by genre to get the shortest duration and lowest rating for each genre.", "Order the results: Finally, we will order the results by genre name for better readability."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "pred_sql": "SELECT genre.g_name, MIN(song.duration) AS shortest_duration, MIN(song.rating) AS lowest_rating\nFROM song\nJOIN genre ON song.genre_is = genre.g_name\nGROUP BY genre.g_name\nORDER BY genre.g_name;", "hint": "\n"}
{"sample_id": "train.3607", "db_id": "music_1", "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "rationale": ["Identify the tables involved: We need information from the 'artist' table and the 'song' table.", "Determine the columns to select: We want the artist's name and country, which are in the 'artist' table.", "Establish the relationship between tables: The 'artist' table can be joined with the 'song' table on the 'artist_name' column.", "Set the condition for filtering: We need to filter songs based on their resolution being greater than 900, which is a condition on the 'song' table."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.country \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.resolution > 900;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3619", "db_id": "music_1", "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their languages and the artist associated with each song.", "Filter songs by language: We need to filter the songs to only include those that have 'Bangla' in the 'languages' column.", "Count the number of songs per artist: We will group the results by 'artist_name' and count the number of songs for each artist using COUNT(song_name).", "Order the results: To find the top artists, we will order the results in descending order based on the count of songs.", "Limit the results: We will limit the output to the top 3 artists using LIMIT 3."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist_name, COUNT(song_name) AS song_count\nFROM song\nWHERE languages LIKE '%Bangla%'\nGROUP BY artist_name\nORDER BY song_count DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3623", "db_id": "music_1", "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?", "rationale": ["Identify the columns needed: duration, file size, and format of songs.", "Determine the relevant tables: 'song' for song details and 'files' for file details.", "Establish the relationship between the tables: 'song' and 'files' are linked by the 'f_id' column.", "Filter the results to include only songs of the genre 'pop'.", "Order the results by the song title (song_name).", "Construct the SQL query using SELECT, JOIN, WHERE, and ORDER BY clauses."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT song.duration, files.file_size, files.formats \nFROM song \nJOIN files ON song.f_id = files.f_id \nWHERE song.genre_is = 'pop' \nORDER BY song.song_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "Determine the columns needed: 'duration' from 'song', 'file_size' and 'formats' from 'files'.", "Establish the relationship between the tables using the foreign key: 'song.f_id' relates to 'files.f_id'.", "Filter the results to include only pop songs by using the condition 'WHERE song.genre_is = 'pop''.", "Order the results alphabetically by song title using 'ORDER BY song.song_name ASC'."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT song.duration, files.file_size, files.formats \nFROM song \nJOIN files ON song.f_id = files.f_id \nWHERE song.genre_is = 'pop' \nORDER BY song.song_name ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["Identify the relevant tables: salary and team.", "We need to calculate the average salary, so we will use the AVG() function on the salary column from the salary table.", "To link the salary data to the team, we will join the salary table with the team table using the team_id column.", "We need to filter the results to only include players from the 'Boston Red Stockings' team, so we will add a WHERE clause to specify this condition."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "pred_sql": "SELECT AVG(salary.salary) AS average_salary\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nWHERE team.name = 'Boston Red Stockings';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\"\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["We need to find the countries with the least number of players.", "To do this, we will select the 'birth_country' from the 'player' table.", "We will count the number of players from each country using COUNT(player_id).", "We will group the results by 'birth_country' to get the count for each country.", "To find the least players, we will order the results in ascending order based on the count of players.", "Finally, we will limit the results to the top 3 countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count \nFROM player \nGROUP BY birth_country \nORDER BY player_count ASC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of countries where players were born, grouped by country and ordered by the number of players from each country in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of countries to return.\"\n}\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["We need to find the highest salary for each team, which requires us to group the salary data by team.", "The salary table contains the salary information along with the team_id, which we can use to join with the team table.", "The team table contains the team names and their corresponding IDs.", "We will use a SQL query that selects the team name, team ID, and the maximum salary from the salary table.", "We will join the salary table with the team table on the team_id column to get the team names.", "We will group the results by team ID and team name to ensure we get the maximum salary for each team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nGROUP BY team.team_id, team.name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\"\n}\n"}
{"sample_id": "train.3658", "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["Identify the tables needed: 'team' for team details and 'salary' for salary information.", "We need to join the 'team' table with the 'salary' table on 'team_id' to associate each team with its salaries.", "We want to select the team name and team id, along with the maximum salary for each team.", "Use the MAX() function to find the maximum salary for each team.", "Group the results by team id and team name to ensure we get one result per team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM team\nJOIN salary ON team.team_id = salary.team_id\nGROUP BY team.team_id, team.name;", "hint": "\n"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["Identify the relevant tables: We need the 'team' table for team names and IDs, and the 'salary' table for salary information.", "Join the 'team' and 'salary' tables on 'team_id' to associate teams with their salaries.", "Group the results by 'team_id' to calculate the average salary for each team.", "Use the AVG() function to compute the average salary for each team.", "Order the results in ascending order based on the average salary to find the lowest.", "Limit the results to 1 to get only the team with the lowest average salary."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id\nFROM team\nJOIN salary ON team.team_id = salary.team_id\nGROUP BY team.team_id\nORDER BY AVG(salary.salary) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["Identify the tables needed: We need the 'player' table for player names and the 'player_award' table to check for awards won in specific years.", "Join the 'player' table with the 'player_award' table twice: one for the year 1960 and another for the year 1961. This allows us to find players who won awards in both years.", "Select the first and last names of the players who meet the criteria."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.name_first, p.name_last\nFROM player p\nJOIN player_award pa1 ON p.player_id = pa1.player_id\nJOIN player_award pa2 ON p.player_id = pa2.player_id\nWHERE pa1.year = 1960 AND pa2.year = 1961;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\"\n}\n"}
{"sample_id": "train.3663", "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["Identify the relevant table: The 'player' table contains the first name, last name, weight, and height of players.", "Determine the columns to select: We need to select 'name_given' for the first name and 'name_last' for the last name.", "Establish the conditions: We want players with a weight greater than 220 or a height shorter than 75.", "Construct the SQL query: Use a SELECT statement to retrieve the specified columns from the 'player' table with the appropriate WHERE clause for the conditions."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_given, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players from the 'player' table who have a specified year of death. The placeholder in the WHERE clause represents the year of death.\"\n}\n"}
{"sample_id": "train.3664", "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["Identify the relevant table: The 'player' table contains the first name, last name, weight, and height of players.", "Determine the columns needed: We need 'name_first' and 'name_last' for the player's names.", "Establish the conditions: We want players with a weight greater than 220 or a height less than 75.", "Construct the SQL query: Use a SELECT statement to retrieve the names from the 'player' table with the specified conditions in the WHERE clause."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\"\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) of the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Select the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\"\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) for the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Use the MAX function to get the maximum wins for the specified team."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\"\n}\n"}
{"sample_id": "train.3672", "db_id": "baseball_1", "question": "For each year, return the year and the number of times the team Boston Red Stockings won in the postseasons.", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team names.", "Join the 'postseason' table with the 'team' table on the winning team ID to filter for the Boston Red Stockings.", "Use a WHERE clause to specify that we are only interested in rows where the team name is 'Boston Red Stockings'.", "Group the results by year to count the number of wins for each year.", "Select the year and the count of wins for the final output."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "pred_sql": "SELECT p.year, COUNT(p.team_id_winner) AS wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings'\nGROUP BY p.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\"\n}\n"}
{"sample_id": "train.3677", "db_id": "baseball_1", "question": "What is the total salary paid by team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant tables: 'salary' for salary data and 'team' for team identification.", "We need to calculate the total salary, so we will use the SUM function on the 'salary' column.", "Join the 'salary' table with the 'team' table on 'team_id' to link salaries to the respective teams.", "Filter the results to include only the 'Boston Red Stockings' team and the year 2010.", "Select the sum of the salaries as 'total_salary' from the filtered results."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT SUM(salary) AS total_salary\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nWHERE team.name = 'Boston Red Stockings' AND salary.year = 2010;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\"\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant table: The 'salary' table contains the salary information for players.", "Filter the data: We need to focus on the year 2001, so we will use a WHERE clause to filter the records for that year.", "Select the necessary columns: We want to retrieve the player_id and salary columns from the salary table.", "Sort the results: To find the highest salaries, we will order the results by the salary column in descending order.", "Limit the results: Since we only want the top 3 salaries, we will use the LIMIT clause to restrict the output to 3 records."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3682", "db_id": "baseball_1", "question": "How much salary did the top 3 well-paid players get in 2001?", "rationale": ["Identify the relevant table: The salary table contains the salary information for players.", "Determine the year of interest: The user is asking for salaries in 2001.", "Filter the data: Use a WHERE clause to filter records for the year 2001.", "Sort the results: Use ORDER BY to sort the salaries in descending order to get the highest salaries first.", "Limit the results: Use LIMIT 3 to get only the top 3 salaries."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3683", "db_id": "baseball_1", "question": "What were all the salary values of players in 2010 and 2001?", "rationale": ["Identify the relevant table: The 'salary' table contains the salary information for players.", "Determine the columns needed: We need the 'salary' column for the specified years.", "Specify the years of interest: The years are 2010 and 2001.", "Construct the SQL query using a SELECT statement to retrieve the salary values for the specified years using the IN clause."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT salary FROM salary WHERE year IN (2010, 2001);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "The hint suggests creating a virtual table that summarizes the number of players inducted for each year.", "We will use the COUNT function to count the number of player_ids for each year in the hall_of_fame table.", "We will group the results by yearid to get the count of inductees for each year.", "To find the year with the least inductees, we will order the results in ascending order based on the count of inductees.", "Finally, we will limit the results to 1 to get only the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(player_id) AS inductee_count \nFROM hall_of_fame \nGROUP BY yearid \nORDER BY inductee_count ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "The hint suggests creating a virtual table that summarizes the number of players inducted for each year using a COUNT function.", "We will select the 'yearid' and count the 'player_id' to get the number of inductees per year.", "We will group the results by 'yearid' to aggregate the counts for each year.", "To find the year with the least inductees, we will order the results in ascending order based on the count of inductees.", "Finally, we will limit the results to 1 to get only the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(player_id) AS inductee_count \nFROM hall_of_fame \nGROUP BY yearid \nORDER BY inductee_count ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant table: home_game contains information about home games played, including the year and park.", "Determine the specific park: use the park table to find the park_id for 'Columbia Park'.", "Filter the home_game table for the year 1907 and the specific park_id obtained from the previous step.", "Select the 'games' column to get the total number of games played in that park for that year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT games FROM home_game WHERE park_id = (SELECT park_id FROM park WHERE park_name = 'Columbia Park') AND year = 1907;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\"\n}\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: 'home_game' for home games and 'park' for park details.", "We need to count the number of games, so we will use the COUNT() function.", "Join the 'home_game' table with the 'park' table on the park_id to get the park name.", "Filter the results to only include games played in 'Columbia Park' in the year 1907.", "Select the count of games as total_games."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT COUNT(*) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.park_name = 'Columbia Park' AND home_game.year = 1907;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\"\n}\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games played, including the year and city.", "Determine the columns needed: We need to sum the 'games' column to get the total number of games played in Atlanta in 2000.", "Apply the necessary filters: We need to filter the results to only include records where the 'year' is 2000 and the 'city' is 'Atlanta'.", "Construct the SQL query: Use the SUM function to calculate the total games and select from the 'home_game' table with the appropriate WHERE clause."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nWHERE city = 'Atlanta' AND year = 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\"\n}\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games played, including the year and the number of games.", "Filter for the year 2000: We need to specify that we are only interested in games that took place in the year 2000.", "Identify the team: We need to find the team(s) that are associated with the city of Atlanta. This can be done by querying the 'team' table for the team_id of Atlanta.", "Sum the number of games: We will sum the 'games' column from the 'home_game' table for the specified year and team_id(s) that we found in the previous step."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nWHERE year = 2000 AND team_id IN (\n    SELECT team_id\n    FROM team\n    WHERE name = 'Atlanta'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\"\n}\n"}
{"sample_id": "train.3693", "db_id": "baseball_1", "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?", "rationale": ["Identify the relevant table: The 'home_game' table contains the attendance data for home games.", "Determine the criteria for filtering: We need to filter by the team name 'Boston Red Stockings' and the years from 2000 to 2010.", "Use a subquery to find the team_id for 'Boston Red Stockings' from the 'team' table.", "Sum the attendance for the specified team and years using the SUM() function."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT SUM(attendance) AS total_attendance \nFROM home_game \nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings') \nAND year BETWEEN 2000 AND 2010;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\"\n}\n"}
{"sample_id": "train.3698", "db_id": "baseball_1", "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?", "rationale": ["Identify the relevant tables: 'player' for player names and 'salary' for salary records.", "Join the 'player' table with the 'salary' table on 'player_id' to get player names along with their salary records.", "Filter the results to include only those records where the 'team_id' corresponds to the Washington Nationals.", "Use the 'year' column in the 'salary' table to filter for the years 2005 and 2007.", "Group the results by 'player_id' to aggregate the salary records for each player.", "Use the HAVING clause to ensure that only players who have salary records for both years (2005 and 2007) are included in the final result."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT p.name_first, p.name_last \nFROM player p \nJOIN salary s ON p.player_id = s.player_id \nWHERE s.team_id = (SELECT team_id FROM team WHERE name = 'Washington Nationals') \nAND s.year IN (2005, 2007) \nGROUP BY p.player_id \nHAVING COUNT(DISTINCT s.year) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\"\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant tables: 'home_game' for home games and 'team' for team names.", "We need to find the team with the least number of home games in 1980, so we will filter the 'home_game' table by the year 1980.", "Join the 'home_game' table with the 'team' table to get the team names associated with the home games.", "Order the results by the number of games in ascending order to get the team with the least number of home games at the top.", "Limit the results to 1 to get only the team with the least number of home games."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team.name\nFROM home_game\nJOIN team ON home_game.team_id = team.team_id\nWHERE home_game.year = 1980\nORDER BY home_game.games ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\"\n}\n"}
{"sample_id": "train.3709", "db_id": "baseball_1", "question": "Which park had most attendances in 2008?", "rationale": ["Identify the relevant tables: home_game for attendance data and park for park names.", "Join the home_game table with the park table on the park_id to get park names along with attendance data.", "Filter the results to only include records from the year 2008.", "Order the results by attendance in descending order to get the park with the highest attendance.", "Limit the results to 1 to get only the park with the most attendance."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT park.park_name\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE home_game.year = 2008\nORDER BY home_game.attendance DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\"\n}\n"}
{"sample_id": "train.3857", "db_id": "insurance_policies", "question": "Find the settlement amount of the claim with the largest claim amount. Show both the settlement amount and claim amount.", "rationale": ["We need to find the settlement amount of the claim with the largest claim amount.", "To do this, we will join the 'Claims' table with the 'Settlements' table on the Claim_ID.", "We will select the Amount_Settled from the Settlements table and Amount_Claimed from the Claims table.", "To find the claim with the largest claim amount, we will order the results by Amount_Claimed in descending order.", "Finally, we will limit the results to only one record to get the claim with the largest amount."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"], "pred_sql": "SELECT s.Amount_Settled, c.Amount_Claimed\nFROM Claims c\nJOIN Settlements s ON c.Claim_ID = s.Claim_ID\nORDER BY c.Amount_Claimed DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\"\n}\n"}
{"sample_id": "train.3862", "db_id": "insurance_policies", "question": "Among all the claims, which settlements have a claimed amount that is no more than the average? List the claim start date.", "rationale": ["Identify the relevant tables: Settlements and Claims are needed to get the required information about settlements and their associated claims.", "We need to find settlements where the claimed amount is no more than the average claimed amount across all claims.", "To do this, we will use a subquery to calculate the average claimed amount from the Claims table.", "We will join the Settlements table with the Claims table on the Claim_ID to access the necessary fields.", "Finally, we will select the Date_Claim_Made from the Claims table along with the Amount_Claimed and Amount_Settled from the Settlements table, filtering the results based on the average claimed amount."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT s.Date_Claim_Made, s.Amount_Claimed, s.Amount_Settled \nFROM Settlements s \nJOIN Claims c ON s.Claim_ID = c.Claim_ID \nWHERE s.Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Claims)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\"\n}\n"}
{"sample_id": "train.3863", "db_id": "insurance_policies", "question": "Return the claim start date for the claims whose claimed amount is no more than the average", "rationale": ["Identify the relevant table: Claims, which contains the claim details including the claimed amount and the date the claim was made.", "Determine the condition: We need claims where the claimed amount is no more than the average claimed amount.", "Calculate the average claimed amount using a subquery: (SELECT AVG(Amount_Claimed) FROM Claims).", "Select the Date_Claim_Made from the Claims table where the Amount_Claimed is less than or equal to the average calculated in the subquery."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Claims);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the amounts claimed and settled for insurance claims from the 'Claims' table. The results are ordered by the claimed amount in descending order, and the placeholder allows for limiting the number of records returned.\"\n}\n"}
{"sample_id": "train.3868", "db_id": "insurance_policies", "question": "How many settlements were made on the claim with the most recent claim settlement date? List the number and the claim id.", "rationale": ["Identify the need to count settlements for claims with the most recent settlement date.", "Use a subquery to find the maximum settlement date from the Claims table.", "Join the Settlements table with the Claims table to link settlements to their respective claims.", "Group the results by Claim_ID to count the number of settlements for each claim.", "Select the Claim_ID and the count of settlements for the claim with the most recent settlement date."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT Claim_ID, COUNT(Settlement_ID) AS Settlement_Count\nFROM Settlements\nJOIN Claims ON Settlements.Claim_ID = Claims.Claim_ID\nWHERE Date_Claim_Settled = (\n    SELECT MAX(Date_Claim_Settled)\n    FROM Claims\n)\nGROUP BY Claim_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of settlements associated with each insurance claim from the 'Claims' table. The placeholder in the SELECT statement represents the unique identifier for each claim, while the count reflects the number of settlements linked to that claim.\"\n}\n"}
{"sample_id": "train.3869", "db_id": "insurance_policies", "question": "Find the claim id and the number of settlements made for the claim with the most recent settlement date.", "rationale": ["We need to find the claim ID and the number of settlements for the claim with the most recent settlement date.", "To do this, we will join the 'Claims' table with the 'Settlements' table on the Claim_ID.", "We will use COUNT(Settlements.Settlement_ID) to count the number of settlements for each claim.", "We will group the results by Claims.Claim_ID to get the count for each claim.", "To find the most recent settlement date, we will order the results by the maximum settlement date (MAX(Settlements.Date_Claim_Settled)) in descending order.", "Finally, we will limit the results to 1 to get only the claim with the most recent settlement date."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT Claims.Claim_ID, COUNT(Settlements.Settlement_ID) AS Number_of_Settlements\nFROM Claims\nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID\nGROUP BY Claims.Claim_ID\nORDER BY MAX(Settlements.Date_Claim_Settled) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of settlements associated with each insurance claim from the 'Claims' table. The placeholder in the SELECT statement represents the unique identifier for each claim, while the count reflects the number of settlements linked to that claim.\"\n}\n"}
{"sample_id": "train.3878", "db_id": "insurance_policies", "question": "What is the most popular payment method?", "rationale": ["Identify the relevant table: The Payments table contains information about payment transactions, including the payment method.", "Determine the required information: We need to find the most popular payment method, which implies counting the occurrences of each payment method.", "Group the results: Use GROUP BY to aggregate the counts of each payment method code.", "Order the results: Use ORDER BY to sort the payment methods by their frequency in descending order, so the most popular method comes first.", "Limit the results: Use LIMIT 1 to retrieve only the top result, which is the most popular payment method."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Frequency\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.\"\n}\n"}
{"sample_id": "train.3879", "db_id": "insurance_policies", "question": "Which payment method is used the most often?", "rationale": ["Identify the table that contains payment methods, which is the 'Payments' table.", "To find the most frequently used payment method, we need to count the occurrences of each payment method code.", "We will use the COUNT function to count the number of times each Payment_Method_Code appears in the Payments table.", "We will group the results by Payment_Method_Code to aggregate the counts for each method.", "To get the most often used payment method, we will order the results by the count in descending order.", "Finally, we will limit the results to 1 to get only the most frequently used payment method."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Frequency\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.\"\n}\n"}
{"sample_id": "train.3880", "db_id": "insurance_policies", "question": "With which kind of payment method were the least number of payments processed?", "rationale": ["Identify the relevant table: The Payments table contains information about payment transactions, including the payment method used.", "Determine the required information: We need to find the payment method with the least number of payments processed.", "Group the results: We will group the results by Payment_Method_Code to count the number of payments for each method.", "Count the payments: Use COUNT(*) to count the number of payments for each payment method.", "Order the results: We will order the results in ascending order based on the count of payments to find the least used method.", "Limit the results: We will limit the results to 1 to get only the payment method with the least number of payments."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Payment_Count \nFROM Payments \nGROUP BY Payment_Method_Code \nORDER BY Payment_Count ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.\"\n}\n"}
{"sample_id": "train.3886", "db_id": "insurance_policies", "question": "Which kind of policy type was chosen by the most customers?", "rationale": ["Identify the relevant table: The 'Customer_Policies' table contains the 'Policy_Type_Code' and 'Customer_ID' which are needed to determine the policy types chosen by customers.", "Group by policy type: To find out how many customers chose each policy type, we need to group the results by 'Policy_Type_Code'.", "Count the customers: Use COUNT(Customer_ID) to count the number of customers for each policy type.", "Order the results: To find the most chosen policy type, we will order the results in descending order based on the count of customers.", "Limit the results: Since we only want the most chosen policy type, we will limit the results to 1."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(Customer_ID) AS Customer_Count\nFROM Customer_Policies\nGROUP BY Policy_Type_Code\nORDER BY Customer_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies from the 'Customer_Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.\"\n}\n"}
{"sample_id": "train.3893", "db_id": "insurance_policies", "question": "Which customers do not have any policies? Find the details of these customers.", "rationale": ["Identify the Customers table to retrieve customer details.", "Determine the criteria for customers without policies, which means they should not exist in the Customer_Policies table.", "Use a subquery to select Customer_IDs from the Customer_Policies table.", "Use the NOT IN clause to filter out those customers from the Customers table."], "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"], "pred_sql": "SELECT * FROM Customers WHERE Customer_ID NOT IN (SELECT Customer_ID FROM Customer_Policies);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies from the 'Customer_Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.\"\n}\n"}
{"sample_id": "train.3895", "db_id": "insurance_policies", "question": "Which claims had exactly one settlement? For each, tell me the the date the claim was made, the date it was settled and the amount settled.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find claims that have exactly one settlement, so we will join the Claims table with the Settlements table on the Claim_ID.", "We will select the required fields: Date_Claim_Made, Date_Claim_Settled, and Amount_Settled.", "To ensure we only get claims with exactly one settlement, we will group the results by Claim_ID and use the HAVING clause to filter for those with a count of settlements equal to one."], "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT c.Date_Claim_Made, c.Date_Claim_Settled, s.Amount_Settled \nFROM Claims c \nJOIN Settlements s ON c.Claim_ID = s.Claim_ID \nGROUP BY c.Claim_ID \nHAVING COUNT(s.Settlement_ID) = 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of settlements associated with each insurance claim from the 'Claims' table. The placeholder in the SELECT statement represents the unique identifier for each claim, while the count reflects the number of settlements linked to that claim.\"\n}\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to count the number of employees (physicians) in each department.", "Join the Department table with the Physician table on the Head of the department.", "Group the results by department to get the count of physicians in each department.", "Order the results by the count of physicians in descending order to find the department with the most employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT d.Name, COUNT(p.EmployeeID) AS EmployeeCount\nFROM Department d\nLEFT JOIN Physician p ON d.Head = p.EmployeeID\nGROUP BY d.DepartmentID\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["We need to find the department with the most employees, which means we need to count the number of physicians affiliated with each department.", "To do this, we will join the 'Department' table with the 'Affiliated_With' table on the department identifier.", "We will use a LEFT JOIN to ensure we include departments even if they have no affiliated physicians.", "Next, we will group the results by the department ID to count the number of physicians in each department.", "We will count the number of physicians using COUNT(Affiliated_With.Physician) and alias it as EmployeeCount.", "Finally, we will order the results in descending order by EmployeeCount to get the department with the most employees at the top, and limit the results to 1 to get only the top department."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Affiliated_With.Physician) AS EmployeeCount\nFROM Department\nLEFT JOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.DepartmentID\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3901", "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["Identify the department with the least number of employees by counting the number of physicians affiliated with each department.", "Use a subquery to group the 'Affiliated_With' table by 'DepartmentID' and count the number of physicians in each department.", "Order the results of the subquery in ascending order based on the count of physicians to find the department with the least employees.", "Limit the results of the subquery to 1 to get the department ID with the least employees.", "Use the department ID obtained from the subquery to select the 'Head' from the 'Department' table."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Head FROM Department WHERE DepartmentID = (SELECT DepartmentID FROM Affiliated_With GROUP BY DepartmentID ORDER BY COUNT(Physician) ASC LIMIT 1)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["Identify the head of each department by joining the Physician table with the Department table on the Head column.", "Count the number of employees in each department using the Affiliated_With table, grouping by DepartmentID.", "Order the departments by the count of employees in ascending order to find the department with the least number of employees.", "Use a subquery to get the DepartmentID of the department with the least number of employees.", "Select the Name and Position of the physician who is the head of that department."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT P.Name, P.Position \nFROM Physician P \nJOIN Department D ON P.EmployeeID = D.Head \nWHERE D.DepartmentID = \n  (SELECT DepartmentID \n   FROM Affiliated_With \n   GROUP BY DepartmentID \n   ORDER BY COUNT(Physician) ASC \n   LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3903", "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["Identify the head of the department with the least employees.", "To find the department with the least employees, we need to count the number of physicians affiliated with each department.", "We can use a subquery to group by DepartmentID in the Affiliated_With table and count the number of physicians in each department.", "Order the results of the subquery by the count of physicians in ascending order and limit the result to 1 to get the department with the least employees.", "Join the Department table with the Physician table to get the names and positions of the heads of the departments.", "Select the Name and Position of the physician whose EmployeeID matches the head of the department identified in the subquery."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Department \nJOIN Physician ON Department.Head = Physician.EmployeeID \nWHERE Department.DepartmentID = \n    (SELECT DepartmentID \n     FROM Affiliated_With \n     GROUP BY DepartmentID \n     ORDER BY COUNT(Physician) ASC \n     LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["Identify the relevant tables: Patient and Appointment.", "We need to find the names of patients who have made appointments, which means we need to join the Patient table with the Appointment table on the Patient's SSN.", "Use a SELECT statement to retrieve the names from the Patient table.", "Use DISTINCT to ensure that we only get unique patient names, in case a patient has multiple appointments."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT Patient.Name\nFROM Patient\nJOIN Appointment ON Patient.SSN = Appointment.Patient;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\"\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["We need to find the names of all physicians and their primary affiliated departments' names.", "To do this, we will select the 'Name' column from the 'Physician' table and the 'Name' column from the 'Department' table.", "We will join the 'Physician' table with the 'Affiliated_With' table on the 'EmployeeID' of the physician and the 'Physician' identifier in the 'Affiliated_With' table.", "Next, we will join the 'Affiliated_With' table with the 'Department' table on the 'Department' identifier in the 'Affiliated_With' table and the 'DepartmentID' in the 'Department' table.", "Finally, we will filter the results to include only those records where the 'PrimaryAffiliation' is marked as 'Yes' to ensure we are only getting primary affiliations."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name, Department.Name \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nJOIN Department ON Affiliated_With.Department = Department.DepartmentID \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\"\n}\n"}
{"sample_id": "train.3928", "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["Identify the tables needed: Physician and Patient.", "We need to count the number of patients each physician takes care of, which means we need to join the Physician table with the Patient table based on the primary care physician (PCP) relationship.", "Use a LEFT JOIN to ensure we include physicians even if they have no patients.", "Select the physician's name and count the number of patients (using COUNT function) for each physician.", "Group the results by physician's name to get the count for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name, COUNT(Patient.SSN) AS NumberOfPatients\nFROM Physician\nLEFT JOIN Patient ON Physician.EmployeeID = Patient.PCP\nGROUP BY Physician.Name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\"\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["We need to find physicians who are in charge of more than one patient.", "To do this, we will join the Physician table with the Appointment table on the Physician's EmployeeID and the Appointment's Physician field.", "We will group the results by the Physician's EmployeeID to aggregate the number of patients each physician is in charge of.", "Using the HAVING clause, we will filter the groups to only include those where the count of patients is greater than one."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Appointment ON Physician.EmployeeID = Appointment.Physician\nGROUP BY Physician.EmployeeID\nHAVING COUNT(Appointment.Patient) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\"\n}\n"}
{"sample_id": "train.3940", "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication.", "We need to find the names of physicians who have prescribed a specific medication, 'Thesisin'.", "Join the Physician table with the Prescribes table on the Physician's EmployeeID and the Prescribes table's Physician field.", "Next, join the Prescribes table with the Medication table on the Medication's Code and the Prescribes table's Medication field.", "Filter the results to only include those where the Medication's Name is 'Thesisin'.", "Select the distinct names of the physicians from the resulting joined tables."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT DISTINCT Physician.Name \nFROM Physician \nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician \nJOIN Medication ON Prescribes.Medication = Medication.Code \nWHERE Medication.Name = 'Thesisin';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\"\n}\n"}
{"sample_id": "train.3941", "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication.", "We need to find the names of physicians who prescribe a specific medication, which is 'Thesisin'.", "Join the Physician table with the Prescribes table on the EmployeeID and Physician columns respectively.", "Join the Prescribes table with the Medication table on the Medication code.", "Filter the results to only include rows where the medication name is 'Thesisin'.", "Select the Name column from the Physician table to get the names of the physicians."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT Physician.Name \nFROM Physician \nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician \nJOIN Medication ON Prescribes.Medication = Medication.Code \nWHERE Medication.Name = 'Thesisin';", "hint": "\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["Identify the tables involved: Medication and Prescribes.", "We need to count the number of medications prescribed for each brand, so we will use the COUNT function.", "Join the Medication table with the Prescribes table on the medication code (Medication.Code = Prescribes.Medication).", "Select the Brand from the Medication table and count the number of prescriptions from the Prescribes table.", "Group the results by the Brand to get the count for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT m.Brand, COUNT(p.Medication) AS NumberOfMedications\nFROM Medication m\nJOIN Prescribes p ON m.Code = p.Medication\nGROUP BY m.Brand;", "hint": "\n"}
{"sample_id": "train.3948", "db_id": "hospital_1", "question": "Find the patient who has the most recent undergoing treatment?", "rationale": ["Identify the relevant tables: Undergoes (for treatment information) and Patient (for patient details).", "We need to find the most recent undergoing treatment, which means we will order the results by the DateUndergoes column in descending order.", "To get the patient's details along with the treatment date, we will join the Undergoes table with the Patient table on the Patient identifier (SSN).", "Finally, we will limit the results to 1 to get only the most recent entry."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT Patient.SSN, Patient.Name, Undergoes.DateUndergoes \nFROM Undergoes \nJOIN Patient ON Undergoes.Patient = Patient.SSN \nORDER BY Undergoes.DateUndergoes DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\"\n}\n"}
{"sample_id": "train.3949", "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["Identify the relevant tables: Patient and Undergoes.", "We need to find the patient who is undergoing the most recent treatment, which involves the Undergoes table that records treatments for patients.", "Join the Patient table with the Undergoes table on the Patient's SSN to get the names of patients along with their treatment dates.", "Order the results by the DateUndergoes in descending order to get the most recent treatment first.", "Limit the results to 1 to get only the most recent patient undergoing treatment."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT Patient.Name\nFROM Patient\nJOIN Undergoes ON Patient.SSN = Undergoes.Patient\nORDER BY Undergoes.DateUndergoes DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\"\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: Prescribes and Physician.", "We need to find the physician who prescribed the highest dose, so we will look at the Dose column in the Prescribes table.", "To get the physician's name, we will join the Prescribes table with the Physician table on the Physician identifier.", "We will use a subquery to find the maximum dose prescribed by any physician.", "The final query will select the name of the physician whose dose matches the maximum dose found in the subquery."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT Physician.Name\nFROM Prescribes\nJOIN Physician ON Prescribes.Physician = Physician.EmployeeID\nWHERE Prescribes.Dose = (SELECT MAX(Dose) FROM Prescribes);", "hint": "\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["We need to list the employee IDs of physicians along with their primary affiliation department IDs.", "The relevant tables for this query are 'Physician' and 'Affiliated_With'.", "We will select the 'EmployeeID' from the 'Physician' table and the 'Department' from the 'Affiliated_With' table.", "To get the correct associations, we will perform a JOIN operation between 'Physician' and 'Affiliated_With' on the common column 'EmployeeID' and 'Physician'.", "We need to filter the results to only include those records where the affiliation is marked as primary, which is indicated by the 'PrimaryAffiliation' column in the 'Affiliated_With' table."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department\nFROM Physician\nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician\nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\"\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["Identify the table that contains procedure information, which is the Procedures table.", "Determine the relevant columns needed for the query: Name and Cost of the procedures.", "To find the most costly procedures, sort the results by the Cost column in descending order.", "Limit the results to the top three entries to get the three most costly procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "\n"}
{"sample_id": "train.3972", "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find physicians who are trained in specific procedures, so we will join the Physician table with the Trained_In table on the Physician's EmployeeID.", "Next, we join the Trained_In table with the Procedures table on the Treatment code to access the cost of the procedures.", "We need to filter the results to only include procedures that cost more than 5000, so we will add a WHERE clause for Procedures.Cost > 5000.", "Finally, we select the distinct names of the physicians who meet this criterion."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT DISTINCT Physician.Name\nFROM Physician\nJOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician\nJOIN Procedures ON Trained_In.Treatment = Procedures.Code\nWHERE Procedures.Cost > 5000;", "hint": "\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find the physician who was trained in the most expensive procedure, so we will join the Physician table with the Trained_In table on the physician's identifier.", "Next, we will join the Trained_In table with the Procedures table on the treatment code to access the cost of the procedures.", "To find the most expensive procedure, we will use a subquery to select the maximum cost from the Procedures table.", "Finally, we will filter the results to only include the physician(s) who were trained in the procedure with the maximum cost."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT p.Name\nFROM Physician p\nJOIN Trained_In t ON p.EmployeeID = t.Physician\nJOIN Procedures pr ON t.Treatment = pr.Code\nWHERE pr.Cost = (SELECT MAX(Cost) FROM Procedures);", "hint": "\n"}
{"sample_id": "train.3980", "db_id": "hospital_1", "question": "Find all procedures which cost more than 1000 or which physician John Wen was trained in.", "rationale": ["Identify the relevant tables: Procedures and Trained_In, and Physician.", "We need to find procedures that either cost more than 1000 or are associated with the physician named John Wen.", "Use a LEFT JOIN to connect Procedures with Trained_In on the procedure code and then join with Physician on the physician's EmployeeID.", "The WHERE clause will filter for procedures with a cost greater than 1000 or those associated with John Wen.", "Select the distinct names of the procedures that meet either of these criteria."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT DISTINCT Procedures.Name \nFROM Procedures \nLEFT JOIN Trained_In ON Procedures.Code = Trained_In.Treatment \nLEFT JOIN Physician ON Trained_In.Physician = Physician.EmployeeID \nWHERE Procedures.Cost > 1000 OR Physician.Name = 'John Wen';", "hint": "\n"}
{"sample_id": "train.3993", "db_id": "hospital_1", "question": "How many patients are not using Procrastin-X as medication?", "rationale": ["Identify the main goal: Count the number of patients not using 'Procrastin-X' as medication.", "To achieve this, we need to find all patients who have not been prescribed 'Procrastin-X'.", "First, we need to find the medication code for 'Procrastin-X' from the Medication table.", "Next, we will create a subquery to select all patients who have been prescribed 'Procrastin-X' using the Prescribes table.", "Finally, we will count all patients from the Patient table whose SSN is not in the list of patients prescribed 'Procrastin-X'."], "gold_sql": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )", "source_tables": ["patient", "prescribes", "medication"], "pred_sql": "SELECT COUNT(*) AS PatientCount \nFROM Patient \nWHERE SSN NOT IN (\n    SELECT Patient \n    FROM Prescribes \n    WHERE Medication = (SELECT Code FROM Medication WHERE Name = 'Procrastin-X')\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\"\n}\n"}
{"sample_id": "train.4256", "db_id": "club_1", "question": "What are the first names of all the students?", "rationale": ["Identify the table that contains the information needed: the 'Student' table.", "Determine which column contains the first names of the students: the 'Fname' column.", "Construct the SQL query to select the 'Fname' column from the 'Student' table."], "gold_sql": "SELECT DISTINCT fname FROM student", "source_tables": ["student"], "pred_sql": "SELECT Fname FROM Student;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.4271", "db_id": "club_1", "question": "Give me the first name and last name for all the female members of the club \"Bootup Baltimore\".", "rationale": ["Identify the tables needed: Student, Member_of_club, and Club.", "We need to select the first name (Fname) and last name (LName) of students who are female members of a specific club.", "Join the Student table with the Member_of_club table on StuID to get the members' details.", "Join the Member_of_club table with the Club table on ClubID to filter by club name.", "Add a WHERE clause to filter for female students and the specific club name 'Bootup Baltimore'."], "gold_sql": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  'Bootup Baltimore' AND t3.sex  =  'F'", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Student.Fname, Student.LName \nFROM Student \nJOIN Member_of_club ON Student.StuID = Member_of_club.StuID \nJOIN Club ON Member_of_club.ClubID = Club.ClubID \nWHERE Student.Sex = 'Female' AND Club.ClubName = 'Bootup Baltimore';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.4277", "db_id": "club_1", "question": "Find the club which has the largest number of members majoring in \"600\".", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "We need to count the number of members in each club who are majoring in '600'.", "Join the Club table with the Member_of_club table on ClubID to link clubs with their members.", "Join the resulting table with the Student table on StuID to access the major of each student.", "Filter the results to include only those students whose Major is '600'.", "Group the results by ClubID to count the number of members per club.", "Order the results by the count of members in descending order to find the club with the most members majoring in '600'.", "Limit the results to 1 to get only the club with the largest number of members."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  '600' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Club.ClubName, COUNT(Member_of_club.StuID) AS MemberCount\nFROM Club\nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID\nJOIN Student ON Member_of_club.StuID = Student.StuID\nWHERE Student.Major = '600'\nGROUP BY Club.ClubID\nORDER BY MemberCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.4278", "db_id": "club_1", "question": "Find the name of the club that has the most female students.", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "We need to find the club with the most female students, so we will join these tables based on their relationships.", "Filter the students by gender (Sex = 'Female').", "Group the results by ClubID to count the number of female students in each club.", "Order the results by the count of female students in descending order to get the club with the most female members at the top.", "Limit the results to 1 to get only the club with the highest count."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Club.ClubName\nFROM Club\nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID\nJOIN Student ON Member_of_club.StuID = Student.StuID\nWHERE Student.Sex = 'Female'\nGROUP BY Club.ClubID\nORDER BY COUNT(Student.StuID) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.4312", "db_id": "club_1", "question": "List the clubs that have at least a member with advisor \"1121\".", "rationale": ["We need to list clubs that have at least one member with a specific advisor.", "To achieve this, we will join the 'Club', 'Member_of_club', and 'Student' tables.", "The 'Club' table contains the club names we want to list.", "The 'Member_of_club' table links students to clubs, so we will join it to find which students are in which clubs.", "The 'Student' table contains the advisor information, which we will filter on to find students with advisor '1121'.", "We will use a DISTINCT clause to ensure that each club is listed only once, even if multiple members from the same club have the same advisor."], "gold_sql": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  1121", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT DISTINCT Club.ClubName \nFROM Club \nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID \nJOIN Student ON Member_of_club.StuID = Student.StuID \nWHERE Student.Advisor = '1121';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: Grants, Organisations, and Organisation_Types.", "We need to sum the grant amounts, so we will use the SUM function on the 'grant_amount' column from the Grants table.", "To filter the organisations described as research, we will join the Organisations table with the Organisation_Types table to access the organisation type descriptions.", "The join condition will be based on the foreign key relationships: Grants.organisation_id = Organisations.organisation_id and Organisations.organisation_type = Organisation_Types.organisation_type.", "We will filter the results where the organisation type description is 'research'.", "Finally, we will select the total grant amount using the SUM function and alias it as 'total_grant_amount'."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT SUM(Grants.grant_amount) AS total_grant_amount\nFROM Grants\nJOIN Organisations ON Grants.organisation_id = Organisations.organisation_id\nJOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type\nWHERE Organisation_Types.organisation_type_description = 'research';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\"\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the role code for staff members in a leader role by querying the Staff_Roles table.", "Use this role code to filter the Project_Staff table to find projects that have staff in a leader role.", "Group the results by project_id and count the number of staff members for each project to determine which project has the most staff.", "Select the project_id of the project with the highest staff count.", "Finally, retrieve the date_from and date_to for the staff members working on that project."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to \nFROM Project_Staff \nWHERE project_id = (\n    SELECT project_id \n    FROM Project_Staff \n    WHERE role_code = (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%leader%') \n    GROUP BY project_id \n    ORDER BY COUNT(staff_id) DESC \n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\"\n}\n"}
{"sample_id": "train.4328", "db_id": "tracking_grants_for_research", "question": "Find the organisation ids and details of the organisations which are involved in", "rationale": ["Identify the relevant tables: Organisations and Organisation_Types.", "Determine the columns needed: organisation_id and organisation_details from Organisations.", "Join the Organisations table with Organisation_Types to filter based on organisation type.", "Since the query asks for all organisations, we do not need a WHERE clause to filter by type description.", "Order the results by organisation_details for better readability."], "gold_sql": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  6000", "source_tables": ["grants", "organisations"], "pred_sql": "SELECT organisation_id, organisation_details FROM Organisations INNER JOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type ORDER BY organisation_details;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the details of organisations from the 'Organisations' table that are associated with a specific type of organisation. It joins the 'Organisations' table with the 'Organisation_Types' table to filter organisations based on their type description. The placeholder in the WHERE clause represents the description of the organisation type, and the results are ordered by the organisation details.\"\n}\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Research_Staff and Organisations.", "Join the Research_Staff table with the Organisations table on the employer_organisation_id to get the organisation details for each research staff member.", "Group the results by organisation type and organisation id to count the number of research staff in each organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most research staff.", "Limit the results to 1 to get only the organisation with the highest count."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_type, Organisations.organisation_id\nFROM Research_Staff\nJOIN Organisations ON Research_Staff.employer_organisation_id = Organisations.organisation_id\nGROUP BY Organisations.organisation_type, Organisations.organisation_id\nORDER BY COUNT(Research_Staff.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\"\n}\n"}
{"sample_id": "train.4331", "db_id": "tracking_grants_for_research", "question": "What is the type and id of the organization that has the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields.", "Group the results by organisation_id and organisation_type to aggregate the number of research staff per organisation.", "Count the number of research staff for each organisation using COUNT(Research_Staff.staff_id).", "Order the results in descending order to get the organisation with the most research staff at the top.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_type, Organisations.organisation_id\nFROM Organisations\nJOIN Research_Staff ON Organisations.organisation_id = Research_Staff.employer_organisation_id\nGROUP BY Organisations.organisation_id, Organisations.organisation_type\nORDER BY COUNT(Research_Staff.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\"\n}\n"}
{"sample_id": "train.4333", "db_id": "tracking_grants_for_research", "question": "What is the type of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Research_Staff, Organisations, and Organisation_Types.", "Join Research_Staff with Organisations on employer_organisation_id to get the organisation details for each research staff member.", "Join Organisations with Organisation_Types to get the description of the organisation type.", "Group the results by organisation type to count the number of research staff in each type.", "Order the results by the count of research staff in descending order to find the type with the most staff.", "Limit the results to 1 to get only the top organisation type."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisation_Types.organisation_type_description\nFROM Research_Staff\nJOIN Organisations ON Research_Staff.employer_organisation_id = Organisations.organisation_id\nJOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type\nGROUP BY Organisations.organisation_type\nORDER BY COUNT(Research_Staff.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\"\n}\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the relevant tables: Documents, Grants, Organisations, and Organisation_Types.", "Determine the columns needed: We need the 'sent_date' from the Documents table and the 'grant_amount' from the Grants table.", "Establish the relationships: Documents are linked to Grants via 'grant_id', and Grants are linked to Organisations via 'organisation_id'.", "Filter the results based on the condition that the grant amount must be greater than 5000.", "Construct the SQL query using JOINs to connect the tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT Documents.sent_date \nFROM Documents \nJOIN Grants ON Documents.grant_id = Grants.grant_id \nJOIN Organisations ON Grants.organisation_id = Organisations.organisation_id \nJOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type \nWHERE Grants.grant_amount > 5000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\"\n}\n"}
{"sample_id": "train.4335", "db_id": "tracking_grants_for_research", "question": "What are the send dates for all documents that have a grant amount of more than 5000 and are involved in research?", "rationale": ["Identify the relevant tables: Documents, Grants, and Document_Types.", "Determine the columns needed: sent_date from Documents, and grant_amount from Grants.", "Establish the relationships: Documents are linked to Grants via grant_id, and to Document_Types via document_type_code.", "Apply the filter criteria: grant_amount must be greater than 5000, and the document type must be related to research.", "Construct the SQL query using JOINs to combine the necessary tables and apply the WHERE conditions."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT Documents.sent_date \nFROM Documents \nJOIN Grants ON Documents.grant_id = Grants.grant_id \nJOIN Document_Types ON Documents.document_type_code = Document_Types.document_type_code \nWHERE Grants.grant_amount > 5000 \nAND Document_Types.document_description LIKE '%research%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\"\n}\n"}
{"sample_id": "train.4343", "db_id": "tracking_grants_for_research", "question": "When did researchers start and stop working?", "rationale": ["Identify the relevant table: Project_Staff contains information about staff members associated with projects, including their involvement dates.", "Select the columns of interest: staff_id, date_from, and date_to to know when researchers started and stopped working.", "Filter the results to ensure that only records with non-null start and end dates are included, indicating actual involvement."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT staff_id, date_from, date_to \nFROM Project_Staff \nWHERE date_from IS NOT NULL AND date_to IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\"\n}\n"}
{"sample_id": "train.4349", "db_id": "tracking_grants_for_research", "question": "What are the details for the project whose research has been published?", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes are needed to find projects with published research.", "Join the Projects table with Project_Outcomes on project_id to link projects to their outcomes.", "Join the Project_Outcomes table with Research_Outcomes on outcome_code to access the descriptions of the research outcomes.", "Filter the results to include only those outcomes that indicate the research has been published, using a WHERE clause with a LIKE condition."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE '%Published%'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT Projects.project_id, Projects.project_details \nFROM Projects \nJOIN Project_Outcomes ON Projects.project_id = Project_Outcomes.project_id \nJOIN Research_Outcomes ON Project_Outcomes.outcome_code = Research_Outcomes.outcome_code \nWHERE Research_Outcomes.outcome_description LIKE '%published%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\"\n}\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes.", "Join the Projects table with the Project_Outcomes table on the project_id.", "Count the number of outcomes for each project using COUNT(po.outcome_code).", "Group the results by project_id and project_details to aggregate the counts correctly.", "Order the results by the count of outcomes in descending order to find the project with the most outcomes.", "Limit the results to 1 to get only the project with the highest count."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT p.project_id, p.project_details, COUNT(po.outcome_code) AS outcome_count\nFROM Projects p\nJOIN Project_Outcomes po ON p.project_id = po.project_id\nGROUP BY p.project_id, p.project_details\nORDER BY outcome_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Research_Staff and Organisations.", "We need to join these tables on the employer_organisation_id from Research_Staff and organisation_id from Organisations.", "We want to group the results by organisation_id, organisation_type, and organisation_details to count the number of research staff per organisation.", "Use COUNT() to count the number of staff members for each organisation.", "Order the results in descending order to get the organisation with the most research staff at the top.", "Limit the results to 1 to get only the organisation that hired the most research staff."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_id, Organisations.organisation_type, Organisations.organisation_details\nFROM Research_Staff\nJOIN Organisations ON Research_Staff.employer_organisation_id = Organisations.organisation_id\nGROUP BY Organisations.organisation_id, Organisations.organisation_type, Organisations.organisation_details\nORDER BY COUNT(Research_Staff.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\"\n}\n"}
{"sample_id": "train.4361", "db_id": "tracking_grants_for_research", "question": "What are the ids, types, and details of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields.", "Group the results by organisation_id, organisation_type, and organisation_details to aggregate the research staff count for each organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most research staff.", "Limit the results to 1 to get only the organisation with the highest count."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id, o.organisation_type, o.organisation_details\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\"\n}\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff for staff involvement in projects and Staff_Roles for role descriptions.", "Join Project_Staff with Staff_Roles on role_code to get the role descriptions for each staff member.", "Filter the results to include only those staff members who are currently involved in projects based on their date_from and date_to fields.", "Group the results by staff_id and role_description to count the number of projects each staff member is involved in for each role.", "Order the results by the count of projects in descending order to find the role with the most involvement.", "Limit the results to 1 to get the role description of the staff member involved in the most projects."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT ps.staff_id, sr.role_description\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nWHERE ps.date_from <= CURRENT_DATE AND (ps.date_to IS NULL OR ps.date_to >= CURRENT_DATE)\nGROUP BY ps.staff_id, sr.role_description\nORDER BY COUNT(ps.project_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\"\n}\n"}
{"sample_id": "train.4367", "db_id": "tracking_grants_for_research", "question": "For grants that have descriptions of Regular and Initial Applications, what are their start dates?", "rationale": ["Identify the relevant tables: Grants, Documents, and Document_Types.", "Determine the columns needed: grant_start_date from Grants.", "Establish the relationships: Documents are linked to Grants via grant_id, and Documents are linked to Document_Types via document_type_code.", "Filter the results based on the document descriptions: Regular Applications and Initial Applications.", "Construct the SQL query using JOINs to connect the tables and a WHERE clause to filter by the specified document descriptions."], "gold_sql": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Regular' INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Initial Application'", "source_tables": ["grants", "document_types", "documents"], "pred_sql": "SELECT Grants.grant_start_date \nFROM Grants \nJOIN Documents ON Grants.grant_id = Documents.grant_id \nJOIN Document_Types ON Documents.document_type_code = Document_Types.document_type_code \nWHERE Document_Types.document_description IN ('Regular Applications', 'Initial Applications');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\"\n}\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["Identify the relevant tables: Grants and Documents.", "We need to count the number of documents associated with each grant, so we will join the Grants table with the Documents table on the grant_id.", "Use COUNT() to count the number of documents for each grant.", "Group the results by grant_id to get the count for each grant.", "To find the grant with the most documents, we will order the results by the document count in descending order.", "Limit the results to 1 to get the grant with the most documents."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT g.grant_id, COUNT(d.document_id) AS document_count, d.document_id AS most_documents\nFROM Grants g\nLEFT JOIN Documents d ON g.grant_id = d.grant_id\nGROUP BY g.grant_id\nORDER BY document_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\"\n}\n"}
{"sample_id": "train.4372", "db_id": "tracking_grants_for_research", "question": "What are all the details of the organisations described as 'Sponsor'? Sort the result in an ascending order.", "rationale": ["Identify the relevant table: Organisations.", "Determine the condition to filter organisations: organisation_type should match the type described as 'Sponsor'.", "Use a subquery to find the organisation_type corresponding to the description 'Sponsor' from the Organisation_Types table.", "Select all columns from the Organisations table where the organisation_type matches the result of the subquery.", "Sort the results in ascending order based on organisation_id."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "pred_sql": "SELECT * FROM Organisations WHERE organisation_type = (SELECT organisation_type FROM Organisation_Types WHERE organisation_type_description = 'Sponsor') ORDER BY organisation_id ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\"\n}\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant table: The question asks for project details, which are found in the 'Projects' table.", "Determine the specific column needed: The 'project_details' column contains the descriptions of the projects.", "Formulate the SQL query: We need to select the 'project_id' and 'project_details' from the 'Projects' table where the 'project_details' match the given value 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT project_id, project_details FROM Projects WHERE project_details = 'sint';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\"\n}\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes.", "Determine the relationship between the tables: Projects has a project_id that links to Project_Outcomes.", "Select the fields needed: project_details from Projects and outcome_details from Project_Outcomes.", "Filter the results based on the project detail specified in the question: 'sint'.", "Construct the SQL query using JOIN to combine the two tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT p.project_details, po.outcome_details \nFROM Projects p \nJOIN Project_Outcomes po ON p.project_id = po.project_id \nWHERE p.project_details = 'sint';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\"\n}\n"}
{"sample_id": "train.4383", "db_id": "tracking_grants_for_research", "question": "What is the id of the organization with the maximum number of outcomes and how many outcomes are there?", "rationale": ["Identify the relevant tables: Organisations, Projects, and Project_Outcomes are needed to find the organization with the maximum number of outcomes.", "Join the Organisations table with the Projects table on organisation_id to link organizations to their projects.", "Join the resulting table with the Project_Outcomes table on project_id to associate outcomes with each project.", "Group the results by organisation_id to count the number of outcomes for each organization.", "Use COUNT(po.outcome_code) to count the outcomes associated with each organization.", "Order the results by the count of outcomes in descending order to get the organization with the maximum outcomes at the top.", "Limit the results to 1 to get only the organization with the maximum number of outcomes."], "gold_sql": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT o.organisation_id, COUNT(po.outcome_code) AS outcome_count\nFROM Organisations o\nJOIN Projects p ON o.organisation_id = p.organisation_id\nJOIN Project_Outcomes po ON p.project_id = po.project_id\nGROUP BY o.organisation_id\nORDER BY outcome_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.4384", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects launched by the organisation", "rationale": ["Identify the relevant table: The 'Projects' table contains the project details we need.", "Determine the filtering criteria: We want projects launched by organisations, so we need to group projects by 'organisation_id'.", "Count the number of projects per organisation: Use COUNT(project_id) to determine how many projects each organisation has.", "Order the organisations by the number of projects: Use ORDER BY COUNT(project_id) DESC to get organisations with the most projects first.", "Select the project details: Finally, we select the 'project_details' from the 'Projects' table where the 'organisation_id' matches those in the subquery."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT project_details FROM Projects WHERE organisation_id IN (SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY COUNT(project_id) DESC);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\"\n}\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["Identify the relevant tables: Project_Staff and Staff_Roles are needed to get the staff roles.", "Join the Project_Staff table with the Staff_Roles table on the role_code to get the role descriptions.", "Filter the results based on the involvement dates of the staff members: include those whose date_from is less than or equal to the current date and whose date_to is either NULL or greater than or equal to the current date."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT Staff_Roles.role_description \nFROM Project_Staff \nJOIN Staff_Roles ON Project_Staff.role_code = Staff_Roles.role_code \nWHERE Project_Staff.date_from <= DATE('now') AND (Project_Staff.date_to IS NULL OR Project_Staff.date_to >= DATE('now'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\"\n}\n"}
{"sample_id": "train.4394", "db_id": "tracking_grants_for_research", "question": "What are the descriptions of all the project outcomes?", "rationale": ["The user wants to retrieve descriptions of all project outcomes.", "The relevant table for project outcomes is 'Project_Outcomes', which contains 'outcome_code' and 'outcome_details'.", "To get the descriptions, we need to select 'outcome_code' and 'outcome_details' from the 'Project_Outcomes' table.", "The SQL query will be a simple SELECT statement that retrieves these columns from the specified table."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code", "source_tables": ["project_outcomes", "research_outcomes"], "pred_sql": "SELECT outcome_code, outcome_details FROM Project_Outcomes;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["Identify the relevant table: The question pertains to staff roles, so we will focus on the Project_Staff table.", "Count occurrences: We need to count how many times each role_code appears in the Project_Staff table to determine the most common role.", "Group by role_code: To count the occurrences of each role, we will group the results by role_code.", "Order by count: We will order the results in descending order based on the count of each role to find the most common one.", "Limit the results: Since we only want the most common role, we will limit the results to 1."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count \nFROM Project_Staff \nGROUP BY role_code \nORDER BY role_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\"\n}\n"}
{"sample_id": "train.4410", "db_id": "network_2", "question": "Who is the oldest person whose job is student?", "rationale": ["Identify the table to query: The 'Person' table contains the relevant information about individuals.", "Determine the criteria: We need to find individuals whose job is 'student'.", "Select the relevant columns: We want to retrieve the 'name' and 'age' of the person.", "Sort the results: To find the oldest person, we will sort the results by 'age' in descending order.", "Limit the results: We only need the oldest person, so we will limit the results to 1."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "pred_sql": "SELECT name, age FROM Person WHERE job = 'student' ORDER BY age DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\"\n}\n"}
{"sample_id": "train.4439", "db_id": "network_2", "question": "What is the name and age of every male? Order the results by age.", "rationale": ["Identify the relevant table: The 'Person' table contains the necessary information about individuals.", "Select the required columns: We need the 'name' and 'age' of every male.", "Filter by gender: We will use a WHERE clause to specify that we only want males.", "Order the results: We will use an ORDER BY clause to sort the results by age."], "gold_sql": "SELECT name FROM Person WHERE gender  =  'male' ORDER BY age", "source_tables": ["person"], "pred_sql": "SELECT name, age FROM Person WHERE gender = 'male' ORDER BY age;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\"\n}\n"}
{"sample_id": "train.4441", "db_id": "network_2", "question": "What are the names and ages of every person who is a friend of both Dan and Alice?", "rationale": ["Identify the required information: names and ages of persons who are friends with both Dan and Alice.", "To find friends of both Dan and Alice, we need to join the PersonFriend table twice: once for Dan and once for Alice.", "Use the Person table to get the names and ages of the friends identified in the previous step.", "The final query will select the name and age from the Person table where the person is a friend of both Dan and Alice."], "gold_sql": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, P.age \nFROM Person P \nJOIN PersonFriend PF1 ON P.name = PF1.friend \nJOIN PersonFriend PF2 ON P.name = PF2.friend \nWHERE PF1.name = 'Dan' AND PF2.name = 'Alice';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\"\n}\n"}
{"sample_id": "train.4444", "db_id": "network_2", "question": "Find the name of the person who has friends with age above 40 and under age 30?", "rationale": ["Identify the relevant tables: We need to use both the 'Person' and 'PersonFriend' tables to find the names of individuals who have friends with specific age criteria.", "Determine the relationship: The 'PersonFriend' table contains the names of individuals and their friends, while the 'Person' table contains the age of those friends.", "Set the conditions: We need to filter friends based on their age being above 40 or below 30.", "Use a JOIN operation: We will join the 'PersonFriend' table with the 'Person' table on the condition that the friend's name in 'PersonFriend' matches the name in 'Person'.", "Select distinct names: We want to select distinct names from the 'PersonFriend' table where the age conditions are met."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT pf.name \nFROM PersonFriend pf \nJOIN Person p ON pf.friend = p.name \nWHERE p.age > 40 OR p.age < 30;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\"\n}\n"}
{"sample_id": "train.4445", "db_id": "network_2", "question": "What are the names of every person who has a friend over 40 and under 30?", "rationale": ["Identify the main table to query from, which is the 'Person' table for the names of individuals.", "Use the 'PersonFriend' table to find friends of the individuals in the 'Person' table.", "Join the 'Person' table with the 'PersonFriend' table to link individuals with their friends.", "Join again with the 'Person' table to access the age of the friends.", "Apply the condition to filter friends who are either over 40 or under 30 years old.", "Select distinct names of individuals who have friends meeting the age criteria."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT p1.name \nFROM Person p1 \nJOIN PersonFriend pf ON p1.name = pf.name \nJOIN Person p2 ON pf.friend = p2.name \nWHERE (p2.age > 40 OR p2.age < 30);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\"\n}\n"}
{"sample_id": "train.4449", "db_id": "network_2", "question": "What are the names of the people who have no friends who are students?", "rationale": ["Identify the main requirement: We need the names of people who have no friends who are students.", "To find friends who are students, we need to look at the 'Person' table and filter by job = 'student'.", "We will create a subquery to select the names of friends who are students.", "Next, we need to find people in the 'Person' table whose names are not in the list of friends who are students.", "We will use a NOT IN clause to filter out those names from the 'Person' table."], "gold_sql": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  'student'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT name FROM Person WHERE name NOT IN (SELECT name FROM PersonFriend WHERE friend IN (SELECT name FROM Person WHERE job = 'student'));", "hint": "\n"}
{"sample_id": "train.4454", "db_id": "network_2", "question": "Find the name of persons who are friends with Bob.", "rationale": ["Identify the relevant table: PersonFriend, which contains information about friendships.", "Determine the specific person of interest: Bob.", "Construct a SQL query to select the 'friend' column from the PersonFriend table where the 'name' column matches 'Bob'."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Bob';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\"\n}\n"}
{"sample_id": "train.4455", "db_id": "network_2", "question": "What are the names of all of Bob's friends?", "rationale": ["Identify the relevant table: PersonFriend contains the friendships.", "Determine the specific person of interest: Bob.", "Construct a query to select the 'friend' column from the PersonFriend table where the 'name' column matches 'Bob'."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Bob';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\"\n}\n"}
{"sample_id": "train.4456", "db_id": "network_2", "question": "Find the names of females who are friends with Zach", "rationale": ["Identify the relevant tables: We need to use the 'Person' table to get the names of females and the 'PersonFriend' table to find friends of Zach.", "We need to join the 'Person' table with the 'PersonFriend' table on the condition that the name in 'Person' matches the friend in 'PersonFriend'.", "We filter the results to only include friends of Zach by using the condition 'PF.name = 'Zach' '.", "Additionally, we need to filter the results to only include females by adding the condition 'P.gender = 'female' '.", "Finally, we select the names of the females who are friends with Zach."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Zach' AND T1.gender  =  'female'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name \nFROM Person P \nJOIN PersonFriend PF ON P.name = PF.friend \nWHERE PF.name = 'Zach' AND P.gender = 'female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\"\n}\n"}
{"sample_id": "train.4465", "db_id": "network_2", "question": "What are the different names of friends who are younger than the average age for a friend?", "rationale": ["Identify the relevant tables: We need to work with the Person and PersonFriend tables to find friends and their ages.", "Determine the condition: We want friends who are younger than the average age of all persons.", "Calculate the average age: We can use a subquery to calculate the average age from the Person table.", "Join the tables: We need to join PersonFriend with Person to access the age of each friend.", "Select distinct names: We want to select distinct names of friends that meet the age condition."], "gold_sql": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT pf.friend \nFROM PersonFriend pf \nJOIN Person p ON pf.friend = p.name \nWHERE p.age < (SELECT AVG(age) FROM Person)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\"\n}\n"}
{"sample_id": "train.4466", "db_id": "network_2", "question": "Who has friends that are older than the average age? Print their friends and their ages as well", "rationale": ["Identify the tables involved: Person and PersonFriend.", "We need to find friends of individuals, so we will use the PersonFriend table to get the friends' names.", "To find the ages of these friends, we will join the Person table on the friend's name.", "We need to filter the results to only include friends who are older than the average age.", "To calculate the average age, we will use a subquery that selects the average age from the Person table."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT pf.friend, p.age \nFROM PersonFriend pf \nJOIN Person p ON pf.friend = p.name \nWHERE p.age > (SELECT AVG(age) FROM Person)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\"\n}\n"}
{"sample_id": "train.4467", "db_id": "network_2", "question": "Whare the names, friends, and ages of all people who are older than the average age of a person?", "rationale": ["Identify the required fields: names, friends, and ages of people.", "The names and ages are from the 'Person' table, while friends are from the 'PersonFriend' table.", "To get the friends, we need to join the 'Person' table with the 'PersonFriend' table on the name column.", "We need to filter the results to include only those people whose age is greater than the average age of all persons.", "The average age can be calculated using a subquery: (SELECT AVG(age) FROM Person).", "Construct the final SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name, pf.friend, p.age \nFROM Person p \nJOIN PersonFriend pf ON p.name = pf.name \nWHERE p.age > (SELECT AVG(age) FROM Person);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\"\n}\n"}
{"sample_id": "train.4473", "db_id": "network_2", "question": "What are the names of all people who are friends with Alice for the shortest amount of time?", "rationale": ["Identify the person of interest, which is 'Alice'.", "We need to find friends of Alice from the PersonFriend table.", "To find the friends with the shortest amount of time, we will order the results by the 'year' column in ascending order.", "We will limit the results to 1 to get only the friend with the shortest friendship duration."], "gold_sql": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Alice' ORDER BY year ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\"\n}\n"}
{"sample_id": "train.4475", "db_id": "network_2", "question": "What are the names, ages, and jobs of all people who are friends with Alice for the longest amount of time?", "rationale": ["Identify the relevant tables: Person and PersonFriend.", "We need to find people who are friends with Alice, so we will join the Person table with the PersonFriend table on the condition that the friend's name matches the name in the Person table.", "We will filter the results to only include friends of Alice by using a WHERE clause that specifies pf.name = 'Alice'.", "To find the friends who have been friends with Alice for the longest time, we will order the results by the year the friendship was established in ascending order.", "Finally, we will select the name, age, and job of these friends and limit the results to the first entry, which represents the friend with the longest friendship with Alice."], "gold_sql": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name, p.age, p.job\nFROM Person p\nJOIN PersonFriend pf ON p.name = pf.friend\nWHERE pf.name = 'Alice'\nORDER BY pf.year ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\"\n}\n"}
{"sample_id": "train.4478", "db_id": "network_2", "question": "Which person whose friends have the oldest average age?", "rationale": ["We need to find the person whose friends have the oldest average age.", "To do this, we will join the PersonFriend table with the Person table on the friend's name.", "We will group the results by the person's name to calculate the average age of their friends.", "We will use the AVG function to calculate the average age of friends for each person.", "Finally, we will order the results in descending order based on the average age and limit the results to the top one person."], "gold_sql": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT 1", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT pf.name\nFROM PersonFriend pf\nJOIN Person p ON pf.friend = p.name\nGROUP BY pf.name\nORDER BY AVG(CAST(p.age AS INTEGER)) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\"\n}\n"}
{"sample_id": "train.4480", "db_id": "network_2", "question": "What is the total number of people who has no friend living in the city of Austin.", "rationale": ["We need to count the total number of people who have no friends living in Austin.", "First, we identify the friends who live in Austin by selecting names from the Person table where the city is 'Austin'.", "Next, we find all names from the PersonFriend table where the friend is in the list of friends living in Austin.", "Finally, we count the number of people in the Person table whose names are not in the list of friends found in the previous step."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT COUNT(*) FROM Person WHERE name NOT IN (SELECT name FROM PersonFriend WHERE friend IN (SELECT name FROM Person WHERE city = 'Austin'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\"\n}\n"}
{"sample_id": "train.4503", "db_id": "document_management", "question": "Find the types of documents with more than 4 documents.", "rationale": ["Identify the relevant table: The Documents table contains the document types and their counts.", "Group the documents by their type: Use GROUP BY on the document_type_code to aggregate the counts of documents for each type.", "Count the number of documents for each type: Use COUNT(document_code) to get the number of documents associated with each document type.", "Filter the results: Use HAVING to filter the groups where the count of documents is greater than 4."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code, COUNT(document_code) AS document_count \nFROM Documents \nGROUP BY document_type_code \nHAVING COUNT(document_code) > 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average access count of documents grouped by their document structure code. The placeholder in the LIMIT clause allows the user to specify the maximum number of groups to return, based on the ascending order of their count.\"\n}\n"}
{"sample_id": "train.4504", "db_id": "document_management", "question": "What are the codes of types of documents of which there are for or more?", "rationale": ["Identify the relevant table: The question pertains to document types, which are found in the 'Documents' table.", "Determine the required information: We need the 'document_type_code' for document types that have four or more associated documents.", "Use GROUP BY: To find the document types, we will group the results by 'document_type_code'.", "Use HAVING clause: To filter the groups, we will use the HAVING clause to ensure we only include those with a count of documents (document_code) that is four or more."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code\nFROM Documents\nGROUP BY document_type_code\nHAVING COUNT(document_code) >= 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of document structure descriptions from the 'Document_Structures' table, which are associated with documents in the 'Documents' table. The results are grouped by the document structure code and ordered by the number of documents associated with each structure, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.4505", "db_id": "document_management", "question": "Find the total access count of all documents in the most popular document type.", "rationale": ["Identify the requirement to find the total access count of documents.", "Determine that we need to group documents by their document type to find the most popular one based on access count.", "Use a subquery to select the document type code that has the highest total access count.", "In the main query, sum the access counts of documents that match the most popular document type code."], "gold_sql": "SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT SUM(access_count) AS total_access_count\nFROM Documents\nWHERE document_type_code = (\n    SELECT document_type_code\n    FROM Documents\n    GROUP BY document_type_code\n    ORDER BY SUM(access_count) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average access count of documents grouped by their document structure code. The placeholder in the LIMIT clause allows the user to specify the maximum number of groups to return, based on the ascending order of their count.\"\n}\n"}
{"sample_id": "train.4525", "db_id": "document_management", "question": "Find names of the document without any images.", "rationale": ["We need to find documents that do not have any associated images.", "To do this, we will use a LEFT JOIN between the Documents table and the Document_Sections table to get all sections of each document.", "Next, we will perform another LEFT JOIN with the Document_Sections_Images table to find any images associated with those sections.", "By using LEFT JOINs, we can still include documents that have no images, as they will return NULL for the image fields.", "Finally, we will filter the results using a WHERE clause to only include documents where the image_id from the Document_Sections_Images table is NULL, indicating no images are associated."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "pred_sql": "SELECT d.document_name \nFROM Documents d \nLEFT JOIN Document_Sections ds ON d.document_code = ds.document_code \nLEFT JOIN Document_Sections_Images dsi ON ds.section_id = dsi.section_id \nWHERE dsi.image_id IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of document structure descriptions from the 'Document_Structures' table, which are associated with documents in the 'Documents' table. The results are grouped by the document structure code and ordered by the number of documents associated with each structure, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.4532", "db_id": "document_management", "question": "Count the number of users that are logged in.", "rationale": ["The task is to count the number of users that are logged in.", "In the Users table, we need to count the total number of entries, as there is no specific column indicating whether a user is logged in or not.", "Using COUNT(*) will give us the total number of users in the Users table, which can be interpreted as the number of users that are logged in."], "gold_sql": "SELECT count(*) FROM users WHERE user_login  =  1", "source_tables": ["users"], "pred_sql": "SELECT COUNT(*) AS logged_in_users FROM Users;", "hint": "\n"}
{"sample_id": "train.4733", "db_id": "department_store", "question": "Return the distinct name of customers whose order status is Pending, in the order of customer id.", "rationale": ["We need to return distinct names of customers.", "The relevant table for customer information is the 'Customers' table, which contains customer names and IDs.", "The 'Customer_Orders' table contains order information, including the order status and customer ID.", "To find customers with a specific order status ('Pending'), we will join the 'Customers' table with the 'Customer_Orders' table on the customer ID.", "We will filter the results to include only those orders where the order status code is 'Pending'.", "Finally, we will order the results by customer ID to meet the requirement of ordering the output."], "gold_sql": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending' ORDER BY T2.customer_id", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT c.customer_name \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nWHERE co.order_status_code = 'Pending' \nORDER BY c.customer_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The date is determined by finding the earliest order date associated with a particular order status, represented by a placeholder.\"\n}\n"}
{"sample_id": "train.4736", "db_id": "department_store", "question": "What are the names and addressed of customers who have both New and Pending orders?", "rationale": ["Identify the relevant tables: Customers, Customer_Orders, and Customer_Addresses.", "Join the Customers table with Customer_Orders to filter customers based on their order status.", "Join the Customer_Addresses table to get the addresses of the customers.", "Use a WHERE clause to filter orders that have the status 'New' and 'Pending'.", "Group the results by customer_id to ensure we are counting unique customers.", "Use HAVING to ensure that only customers with both order statuses are included in the final result."], "gold_sql": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'New' INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending'", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT c.customer_name, ca.address_id \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nWHERE co.order_status_code IN ('New', 'Pending') \nGROUP BY c.customer_id \nHAVING COUNT(DISTINCT co.order_status_code) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The date is determined by finding the earliest order date associated with a particular order status, represented by a placeholder.\"\n}\n"}
{"sample_id": "train.4749", "db_id": "department_store", "question": "Find the id and name of the staff who has been assigned for the shortest period.", "rationale": ["Identify the relevant table: Staff_Department_Assignments contains the staff assignments with their respective dates.", "To find the staff assigned for the shortest period, we need to look for the minimum 'date_assigned_to' in the Staff_Department_Assignments table.", "The query will select the staff_id and staff_name from the Staff table where the date_assigned_to matches the minimum date found in the subquery."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name FROM Staff_Department_Assignments WHERE date_assigned_to = (SELECT MIN(date_assigned_to) FROM Staff_Department_Assignments)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\"\n}\n"}
{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["Identify the relevant table: Staff_Department_Assignments contains the staff assignments and their dates.", "We need to find the staff member with the least amount of time assigned, which corresponds to the earliest 'date_assigned_to'.", "Use a subquery to find the minimum 'date_assigned_to' from the Staff_Department_Assignments table.", "Select the 'staff_id' and 'staff_name' from the Staff table where the 'staff_id' matches the one with the earliest 'date_assigned_to'."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name FROM Staff_Department_Assignments WHERE date_assigned_to = (SELECT MIN(date_assigned_to) FROM Staff_Department_Assignments)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\"\n}\n"}
{"sample_id": "train.4753", "db_id": "department_store", "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.", "rationale": ["We need to find distinct customer IDs from the Customer_Orders table.", "We will filter the orders based on the order date being after a certain date.", "This date is determined by finding the earliest order date for orders that have a status of 'Cancelled'.", "We will use a subquery to get the minimum order date from the Customer_Orders table where the order_status_code is 'Cancelled'.", "Finally, we will select distinct customer IDs from the Customer_Orders table where the order date is greater than the date obtained from the subquery."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "pred_sql": "SELECT DISTINCT co.customer_id\nFROM Customer_Orders co\nWHERE co.order_date > (\n    SELECT MIN(co2.order_date)\n    FROM Customer_Orders co2\n    WHERE co2.order_status_code = 'Cancelled'\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The date is determined by finding the earliest order date associated with a particular order status, represented by a placeholder.\"\n}\n"}
{"sample_id": "train.4755", "db_id": "department_store", "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?", "rationale": ["Identify the requirement: We need to find the staff IDs of those who had a department assignment earlier than any Clerical Staff.", "Understand the hint: The hint describes a virtual table that lists staff members assigned to a department whose assignment ended before the most recent assignment date for a specific job title.", "Determine the job title code for Clerical Staff: We will use 'Clerical' as the job title code in our subquery.", "Construct the subquery: We need to find the maximum 'date_assigned_to' for Clerical staff from the Staff_Department_Assignments table.", "Construct the main query: We will select 'staff_id' from Staff_Department_Assignments where 'date_assigned_to' is less than the result of the subquery."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "pred_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to < (SELECT MAX(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\"\n}\n"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to retrieve customer names and IDs, so we will select 'customer_id' and 'customer_name' from the Customers table.", "To find customers with 'TN' in their address, we need to join the Customers table with the Customer_Addresses table on 'customer_id'.", "Next, we join the Customer_Addresses table with the Addresses table on 'address_id' to access the address details.", "Finally, we filter the results using a WHERE clause to find addresses that contain 'TN' in the 'address_details' column."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "pred_sql": "SELECT Customers.customer_id, Customers.customer_name \nFROM Customers \nJOIN Customer_Addresses ON Customers.customer_id = Customer_Addresses.customer_id \nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id \nWHERE Addresses.address_details LIKE '%TN%';", "hint": "\n"}
{"sample_id": "train.4760", "db_id": "department_store", "question": "What are the names and genders of staff who were assigned in 2016?", "rationale": ["Identify the relevant tables: 'Staff' for staff details and 'Staff_Department_Assignments' for assignment details.", "We need to select the staff names and genders, which are in the 'Staff' table.", "To find staff assigned in 2016, we need to join 'Staff' with 'Staff_Department_Assignments' on 'staff_id'.", "The condition for the assignment date should be set to include all dates in 2016, which means we check for dates from '2016-01-01' to '2017-01-01'.", "Construct the SQL query using SELECT to get the required fields and JOIN to combine the tables with the appropriate WHERE clause."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT Staff.staff_name, Staff.staff_gender \nFROM Staff \nJOIN Staff_Department_Assignments ON Staff.staff_id = Staff_Department_Assignments.staff_id \nWHERE Staff_Department_Assignment.date_assigned_from >= '2016-01-01' AND Staff_Department_Assignment.date_assigned_from < '2017-01-01';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\"\n}\n"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments are needed to get staff names and their job assignments.", "Join the Staff table with Staff_Department_Assignments on staff_id to link staff members with their job assignments.", "Use a subquery to find staff members who have been assigned to more than one job title by grouping by staff_id and counting distinct job_title_code.", "Filter the main query to only include staff members who are in the result of the subquery, ensuring we only get those with multiple job assignments."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT DISTINCT s.staff_name \nFROM Staff s \nJOIN Staff_Department_Assignments sda ON s.staff_id = sda.staff_id \nWHERE sda.staff_id IN (\n    SELECT staff_id \n    FROM Staff_Department_Assignments \n    GROUP BY staff_id \n    HAVING COUNT(DISTINCT job_title_code) > 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\"\n}\n"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["Identify the relevant table: Customers, which contains customer_id, customer_name, customer_address, and payment_method_code.", "Filter customers based on their address containing 'WY'. This can be done using the LIKE operator with a wildcard: '%WY%'.", "Exclude customers who use a credit card for payment. This is done by checking that payment_method_code is not equal to 'CREDIT_CARD'.", "Combine these conditions in the WHERE clause of the SQL query to retrieve the desired customer ids and names."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name \nFROM Customers \nWHERE customer_address LIKE '%WY%' \nAND payment_method_code != 'CREDIT_CARD';", "hint": "\n"}
{"sample_id": "train.4793", "db_id": "department_store", "question": "Find the average price of all product clothes.", "rationale": ["Identify the table that contains product information, which is the 'Products' table.", "Determine the relevant column for price, which is 'product_price'.", "To find the average price, use the AVG() function.", "Filter the products to only include those that are classified as 'clothes' using the 'product_type_code' column."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "pred_sql": "SELECT AVG(product_price) AS average_price\nFROM Products\nWHERE product_type_code = 'clothes';", "hint": "\n"}
{"sample_id": "train.4795", "db_id": "department_store", "question": "Find the name of the most expensive hardware product.", "rationale": ["Identify the relevant table: Products.", "Determine the criteria for 'hardware' products, which is indicated by the product_type_code.", "Select the product_name from the Products table.", "Order the results by product_price in descending order to get the most expensive product at the top.", "Limit the results to 1 to get only the most expensive hardware product."], "gold_sql": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1", "source_tables": ["products"], "pred_sql": "SELECT product_name FROM Products WHERE product_type_code = 'hardware' ORDER BY product_price DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["We need to find the list of maximum page sizes that have more than 3 products listed.", "To do this, we will join the 'product' table with the 'store_product' table using the 'product_id' and 'Product_ID' columns.", "We will group the results by 'max_page_size' to aggregate the products based on their page sizes.", "Finally, we will use the HAVING clause to filter the groups where the count of products is greater than 3."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size\nFROM product\nJOIN store_product ON product.product_id = store_product.Product_ID\nGROUP BY max_page_size\nHAVING COUNT(store_product.Product_ID) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\"\n}\n"}
{"sample_id": "train.4903", "db_id": "store_product", "question": "What is the maximum page size for everything that has more than 3 products listed?", "rationale": ["Identify the relevant tables: product, store_product, and store.", "We need to find the maximum page size for products that are listed in stores with more than 3 products.", "Join the product table with the store_product table to link products to stores.", "Join the resulting table with the store table to access store information.", "Group the results by store to count the number of products per store.", "Use the HAVING clause to filter stores that have more than 3 products listed.", "Select the maximum page size from the product table for the filtered stores."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT MAX(p.max_page_size) \nFROM product p \nJOIN store_product sp ON p.product_id = sp.Product_ID \nJOIN store s ON sp.Store_ID = s.Store_ID \nGROUP BY s.Store_ID \nHAVING COUNT(sp.Product_ID) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\"\n}\n"}
{"sample_id": "train.4913", "db_id": "store_product", "question": "What is the total number of residents for the districts with the 3 largest areas?", "rationale": ["Identify the relevant table: The 'district' table contains the population and area information needed for the query.", "Determine the requirement: We need to find the total number of residents in the districts with the 3 largest areas.", "Use a subquery to find the 3 districts with the largest areas: This can be done by ordering the districts by 'City_Area' in descending order and limiting the results to 3.", "Sum the populations of these districts: Use the SUM function to calculate the total population of the districts identified in the subquery."], "gold_sql": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3", "source_tables": ["district"], "pred_sql": "SELECT SUM(City_Population) AS Total_Residents\nFROM district\nWHERE District_ID IN (\n    SELECT District_ID\n    FROM district\n    ORDER BY City_Area DESC\n    LIMIT 3\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of stores grouped by the city where their respective districts are headquartered. The placeholders in the query represent the relationships between stores and districts, allowing for aggregation of store counts based on the city names.\"\n}\n"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["Identify the relevant tables: store, store_district, and district are needed to find stores in a specific district.", "Join the store table with the store_district table on Store_ID to link stores to their respective districts.", "Join the resulting table with the district table on District_ID to access district names.", "Filter the results to only include stores located in 'Khanewal District' by using a WHERE clause."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT store.Store_Name \nFROM store \nJOIN store_district ON store.Store_ID = store_district.Store_ID \nJOIN district ON store_district.District_ID = district.District_ID \nWHERE district.District_name = 'Khanewal';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in each city, with a limit on the number of cities returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["Identify the relevant tables: store, store_district, and district are needed to find the number of stores in each city.", "Join the store table with store_district to associate stores with their respective districts.", "Join the resulting table with the district table to access the Headquartered_City for each district.", "Group the results by Headquartered_City to count the number of stores in each city.", "Order the results by the count of stores in descending order to find the city with the most stores.", "Limit the results to 1 to get only the city with the highest number of stores."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT d.Headquartered_City, COUNT(s.Store_ID) AS Number_of_Stores\nFROM store s\nJOIN store_district sd ON s.Store_ID = sd.Store_ID\nJOIN district d ON sd.District_ID = d.District_ID\nGROUP BY d.Headquartered_City\nORDER BY Number_of_Stores DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in each city, with a limit on the number of cities returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.4930", "db_id": "store_product", "question": "Find products with max page size as \"A4\" and pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to filter products based on 'max_page_size' being 'A4' and 'pages_per_minute_color' being less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table where the specified conditions are met."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' AND pages_per_minute_color < 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\"\n}\n"}
{"sample_id": "train.4932", "db_id": "store_product", "question": "Find products with max page size as \"A4\" or pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to find products with a max page size of 'A4' or a pages per minute color speed less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table where either of the conditions is met."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < '5';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\"\n}\n"}
{"sample_id": "train.4935", "db_id": "store_product", "question": "What are all of the products whose name includes the substring \"Scanner\"?", "rationale": ["Identify the table that contains product information, which is the 'product' table.", "Determine the column that contains the product names, which is the 'product' column.", "Formulate a SQL query to select all columns from the 'product' table where the 'product' column contains the substring 'Scanner'.", "Use the SQL LIKE operator with wildcards (%) to match any product names that include 'Scanner'."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE product LIKE '%Scanner%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\"\n}\n"}
{"sample_id": "train.4937", "db_id": "store_product", "question": "What is the most common maximum page size?", "rationale": ["Identify the relevant table: The question pertains to the maximum page size of products, which is found in the 'product' table.", "Determine the required information: We need to find the most common maximum page size, which implies counting occurrences of each maximum page size.", "Use GROUP BY: To count how many times each maximum page size appears, we will group the results by the 'max_page_size' column.", "Count occurrences: We will use COUNT(*) to count the number of products for each maximum page size.", "Order the results: To find the most common maximum page size, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most common maximum page size, we will limit the results to 1."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1", "source_tables": ["product"], "pred_sql": "SELECT max_page_size, COUNT(*) as count\nFROM product\nGROUP BY max_page_size\nORDER BY count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\"\n}\n"}
{"sample_id": "train.4938", "db_id": "store_product", "question": "Find the name of the products that are not using the most frequently-used max page size.", "rationale": ["Identify the relevant table: The 'product' table contains the product names and their maximum page sizes.", "Determine the most frequently-used max page size: This can be done by grouping the products by 'max_page_size' and counting the occurrences, then ordering by count in descending order to get the most common one.", "Select products that do not match this max page size: Use a WHERE clause to filter out products that have the most frequently-used max page size."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "pred_sql": "SELECT product.product \nFROM product \nWHERE product.max_page_size != (SELECT max_page_size \n                                  FROM product \n                                  GROUP BY max_page_size \n                                  ORDER BY COUNT(*) DESC \n                                  LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\"\n}\n"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["Identify the table needed: The 'College' table contains the enrollment numbers and college names.", "Determine the required calculation: We need to calculate the average enrollment number for each college.", "Use the AVG() function to compute the average of the 'enr' column.", "Group the results by 'cName' to get the average enrollment for each college."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "pred_sql": "SELECT AVG(enr) AS average_enrollment, cName FROM College GROUP BY cName;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\"\n}\n"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["The question asks for the average training hours of players.", "To find this, we need to calculate the average of a specific column that represents training hours.", "The hint suggests using a virtual table that calculates averages based on decisions made during tryouts.", "We will join the Player and Tryout tables on the player ID (pID) to access the relevant data.", "We will filter the results based on the decision made regarding the player's tryout, which is assumed to be 'accepted' for this query.", "Finally, we will use the AVG() function to calculate the average training hours from the relevant records."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_training_hours FROM Player JOIN Tryout ON Player.pID = Tryout.pID WHERE decision = 'accepted';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4956", "db_id": "soccer_2", "question": "Find the name and training hours of players whose hours are below 1500.", "rationale": ["Identify the relevant table: The 'Player' table contains the names of players.", "Determine the columns needed: We need the 'pName' for the player's name and 'training_hours' for the hours they have trained.", "Apply the condition: We want players whose training hours are below 1500, so we will use a WHERE clause to filter those records.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "pred_sql": "SELECT pName, training_hours FROM Player WHERE training_hours < 1500;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\"\n}\n"}
{"sample_id": "train.4961", "db_id": "soccer_2", "question": "What are the different types of player positions?", "rationale": ["The question asks for the different types of player positions.", "To find the different types of player positions, we need to select the 'pPos' column from the 'Tryout' table.", "Using 'DISTINCT' will ensure that we only get unique player positions without duplicates."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT pPos FROM Tryout;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\"\n}\n"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["Identify the relevant table: The 'Tryout' table contains the information about players and their decisions after tryouts.", "Determine the specific information needed: We need to count how many students were accepted after the tryout.", "Use the COUNT() function to count the number of records where the decision is 'accepted'.", "Construct the SQL query to select the count from the 'Tryout' table with the appropriate WHERE clause."], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) AS accepted_students\nFROM Tryout\nWHERE decision = 'accepted';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\"\n}\n"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["Identify the relevant table: The 'Player' table contains information about players, but it does not have a column for training hours. Therefore, we need to assume that training hours are either part of the 'Tryout' table or need to be calculated based on some other criteria.", "Since the hint mentions a virtual table that calculates average and maximum based on decisions, we can infer that we might need to filter players based on their tryout decisions.", "However, the original question does not specify any decision criteria, so we will consider all players regardless of their tryout decision.", "We will select the maximum, average, and minimum of the training hours, assuming that there is a column for training hours in the relevant table. If not, we would need to adjust the query accordingly."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT MAX(training_hours) AS max_training_hours, AVG(training_hours) AS avg_training_hours, MIN(training_hours) AS min_training_hours FROM Player;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4967", "db_id": "soccer_2", "question": "What is the average, maximum, and minimum for the number of hours spent training?", "rationale": ["Identify the relevant tables: The question pertains to training hours, which suggests a need for a table that records training data, although it is not explicitly mentioned in the schema provided.", "The hint mentions a virtual table that calculates averages and maximums based on decisions made in tryouts, indicating that we may need to filter based on the decision column in the Tryout table.", "Since the question asks for average, maximum, and minimum values, we will use aggregate functions: AVG(), MAX(), and MIN().", "The output should include these aggregate values, and we will assume a hypothetical 'training_hours' column exists in a related table, as it is not defined in the provided schema.", "The final SQL query will select the average, maximum, and minimum training hours from the relevant table, filtered by a specific decision."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_training_hours, MAX(training_hours) AS max_training_hours, MIN(training_hours) AS min_training_hours FROM Training WHERE decision = 'specific_decision';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4970", "db_id": "soccer_2", "question": "What are the names of players whose training hours is between 500 and 1500?", "rationale": ["Identify the relevant tables: Player and Tryout.", "The question asks for player names, so we will select from the Player table.", "We need to filter players based on their training hours, which suggests a need for a virtual table that tracks training hours.", "The hint mentions a virtual table that provides information about players who participated in tryouts and received a decision, which we can use to filter players.", "We will use a subquery to find players who have a decision in the Tryout table, ensuring they participated in tryouts.", "We will also need to filter players based on their training hours being between 500 and 1500, which will be done in another subquery.", "Combine the results to get the names of players who meet both criteria."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE decision IS NOT NULL) AND pID IN (SELECT pID FROM Training WHERE hours BETWEEN 500 AND 1500);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4971", "db_id": "soccer_2", "question": "What are the names of players who train between 500 and 1500 hours?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find players who have trained between 500 and 1500 hours.", "The hint suggests a virtual table that provides information about players who participated in tryouts and received a specific decision.", "Assuming we are interested in players who were accepted in tryouts, we filter the Tryout table for those with a decision of 'accepted'.", "Next, we need to filter players based on their training hours, which is not directly mentioned in the schema but can be assumed to be in a hypothetical Training table.", "We will use a subquery to find player IDs (pID) from the Training table where hours are between 500 and 1500.", "Finally, we select the names of players from the Player table whose IDs match the filtered IDs from the Training subquery."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE decision = 'accepted') AND pID IN (SELECT pID FROM Training WHERE hours BETWEEN 500 AND 1500);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4975", "db_id": "soccer_2", "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?", "rationale": ["Identify the relevant table: College.", "Determine the columns needed: cName and enr.", "Set the condition for enrollment: enr > 10000.", "Specify the state condition: state = 'Louisiana'.", "Combine these conditions in a SELECT statement to retrieve the desired data."], "gold_sql": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = 'LA'", "source_tables": ["college"], "pred_sql": "SELECT cName, enr FROM College WHERE enr > 10000 AND state = 'Louisiana';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\"\n}\n"}
{"sample_id": "train.4981", "db_id": "soccer_2", "question": "What are the name of the players who received a card in descending order of the hours of training?", "rationale": ["Identify the relevant table: The 'Player' table contains the names of the players and their eligibility year.", "Determine the required output: We need the names of the players who received a card, which corresponds to the 'pName' column.", "Sort the results: The output should be in descending order based on the 'yCard' column, which represents the year of the player's card or eligibility.", "Construct the SQL query: Use SELECT to get 'pName' from 'Player' and ORDER BY 'yCard' in descending order."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player ORDER BY yCard DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\"\n}\n"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["We need to find out which position is most popular among players in the tryout.", "To do this, we will count the occurrences of each position in the 'Tryout' table.", "We will use the COUNT function to count how many players are trying out for each position.", "We will group the results by the position (pPos) to get the count for each position.", "Finally, we will order the results in descending order based on the count and limit the results to 1 to get the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(pPos) AS position_count\nFROM Tryout\nGROUP BY pPos\nORDER BY position_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\"\n}\n"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["To find the most popular position at tryouts, we need to count how many players tried out for each position.", "We will use the 'Tryout' table, which contains the 'pPos' column representing the position players are trying out for.", "We will group the results by 'pPos' to aggregate the counts for each position.", "We will count the number of occurrences of each position using COUNT(*).", "To determine the most popular position, we will order the results in descending order based on the count of players for each position.", "Finally, we will limit the results to 1 to get only the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\"\n}\n"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["Identify the relevant table: The question pertains to players and their positions, so the 'Tryout' table is the most relevant.", "Determine the required information: We need to find the minimum hours played by students in different positions.", "Use the MIN() function: To find the minimum hours, we will use the MIN() aggregate function.", "Group by position: Since we want the minimum hours for each position, we will group the results by 'pPos'.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(hours) AS min_hours\nFROM Tryout\nGROUP BY pPos;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\"\n}\n"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["Identify the relevant tables: We need to find information about players and their practice times, which suggests a table that tracks practice sessions.", "Determine the necessary columns: We need the position (pPos) and the minimum practice time for each position.", "Group the results: To find the minimum practice time for each position, we will use the GROUP BY clause on the position column.", "Use the MIN function: We will apply the MIN function to the practice time column to get the minimum time for each position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(practice_time) AS min_practice_time\nFROM Practice\nGROUP BY pPos;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\"\n}\n"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["Identify the tables involved: Player and Tryout.", "We need to select the names of players, which is in the Player table under the column pName.", "The decision regarding the tryout is in the Tryout table under the column decision.", "We are only interested in players who received a 'yes' decision, so we will filter the results based on this condition.", "To get the names of the players who received a 'yes', we will perform a JOIN between the Player and Tryout tables on the pID column, which is the unique identifier for each player."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT Player.pName, Tryout.pPos \nFROM Player \nJOIN Tryout ON Player.pID = Tryout.pID \nWHERE Tryout.decision = 'yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\"\n}\n"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find the names of students (players) who successfully tried out for a specific position (striker).", "This requires a JOIN between the Player and Tryout tables on the pID column, which is the unique identifier for players.", "We filter the results where the decision in the Tryout table is 'successful' and the position (pPos) is 'striker'.", "Select the pName from the Player table as the final output."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT Player.pName \nFROM Player \nJOIN Tryout ON Player.pID = Tryout.pID \nWHERE Tryout.decision = 'successful' AND Tryout.pPos = 'striker';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\"\n}\n"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["Identify the requirement: We need to find the average number of hours spent practicing for students who got rejected.", "Understand the data structure: The 'Tryout' table contains the 'decision' column which indicates if a player was accepted or rejected.", "To find the average hours, we need to count the number of tryouts (which we assume represents hours of practice) for players who were rejected.", "We will group the results by player ID (pID) to get the total hours for each rejected player.", "Finally, we will calculate the average of these hours using the AVG() function."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT AVG(hours) AS average_hours FROM (SELECT pID, COUNT(*) AS hours FROM Tryout WHERE decision = 'rejected' GROUP BY pID) AS rejected_players;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.5018", "db_id": "soccer_2", "question": "Which college has any student who is a goalie and succeeded in the tryout.", "rationale": ["We need to find colleges that have students who are goalies and succeeded in their tryouts.", "To do this, we will join the College, Tryout, and Player tables based on their relationships.", "The Tryout table will be filtered to include only those records where the position (pPos) is 'goalie' and the decision is 'succeeded'.", "We will select distinct college names (cName) from the College table that meet these criteria."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT College.cName \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nJOIN Player ON Tryout.pID = Player.pID \nWHERE Tryout.pPos = 'goalie' AND Tryout.decision = 'succeeded';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\"\n}\n"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["We need to find the state and enrollment of colleges that have students accepted in the tryout decision.", "The relevant tables are College and Tryout, as we need information about colleges and the decisions made in tryouts.", "We will join the College table with the Tryout table on the common column cName.", "We are interested in the distinct states and enrollment numbers of colleges where the decision is 'accepted'.", "The final SQL query will select the distinct state and enrollment from the College table, joining it with the Tryout table and filtering for accepted decisions."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT College.state, College.enr \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.decision = 'accepted';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find the total enrollment of colleges where students were accepted during tryouts.", "Join the College table with the Tryout table on the college name (cName).", "Filter the results to include only those tryouts where the decision was 'accepted'.", "Group the results by the state of the colleges to get the total enrollment per state.", "Use SUM to calculate the total enrollment from the College table, converting the enrollment number to an integer for accurate summation."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT SUM(CAST(College.enr AS INTEGER)) AS total_enrollment, College.state \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.decision = 'accepted' \nGROUP BY College.state;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.5026", "db_id": "soccer_2", "question": "Find the names of schools that have some students playing in goalie and mid positions.", "rationale": ["We need to find the names of schools (colleges) that have students playing in specific positions: goalie and mid.", "To do this, we will use the College table and the Tryout table, as the Tryout table contains the positions players are trying out for and is linked to the College table by the college name.", "We will perform a JOIN operation between the College and Tryout tables on the college name (cName).", "We will filter the results using a WHERE clause to include only those records where the position (pPos) is either 'goalie' or 'mid'.", "Finally, we will use DISTINCT to ensure that we only get unique college names in the result."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT College.cName \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.pPos IN ('goalie', 'mid');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\"\n}\n"}
{"sample_id": "train.5028", "db_id": "soccer_2", "question": "Find the names of states that have some college students playing in goalie and mid positions.", "rationale": ["We need to find distinct states where colleges have students playing in specific positions (goalie and mid).", "To do this, we will join the College table with the Tryout table on the college name (cName).", "We will filter the results to include only those tryouts where the position (pPos) is either 'goalie' or 'mid'.", "Finally, we will select the distinct states from the College table that meet these criteria."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT College.state \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.pPos IN ('goalie', 'mid');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.5029", "db_id": "soccer_2", "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?", "rationale": ["We need to find distinct states where colleges have students playing in specific positions (goalie and mid-field).", "To do this, we will join the College, Tryout, and Player tables based on their relationships.", "The College table provides the state information, while the Tryout table links players to colleges and their positions.", "We will filter the results using a WHERE clause to include only those players who are trying out for the positions of 'goalie' and 'mid-field'.", "Finally, we will select distinct states to avoid duplicates in our results."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT College.state \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nJOIN Player ON Tryout.pID = Player.pID \nWHERE Tryout.pPos IN ('goalie', 'mid-field');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant tables: We need to look at the 'Tryout' table to find players' positions and the colleges they are associated with.", "We need to count distinct colleges, so we will use COUNT(DISTINCT cName).", "We are interested in players who are trying out for the 'goalie' and 'mid' positions, so we will use a WHERE clause to filter for these positions.", "The final SQL query will select the count of distinct college names from the Tryout table where the position is either 'goalie' or 'mid'."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(DISTINCT cName) AS school_count\nFROM Tryout\nWHERE pPos IN ('goalie', 'mid')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\"\n}\n"}
{"sample_id": "train.5037", "db_id": "soccer_2", "question": "What is the count of states with college students playing in the mid position but not as goalies?", "rationale": ["Identify the relevant tables: College, Player, and Tryout.", "We need to count distinct states, so we will use COUNT(DISTINCT College.state).", "We need to join the College table with the Tryout table on the college name (cName).", "We also need to join the Player table with the Tryout table on the player ID (pID).", "The condition specifies that we are interested in players trying out for the 'mid' position and not for 'goalie', so we will add a WHERE clause for these conditions."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')", "source_tables": ["tryout", "college"], "pred_sql": "SELECT COUNT(DISTINCT College.state) \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nJOIN Player ON Tryout.pID = Player.pID \nWHERE Tryout.pPos = 'mid' AND Tryout.decision != 'goalie';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["Identify the requirement: We need to find states with colleges that have enrollments less than some other college.", "Understand the schema: The 'College' table contains the columns 'cName', 'state', and 'enr'.", "Use a subquery to find the maximum enrollment number of colleges in each state.", "The main query will select distinct states from the 'College' table where the enrollment number is less than the maximum enrollment number found in the subquery."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE enr < (SELECT MAX(enr) FROM College WHERE state = College.state);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\"\n}\n"}
{"sample_id": "train.5102", "db_id": "cre_Drama_Workshop_Groups", "question": "Show the minimum, average, maximum order quantity of all invoices.", "rationale": ["Identify the relevant table: The 'Invoice_Items' table contains the 'Order_Quantity' column which we need to analyze.", "Determine the required calculations: We need to find the minimum, average, and maximum of the 'Order_Quantity'.", "Construct the SQL query: Use the aggregate functions MIN(), AVG(), and MAX() on the 'Order_Quantity' column from the 'Invoice_Items' table."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "pred_sql": "SELECT MIN(Order_Quantity) AS Min_Quantity, AVG(Order_Quantity) AS Avg_Quantity, MAX(Order_Quantity) AS Max_Quantity\nFROM Invoice_Items;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\"\n}\n"}
{"sample_id": "train.5118", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the payment method code used by the most orders?", "rationale": ["Identify the relevant table: Invoices contains the payment_method_code and Order_ID.", "Group the results by payment_method_code to count the number of orders associated with each payment method.", "Use COUNT(Order_ID) to count the number of orders for each payment method.", "Order the results in descending order to get the payment method with the most orders at the top.", "Limit the results to 1 to get only the payment method code used by the most orders."], "gold_sql": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices"], "pred_sql": "SELECT payment_method_code\nFROM Invoices\nGROUP BY payment_method_code\nORDER BY COUNT(Order_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5127", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the descriptions of the service types that cost more than 100.", "rationale": ["Identify the relevant table for service types, which is 'Ref_Service_Types'.", "Determine the column needed for the description of the service types, which is 'Service_Type_Description'.", "Identify the relationship between service types and their prices, which is found in the 'Services' table.", "Use a subquery to select 'Service_Type_Code' from the 'Services' table where 'Product_Price' is greater than 100.", "Combine the results of the subquery with the main query to filter the service type descriptions accordingly."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT Service_Type_Description FROM Ref_Service_Types WHERE Service_Type_Code IN (SELECT Service_Type_Code FROM Services WHERE Product_Price > 100)", "hint": "\n"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["Identify the relevant tables: We need to find workshop groups and services, so we will use the Drama_Workshop_Groups and Services tables.", "Determine the relationship: The Services table has a foreign key Workshop_Group_ID that links to the Drama_Workshop_Groups table.", "Filter the services: We need to filter the services to only those with the product name 'film'.", "Select the distinct workshop group names: We want the names of the workshop groups, so we will select Store_Name from the Drama_Workshop_Groups table and ensure we get distinct values."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "pred_sql": "SELECT DISTINCT dg.Store_Name\nFROM Drama_Workshop_Groups dg\nJOIN Services s ON dg.Workshop_Group_ID = s.Workshop_Group_ID\nWHERE s.Product_Name = 'film';", "hint": "\n"}
{"sample_id": "train.5142", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the order details of the products with price higher than 2000?", "rationale": ["Identify the relevant tables: Order_Items, Products, and Customer_Orders are needed to get order details and product prices.", "Join Order_Items with Products to access product prices using the Product_ID.", "Join Order_Items with Customer_Orders to get additional order details using the Order_ID.", "Filter the results to include only those products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_Items.Order_ID, Order_Items.Product_ID, Order_Items.Order_Quantity, Products.Product_Price, Customer_Orders.Other_Order_Details \nFROM Order_Items \nJOIN Products ON Order_Items.Product_ID = Products.Product_ID \nJOIN Customer_Orders ON Order_Items.Order_ID = Customer_Orders.Order_ID \nWHERE Products.Product_Price > 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\"\n}\n"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["Identify the relevant tables: We need to retrieve order details and product prices, so we will use the 'Order_Items' and 'Products' tables.", "Determine the columns needed: We need the order item ID, order ID, product ID, order quantity, and product price.", "Join the tables: We will join 'Order_Items' with 'Products' on the 'Product_ID' to access product prices.", "Apply the filter: We will filter the results to include only those products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT oi.Order_Item_ID, oi.Order_ID, oi.Product_ID, oi.Order_Quantity, p.Product_Price \nFROM Order_Items oi \nJOIN Products p ON oi.Product_ID = p.Product_ID \nWHERE p.Product_Price > 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\"\n}\n"}
{"sample_id": "train.5160", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the most frequent status of bookings?", "rationale": ["Identify the table that contains the booking status, which is the 'Bookings' table.", "To find the most frequent status, we need to count the occurrences of each 'Status_Code'.", "Use the COUNT function to count the number of bookings for each status code.", "Group the results by 'Status_Code' to aggregate the counts for each unique status.", "Order the results in descending order based on the frequency count to get the most frequent status at the top.", "Limit the results to 1 to get only the most frequent status."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Frequency\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most common status code, which implies counting occurrences of each status code.", "Use the COUNT function: We will count the number of bookings for each status code using COUNT(*) and group the results by 'Status_Code'.", "Sort the results: To find the most common status code, we will order the results in descending order based on the count.", "Limit the results: Since we only need the most common status code, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Count\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["Identify the relevant tables: We need information from the Drama_Workshop_Groups table for workshop group names and the Bookings table for booking status.", "Determine the relationship: The Drama_Workshop_Groups table is linked to the Bookings table through the Workshop_Group_ID.", "Filter the results: We want only those bookings that have a status code of 'stop'.", "Select the distinct store names from the Drama_Workshop_Groups table that match the filtered bookings."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "pred_sql": "SELECT DISTINCT d.Store_Name\nFROM Drama_Workshop_Groups d\nJOIN Bookings b ON d.Workshop_Group_ID = b.Workshop_Group_ID\nWHERE b.Status_Code = 'stop';", "hint": "\n"}
{"sample_id": "train.5171", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the description of the service type that offers not only the photo product but also the film product.", "rationale": ["Identify the relevant tables: Ref_Service_Types for service descriptions, Services for linking service types to products, and Order_Items for product details.", "Join Ref_Service_Types with Services on Service_Type_Code to get the service descriptions associated with each service.", "Join Services with Order_Items to link services to the products they offer.", "Use a subquery to filter products to only those that are 'photo' and 'film'.", "Group the results by Service_Type_Description to aggregate services that offer both products.", "Use HAVING clause to ensure that only service types offering both products are included, which means counting distinct Product_IDs should equal 2."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT DISTINCT rst.Service_Type_Description\nFROM Ref_Service_Types rst\nJOIN Services s ON rst.Service_Type_Code = s.Service_Type_Code\nJOIN Order_Items oi ON s.Product_ID = oi.Product_ID\nWHERE oi.Product_ID IN (\n    SELECT Product_ID\n    FROM Products\n    WHERE Product_Name IN ('photo', 'film')\n)\nGROUP BY rst.Service_Type_Description\nHAVING COUNT(DISTINCT oi.Product_ID) = 2;", "hint": "\n"}
{"sample_id": "train.5459", "db_id": "voter_2", "question": "Find the average age of female students.", "rationale": ["Identify the table needed: The 'Student' table contains the age and gender information.", "Determine the condition: We need to filter for female students, so we will use the condition 'Sex = 'Female' '.", "Calculate the average: We will use the AVG() function to calculate the average age of the filtered students.", "Construct the SQL query: Combine the SELECT statement with the AVG function and the WHERE clause to filter by gender."], "gold_sql": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  'F'", "source_tables": ["student"], "pred_sql": "SELECT AVG(Age) AS Average_Age FROM Student WHERE Sex = 'Female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\"\n}\n"}
{"sample_id": "train.5466", "db_id": "voter_2", "question": "What are the distinct president votes on 08/30/2015?", "rationale": ["Identify the relevant table: Voting_record, which contains the voting information.", "Determine the specific column needed: President_Vote, which records the votes for the presidential candidate.", "Filter the records based on the date of voting: Registration_Date should match '2015-08-30'.", "Use the DISTINCT keyword to ensure that only unique president votes are returned."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote FROM Voting_record WHERE Registration_Date = '2015-08-30';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["The query needs to select distinct president votes from the Voting_record table.", "We will use the SELECT DISTINCT statement to ensure that we only get unique votes.", "The WHERE clause will filter the records to only include those with a Registration_Date of '2015-08-30'.", "The date format used in SQLite is 'YYYY-MM-DD', so we format the date accordingly."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote \nFROM Voting_record \nWHERE Registration_Date = '2015-08-30';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5476", "db_id": "voter_2", "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.", "rationale": ["Identify the relevant tables: Student and Voting_record.", "We need to find distinct ages, so we will use SELECT DISTINCT on the Age column from the Student table.", "We need to join the Student table with the Voting_record table on the StuID column to access voting records for each student.", "We need to filter the results to include only those students who have cast a vote for the secretary candidate, which means checking if Secretary_Vote is not null.", "Additionally, we need to filter the results to include only those records from the fall election cycle, which is specified in the WHERE clause."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Student.Age \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Voting_record.Secretary_Vote IS NOT NULL \nAND Voting_record.Election_Cycle = 'fall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["Identify the relevant tables: We need to look at the Student table for advisors and the Voting_record table for voting information.", "Determine the relationship: The Student table is linked to the Voting_record table through the StuID and the Treasurer_Vote column.", "Select the necessary fields: We want to retrieve the Advisor from the Student table.", "Apply filtering criteria: We need to filter the records to only include those from the spring election cycle.", "Use DISTINCT to ensure we only get unique advisors."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Advisor FROM Student INNER JOIN Voting_record ON Student.StuID = Voting_record.Treasurer_Vote WHERE Voting_record.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5486", "db_id": "voter_2", "question": "How many male (sex is M) students have class senator votes in the fall election cycle?", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "Determine the condition for counting students: they must be male (Sex = 'M') and have class senator votes in the fall election cycle.", "Join the 'Student' table with the 'Voting_record' table on the StuID column to link students with their voting records.", "Use the COUNT function to count the number of male students who meet the criteria.", "Specify the conditions in the WHERE clause to filter by gender and election cycle."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT COUNT(*) FROM Student s JOIN Voting_record v ON s.StuID = v.StuID WHERE s.Sex = 'M' AND v.Election_Cycle = 'fall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of students from the 'Student' table who are registered to vote in a specific election cycle and belong to a particular gender. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "Determine the columns needed: average age from 'Student' and filter conditions from 'Voting_record'.", "Join the 'Student' table with the 'Voting_record' table on 'StuID'.", "Apply the WHERE clause to filter students by city code 'NYC' and ensure they have voted for the secretary candidate in the spring election cycle.", "Use the AVG() function to calculate the average age of the filtered students."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(Age) AS Average_Age\nFROM Student\nJOIN Voting_record ON Student.StuID = Voting_record.StuID\nWHERE Student.city_code = 'NYC' AND Voting_record.Secretary_Vote IS NOT NULL AND Voting_record.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5492", "db_id": "voter_2", "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "We need to calculate the average age, so we will use the AVG() function on the 'Age' column from the 'Student' table.", "We need to filter for female students, so we will add a WHERE clause to check if 'Sex' is 'F'.", "We also need to ensure that these students have voted for the secretary candidate, which means we will check if 'Secretary_Vote' is not null in the 'Voting_record' table.", "Finally, we need to specify the election cycle as 'spring', so we will add another condition in the WHERE clause for 'Election_Cycle'.", "Join the 'Student' and 'Voting_record' tables on 'StuID' to combine the relevant data."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(Age) AS Average_Age\nFROM Student\nJOIN Voting_record ON Student.StuID = Voting_record.StuID\nWHERE Student.Sex = 'F' AND Voting_record.Secretary_Vote IS NOT NULL AND Voting_record.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["We need to find distinct first names of students who voted for the vice president.", "To do this, we will join the Student table with the Voting_record table on the StuID column, which is the unique identifier for students.", "We will filter the results to include only those records where the Vice_President_Vote is not null, indicating that the student has cast a vote for vice president.", "Additionally, we will filter out students whose city code is 'PIT' by using the condition S.city_code != 'PIT'.", "Finally, we will select distinct first names (Fname) from the resulting dataset."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Fname \nFROM Student S \nJOIN Voting_record V ON S.StuID = V.StuID \nWHERE V.Vice_President_Vote IS NOT NULL \nAND S.city_code != 'PIT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5495", "db_id": "voter_2", "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?", "rationale": ["We need to find distinct first names of students who voted for the vice president.", "To do this, we will join the Student table with the Voting_record table on the StuID column, which is the unique identifier for students in both tables.", "We will filter the results to include only those records where the Vice_President_Vote is not null, indicating that the student has cast a vote for vice president.", "Additionally, we will filter out students who reside in a city with the city code 'PIT' by adding a condition that city_code should not equal 'PIT'.", "Finally, we will select the distinct first names (Fname) from the resulting dataset."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Fname FROM Student JOIN Voting_record ON Student.StuID = Voting_record.StuID WHERE Vice_President_Vote IS NOT NULL AND city_code != 'PIT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5496", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is not 2192.", "rationale": ["We need to find distinct last names of students who voted for president.", "This requires joining the Student table with the Voting_record table on the StuID column, as this is the common identifier.", "We will filter the results to include only those records where the President_Vote is not null, indicating that the student voted for president.", "Additionally, we need to ensure that the Advisor is not equal to '2192'.", "Finally, we will select distinct last names (LName) from the resulting dataset."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student JOIN Voting_record ON Student.StuID = Voting_record.StuID WHERE President_Vote IS NOT NULL AND Advisor != '2192';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5499", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes and have 8741 as the advisor?", "rationale": ["Identify the requirement to find distinct last names of students.", "The condition specifies that the students must have voted for a president, which relates to the Voting_record table.", "We need to filter students based on their advisor, which is a column in the Student table.", "The query will involve a subquery to check if the student's ID is present in the President_Vote column of the Voting_record table.", "Combine the conditions to form the final SQL query."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student WHERE Advisor = '8741' AND StuID IN (SELECT President_Vote FROM Voting_record)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["We need to find the most common major among female students, so we will focus on the 'Student' table.", "We will filter the records to include only those where the 'Sex' column is 'F'.", "Next, we will group the results by the 'Major' column to count how many female students are in each major.", "To find the most common major, we will count the number of students in each major using COUNT(*) and alias it as 'MajorCount'.", "We will order the results in descending order based on 'MajorCount' to get the major with the highest count at the top.", "Finally, we will limit the results to 1 to get only the most common major."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as MajorCount \nFROM Student \nWHERE Sex = 'F' \nGROUP BY Major \nORDER BY MajorCount DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major field of study. The results are ordered by the number of students in each major in descending order, with a limit on the number of majors returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["We need to find the major studied by the most female students.", "To do this, we will filter the 'Student' table for female students by using the condition 'Sex = 'Female'.", "Next, we will group the results by the 'Major' column to count how many female students are in each major.", "We will then order the results in descending order based on the count of students in each major using 'ORDER BY COUNT(*) DESC'.", "Finally, we will limit the results to just one major using 'LIMIT 1' to get the major with the highest count."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student WHERE Sex = 'Female' GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major field of study. The results are ordered by the number of students in each major in descending order, with a limit on the number of majors returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to count the number of products, so we will use the COUNT() function.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to filter by category.", "Add a WHERE clause to filter for products in the 'Spices' category.", "Add another condition in the WHERE clause to filter for products with a typical selling price greater than 1000."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT COUNT(*) AS product_count \nFROM Products \nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code \nWHERE Ref_Product_Categories.product_category_description = 'Spices' \nAND Products.typical_selling_price > 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to retrieve product category descriptions, so we will select from Ref_Product_Categories.", "Join the Products table with Ref_Product_Categories on the product_category_code to link products to their categories.", "Filter the products based on their descriptions containing the letter 't' using the LIKE operator.", "Use DISTINCT to ensure that we only get unique product category descriptions."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description \nFROM Products p \nJOIN Ref_Product_Categories rpc ON p.product_category_code = rpc.product_category_code \nWHERE p.product_description LIKE '%t%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["Identify the product 'cumin' in the Products table.", "Join the Products table with the Product_Characteristics table to link products with their characteristics.", "Join the Product_Characteristics table with the Characteristics table to access the characteristic names.", "Count the distinct characteristic names associated with the product 'cumin' using COUNT(DISTINCT ...).", "Construct the SQL query to retrieve the count of distinct characteristic names for the specified product."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT Characteristics.characteristic_name) AS distinct_characteristic_count\nFROM Products\nJOIN Product_Characteristics ON Products.product_id = Product_Characteristics.product_id\nJOIN Characteristics ON Product_Characteristics.characteristic_id = Characteristics.characteristic_id\nWHERE Products.product_name = 'cumin';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["Identify the tables involved: Products, Ref_Colors, Product_Characteristics, and Characteristics.", "Determine the relationships between these tables using foreign keys: Products to Ref_Colors via color_code, Products to Product_Characteristics via product_id, and Product_Characteristics to Characteristics via characteristic_id.", "Use a LEFT JOIN to include all products, even if they don't have a matching color or characteristic.", "Filter the results in the WHERE clause to count products that are either 'white' in color or have a characteristic named 'hot'.", "Use COUNT(DISTINCT p.product_id) to ensure that each product is only counted once, regardless of how many characteristics it has or if it matches the color condition."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT p.product_id) \nFROM Products p \nLEFT JOIN Ref_Colors c ON p.color_code = c.color_code \nLEFT JOIN Product_Characteristics pc ON p.product_id = pc.product_id \nLEFT JOIN Characteristics ch ON pc.characteristic_id = ch.characteristic_id \nWHERE c.color_description = 'white' OR ch.characteristic_name = 'hot';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\"\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: We need to find the unit of measure for 'Herb' products, which involves the Products and Ref_Product_Categories tables.", "Join the Products table with Ref_Product_Categories to access the unit of measure associated with each product category.", "Join the Product_Characteristics table to link products with their characteristics.", "Join the Characteristics table to filter for the specific characteristic name 'Herb'.", "Select the unit_of_measure from the Ref_Product_Categories table where the characteristic name matches 'Herb'."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT pc.unit_of_measure \nFROM Ref_Product_Categories rpc \nJOIN Products p ON rpc.product_category_code = p.product_category_code \nJOIN Product_Characteristics pc ON p.product_id = pc.product_id \nJOIN Characteristics c ON pc.characteristic_id = c.characteristic_id \nWHERE c.characteristic_name = 'Herb';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the columns needed: unit_of_measure from Ref_Product_Categories and product_category_code from Products.", "Establish the relationship between the tables using the foreign key: Products.product_category_code = Ref_Product_Categories.product_category_code.", "Filter the results to only include the product named 'chervil'.", "Construct the SQL SELECT statement to retrieve the desired columns."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT pc.product_category_code, p.product_name, p.unit_of_measure \nFROM Products p \nJOIN Ref_Product_Categories pc ON p.product_category_code = pc.product_category_code \nWHERE p.product_name = 'chervil';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["We need to find the description of the color for the most products.", "To do this, we will join the 'Products' table with the 'Ref_Colors' table on the 'color_code'.", "We will group the results by 'color_code' to count how many products are associated with each color.", "Next, we will order the results by the count of products in descending order to get the color with the most products at the top.", "Finally, we will limit the results to 1 to get only the top color description."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT rc.color_description\nFROM Products p\nJOIN Ref_Colors rc ON p.color_code = rc.color_code\nGROUP BY p.color_code\nORDER BY COUNT(p.product_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\"\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["We need to find the description of the color used by the least number of products.", "To do this, we will join the 'Ref_Colors' table with the 'Products' table on the 'color_code'.", "Next, we will group the results by 'color_code' to count how many products are associated with each color.", "We will order the results in ascending order based on the count of products, so that the color with the least products comes first.", "Finally, we will limit the results to 1 to get only the color description used by the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT rc.color_description\nFROM Ref_Colors rc\nJOIN Products p ON rc.color_code = p.color_code\nGROUP BY rc.color_code\nORDER BY COUNT(p.product_id) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\"\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find characteristics that are associated with two or more products.", "To do this, we will join the 'Characteristics' table with the 'Product_Characteristics' table to link characteristics to products.", "Next, we will join the 'Products' table to get the product information associated with each characteristic.", "We will group the results by the characteristic name to count how many distinct products each characteristic is associated with.", "Finally, we will use the HAVING clause to filter the results to only include characteristics that are linked to two or more distinct products."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT c.characteristic_name\nFROM Characteristics c\nJOIN Product_Characteristics pc ON c.characteristic_id = pc.characteristic_id\nJOIN Products p ON pc.product_id = p.product_id\nGROUP BY c.characteristic_name\nHAVING COUNT(DISTINCT p.product_id) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\"\n}\n"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to query.", "Select the 'Builder' column: We want to list the builders, so we will select this column.", "Use DISTINCT to avoid duplicate entries: Since multiple railways can have the same builder, we will use DISTINCT to ensure each builder is listed only once.", "Order the results: We need the results in ascending alphabetical order, so we will use ORDER BY Builder ASC.", "Construct the SQL query: Combine all these elements into a complete SQL query."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "pred_sql": "SELECT DISTINCT Builder FROM railway ORDER BY Builder ASC;", "hint": "\n"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["Identify the relevant tables: railway and train.", "We need to find the railway associated with the most trains, so we will join the railway table with the train table on the Railway_ID.", "We will group the results by Railway_ID and Builder to count the number of trains associated with each railway.", "Use COUNT(train.Train_ID) to count the number of trains for each railway.", "Order the results in descending order based on the count of trains to get the railway with the most trains at the top.", "Limit the results to 1 to get only the railway associated with the most trains."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "pred_sql": "SELECT railway.Railway_ID, railway.Builder\nFROM railway\nJOIN train ON railway.Railway_ID = train.Railway_ID\nGROUP BY railway.Railway_ID, railway.Builder\nORDER BY COUNT(train.Train_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["We need to find the most common builder of railways, which means we need to count how many railways each builder has constructed.", "To do this, we will select the 'Builder' column from the 'railway' table and count the occurrences of each builder using COUNT(*).", "We will group the results by 'Builder' to aggregate the counts for each builder.", "Next, we will order the results in descending order based on the count of railways built by each builder, so that the most common builder appears first.", "Finally, we will limit the results to just one entry to get the most common builder."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "pred_sql": "SELECT Builder, COUNT(*) as BuilderCount \nFROM railway \nGROUP BY Builder \nORDER BY BuilderCount DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["Identify the table to query: The relevant table is 'Student' as we need student information.", "Determine the columns needed: We need the 'LName' column for the last names of the students.", "Define the conditions for selection: We need students who are either female, live in a city with the code 'BAL', or are male and under 20 years old.", "Construct the SQL query using the SELECT statement with the identified conditions in the WHERE clause."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "pred_sql": "SELECT LName FROM Student WHERE (Sex = 'Female') OR (city_code = 'BAL') OR (Sex = 'Male' AND Age < '20');", "hint": "\n"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["Identify the relevant tables: Dorm and Has_amenity.", "We need to count the number of amenities for each dormitory, so we will use COUNT() function on the amenid from Has_amenity table.", "We need to filter dormitories that can accommodate more than 100 students, which is done using the WHERE clause on the student_capacity column in the Dorm table.", "To get the names of the dorms along with the count of amenities, we will select Dorm.dorm_name and the count of amenities.", "We will join the Dorm table with the Has_amenity table on the dormid to link dormitories with their amenities.", "Finally, we will group the results by Dorm.dormid and Dorm.dorm_name to get the count of amenities for each dorm."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "pred_sql": "SELECT Dorm.dorm_name, COUNT(Has_amenity.amenid) AS amenity_count\nFROM Dorm\nJOIN Has_amenity ON Dorm.dormid = Has_amenity.dormid\nWHERE Dorm.student_capacity > 100\nGROUP BY Dorm.dormid, Dorm.dorm_name;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\"\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables needed: We need to count students, so we will use the 'Student' table and the 'Lives_in' table to find out where students live.", "Join the 'Student' table with the 'Lives_in' table on the student ID to get the dormitory information for each student.", "Next, we need to join the 'Dorm' table to filter the dormitories based on their gender designation.", "We are specifically interested in male dormitories, so we will add a WHERE clause to filter for dorms where the gender is 'male'.", "Finally, we will use COUNT(DISTINCT s.StuID) to count the unique students living in male dorms."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(DISTINCT s.StuID) AS total_students\nFROM Student s\nJOIN Lives_in l ON s.StuID = l.stuid\nJOIN Dorm d ON l.dormid = d.dormid\nWHERE d.gender = 'male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\"\n}\n"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["Identify the tables involved: Student, Lives_in, and Has_amenity.", "We need to find students' first names, so we will select the Fname column from the Student table.", "Students live in dorms, so we will join the Student table with the Lives_in table on the StuID and stuid columns.", "To find the dorm with the most amenities, we will create a subquery that counts the amenities for each dorm in the Has_amenity table.", "The subquery will group by dormid and order the results by the count of amenities in descending order, limiting the results to the top one dorm.", "Finally, we will join the result of the subquery with the Lives_in table to filter students living in the dorm with the most amenities."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT S.Fname \nFROM Student S \nJOIN Lives_in L ON S.StuID = L.stuid \nJOIN ( \n    SELECT H.dormid \n    FROM Has_amenity H \n    GROUP BY H.dormid \n    ORDER BY COUNT(H.amenid) DESC \n    LIMIT 1 \n) AS MostAmenities ON L.dormid = MostAmenities.dormid;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\"\n}\n"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["Identify the required fields: first name and age of students.", "Determine the tables involved: Student, Lives_in, Dorm, Has_amenity, and Dorm_amenity.", "Establish relationships between the tables using JOINs:", "- Join Student with Lives_in on StuID to get students' dorm information.", "- Join Lives_in with Dorm on dormid to access dorm details.", "- Join Dorm with Has_amenity to find amenities associated with each dorm.", "- Join Has_amenity with Dorm_amenity to filter for specific amenities, in this case, 'TV Lounge'.", "Add a WHERE clause to filter results to only include dorms that have a 'TV Lounge'."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "pred_sql": "SELECT Student.Fname, Student.Age \nFROM Student \nJOIN Lives_in ON Student.StuID = Lives_in.stuid \nJOIN Dorm ON Lives_in.dormid = Dorm.dormid \nJOIN Has_amenity ON Dorm.dormid = Has_amenity.dormid \nJOIN Dorm_amenity ON Has_amenity.amenid = Dorm_amenity.amenid \nWHERE Dorm_amenity.amenity_name = 'TV Lounge';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\"\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the relevant tables: Customers and Complaints.", "We need to find the email addresses of customers who have filed complaints, so we will join the Customers table with the Complaints table on the customer_id.", "To find the product with the greatest number of complaints, we will use a subquery that counts the number of complaints for each product and orders them in descending order, limiting the result to the top product.", "The main query will select the email addresses from the Customers table where the product_id matches the product_id from the subquery."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address\nFROM Customers c\nJOIN Complaints comp ON c.customer_id = comp.customer_id\nWHERE comp.product_id = (\n    SELECT product_id\n    FROM Complaints\n    GROUP BY product_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["Identify the products that have been complained about by customers.", "Join the Products table with the Complaints table on product_id to get the relevant product information for each complaint.", "To find the customer who has filed the least amount of complaints, we need to group the Complaints by customer_id and count the number of complaints for each customer.", "Order the grouped results by the count of complaints in ascending order to get the customer with the least complaints at the top.", "Limit the results to just one customer to get the customer with the least complaints.", "Use a subquery to find the customer_id of the customer with the least complaints and use it in the WHERE clause to filter the products."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT p.product_id, p.product_name \nFROM Products p \nJOIN Complaints c ON p.product_id = c.product_id \nWHERE c.customer_id = (\n    SELECT customer_id \n    FROM Complaints \n    GROUP BY customer_id \n    ORDER BY COUNT(complaint_id) ASC \n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the relevant tables: Complaints, Products, and Staff.", "We need to find the product with the lowest price, so we will use a subquery to get the minimum product price from the Products table.", "Next, we need to join the Complaints table with the Products table to link complaints to their respective products.", "We also need to join the Complaints table with the Staff table to find out which staff member is handling the complaint.", "Finally, we will select the last name of the staff member where the product price matches the lowest price found in the subquery."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT Staff.last_name \nFROM Complaints \nJOIN Products ON Complaints.product_id = Products.product_id \nJOIN Staff ON Complaints.staff_id = Staff.staff_id \nWHERE Products.product_price = (SELECT MIN(product_price) FROM Products);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["Identify the relevant table: The Complaints table contains the complaint status information.", "Determine the required fields: We need the complaint status code and the count of records for each status.", "Group the results: Use GROUP BY to aggregate the records by complaint status code.", "Filter the results: Use HAVING to filter out groups with a count of 3 or fewer records."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "pred_sql": "SELECT complaint_status_code, COUNT(*) as complaint_count \nFROM Complaints \nGROUP BY complaint_status_code \nHAVING COUNT(*) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["Identify the need to count customers based on their type.", "Use the Customers table to access customer_type_code and customer_id.", "Group the results by customer_type_code to get the count of customers for each type.", "Order the results in descending order based on the count of customers to find the most common type.", "Limit the results to 1 to get only the most common customer type."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT customer_type_code, COUNT(customer_id) AS customer_count \nFROM Customers \nGROUP BY customer_type_code \nORDER BY customer_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.\"\n}\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to find the first names of staff members, so we will select the 'first_name' column from the Staff table.", "To determine how many complaints each staff member has handled, we will join the Staff table with the Complaints table on the staff_id column.", "We will group the results by staff_id to aggregate the number of complaints handled by each staff member.", "We will order the results in descending order based on the count of complaints to get the top staff members who handled the most complaints.", "Finally, we will limit the results to the top 5 staff members."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name FROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nGROUP BY Staff.staff_id \nORDER BY COUNT(Complaints.complaint_id) DESC \nLIMIT 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["We need to return the first names of staff members who have handled the most complaints.", "To find out which staff members handled the most complaints, we will use the Complaints table and group the results by staff_id.", "We will count the number of complaints for each staff member using COUNT(complaint_id).", "Next, we will order the results in descending order to get the staff members with the most complaints at the top.", "Finally, we will limit the results to the top 5 staff members using LIMIT 5.", "We will then select the first names of these staff members from the Staff table using a subquery that retrieves the staff_ids of the top 5 staff members."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Complaints GROUP BY staff_id ORDER BY COUNT(complaint_id) DESC LIMIT 5);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The user wants to see all investor details, which means we need to select all columns from the Investors table.", "The SQL query to retrieve all columns from a table is 'SELECT * FROM table_name'.", "In this case, the table name is 'Investors', so the query becomes 'SELECT * FROM Investors'."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "pred_sql": "SELECT * FROM Investors;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\"\n}\n"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["We need to show details of all investors who have made transactions with a share count greater than 100.", "To do this, we will select the investor_id and Investor_details from the Investors table.", "We will join the Investors table with the Transactions table on the investor_id to link investors with their transactions.", "We will apply a WHERE clause to filter transactions where the share_count is greater than 100.", "Using DISTINCT ensures that we do not have duplicate investor entries in the result."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "pred_sql": "SELECT DISTINCT Investors.investor_id, Investors.Investor_details \nFROM Investors \nJOIN Transactions ON Investors.investor_id = Transactions.investor_id \nWHERE Transactions.share_count > 100;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\"\n}\n"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["Identify the relevant tables: Lots, Transactions, and Transactions_Lots.", "Determine the relationship between these tables: Lots are linked to Transactions through Transactions_Lots.", "We need to select the lot details from the Lots table.", "Apply a filter to the Transactions table to only include those with a share count smaller than 50.", "Construct the SQL query using JOINs to connect the tables and apply the WHERE clause for the share count condition."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT Lots.lot_details \nFROM Lots \nJOIN Transactions_Lots ON Lots.lot_id = Transactions_Lots.lot_id \nJOIN Transactions ON Transactions_Lots.transaction_id = Transactions.transaction_id \nWHERE Transactions.share_count < 50;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\"\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["Identify the relevant tables: Transactions and Ref_Transaction_Types are needed to get transaction amounts and their types.", "We need to calculate the average transaction amount, so we will use the AVG() function on the amount_of_transaction column from the Transactions table.", "To associate each transaction with its type, we will join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code.", "We will group the results by transaction_type_description to get the average for each type.", "Finally, we will select the transaction type description and the calculated average amount in the final output."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\"\n}\n"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["Identify the relevant tables: Transactions and Ref_Transaction_Types.", "We need to group the results by transaction type, which is found in the Ref_Transaction_Types table.", "We want to calculate the maximum and minimum share counts for each transaction type, which are found in the Transactions table.", "Join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to get the transaction descriptions.", "Use the MAX() and MIN() functions to get the maximum and minimum share counts respectively.", "Group the results by the transaction type description to get the desired output."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, MAX(t.share_count) AS max_share_count, MIN(t.share_count) AS min_share_count\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\"\n}\n"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["We need to retrieve details of all sales and purchases, which are stored in the Sales and Purchases tables respectively.", "To get the details from both tables, we will use a SQL JOIN operation.", "Since a transaction can be either a sale or a purchase, we will use a LEFT JOIN to ensure we get all sales and any corresponding purchases.", "We will join the Sales table with the Transactions table on the transaction_id to link sales to their respective transactions.", "We will also join the Purchases table with the Transactions table on the purchase_transaction_id to link purchases to their respective transactions."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "pred_sql": "SELECT Sales.sales_transaction_id, Sales.sales_details, Purchases.purchase_transaction_id, Purchases.purchase_details\nFROM Sales\nLEFT JOIN Transactions ON Sales.sales_transaction_id = Transactions.transaction_id\nLEFT JOIN Purchases ON Transactions.transaction_id = Purchases.purchase_transaction_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\"\n}\n"}
{"sample_id": "train.5898", "db_id": "cre_Theme_park", "question": "What is the average price range of five star hotels that allow pets?", "rationale": ["Identify the table needed: The 'Hotels' table contains the relevant information about hotel star ratings and pet policies.", "Determine the criteria: We need to filter for five-star hotels (star_rating_code = '5') and those that allow pets (pets_allowed_yn = 'Yes').", "Calculate the average price range: Use the AVG() function to compute the average of the price_range column for the filtered hotels."], "gold_sql": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  '5' AND pets_allowed_yn  =  1", "source_tables": ["hotels"], "pred_sql": "SELECT AVG(price_range) AS average_price_range \nFROM Hotels \nWHERE star_rating_code = '5' AND pets_allowed_yn = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average price range of hotels from the 'Hotels' table that meet specific criteria. The placeholders in the WHERE clause represent the star rating code and whether pets are allowed, allowing users to specify their desired conditions.\"\n}\n"}
{"sample_id": "train.5904", "db_id": "cre_Theme_park", "question": "Find all the locations whose names contain the word \"film\".", "rationale": ["Identify the table that contains location names: Locations.", "Determine the column that holds the names of the locations: Location_Name.", "Use the SQL SELECT statement to retrieve all columns from the Locations table.", "Apply a WHERE clause to filter the results where Location_Name contains the word 'film'.", "Use the LIKE operator with wildcards '%' to match any location names that include 'film'."], "gold_sql": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE '%film%'", "source_tables": ["locations"], "pred_sql": "SELECT * FROM Locations WHERE Location_Name LIKE '%film%';", "hint": "\n"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["Identify the relevant table: Museums, which contains details about museums and their opening hours.", "Select the columns needed: Museum_ID, Museum_Details, and Opening_Hours.", "Construct the SQL query to retrieve these columns from the Museums table."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT Museum_ID, Museum_Details, Opening_Hours FROM Museums", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\"\n}\n"}
{"sample_id": "train.5916", "db_id": "cre_Theme_park", "question": "Give me the detail and opening hour for each museum.", "rationale": ["Identify the relevant table for museums, which is the 'Museums' table.", "Determine the columns needed: 'Museum_ID' for unique identification and 'Museum_Details' for details about the museum.", "Since the question also asks for opening hours, but the 'Museums' table does not contain this information, we will only retrieve the details from the 'Museums' table."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT Museum_ID, Museum_Details FROM Museums;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\"\n}\n"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Royal_Family.", "Determine the relationship between the tables: Tourist_Attractions has a foreign key linking to Royal_Family.", "Select the columns needed: all details from Tourist_Attractions and the How_to_Get_There column.", "Construct the SQL query using a JOIN to combine the two tables based on the relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.*, Tourist_Attractions.How_to_Get_There \nFROM Tourist_Attractions \nJOIN Royal_Family ON Tourist_Attractions.Tourist_Attraction_ID = Royal_Family.Royal_Family_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\"\n}\n"}
{"sample_id": "train.5923", "db_id": "cre_Theme_park", "question": "What are the details of the shops that can be accessed by walk?", "rationale": ["Identify the relevant tables: Shops and Tourist_Attractions.", "Determine the relationship between Shops and Tourist_Attractions using the Shop_ID and Tourist_Attraction_ID.", "Use a JOIN to combine data from both tables based on the matching IDs.", "Filter the results to include only those attractions that can be accessed by walking, using the 'How_to_Get_There' column."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "pred_sql": "SELECT Shops.Shop_ID, Shops.Shop_Details \nFROM Shops \nJOIN Tourist_Attractions ON Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Tourist_Attractions.How_to_Get_There LIKE '%walk%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\"\n}\n"}
{"sample_id": "train.5931", "db_id": "cre_Theme_park", "question": "Which tourist attractions does the visitor with detail 'Vincent' visit?", "rationale": ["Identify the relevant tables: Visits, Tourist_Attractions, and Visitors are needed to find out which attractions a specific visitor has visited.", "The Visits table links tourists to the attractions they visited, so we will join Visits with Tourist_Attractions to get the names and descriptions of the attractions.", "We also need to join the Visitors table to filter the results based on the visitor's details, specifically looking for the visitor with the detail 'Vincent'.", "The final SQL query will select the Name and Description of the Tourist Attractions where the Tourist_ID matches the one associated with 'Vincent' in the Visitors table."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name, Tourist_Attractions.Description \nFROM Visits \nJOIN Tourist_Attractions ON Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID \nJOIN Visitors ON Visits.Tourist_ID = Visitors.Tourist_ID \nWHERE Visitors.Tourist_Details = 'Vincent';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\"\n}\n"}
{"sample_id": "train.5932", "db_id": "cre_Theme_park", "question": "Show the tourist attractions visited by the tourist whose detail is 'Vincent'.", "rationale": ["Identify the relevant tables: Visits, Visitors, and Tourist_Attractions.", "We need to join these tables to get the tourist attractions visited by a specific tourist.", "The Visits table links tourists to the attractions they visited, while the Visitors table contains details about the tourists.", "We will filter the results based on the tourist's detail being 'Vincent'.", "The final query will select the name and description of the tourist attractions along with the visit date."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name, Tourist_Attractions.Description, Visits.Visit_Date \nFROM Visits \nJOIN Visitors ON Visits.Tourist_ID = Visitors.Tourist_ID \nJOIN Tourist_Attractions ON Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Visitors.Tourist_Details = 'Vincent';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\"\n}\n"}
{"sample_id": "train.5941", "db_id": "cre_Theme_park", "question": "Show the details of the top 3 most expensive hotels.", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "Determine the requirement to show the top 3 most expensive hotels, which implies sorting by the 'price_range' in descending order.", "Use the SQL SELECT statement to retrieve all columns from the 'Hotels' table.", "Apply the ORDER BY clause to sort the results based on 'price_range' in descending order to get the most expensive hotels first.", "Limit the results to 3 using the LIMIT clause."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "Determine the relevant column for sorting the hotels by price, which is 'price_range'.", "Since we want the most expensive hotels, we will order the results in descending order.", "Limit the results to the top three entries to get the three most expensive hotels."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5944", "db_id": "cre_Theme_park", "question": "What are the details and star ratings of the three hotels with the lowest price ranges?", "rationale": ["Identify the relevant table: The Hotels table contains the details and star ratings of hotels.", "Select the required columns: We need 'other_hotel_details' and 'star_rating_code' from the Hotels table.", "Order the results: We need to order the hotels by 'price_range' in ascending order to get the lowest price ranges first.", "Limit the results: We only want the top three hotels, so we will use a LIMIT clause to restrict the output to 3."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT h.other_hotel_details, h.star_rating_code \nFROM Hotels h \nORDER BY h.price_range ASC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["Identify the relevant table: The question pertains to how people get to tourist attractions, which is detailed in the 'Tourist_Attractions' table under the 'How_to_Get_There' column.", "Count the occurrences of each transportation method: We need to count how many times each method appears to determine the most popular one.", "Group the results by the transportation method: This allows us to aggregate the counts for each unique method.", "Order the results by the count in descending order: This will help us find the most chosen method easily.", "Limit the results to the top entry: Since we only want the most popular method, we will limit the results to 1."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Method_Count\nFROM Tourist_Attractions\nGROUP BY How_to_Get_There\nORDER BY Method_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\"\n}\n"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant table: The question pertains to transportation methods used to reach tourist attractions, which is detailed in the 'Tourist_Attractions' table under the 'How_to_Get_There' column.", "Count occurrences: To find the most frequently used transportation method, we need to count how many times each method appears in the 'How_to_Get_There' column.", "Group by method: We will group the results by the 'How_to_Get_There' column to aggregate the counts for each unique method.", "Order by count: To determine the most used method, we will order the results in descending order based on the count of occurrences.", "Limit the results: Finally, we will limit the results to just one entry to get the top transportation method."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as method_count\nFROM Tourist_Attractions\nGROUP BY How_to_Get_There\nORDER BY method_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\"\n}\n"}
{"sample_id": "train.5955", "db_id": "cre_Theme_park", "question": "Show the names and ids of tourist attractions that are visited at most once.", "rationale": ["Identify the relevant table: Tourist_Attractions contains the names and IDs of tourist attractions.", "Determine the criteria: We need to find attractions that are visited at most once, which means we need to count the visits for each attraction.", "Use the Visits table to count the number of visits per Tourist_Attraction_ID.", "Group the results by Tourist_Attraction_ID and filter those with a count greater than 1 using HAVING clause.", "Use a subquery to find all Tourist_Attraction_IDs that have more than one visit.", "Select the Tourist_Attraction_ID and Name from Tourist_Attractions where the ID is not in the list of IDs from the subquery."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attraction_ID, Name \nFROM Tourist_Attractions \nWHERE Tourist_Attraction_ID NOT IN (\n    SELECT Tourist_Attraction_ID \n    FROM Visits \n    GROUP BY Tourist_Attraction_ID \n    HAVING COUNT(Tourist_ID) > 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\"\n}\n"}
{"sample_id": "train.5956", "db_id": "cre_Theme_park", "question": "What are the names and ids of the tourist attractions that are visited at most once?", "rationale": ["Identify the relevant tables: Tourist_Attractions and Visits.", "We need to find tourist attractions that have been visited at most once, so we will join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID.", "Use a LEFT JOIN to ensure we include attractions that may not have any visits.", "Group the results by Tourist_Attraction_ID to aggregate the visit counts for each attraction.", "Use the HAVING clause to filter the grouped results to include only those attractions with a visit count of 0 or 1.", "Select the Name and Tourist_Attraction_ID from the filtered results."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT ta.Name, ta.Tourist_Attraction_ID \nFROM Tourist_Attractions ta \nLEFT JOIN Visits v ON ta.Tourist_Attraction_ID = v.Tourist_Attraction_ID \nGROUP BY ta.Tourist_Attraction_ID \nHAVING COUNT(v.Visit_ID) <= 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\"\n}\n"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["Identify the relevant tables: Tourist_Attractions for attraction names, Tourist_Attraction_Features for linking attractions to their features, and Features for feature details.", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table on the Tourist_Attraction_ID to get the features associated with each attraction.", "Join the resulting table with the Features table on Feature_ID to access the feature details.", "Filter the results where the feature details are either 'parking' or 'shopping'.", "Select the Name of the tourist attractions that meet the criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT ta.Name \nFROM Tourist_Attractions ta \nJOIN Tourist_Attraction_Features taf ON ta.Tourist_Attraction_ID = taf.Tourist_Attraction_ID \nJOIN Features f ON taf.Feature_ID = f.Feature_ID \nWHERE f.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\"\n}\n"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find the names of tourist attractions that have specific features (parking or shopping).", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table on the Tourist_Attraction_ID to link attractions with their features.", "Then, join the Features table to get the feature details associated with each attraction.", "Filter the results where the feature details are either 'parking' or 'shopping'.", "Select the Name of the tourist attractions that meet the criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT ta.Name \nFROM Tourist_Attractions ta \nJOIN Tourist_Attraction_Features taf ON ta.Tourist_Attraction_ID = taf.Tourist_Attraction_ID \nJOIN Features f ON taf.Feature_ID = f.Feature_ID \nWHERE f.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\"\n}\n"}
{"sample_id": "train.5963", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions Vincent and Marcelle visit?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Visits, and Visitors are needed to find the names of attractions visited by specific tourists.", "Join the Visits table with the Tourist_Attractions table on the Tourist_Attraction_ID to link visits to their respective attractions.", "Join the Visitors table with the Visits table on Tourist_ID to link visits to the tourists.", "Filter the results to include only those records where the Tourist_Details in the Visitors table match 'Vincent' or 'Marcelle'.", "Select the Name of the tourist attractions from the Tourist_Attractions table."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT ta.Name\nFROM Tourist_Attractions ta\nJOIN Visits v ON ta.Tourist_Attraction_ID = v.Tourist_Attraction_ID\nJOIN Visitors vi ON v.Tourist_ID = vi.Tourist_ID\nWHERE vi.Tourist_Details IN ('Vincent', 'Marcelle');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\"\n}\n"}
{"sample_id": "train.5985", "db_id": "game_1", "question": "Which game type has most number of games?", "rationale": ["Identify the table that contains the game types, which is the 'Video_Games' table.", "We need to count the number of games for each game type, so we will use the COUNT() function.", "Group the results by the game type using GROUP BY GType.", "To find out which game type has the most games, we will order the results in descending order based on the count of games.", "Finally, we will limit the results to only the top entry using LIMIT 1."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType, COUNT(GameID) AS NumberOfGames\nFROM Video_Games\nGROUP BY GType\nORDER BY NumberOfGames DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the types or genres of video games from the 'Video_Games' table, grouped by their type. The placeholder in the LIMIT clause allows the user to specify the maximum number of genres to retrieve, sorted by the number of games in each genre in descending order.\"\n}\n"}
{"sample_id": "train.5988", "db_id": "game_1", "question": "What is the type with the fewest games?", "rationale": ["Identify the relevant table: The question pertains to the types of video games, which are stored in the 'Video_Games' table.", "Determine the required information: We need to find the type (GType) with the fewest games, which means we need to count the number of games (GameID) for each type.", "Group the results: Use GROUP BY to group the results by GType so that we can count the number of games in each type.", "Count the games: Use COUNT(GameID) to count the number of games for each type and alias it as GameCount.", "Sort the results: To find the type with the fewest games, we need to sort the results in ascending order based on the GameCount.", "Limit the results: Use LIMIT 1 to retrieve only the type with the fewest games."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType, COUNT(GameID) AS GameCount\nFROM Video_Games\nGROUP BY GType\nORDER BY GameCount ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the types or genres of video games from the 'Video_Games' table, grouped by their type. The placeholder in the LIMIT clause allows the user to specify the maximum number of genres to retrieve, sorted by the number of games in each genre in descending order.\"\n}\n"}
{"sample_id": "train.6001", "db_id": "game_1", "question": "How many students play sports?", "rationale": ["Identify the relevant table: The question pertains to students who play sports, so we will focus on the SportsInfo table.", "Determine the information needed: We need to count the number of distinct students (StuID) who are involved in sports.", "Construct the SQL query: Use the COUNT function to count distinct StuID from the SportsInfo table."], "gold_sql": "SELECT count(DISTINCT StuID) FROM Sportsinfo", "source_tables": ["sportsinfo"], "pred_sql": "SELECT COUNT(DISTINCT StuID) AS TotalStudentsPlayingSports FROM SportsInfo;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\"\n}\n"}
{"sample_id": "train.6003", "db_id": "game_1", "question": "List ids for all student who are on scholarship.", "rationale": ["Identify the relevant table: SportsInfo contains information about students involved in sports and their scholarship status.", "Determine the condition: We need to filter students who are on a sports scholarship, which is indicated by the 'OnScholarship' column.", "Construct the SQL query: We will select the 'StuID' from the SportsInfo table where 'OnScholarship' is 'Yes'."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\"\n}\n"}
{"sample_id": "train.6004", "db_id": "game_1", "question": "What are the ids for all sporty students who are on scholarship?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports.", "Determine the criteria: We need to find students who are on a sports scholarship, which is indicated by the 'OnScholarship' column.", "Formulate the SQL query: We will select the 'StuID' from the SportsInfo table where 'OnScholarship' is 'Yes'."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\"\n}\n"}
{"sample_id": "train.6006", "db_id": "game_1", "question": "What are the last names for all scholarship students?", "rationale": ["Identify the relevant table: We need to find last names of students who are on a sports scholarship, so we will use the 'Student' and 'SportsInfo' tables.", "Determine the relationship: The 'StuID' in 'SportsInfo' links to 'StuID' in 'Student', allowing us to join these tables.", "Select the required column: We need the last names, which are in the 'LName' column of the 'Student' table.", "Filter for scholarship students: We need to add a condition to only include students who are on a scholarship, which is indicated by the 'OnScholarship' column in the 'SportsInfo' table."], "gold_sql": "SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT Student.LName \nFROM Student \nJOIN SportsInfo ON Student.StuID = SportsInfo.StuID \nWHERE SportsInfo.OnScholarship = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\"\n}\n"}
{"sample_id": "train.6010", "db_id": "game_1", "question": "What is the total number of all football games played by scholarship students?", "rationale": ["Identify the relevant table: SportsInfo contains information about sports participation.", "Determine the specific sport: The question asks about football games.", "Filter for scholarship students: We need to include only those students who are on a sports scholarship, indicated by the 'OnScholarship' column.", "Use the SUM function: To get the total number of games played, we will sum the 'GamesPlayed' column for the filtered results."], "gold_sql": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  'Football' AND onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SUM(GamesPlayed) AS TotalGamesPlayed\nFROM SportsInfo\nWHERE SportName = 'Football' AND OnScholarship = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\"\n}\n"}
{"sample_id": "train.6014", "db_id": "game_1", "question": "What are the ids of all students along with how many sports and games did they play?", "rationale": ["We need to retrieve the student IDs along with the count of sports and games they play.", "To get the student IDs, we will select 'StuID' from the 'Student' table.", "To count the number of sports played by each student, we will join the 'SportsInfo' table on 'StuID' and use COUNT(DISTINCT SportName) to get the unique sports count.", "To count the number of games played by each student, we will join the 'Plays_Games' table on 'StuID' and use COUNT(DISTINCT GameID) to get the unique games count.", "We will use LEFT JOINs to ensure that we include students who may not be involved in any sports or games.", "Finally, we will group the results by 'StuID' to get the counts for each student."], "gold_sql": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID", "source_tables": ["sportsinfo"], "pred_sql": "SELECT Student.StuID, COUNT(DISTINCT SportsInfo.SportName) AS Total_Sports, COUNT(DISTINCT Plays_Games.GameID) AS Total_Games\nFROM Student\nLEFT JOIN SportsInfo ON Student.StuID = SportsInfo.StuID\nLEFT JOIN Plays_Games ON Student.StuID = Plays_Games.StuID\nGROUP BY Student.StuID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\"\n}\n"}
{"sample_id": "train.6019", "db_id": "game_1", "question": "Which sport has most number of students on scholarship?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Filter the records to include only those students who are on a sports scholarship by using the WHERE clause with 'OnScholarship = 'Yes' '.", "Group the results by SportName to count the number of students in each sport using GROUP BY.", "Count the number of students for each sport using COUNT(StuID) and alias it as NumberOfStudents.", "Order the results in descending order to get the sport with the most students on scholarship at the top using ORDER BY NumberOfStudents DESC.", "Limit the results to only the top entry using LIMIT 1 to get the sport with the most students on scholarship."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName, COUNT(StuID) AS NumberOfStudents\nFROM SportsInfo\nWHERE OnScholarship = 'Yes'\nGROUP BY SportName\nORDER BY NumberOfStudents DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\"\n}\n"}
{"sample_id": "train.6020", "db_id": "game_1", "question": "What is the sport with the most scholarship students?", "rationale": ["Identify the relevant table: SportsInfo contains information about students involved in sports and their scholarship status.", "Filter for students on a sports scholarship by using the condition 'OnScholarship = 'Yes' in the WHERE clause.", "Group the results by SportName to aggregate the data for each sport.", "Use the SUM function to calculate the total number of games played for each sport.", "Order the results in descending order to find the sport with the most games played by scholarship students.", "Limit the results to 1 to get only the sport with the highest number of games played."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName FROM SportsInfo WHERE OnScholarship = 'Yes' GROUP BY SportName ORDER BY SUM(GamesPlayed) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\"\n}\n"}
{"sample_id": "train.6024", "db_id": "game_1", "question": "What are the student ids for those on scholarship in major number 600?", "rationale": ["Identify the requirement: We need to find student IDs of those who are on a sports scholarship and have a specific major (number 600).", "The relevant table for scholarship information is 'SportsInfo', which contains the 'OnScholarship' column.", "We also need to filter students based on their major, which is found in the 'Student' table.", "To achieve this, we will use a subquery to first select the student IDs from the 'Student' table where the Major is '600'.", "Then, we will filter the 'SportsInfo' table to find those students who are on a scholarship (OnScholarship = 'Yes').", "Finally, we will combine these conditions to get the desired student IDs."], "gold_sql": "SELECT StuID FROM Student WHERE major  =  600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes' AND StuID IN (SELECT StuID FROM Student WHERE Major = '600');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\"\n}\n"}
{"sample_id": "train.6025", "db_id": "game_1", "question": "Show student ids who are female and play football.", "rationale": ["Identify the relevant tables: We need to get student IDs from the Student table and filter based on gender and sport.", "The Student table contains the 'Sex' column to filter for females.", "The SportsInfo table contains the 'SportName' column to filter for students who play football.", "We need to join the Student table with the SportsInfo table on the StuID column to get the relevant information about students who play football.", "Construct the SQL query to select the StuID from the joined tables where the conditions for gender and sport are met."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN SportsInfo ON Student.StuID = SportsInfo.StuID \nWHERE Student.Sex = 'Female' AND SportsInfo.SportName = 'Football';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\"\n}\n"}
{"sample_id": "train.6026", "db_id": "game_1", "question": "What are the ids of all female students who play football?", "rationale": ["Identify the relevant tables: We need to get information from the Student and SportsInfo tables.", "Determine the conditions: We are looking for female students, so we will filter by the 'Sex' column in the Student table.", "We also need to filter for students who play football, which is specified in the 'SportName' column of the SportsInfo table.", "Join the Student table with the SportsInfo table on the StuID to combine the relevant information.", "Select the StuID of the students who meet both conditions."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN SportsInfo ON Student.StuID = SportsInfo.StuID \nWHERE Student.Sex = 'Female' AND SportsInfo.SportName = 'Football';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\"\n}\n"}
{"sample_id": "train.6028", "db_id": "game_1", "question": "What are the ids of all male students who do not play football?", "rationale": ["Identify the target group: male students.", "Filter the Student table for male students by checking the 'Sex' column.", "To find male students who do not play football, we need to exclude those who are in the SportsInfo table with 'SportName' as 'Football'.", "Use a subquery to select all StuID from SportsInfo where SportName is 'Football'.", "Combine the conditions using NOT IN to filter out those students from the main query."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male' AND StuID NOT IN (SELECT StuID FROM SportsInfo WHERE SportName = 'Football');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\"\n}\n"}
{"sample_id": "train.6060", "db_id": "customers_and_addresses", "question": "Find the average order quantity per order.", "rationale": ["Identify the relevant table for order quantities, which is the 'Order_Items' table.", "To find the average order quantity, we need to use the AVG() function on the 'order_quantity' column.", "The query should select the average of the 'order_quantity' from the 'Order_Items' table."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "pred_sql": "SELECT AVG(order_quantity) AS average_order_quantity\nFROM Order_Items;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\"\n}\n"}
{"sample_id": "train.6071", "db_id": "customers_and_addresses", "question": "What are the details of all products?", "rationale": ["The user wants to retrieve details of all products.", "To get all details from the 'Products' table, we can use a simple SELECT statement.", "The SQL query will be 'SELECT * FROM Products;' which selects all columns from the Products table."], "gold_sql": "SELECT DISTINCT product_details FROM products", "source_tables": ["products"], "pred_sql": "SELECT * FROM Products;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\"\n}\n"}
{"sample_id": "train.6075", "db_id": "customers_and_addresses", "question": "Find the detail of products whose detail contains the word \"Latte\" or the word \"Americano\"", "rationale": ["Identify the table to query: The question asks for product details, so we will query the 'Products' table.", "Determine the filtering criteria: We need to find products whose details contain the words 'Latte' or 'Americano'.", "Construct the SQL query: Use the SELECT statement to retrieve all columns from the 'Products' table, and apply the WHERE clause to filter based on the specified keywords using the LIKE operator."], "gold_sql": "SELECT product_details FROM products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'", "source_tables": ["products"], "pred_sql": "SELECT * FROM Products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\"\n}\n"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: We need to find the city with the most customers, so we will use the Customer_Addresses and Addresses tables.", "Join the tables: We will join Customer_Addresses with Addresses on the address_id to get the city information for each customer.", "Count distinct customers: We will count the distinct customer_id for each city to avoid counting the same customer multiple times if they have multiple addresses.", "Group by city: We will group the results by city to aggregate the customer counts for each city.", "Order the results: We will order the results in descending order based on the customer count to find the city with the most customers.", "Limit the results: We will limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(DISTINCT customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6086", "db_id": "customers_and_addresses", "question": "Find the city where the most customers live.", "rationale": ["To find the city where the most customers live, we need to count the number of customers associated with each city.", "The relevant tables are Customer_Addresses (which links customers to addresses) and Addresses (which contains city information).", "We will join the Customer_Addresses table with the Addresses table on the address_id to get the city for each customer.", "Next, we will group the results by city and count the number of customer_ids for each city to get the total number of customers per city.", "Finally, we will order the results in descending order based on the customer count and limit the results to 1 to get the city with the most customers."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6097", "db_id": "customers_and_addresses", "question": "Which contact channel has been used by the customer with name \"Tillman Ernser\"?", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "We need to find the contact channels associated with a specific customer, so we will join these two tables on the customer_id.", "We will filter the results using a WHERE clause to specify the customer's name as 'Tillman Ernser'.", "We will select the distinct contact channels used by this customer."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT DISTINCT Customer_Contact_Channels.channel_code \nFROM Customers \nJOIN Customer_Contact_Channels ON Customers.customer_id = Customer_Contact_Channels.customer_id \nWHERE Customers.customer_name = 'Tillman Ernser';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\"\n}\n"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the relevant tables: Customer_Contact_Channels and Customers.", "We need to find the 'active_to_date' for the contact channels associated with the customer named 'Tillman Ernser'.", "Join the Customer_Contact_Channels table with the Customers table on the customer_id to link contact channels to the specific customer.", "Filter the results to only include the customer with the name 'Tillman Ernser'.", "Order the results by 'active_to_date' in descending order to get the latest date first.", "Limit the results to 1 to get only the latest contact channel's 'active_to_date'."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT active_to_date \nFROM Customer_Contact_Channels ccc \nJOIN Customers c ON ccc.customer_id = c.customer_id \nWHERE c.customer_name = 'Tillman Ernser' \nORDER BY ccc.active_to_date DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\"\n}\n"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["To find the average time span of contact channels, we need to calculate the duration for each contact channel.", "The duration can be calculated by subtracting the 'active_from_date' from the 'active_to_date'.", "We will use the 'julianday' function to convert the date strings into Julian day numbers for accurate date calculations.", "We need to ensure that we only consider contact channels that have an 'active_to_date' (i.e., they have been deactivated).", "Finally, we will use the AVG function to calculate the average of these durations."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_time_span FROM Customer_Contact_Channels WHERE active_to_date IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\"\n}\n"}
{"sample_id": "train.6103", "db_id": "customers_and_addresses", "question": "What is the channel code and contact number of the customer contact channel that was active for the longest time?", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the channel code and contact number.", "Determine the criteria for the longest active channel: This can be inferred as the channel that has the earliest active_from_date and has not been deactivated (active_to_date IS NULL).", "Construct a subquery to find the minimum active_from_date from the Customer_Contact_Channels table where the channel is still active.", "Select the channel_code and contact_number from the Customer_Contact_Channels table where the active_from_date matches the result of the subquery."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT channel_code, contact_number\nFROM Customer_Contact_Channels\nWHERE active_from_date = (\n    SELECT MIN(active_from_date)\n    FROM Customer_Contact_Channels\n    WHERE active_to_date IS NULL\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\"\n}\n"}
{"sample_id": "train.6108", "db_id": "customers_and_addresses", "question": "Find the name of the customer who made the order of the largest amount of goods.", "rationale": ["Identify the relevant tables: Customers, Customer_Orders, and Order_Items are needed to find the customer who made the largest order.", "Join the Customers table with Customer_Orders on customer_id to link customers to their orders.", "Join the resulting table with Order_Items on order_id to access the quantities of items ordered.", "Group the results by customer_id to aggregate the total quantity of items ordered by each customer.", "Use SUM(oi.order_quantity) to calculate the total amount of goods ordered by each customer.", "Order the results in descending order to get the customer with the largest order at the top.", "Limit the results to 1 to get only the customer with the largest order."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)", "source_tables": ["customer_orders", "customers", "order_items"], "pred_sql": "SELECT c.customer_name\nFROM Customers c\nJOIN Customer_Orders co ON c.customer_id = co.customer_id\nJOIN Order_Items oi ON co.order_id = oi.order_id\nGROUP BY c.customer_id\nORDER BY SUM(oi.order_quantity) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6123", "db_id": "customers_and_addresses", "question": "What is the total number of products that are in orders with status \"Cancelled\"?", "rationale": ["Identify the relevant tables: We need to look at the 'Customer_Orders' table to find orders with the status 'Cancelled' and the 'Order_Items' table to find the products associated with those orders.", "Join the 'Customer_Orders' table with the 'Order_Items' table on the 'order_id' to link orders to their respective products.", "Filter the results to include only those orders where the 'order_status' is 'Cancelled'.", "Count the distinct 'product_id' from the 'Order_Items' table to get the total number of unique products in cancelled orders."], "gold_sql": "SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_status  =  'Cancelled'", "source_tables": ["customer_orders", "order_items"], "pred_sql": "SELECT COUNT(DISTINCT oi.product_id) AS total_products\nFROM Customer_Orders co\nJOIN Order_Items oi ON co.order_id = oi.order_id\nWHERE co.order_status = 'Cancelled';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\"\n}\n"}
{"sample_id": "train.6130", "db_id": "customers_and_addresses", "question": "What is the most frequently ordered product? Tell me the detail of the product", "rationale": ["Identify the tables involved: We need to look at the 'Order_Items' table to find out which products were ordered and the 'Products' table to get the details of those products.", "Join the 'Order_Items' table with the 'Products' table on the product_id to access product details along with the order information.", "Group the results by product_id to count how many times each product has been ordered.", "Order the results by the count of orders in descending order to find the most frequently ordered product.", "Limit the results to 1 to get only the most frequently ordered product."], "gold_sql": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT p.product_id, p.product_details \nFROM Order_Items oi \nJOIN Products p ON oi.product_id = p.product_id \nGROUP BY oi.product_id \nORDER BY COUNT(oi.order_id) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\"\n}\n"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["Identify the tables involved: Products and Order_Items.", "We need to find the product with the largest total order quantity, so we will join the Products table with the Order_Items table on the product_id.", "We will group the results by product_id to aggregate the order quantities for each product.", "To find the total order quantity for each product, we will use the SUM function on the order_quantity column from the Order_Items table.", "We will order the results in descending order based on the total order quantity to get the product with the largest quantity at the top.", "Finally, we will limit the results to 1 to get only the product with the largest total order quantity."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT p.product_id, p.product_details\nFROM Products p\nJOIN Order_Items oi ON p.product_id = oi.product_id\nGROUP BY p.product_id\nORDER BY SUM(oi.order_quantity) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\"\n}\n"}
{"sample_id": "train.6132", "db_id": "customers_and_addresses", "question": "What are the name and ID of the product bought the most.", "rationale": ["Identify the tables involved: Products and Order_Items.", "Join the Products table with the Order_Items table on product_id to link products with their order quantities.", "Group the results by product_id to aggregate the order quantities for each product.", "Count the number of orders for each product using COUNT(oi.order_id).", "Order the results in descending order based on the count of orders to find the most bought product.", "Limit the results to 1 to get only the top product."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT p.product_id, p.product_details\nFROM Products p\nJOIN Order_Items oi ON p.product_id = oi.product_id\nGROUP BY p.product_id\nORDER BY COUNT(oi.order_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\"\n}\n"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The question asks for addresses, so we will use the 'Addresses' table.", "Determine the filtering criteria: We need to find addresses in two specific cities and states: East Julianaside, Texas and Gleasonmouth, Arizona.", "Construct the WHERE clause: We will use an OR condition to combine the two sets of criteria, checking both the city and state for each.", "Formulate the SQL query: We will select all columns from the Addresses table where the conditions are met."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "\n"}
{"sample_id": "train.6155", "db_id": "music_4", "question": "What are the category of music festivals with result \"Awarded\"?", "rationale": ["Identify the table of interest: music_festival, which contains the categories and results of music festivals.", "Determine the specific result we are interested in: 'Awarded'.", "Use the SELECT statement to retrieve the distinct categories from the music_festival table where the Result matches 'Awarded'.", "Ensure to use DISTINCT to avoid duplicate categories in the result."], "gold_sql": "SELECT Category FROM music_festival WHERE RESULT  =  'Awarded'", "source_tables": ["music_festival"], "pred_sql": "SELECT DISTINCT Category FROM music_festival WHERE Result = 'Awarded';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the categories of awards or recognitions from the 'music_festival' table based on a specific result. The placeholder in the WHERE clause represents the outcome of the festival participation.\"\n}\n"}
{"sample_id": "train.6167", "db_id": "music_4", "question": "Please show the songs that have result \"nominated\" at music festivals.", "rationale": ["Identify the relevant tables: 'music_festival' and 'volume' are needed to find songs that were nominated.", "The 'music_festival' table contains the 'Result' column which we need to filter by the value 'nominated'.", "The 'volume' table is linked to 'music_festival' through the 'Volume' column, which corresponds to 'Volume_ID'.", "We need to select the 'Song' from the 'volume' table that corresponds to the nominated results in the 'music_festival' table.", "Construct the SQL query using a JOIN to connect 'music_festival' and 'volume' on the appropriate foreign key, and filter by the 'Result' column."], "gold_sql": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  'Nominated'", "source_tables": ["music_festival", "volume"], "pred_sql": "SELECT volume.Song \nFROM music_festival \nJOIN volume ON music_festival.Volume = volume.Volume_ID \nWHERE music_festival.Result = 'nominated';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the categories of awards or recognitions from the 'music_festival' table based on a specific result. The placeholder in the WHERE clause represents the outcome of the festival participation.\"\n}\n"}
{"sample_id": "train.6180", "db_id": "music_4", "question": "Return the famous release date for the oldest artist.", "rationale": ["Identify the table that contains the release date of the famous title, which is the 'artist' table.", "To find the oldest artist, we need to sort the artists by their age in ascending order.", "We will select the 'Famous_Release_date' of the artist who is the oldest.", "Using 'LIMIT 1' will ensure that we only get the release date of the oldest artist."], "gold_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1", "source_tables": ["artist"], "pred_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\"\n}\n"}
{"sample_id": "train.6185", "db_id": "music_4", "question": "Please show the categories of the music festivals with count more than 1.", "rationale": ["Identify the relevant table: The 'music_festival' table contains the 'Category' column that we need to analyze.", "Group the results by 'Category': We want to count how many times each category appears, so we will use the GROUP BY clause on the 'Category' column.", "Count the occurrences: We will use the COUNT function to count the number of entries for each category.", "Filter the results: We only want categories that appear more than once, so we will use the HAVING clause with COUNT(*) > 1."], "gold_sql": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*)  >  1", "source_tables": ["music_festival"], "pred_sql": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the categories of awards or recognitions from the 'music_festival' table based on a specific result. The placeholder in the WHERE clause represents the outcome of the festival participation.\"\n}\n"}
{"sample_id": "train.6187", "db_id": "music_4", "question": "What is the song in the volume with the maximum weeks on top?", "rationale": ["Identify the table that contains the relevant information about songs and their weeks on top, which is the 'volume' table.", "To find the song in the volume with the maximum weeks on top, we need to select the 'Song' from the 'volume' table.", "We need to determine the maximum number of weeks a song has stayed at the top, which can be done using a subquery that selects the maximum value from the 'Weeks_on_Top' column in the 'volume' table.", "The main query will filter the 'volume' table to return the song(s) that have the same number of weeks on top as the maximum value found in the subquery."], "gold_sql": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT v.Song \nFROM volume v \nWHERE v.Weeks_on_Top = (SELECT MAX(Weeks_on_Top) FROM volume);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\"\n}\n"}
{"sample_id": "train.6195", "db_id": "music_4", "question": "What is the issue date of the volume with the minimum weeks on top?", "rationale": ["Identify the table that contains the issue date, which is the 'volume' table.", "Determine that we need to find the minimum number of weeks a song has stayed at the top, which requires a subquery to get the minimum value from the 'Weeks_on_Top' column in the 'volume' table.", "Use the result of the subquery to filter the 'volume' table to get the corresponding 'Issue_Date' for the volume with the minimum weeks on top."], "gold_sql": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT Issue_Date FROM volume WHERE Weeks_on_Top = (SELECT MIN(Weeks_on_Top) FROM volume);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\"\n}\n"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["Identify the table that contains the competition information, which is the 'match' table.", "We need to find the Match_ID associated with the competition named '1994 FIFA World Cup qualification'.", "To do this, we will select the Match_ID from the 'match' table where the Competition matches the specified name.", "The query will return the Match_ID for the specified competition."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "pred_sql": "SELECT Match_ID FROM match WHERE Competition = (SELECT Competition FROM match WHERE Competition = '1994 FIFA World Cup qualification');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\"\n}\n"}
{"sample_id": "train.6274", "db_id": "city_record", "question": "Which city has hosted the most events?", "rationale": ["Identify the relevant tables: 'city' for city names and 'hosting_city' for hosted matches.", "Join the 'city' table with the 'hosting_city' table on the city identifier to link cities with their hosted matches.", "Count the number of matches hosted by each city using COUNT(hc.Match_ID).", "Group the results by city to aggregate the match counts using GROUP BY c.City.", "Order the results in descending order based on the count of hosted matches using ORDER BY Event_Count DESC.", "Limit the results to the top city using LIMIT 1."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "pred_sql": "SELECT c.City, COUNT(hc.Match_ID) AS Event_Count\nFROM city c\nJOIN hosting_city hc ON c.City_ID = hc.Host_City\nGROUP BY c.City\nORDER BY Event_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\"\n}\n"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables: 'city' for city names and 'temperature' for February temperatures.", "Join the 'city' table with the 'temperature' table on the City_ID to access both city names and their corresponding February temperatures.", "Select the city name and February temperature from the joined tables.", "Order the results by February temperature in descending order to get the highest temperature at the top.", "Limit the results to 1 to get only the city with the highest temperature in February."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, t.Feb\nFROM city c\nJOIN temperature t ON c.City_ID = t.City_ID\nORDER BY t.Feb DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\"\n}\n"}
{"sample_id": "train.6287", "db_id": "city_record", "question": "In February, which city marks the highest temperature?", "rationale": ["Identify the relevant tables: 'city' for city names and 'temperature' for temperature data.", "We need to find the city with the highest temperature in February, so we will focus on the 'Feb' column in the 'temperature' table.", "Join the 'city' table with the 'temperature' table on 'City_ID' to get city names along with their February temperatures.", "Order the results by the February temperature in descending order to get the highest temperature at the top.", "Limit the results to 1 to get only the city with the highest temperature."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, t.Feb\nFROM city c\nJOIN temperature t ON c.City_ID = t.City_ID\nORDER BY t.Feb DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\"\n}\n"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the tables needed: We need data from the 'city' and 'temperature' tables.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access city names and their corresponding temperatures.", "Use a WHERE clause to filter cities based on the condition that the temperature in March is lower than in July or higher than in October.", "Select the 'City' column from the result set to get the list of cities that meet the criteria."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Jul OR t.Mar > t.Oct;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\"\n}\n"}
{"sample_id": "train.6289", "db_id": "city_record", "question": "Which cities' temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: 'city' and 'temperature'.", "We need to join these tables on the 'City_ID' to access city names and their temperature data.", "Select the city name and the temperature data for March, July, and October.", "Apply the condition to filter cities where the temperature in March is lower than in July or higher than in October."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, t.Mar, t.Jul, t.Oct \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Jul OR t.Mar > t.Oct;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\"\n}\n"}
{"sample_id": "train.6292", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in Dec and which have never been host cities.", "rationale": ["Identify the relevant tables: 'city' for city details and 'temperature' for temperature data.", "We need to filter cities based on temperature in March and December, so we will join the 'city' and 'temperature' tables on 'City_ID'.", "The condition requires that the temperature in March (t.Mar) is lower than in December (t.Dec).", "Additionally, we need to ensure that the cities have never hosted matches, which means their 'City_ID' should not be in the 'hosting_city' table.", "We can achieve this by using a subquery that selects all 'Host_City' from the 'hosting_city' table and using the NOT IN clause to filter out those cities."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City, c.Hanzi, c.Hanyu_Pinyin, c.Regional_Population, c.GDP \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\"\n}\n"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the relevant tables: 'city', 'temperature', and 'hosting_city'.", "We need to compare temperatures in March and December, so we will join the 'city' table with the 'temperature' table on 'City_ID'.", "The condition for lower temperature in March than in December is specified in the WHERE clause: t.Mar < t.Dec.", "To find cities that have never served as host cities, we will use a subquery that selects all Host_City from the 'hosting_city' table and ensure that the City_ID is not in that list using NOT IN.", "Combine all these conditions to form the final SQL query."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\"\n}\n"}
{"sample_id": "train.6298", "db_id": "city_record", "question": "Please give me a list of cities whose regional population is over 8000000 or under 5000000.", "rationale": ["Identify the table to query: The 'city' table contains the relevant information about cities and their populations.", "Determine the condition for filtering: We need cities with a regional population greater than 8,000,000 or less than 5,000,000.", "Construct the SQL SELECT statement: We will select the 'City' column from the 'city' table where the population meets the specified conditions."], "gold_sql": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000", "source_tables": ["city"], "pred_sql": "SELECT City FROM city WHERE Regional_Population > 8000000 OR Regional_Population < 5000000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\"\n}\n"}
{"sample_id": "train.6313", "db_id": "e_government", "question": "What is the name of the party form that is most common?", "rationale": ["Identify the relevant tables: Party_Forms and Forms are needed to get the form names associated with the parties.", "Join the Party_Forms table with the Forms table on the form_id to access the form names.", "Group the results by form_name to count how many times each form appears in the Party_Forms table.", "Order the results by the count of forms in descending order to find the most common form.", "Limit the results to 1 to get only the most common party form."], "gold_sql": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["forms", "party_forms"], "pred_sql": "SELECT form_name, COUNT(*) as form_count \nFROM Party_Forms \nJOIN Forms ON Party_Forms.form_id = Forms.form_id \nGROUP BY form_name \nORDER BY form_count DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6329", "db_id": "e_government", "question": "What are the names of the services that have never been used?", "rationale": ["Identify the table that contains the service names, which is the Services table.", "We need to find services that have never been used, which means we need to check against the Party_Services table where service_id is recorded for used services.", "The query should select service_name from Services where the service_id is not present in the list of service_ids from the Party_Services table.", "This can be achieved using a subquery that selects service_id from Party_Services and using the NOT IN clause to filter out those services from the Services table."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "pred_sql": "SELECT service_name FROM Services WHERE service_id NOT IN (SELECT service_id FROM Party_Services);", "hint": "\n"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table: The question asks for cities and states, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' for cities and 'state_province_county' for states.", "Use DISTINCT to avoid duplicate entries: Since the same city or state may appear multiple times, we use DISTINCT to get unique values.", "Construct the SQL query: Combine the selected columns and table into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6342", "db_id": "e_government", "question": "Which state can address \"6862 Kaitlyn Knolls\" possibly be in?", "rationale": ["Identify the relevant table: The question pertains to addresses, so we will use the 'Addresses' table.", "Determine the relevant column: We need to find the state, which is stored in the 'state_province_county' column.", "Filter the results: We will filter the addresses to find the one that matches '6862 Kaitlyn Knolls' in the 'line_1_number_building' column.", "Select distinct states: Since the same address could potentially exist in multiple states, we will use DISTINCT to ensure we only get unique states."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT state_province_county FROM Addresses WHERE line_1_number_building = '6862 Kaitlyn Knolls';", "hint": "\n"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the relevant tables: Organization_Contact_Individuals and Individuals.", "We need to retrieve the last names of individuals, so we will select the 'individual_last_name' column from the Individuals table.", "To link the individuals to their contact with organizations, we will join the Organization_Contact_Individuals table with the Individuals table on the 'individual_id' column.", "Since we want the last names of individuals who have been contact individuals of an organization, we will not filter by organization name in this case, but we will order the results by the end date of the contact period (date_contact_to) in descending order to get the most recent contacts first."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "pred_sql": "SELECT I.individual_last_name \nFROM Organization_Contact_Individuals OCI \nJOIN Individuals I ON OCI.individual_id = I.individual_id \nORDER BY OCI.date_contact_to DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names of individuals who have contacted a specific organization. The organization is identified by its name, and the results are ordered by the end date of the contact period, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the organization name and the number of results to display.\"\n}\n"}
{"sample_id": "train.6371", "db_id": "flight_company", "question": "What are the names and types of the companies that have ever operated a flight?", "rationale": ["Identify the relevant tables: We need information from the 'operate_company' table for company names and types, and the 'flight' table to find out which companies have operated flights.", "Determine the relationship: The 'flight' table has a foreign key 'company_id' that links to the 'id' in the 'operate_company' table.", "Select the required columns: We need to select the 'name' and 'Type' columns from the 'operate_company' table.", "Use DISTINCT to avoid duplicate entries: Since a company may operate multiple flights, we use DISTINCT to ensure each company is listed only once.", "Construct the SQL query: We will use a JOIN to combine the 'operate_company' and 'flight' tables based on the foreign key relationship."], "gold_sql": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id", "source_tables": ["flight", "operate_company"], "pred_sql": "SELECT DISTINCT operate_company.name, operate_company.Type \nFROM operate_company \nJOIN flight ON operate_company.id = flight.company_id;", "hint": "\n"}
{"sample_id": "train.6375", "db_id": "flight_company", "question": "What is the id, name and IATA code of the airport that had most number of flights?", "rationale": ["Identify the relevant tables: 'airport' and 'flight'.", "We need to find the airport with the most flights, so we will join the 'airport' table with the 'flight' table using the foreign key relationship (airport.id = flight.airport_id).", "Select the required columns: airport.id, airport.name, and airport.IATA.", "Group the results by airport.id, airport.name, and airport.IATA to aggregate the flight counts for each airport.", "Count the number of flights for each airport using COUNT(flight.id).", "Order the results in descending order based on the count of flights to get the airport with the most flights at the top.", "Limit the results to 1 to get only the airport with the highest number of flights."], "gold_sql": "SELECT T1.id ,  T1.name ,  T1.IATA FROM airport AS T1 JOIN flight AS T2 ON T1.id  =  T2.airport_id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airport", "flight"], "pred_sql": "SELECT airport.id, airport.name, airport.IATA\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nGROUP BY airport.id, airport.name, airport.IATA\nORDER BY COUNT(flight.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6381", "db_id": "flight_company", "question": "How many companies operates airlines in each airport?", "rationale": ["Identify the relevant tables: airport, operate_company, and flight.", "We need to count the number of companies that operate airlines at each airport.", "Join the airport table with the flight table on airport.id and flight.airport_id.", "Join the flight table with the operate_company table on flight.company_id and operate_company.id.", "Filter the results to include only those companies that are of type 'airline'.", "Group the results by the airport name to get the count of airlines per airport."], "gold_sql": "SELECT T3.id ,  count(*) FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id JOIN airport AS T3 ON T2.airport_id  =  T3.id GROUP BY T3.id", "source_tables": ["airport", "flight", "operate_company"], "pred_sql": "SELECT airport.name AS Airport_Name, COUNT(operate_company.id) AS Number_of_Airlines\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nJOIN operate_company ON flight.company_id = operate_company.id\nWHERE operate_company.Type = 'airline'\nGROUP BY airport.name;", "hint": "\n"}
{"sample_id": "train.6517", "db_id": "wine_1", "question": "What is the name of the highest rated wine?", "rationale": ["Identify the table that contains the wine names and their scores, which is the 'wine' table.", "To find the highest rated wine, we need to sort the wines by their 'Score' in descending order.", "We will select the 'Name' of the wine and limit the results to 1 to get only the highest rated wine."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\"\n}\n"}
{"sample_id": "train.6518", "db_id": "wine_1", "question": "Give the name of the wine with the highest score.", "rationale": ["Identify the table that contains the wine names and their scores, which is the 'wine' table.", "To find the wine with the highest score, we need to sort the wines by the 'Score' column in descending order.", "Using 'ORDER BY Score DESC' will arrange the wines from highest to lowest score.", "To get only the top wine, we will use 'LIMIT 1' to restrict the result to just one entry.", "Finally, we select the 'Name' of the wine from the sorted list."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\"\n}\n"}
{"sample_id": "train.6520", "db_id": "wine_1", "question": "What is the winery at which the wine with the highest score was made?", "rationale": ["Identify the table that contains the relevant information about wines, which is the 'wine' table.", "Determine that we need to find the winery associated with the wine that has the highest score.", "Use a subquery to find the maximum score from the 'wine' table.", "Select the winery from the 'wine' table where the score matches the maximum score found in the subquery."], "gold_sql": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Winery FROM wine WHERE Score = (SELECT MAX(Score) FROM wine);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\"\n}\n"}
{"sample_id": "train.6533", "db_id": "wine_1", "question": "List the names of all distinct wines that are made of red color grape.", "rationale": ["Identify the tables involved: 'wine' and 'grapes'.", "Determine the relationship between the tables: 'wine.Grape' corresponds to 'grapes.Grape'.", "Select the distinct names of wines from the 'wine' table.", "Filter the results to include only those wines made from grapes that are red in color by using a WHERE clause on 'grapes.Color'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT wine.Name \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'red';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\"\n}\n"}
{"sample_id": "train.6544", "db_id": "wine_1", "question": "Give the names and scores of wines made from white grapes.", "rationale": ["Identify the tables involved: 'wine' and 'grapes'.", "Determine the columns needed: 'Name' and 'Score' from the 'wine' table.", "Join the 'wine' table with the 'grapes' table on the 'Grape' column.", "Filter the results to include only those grapes that are 'white'."], "gold_sql": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT wine.Name, wine.Score \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'white';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\"\n}\n"}
{"sample_id": "train.6547", "db_id": "wine_1", "question": "Find the the grape whose white color grapes are used to produce wines with scores higher than 90.", "rationale": ["We need to find grape varieties that are white in color.", "The relevant tables are 'grapes' and 'wine'.", "We will join these two tables on the grape variety, which is the common column in both tables.", "We will filter the results to include only those grapes that are white in color.", "Additionally, we will filter the wines to include only those with scores higher than 90.", "Finally, we will select distinct grape names to avoid duplicates."], "gold_sql": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White' AND T2.score  >  90", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT grapes.Grape \nFROM grapes \nJOIN wine ON grapes.Grape = wine.Grape \nWHERE grapes.Color = 'white' AND wine.Score > 90;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\"\n}\n"}
{"sample_id": "train.6550", "db_id": "wine_1", "question": "What are the names of wines made from red grapes and with prices above 50?", "rationale": ["Identify the relevant tables: 'wine' and 'grapes'.", "We need to find wines made from red grapes, so we will filter the 'grapes' table for rows where 'Color' is 'red'.", "We also need to filter the 'wine' table for wines with a 'Price' greater than 50.", "To combine the information from both tables, we will use a JOIN on the 'Grape' column, which is common to both tables.", "Finally, we will select the 'Name' of the wine that meets both criteria."], "gold_sql": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red' AND T2.price  >  50", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT wine.Name \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'red' AND wine.Price > 50;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\"\n}\n"}
{"sample_id": "train.6558", "db_id": "wine_1", "question": "What are the distinct names of wines with prices higher than any wine from John Anthony winery.", "rationale": ["Identify the requirement to find distinct names of wines.", "Determine that we need to filter wines based on their price being higher than a certain threshold.", "The threshold is the maximum price of wines produced by 'John Anthony' winery.", "Use a subquery to find the maximum price of wines from 'John Anthony'.", "Construct the main query to select distinct wine names where the price is greater than the result of the subquery."], "gold_sql": "SELECT DISTINCT Name FROM WINE WHERE Price  >  (SELECT min(Price) FROM wine WHERE Winery  =  'John Anthony')", "source_tables": ["wine"], "pred_sql": "SELECT DISTINCT Name FROM wine WHERE Price > (SELECT MAX(Price) FROM wine WHERE Winery = 'John Anthony');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\"\n}\n"}
{"sample_id": "train.6566", "db_id": "wine_1", "question": "Give the color of the grape whose wine products have the highest average price?", "rationale": ["Identify the relevant tables: 'grapes' for grape color and 'wine' for wine prices.", "Join the 'grapes' table with the 'wine' table on the grape variety to access both grape color and wine price.", "Group the results by grape color to calculate the average price of wines for each grape color.", "Order the results by the average price in descending order to find the highest average price.", "Limit the results to 1 to get the grape color associated with the highest average price."], "gold_sql": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT 1", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT g.Color\nFROM grapes g\nJOIN wine w ON g.Grape = w.Grape\nGROUP BY g.Color\nORDER BY AVG(w.Price) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\"\n}\n"}
{"sample_id": "train.6588", "db_id": "wine_1", "question": "Which 3 wineries produce the most wines made from white grapes?", "rationale": ["Identify the relevant tables: 'wine' and 'grapes'.", "Join the 'wine' table with the 'grapes' table on the 'Grape' column to access grape color information.", "Filter the results to include only wines made from white grapes by adding a WHERE clause for grapes.Color = 'white'.", "Group the results by Winery to count the number of wines produced by each winery.", "Use COUNT(*) to count the number of wines for each winery.", "Order the results in descending order based on the count of wines to find the top producers.", "Limit the results to the top 3 wineries using LIMIT 3."], "gold_sql": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  'White' GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT Winery, COUNT(*) as WineCount\nFROM wine\nJOIN grapes ON wine.Grape = grapes.Grape\nWHERE grapes.Color = 'white'\nGROUP BY Winery\nORDER BY WineCount DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\"\n}\n"}
{"sample_id": "train.6597", "db_id": "wine_1", "question": "Find the county where produces the most number of wines with score higher than 90.", "rationale": ["We need to find the county that produces the most wines with a score higher than 90.", "To do this, we will join the 'wine' table with the 'appellations' table on the 'Appelation' column, as this will allow us to access the county information for each wine.", "We will filter the wines to only include those with a score greater than 90 using a WHERE clause.", "Next, we will group the results by county to count the number of wines produced in each county using COUNT(w.No).", "To find the county with the most wines, we will order the results in descending order based on the count of wines and limit the results to 1."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1", "source_tables": ["wine", "appellations"], "pred_sql": "SELECT a.County, COUNT(w.No) AS WineCount\nFROM wine w\nJOIN appellations a ON w.Appelation = a.Appelation\nWHERE w.Score > 90\nGROUP BY a.County\nORDER BY WineCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\"\n}\n"}
{"sample_id": "train.6626", "db_id": "driving_school", "question": "Show the detail of vehicle with id 1.", "rationale": ["Identify the table that contains vehicle details, which is the Vehicles table.", "Determine the specific vehicle we want to retrieve details for, which is identified by vehicle_id '1'.", "Construct a SQL SELECT statement to retrieve all columns from the Vehicles table where the vehicle_id matches '1'."], "gold_sql": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;", "source_tables": ["vehicles"], "pred_sql": "SELECT * FROM Vehicles WHERE vehicle_id = '1';", "hint": "\n"}
{"sample_id": "train.6650", "db_id": "driving_school", "question": "How many staff live in state Georgia?", "rationale": ["Identify the relevant tables: Staff and Addresses.", "Determine the relationship between Staff and Addresses using the foreign key (staff_address_id).", "Count the number of staff members who live in Georgia by filtering the Addresses table on the state_province_county column.", "Use COUNT(*) to get the total number of staff that meet the criteria."], "gold_sql": "SELECT count(*) FROM Addresses WHERE state_province_county = 'Georgia';", "source_tables": ["addresses"], "pred_sql": "SELECT COUNT(*) AS staff_count \nFROM Staff \nJOIN Addresses ON Staff.staff_address_id = Addresses.address_id \nWHERE Addresses.state_province_county = 'Georgia';", "hint": "\n"}
{"sample_id": "train.6665", "db_id": "driving_school", "question": "What is the status code, phone number, and email address of the customer whose last name is Kohler or whose first name is Marina?", "rationale": ["Identify the relevant table: The question pertains to customer information, so we will use the Customers table.", "Determine the required columns: The question asks for the status code, phone number, and email address of the customer.", "Construct the SELECT statement: We will select customer_status_code, phone_number, and email_address from the Customers table.", "Add the WHERE clause: We need to filter the results to include customers whose last name is 'Kohler' or whose first name is 'Marina'.", "Combine all parts to form the complete SQL query."], "gold_sql": "SELECT customer_status_code ,  cell_mobile_phone_number ,  email_address FROM Customers WHERE first_name = 'Marina' OR last_name  =  'Kohler'", "source_tables": ["customers"], "pred_sql": "SELECT customer_status_code, phone_number, email_address \nFROM Customers \nWHERE last_name = 'Kohler' OR first_name = 'Marina';", "hint": "\n"}
{"sample_id": "train.6676", "db_id": "driving_school", "question": "How many lessons taken by customer with first name as Rylan and last name as Goodwin were completed?", "rationale": ["Identify the relevant tables: Lessons and Customers.", "We need to count the number of lessons, so we will use the COUNT() function.", "We need to filter the lessons based on the customer's first and last name, which requires a JOIN between the Lessons and Customers tables.", "The WHERE clause will specify the first name as 'Rylan' and the last name as 'Goodwin'.", "Additionally, we need to filter for completed lessons, so we will check the lesson_status_code for 'completed'.", "Finally, we will select the count of completed lessons for the specified customer."], "gold_sql": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = 'Rylan' AND T2.last_name = 'Goodwin' AND T1.lesson_status_code = 'Completed';", "source_tables": ["lessons", "customers"], "pred_sql": "SELECT COUNT(*) AS completed_lessons_count\nFROM Lessons\nJOIN Customers ON Lessons.customer_id = Customers.customer_id\nWHERE Customers.first_name = 'Rylan' AND Customers.last_name = 'Goodwin' AND Lessons.lesson_status_code = 'completed';", "hint": "\n"}
{"sample_id": "train.6688", "db_id": "driving_school", "question": "Which city does has most number of customers?", "rationale": ["Identify the relevant tables: Customers and Addresses.", "Join the Customers table with the Addresses table on the customer_address_id and address_id fields to get the city for each customer.", "Group the results by city to count the number of customers in each city.", "Order the results in descending order based on the count of customers to find the city with the most customers.", "Limit the results to 1 to get only the city with the highest number of customers."], "gold_sql": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "customers"], "pred_sql": "SELECT a.city, COUNT(c.customer_id) AS customer_count\nFROM Customers c\nJOIN Addresses a ON c.customer_address_id = a.address_id\nGROUP BY a.city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities where customers are located, derived from the 'Customers' and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6711", "db_id": "driving_school", "question": "What are the last names that are used by customers and staff?", "rationale": ["Identify the tables that contain last names: Customers and Staff.", "Select the last_name column from the Customers table.", "Select the last_name column from the Staff table.", "Use UNION to combine the results from both tables, ensuring distinct last names are returned."], "gold_sql": "SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff", "source_tables": ["staff", "customers"], "pred_sql": "SELECT DISTINCT last_name FROM Customers UNION SELECT DISTINCT last_name FROM Staff;", "hint": "\n"}
{"sample_id": "train.6714", "db_id": "driving_school", "question": "What is the id and detail of the vehicle used in lessons for most of the times?", "rationale": ["Identify the relevant tables: We need to look at the 'Lessons' table to find out which vehicles are used in lessons.", "We need to group the results by 'vehicle_id' to count how many times each vehicle is used in lessons.", "Use the COUNT function to count the number of lessons for each vehicle.", "Order the results in descending order based on the count to find the vehicle used the most.", "Limit the results to 1 to get only the vehicle used in lessons the most times."], "gold_sql": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["lessons", "vehicles"], "pred_sql": "SELECT vehicle_id, vehicle_details\nFROM Lessons\nGROUP BY vehicle_id\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the table that contains faculty information, which is the Faculty table.", "Determine the column that stores the gender of faculty members, which is the 'Sex' column.", "Formulate a SQL query to select the 'FacID' of faculty members where 'Sex' is equal to 'Male'."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "pred_sql": "SELECT FacID FROM Faculty WHERE Sex = 'Male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\"\n}\n"}
{"sample_id": "train.6734", "db_id": "activity_1", "question": "What are the first name and last name of all the instructors?", "rationale": ["Identify the table that contains the information about instructors, which is the 'Faculty' table.", "Determine the columns needed for the output, which are 'Fname' (first name) and 'Lname' (last name).", "Construct the SQL SELECT statement to retrieve the specified columns from the 'Faculty' table."], "gold_sql": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  'Instructor'", "source_tables": ["faculty"], "pred_sql": "SELECT Fname, Lname FROM Faculty;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\"\n}\n"}
{"sample_id": "train.6737", "db_id": "activity_1", "question": "Which building has most faculty members?", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their building locations.", "Count the number of faculty members in each building: Use COUNT(FacID) to count the number of faculty members grouped by the Building column.", "Group the results by building: Use GROUP BY Building to aggregate the counts for each building.", "Order the results by the count of faculty members in descending order: Use ORDER BY FacultyCount DESC to sort the buildings by the number of faculty members.", "Limit the results to the top building: Use LIMIT 1 to return only the building with the most faculty members."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(FacID) AS FacultyCount \nFROM Faculty \nGROUP BY Building \nORDER BY FacultyCount DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The results are ordered by the number of faculty members in each building in descending order, and the placeholder allows the user to specify the maximum number of buildings to return.\"\n}\n"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["Identify the relevant table: Faculty, which contains information about faculty members including their rank and gender.", "Filter the records to include only those faculty members who are assistant professors by using the WHERE clause with Rank = 'Assistant Professor'.", "Group the results by the gender of the faculty members using GROUP BY Sex to count the number of male and female assistant professors.", "Use COUNT(*) to count the number of faculty members in each gender group."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) AS NumberOfProfessors\nFROM Faculty\nWHERE Rank = 'Assistant Professor'\nGROUP BY Sex;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\"\n}\n"}
{"sample_id": "train.6748", "db_id": "activity_1", "question": "How many male and female assistant professors do we have?", "rationale": ["Identify the relevant table: Faculty, which contains information about faculty members including their rank and gender.", "Filter the faculty members to only include those with the rank of 'Assistant Professor'.", "Group the results by the 'Sex' column to count the number of male and female assistant professors.", "Use the COUNT function to get the number of faculty members for each gender."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) AS Count\nFROM Faculty\nWHERE Rank = 'Assistant Professor'\nGROUP BY Sex;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\"\n}\n"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the tables involved: We need to find the advisor of a student named Linda Smith, which involves the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that references the 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the SELECT statement: We want to retrieve the first name (Fname) and last name (Lname) of the faculty member who is the advisor.", "Add the JOIN clause: We need to join the Faculty table with the Student table on the condition that the Faculty's FacID matches the Student's Advisor.", "Add the WHERE clause: We need to filter the results to only include the student named Linda Smith by checking both the first name and last name."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Fname, Lname \nFROM Faculty \nJOIN Student ON Faculty.FacID = Student.Advisor \nWHERE Student.Fname = 'Linda' AND Student.Lname = 'Smith';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\"\n}\n"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["We need to find the IDs of students whose advisors are professors.", "The 'Student' table contains the 'Advisor' column which references the 'FacID' in the 'Faculty' table.", "To find students with professors as advisors, we will perform a JOIN between the 'Student' and 'Faculty' tables on the condition that 'Student.Advisor' matches 'Faculty.FacID'.", "We will select the distinct 'StuID' from the 'Student' table to ensure we get unique student IDs."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT DISTINCT Student.StuID\nFROM Student\nJOIN Faculty ON Student.Advisor = Faculty.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\"\n}\n"}
{"sample_id": "train.6752", "db_id": "activity_1", "question": "Which students have professors as their advisors? Find their student ids.", "rationale": ["Identify the tables involved: We need to find students and their advisors, so we will use the 'Student' and 'Faculty' tables.", "Determine the relationship: The 'Advisor' column in the 'Student' table references the 'FacID' in the 'Faculty' table, indicating which faculty member is the advisor for each student.", "Construct the SQL query: We will select the 'StuID' from the 'Student' table and join it with the 'Faculty' table on the condition that 'Student.Advisor' matches 'Faculty.FacID'."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN Faculty ON Student.Advisor = Faculty.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\"\n}\n"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the relevant tables: We need to retrieve student information, which is in the 'Student' table, and we also need to filter based on the advisor's name, which is in the 'Faculty' table.", "Determine the relationship: The 'Student' table has a foreign key 'Advisor' that references 'FacID' in the 'Faculty' table. This means we can join these two tables on this key.", "Select the required fields: We need the first name and last name of the students, which are 'Fname' and 'LName' from the 'Student' table.", "Filter the results: We need to filter the faculty members to find the one with the first name 'Michael' and last name 'Goodrich'.", "Construct the SQL query: Using a JOIN to combine the 'Student' and 'Faculty' tables, selecting the appropriate fields, and applying the WHERE clause for filtering."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT S.Fname, S.LName \nFROM Student S \nJOIN Faculty F ON S.Advisor = F.FacID \nWHERE F.Fname = 'Michael' AND F.Lname = 'Goodrich';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\"\n}\n"}
{"sample_id": "train.6756", "db_id": "activity_1", "question": "What are the faculty id and the number of students each faculty has?", "rationale": ["We need to find the faculty ID and the number of students associated with each faculty member.", "To achieve this, we will join the 'Faculty' table with the 'Faculty_Participates_in' table to link faculty members to the activities they participate in.", "Next, we will join the 'Participates_in' table to link those activities to the students who participate in them.", "We will use a LEFT JOIN to ensure we include faculty members even if they have no students participating in their activities.", "Finally, we will group the results by faculty ID and count the number of students for each faculty member."], "gold_sql": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Faculty.FacID, COUNT(Participates_in.stuid) AS student_count\nFROM Faculty\nLEFT JOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID\nLEFT JOIN Participates_in ON Faculty_Participates_in.actid = Participates_in.actid\nGROUP BY Faculty.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\"\n}\n"}
{"sample_id": "train.6758", "db_id": "activity_1", "question": "How many students are advised by each rank of faculty? List the rank and the number of students.", "rationale": ["We need to find out how many students are advised by each rank of faculty.", "To do this, we will join the 'Faculty' table with the 'Student' table based on the advisor relationship, which is represented by the 'Advisor' column in the 'Student' table and the 'FacID' column in the 'Faculty' table.", "We will select the 'Rank' from the 'Faculty' table and count the number of students (using 'StuID') from the 'Student' table.", "Finally, we will group the results by the faculty rank to get the count of students for each rank."], "gold_sql": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Faculty.Rank, COUNT(Student.StuID) AS NumberOfStudents\nFROM Faculty\nJOIN Student ON Faculty.FacID = Student.Advisor\nGROUP BY Faculty.Rank;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\"\n}\n"}
{"sample_id": "train.6761", "db_id": "activity_1", "question": "Show the ids for all the faculty members who have at least 2 students.", "rationale": ["We need to find faculty members who have at least 2 students assigned to them as their advisor.", "The 'Student' table contains a column 'Advisor' which indicates the faculty member assigned to each student.", "We can group the students by their 'Advisor' and count the number of students for each advisor using COUNT(StuID).", "To find advisors with at least 2 students, we will use the HAVING clause with COUNT(StuID) >= 2.", "The result will give us the 'Advisor' IDs which correspond to faculty members in the 'Faculty' table.", "Finally, we will select the 'FacID' from the 'Faculty' table where the 'FacID' is in the list of advisors with at least 2 students."], "gold_sql": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  2", "source_tables": ["faculty", "student"], "pred_sql": "SELECT FacID FROM Faculty WHERE FacID IN (SELECT Advisor FROM Student GROUP BY Advisor HAVING COUNT(StuID) >= 2)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\"\n}\n"}
{"sample_id": "train.6777", "db_id": "activity_1", "question": "Show the names of all the activities Mark Giuliano participates in.", "rationale": ["Identify the tables involved: Activity, Faculty_Participates_in, and Faculty.", "We need to find activities that a specific faculty member, Mark Giuliano, participates in.", "Join the Activity table with Faculty_Participates_in on actid to link activities with faculty participation.", "Join the Faculty table to get the names of faculty members based on their unique identifier (FacID).", "Filter the results where the first name is 'Mark' and the last name is 'Giuliano' to get the specific faculty member's activities."], "gold_sql": "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  'Mark' AND T1.lname  =  'Giuliano'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Activity.activity_name \nFROM Activity \nJOIN Faculty_Participates_in ON Activity.actid = Faculty_Participates_in.actid \nJOIN Faculty ON Faculty_Participates_in.FacID = Faculty.FacID \nWHERE Faculty.Fname = 'Mark' AND Faculty.Lname = 'Giuliano';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\"\n}\n"}
{"sample_id": "train.6779", "db_id": "activity_1", "question": "Show the first and last name of all the faculty members who participated in some activity, together with the number of activities they participated in.", "rationale": ["We need to retrieve the first and last names of faculty members who participated in activities.", "The relevant tables for this query are 'Faculty' and 'Faculty_Participates_in'.", "We will join these two tables on the 'FacID' column to link faculty members with their activities.", "To count the number of activities each faculty member participated in, we will use the COUNT() function on the 'actid' from the 'Faculty_Participates_in' table.", "We will group the results by 'FacID', 'Fname', and 'Lname' to ensure we get a count for each faculty member."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname, Faculty.Lname, COUNT(Faculty_Participates_in.actid) AS num_activities\nFROM Faculty\nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID\nGROUP BY Faculty.FacID, Faculty.Fname, Faculty.Lname;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\"\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: We need to find students who participate in activities, so we will use the 'Participates_in' and 'Student' tables.", "Determine the columns needed: We need the student IDs (stuid) from the 'Participates_in' table and we need to filter based on the age of the students from the 'Student' table.", "Join the tables: We will join 'Participates_in' with 'Student' on the student ID to get the necessary information about the students who participate in activities.", "Apply the filter: We will add a WHERE clause to filter students who are under 20 years old."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT p.stuid \nFROM Participates_in p \nJOIN Student s ON p.stuid = s.StuID \nWHERE s.Age < 20;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\"\n}\n"}
{"sample_id": "train.6797", "db_id": "activity_1", "question": "Find the first names of professors who are not playing Canoeing or Kayaking.", "rationale": ["Identify the main table to query from, which is the Faculty table to get the first names of professors.", "We need to filter out professors who are participating in Canoeing or Kayaking activities.", "To do this, we will use a subquery that selects the FacID of faculty members participating in these activities.", "The subquery will join the Faculty_Participates_in table with the Activity table to filter based on the activity names.", "The main query will select distinct first names from the Faculty table where the FacID is not in the results of the subquery."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT DISTINCT Faculty.Fname \nFROM Faculty \nWHERE Faculty.FacID NOT IN (\n    SELECT Faculty_Participates_in.FacID \n    FROM Faculty_Participates_in \n    JOIN Activity ON Faculty_Participates_in.actid = Activity.actid \n    WHERE Activity.activity_name IN ('Canoeing', 'Kayaking')\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\"\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the main entities involved: Faculty and their activities.", "We need to find faculty members who do not participate in specific activities (Canoeing and Kayaking).", "Use a subquery to find faculty IDs that are associated with Canoeing or Kayaking activities.", "The subquery will join the Faculty_Participates_in table with the Activity table to filter based on activity names.", "The main query will select distinct first names from the Faculty table where the faculty ID is not in the list obtained from the subquery."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT DISTINCT Faculty.Fname \nFROM Faculty \nWHERE Faculty.FacID NOT IN (\n    SELECT Faculty_Participates_in.FacID \n    FROM Faculty_Participates_in \n    JOIN Activity ON Faculty_Participates_in.actid = Activity.actid \n    WHERE Activity.activity_name IN ('Canoeing', 'Kayaking')\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\"\n}\n"}
{"sample_id": "train.6799", "db_id": "activity_1", "question": "Find the first names of the faculty members who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables involved: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members who participate in specific activities, which requires joining the Faculty table with the Faculty_Participates_in table on the FacID.", "Next, we join the Activity table to filter the activities by their names (Canoeing and Kayaking).", "The final output should select the first names (Fname) of the faculty members who meet the criteria."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname \nFROM Faculty \nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID \nJOIN Activity ON Faculty_Participates_in.actid = Activity.actid \nWHERE Activity.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\"\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables involved: We need to find student IDs from the Participates_in table and the activity names from the Activity table.", "Determine the relationship: The Participates_in table has a foreign key actid that links to the Activity table's actid.", "Filter the activities: We are specifically looking for students who participate in 'Canoeing' and 'Kayaking'.", "Construct the SQL query: Use a SELECT statement to get the student IDs, join the Participates_in table with the Activity table on actid, and filter the results based on the activity names."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT p.stuid \nFROM Participates_in p \nJOIN Activity a ON p.actid = a.actid \nWHERE a.activity_name IN ('Canoeing', 'Kayaking');", "hint": "\n"}
{"sample_id": "train.6825", "db_id": "flight_4", "question": "Find the number of routes operated by American Airlines.", "rationale": ["Identify the relevant table: The 'routes' table contains information about the routes operated by airlines.", "Determine the condition: We need to find routes operated by 'American Airlines'.", "Use a subquery to find the airline ID (alid) for 'American Airlines' from the 'airlines' table.", "Count the number of routes in the 'routes' table where the airline ID matches the one found in the subquery."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT COUNT(*) AS number_of_routes \nFROM routes \nWHERE alid = (SELECT alid FROM airlines WHERE name = 'American Airlines');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.6826", "db_id": "flight_4", "question": "How many routes does American Airlines operate?", "rationale": ["Identify the airline of interest: American Airlines.", "Find the unique identifier (alid) for American Airlines from the airlines table.", "Count the number of routes in the routes table where the alid matches that of American Airlines."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT COUNT(*) AS route_count \nFROM routes \nWHERE alid = (SELECT alid FROM airlines WHERE name = 'American Airlines')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.6831", "db_id": "flight_4", "question": "Find the name, city, and country of the airport that has the highest latitude.", "rationale": ["To find the airport with the highest latitude, we need to look at the 'y' coordinate in the airports table, as it represents the latitude.", "We will use a subquery to select the 'apid' of the airport with the maximum 'y' value.", "The outer query will then select the 'name', 'city', and 'country' of the airport that corresponds to this 'apid'.", "The final SQL query combines these elements to retrieve the desired information."], "gold_sql": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT 1", "source_tables": ["airports"], "pred_sql": "SELECT name, city, country FROM airports WHERE apid = (SELECT apid FROM airports ORDER BY y DESC LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\"\n}\n"}
{"sample_id": "train.6834", "db_id": "flight_4", "question": "What is the name and city of the airport that the most routes end at?", "rationale": ["Identify the relevant tables: 'airports' for airport details and 'routes' for route information.", "We need to find the airport that has the most routes ending at it, which means we will focus on the 'dst_apid' in the 'routes' table.", "Join the 'airports' table with the 'routes' table on the destination airport ID ('dst_apid').", "Group the results by the airport ID to count the number of routes for each airport.", "Order the results in descending order based on the count of routes to find the airport with the most routes.", "Limit the results to 1 to get only the airport with the highest count."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, airports.city\nFROM airports\nJOIN routes ON airports.apid = routes.dst_apid\nGROUP BY airports.apid\nORDER BY COUNT(routes.rid) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\"\n}\n"}
{"sample_id": "train.6838", "db_id": "flight_4", "question": "What is the name and city of the airport from most of the routes start?", "rationale": ["We need to find the airport that most routes start from, which means we need to count the number of routes for each source airport.", "To do this, we will join the 'routes' table with the 'airports' table on the source airport ID ('src_apid').", "We will select the airport name and city from the 'airports' table.", "We will group the results by the airport name and city to get the count of routes for each airport.", "We will order the results by the count of routes in descending order to get the airport with the most routes at the top.", "Finally, we will limit the results to 1 to get only the airport with the most routes."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, airports.city\nFROM routes\nJOIN airports ON routes.src_apid = airports.apid\nGROUP BY airports.name, airports.city\nORDER BY COUNT(routes.rid) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\"\n}\n"}
{"sample_id": "train.6841", "db_id": "flight_4", "question": "Which countries has the most number of airlines?", "rationale": ["Identify the table that contains information about airlines, which is the 'airlines' table.", "We need to count the number of airlines for each country, so we will use the COUNT() function.", "To group the results by country, we will use the GROUP BY clause on the 'country' column.", "To get the countries with the most airlines, we will order the results in descending order using ORDER BY airline_count DESC."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country, COUNT(*) AS airline_count\nFROM airlines\nGROUP BY country\nORDER BY airline_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\"\n}\n"}
{"sample_id": "train.6842", "db_id": "flight_4", "question": "What is the name of the country with the most number of home airlines?", "rationale": ["We need to find the country with the most number of home airlines.", "To do this, we will count the number of airlines grouped by their country.", "We will use the COUNT() function to count the number of airlines for each country.", "We will group the results by the 'country' column in the airlines table.", "To get the country with the most airlines, we will order the results in descending order based on the count of airlines.", "Finally, we will limit the results to just one entry to get the country with the highest count."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country, COUNT(*) as airline_count FROM airlines GROUP BY country ORDER BY airline_count DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\"\n}\n"}
{"sample_id": "train.6858", "db_id": "flight_4", "question": "What are the cities that have more than 2 airports sorted by number of airports?", "rationale": ["Identify the relevant table: The 'airports' table contains information about airports, including their cities.", "Count the number of airports in each city: Use the COUNT function to count the number of airport IDs (apid) for each city.", "Group the results by city: Use the GROUP BY clause to group the results based on the city.", "Filter cities with more than 2 airports: Use the HAVING clause to filter out cities that have 2 or fewer airports.", "Sort the results: Use the ORDER BY clause to sort the cities by the number of airports in descending order."], "gold_sql": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)", "source_tables": ["airports"], "pred_sql": "SELECT city, COUNT(apid) AS airport_count \nFROM airports \nGROUP BY city \nHAVING COUNT(apid) > 2 \nORDER BY airport_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\"\n}\n"}
{"sample_id": "train.6862", "db_id": "flight_4", "question": "For each  airport name, how many routes start at that airport, ordered from most to least?", "rationale": ["We need to count the number of routes that start at each airport.", "To do this, we will join the 'airports' table with the 'routes' table on the airport ID, where the airport ID in the 'airports' table matches the source airport ID in the 'routes' table.", "We will select the airport name and the count of routes (using COUNT(routes.rid)) as 'route_count'.", "We will group the results by the airport name to get the count for each airport.", "Finally, we will order the results by 'route_count' in descending order to show the airports with the most routes first."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, COUNT(routes.rid) AS route_count \nFROM airports \nJOIN routes ON airports.apid = routes.src_apid \nGROUP BY airports.name \nORDER BY route_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\"\n}\n"}
{"sample_id": "train.6867", "db_id": "flight_4", "question": "For each country and airline name, how many routes are there?", "rationale": ["We need to count the number of routes for each airline grouped by their country.", "To achieve this, we will use a SQL SELECT statement that includes the country and airline name from the airlines table.", "We will join the routes table to the airlines table using the airline ID (alid) as the foreign key.", "We will use a LEFT JOIN to ensure we include all airlines even if they have no routes.", "We will use the COUNT function to count the number of routes (rid) for each airline.", "Finally, we will group the results by both the country and the airline name to get the desired counts."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT airlines.country, airlines.name, COUNT(routes.rid) AS route_count\nFROM airlines\nLEFT JOIN routes ON airlines.alid = routes.alid\nGROUP BY airlines.country, airlines.name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\"\n}\n"}
{"sample_id": "train.6868", "db_id": "flight_4", "question": "What is the total number of routes for each country and airline in that country?", "rationale": ["We need to find the total number of routes for each country and airline.", "To do this, we will join the 'routes' table with the 'airlines' table on the airline ID (alid).", "We will select the country from the airlines table and the airline name from the routes table.", "We will count the number of routes (rid) for each combination of country and airline.", "Finally, we will group the results by country and airline to get the total count for each combination."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT a.country, r.airline, COUNT(r.rid) AS total_routes\nFROM routes r\nJOIN airlines a ON r.alid = a.alid\nGROUP BY a.country, r.airline;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\"\n}\n"}
{"sample_id": "train.6873", "db_id": "flight_4", "question": "Find the number of routes that have destination John F Kennedy International Airport.", "rationale": ["Identify the requirement: We need to find the number of routes that have a specific destination airport, which is John F Kennedy International Airport.", "The relevant table for this query is 'routes', as it contains information about the routes and their destination airports.", "We will use the COUNT() function to count the number of routes that match the specified destination.", "The WHERE clause will filter the results to only include routes where the destination airport name (dst_ap) is 'John F Kennedy International Airport'.", "Finally, we will select the count of these routes."], "gold_sql": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'", "source_tables": ["airports", "routes"], "pred_sql": "SELECT COUNT(*) AS route_count \nFROM routes \nWHERE dst_ap = 'John F Kennedy International Airport';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\"\n}\n"}
{"sample_id": "train.6880", "db_id": "flight_4", "question": "What is the name of the airline with the most routes?", "rationale": ["We need to find the airline with the most routes.", "To do this, we will join the 'airlines' table with the 'routes' table on the airline ID (alid).", "We will group the results by the airline name to count the number of routes each airline has.", "We will order the results in descending order based on the count of routes.", "Finally, we will limit the results to 1 to get the airline with the most routes."], "gold_sql": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT airline FROM airlines JOIN routes ON airlines.alid = routes.alid GROUP BY airline ORDER BY COUNT(routes.rid) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\"\n}\n"}
{"sample_id": "train.6883", "db_id": "flight_4", "question": "Find the busiest destination airport that runs most number of routes in China.", "rationale": ["Identify the relevant tables: 'routes' for route information and 'airports' for airport details.", "We need to find the busiest destination airport in China, so we will focus on the 'dst_ap' (destination airport name) from the 'routes' table and join it with the 'airports' table to filter by country.", "Use a JOIN operation to connect 'routes' and 'airports' on the destination airport ID ('dst_apid' in 'routes' and 'apid' in 'airports').", "Filter the results to include only those airports located in China by using a WHERE clause on the 'country' column of the 'airports' table.", "Group the results by destination airport name ('dst_ap') and count the number of routes for each airport using COUNT(rid).", "Order the results in descending order based on the count of routes to find the busiest airport.", "Limit the results to 1 to get only the busiest destination airport."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT dst_ap, COUNT(rid) AS route_count\nFROM routes r\nJOIN airports a ON r.dst_apid = a.apid\nWHERE a.country = 'China'\nGROUP BY dst_ap\nORDER BY route_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\"\n}\n"}
{"sample_id": "train.6884", "db_id": "flight_4", "question": "What is the name of the airport that is the destination of the most number of routes that start in China?", "rationale": ["Identify the relevant tables: 'routes' for route information and 'airports' for airport details.", "We need to find the destination airport name ('dst_ap') that has the most routes starting from China.", "Join the 'routes' table with the 'airports' table on the destination airport ID ('dst_apid' = 'apid').", "Filter the results to include only those routes where the source airport is in China (using the country column in the airports table).", "Group the results by destination airport name to count the number of routes for each destination.", "Order the results in descending order based on the count of routes to find the most popular destination.", "Limit the results to 1 to get only the top destination airport."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT dst_ap, COUNT(*) as route_count\nFROM routes r\nJOIN airports a ON r.dst_apid = a.apid\nWHERE a.country = 'China'\nGROUP BY dst_ap\nORDER BY route_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\"\n}\n"}
{"sample_id": "train.6980", "db_id": "culture_company", "question": "Show all publishers which do not have a book in 1989.", "rationale": ["We need to find all publishers that do not have a book published in 1989.", "First, we will select distinct publishers from the 'book_club' table.", "Next, we will create a subquery to find all publishers that have published a book in 1989.", "We will use the NOT IN clause to filter out those publishers from the main query, ensuring we only get publishers without books in 1989."], "gold_sql": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  1989", "source_tables": ["book_club"], "pred_sql": "SELECT DISTINCT Publisher \nFROM book_club \nWHERE Publisher NOT IN (\n    SELECT DISTINCT Publisher \n    FROM book_club \n    WHERE Year = '1989'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of publishers from the 'book_club' table, grouped by the publisher's name. The results are ordered by the number of books published by each publisher in descending order, with a limit on the number of publishers returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6990", "db_id": "culture_company", "question": "Show all director names who have a movie in the year 1999 or 2000.", "rationale": ["Identify the table that contains the director information, which is the 'movie' table.", "Determine the relevant column for the year of the movie, which is 'Year'.", "Specify the years of interest, which are 1999 and 2000.", "Use the SQL 'SELECT' statement to retrieve the 'Director' column from the 'movie' table.", "Use 'DISTINCT' to ensure that each director is listed only once, even if they have multiple movies in those years.", "Use the 'WHERE' clause to filter the results to only include movies from the years 1999 and 2000."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6991", "db_id": "culture_company", "question": "Which directors had a movie in either 1999 or 2000?", "rationale": ["Identify the relevant table: The question pertains to movie directors, so we will focus on the 'movie' table.", "Determine the columns needed: We need the 'Director' column to answer the question.", "Filter the results: We need to filter the movies based on the years 1999 and 2000.", "Use the DISTINCT keyword: Since we want to know which directors had movies in those years, we should use DISTINCT to avoid duplicate entries for directors who may have multiple movies in those years."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6996", "db_id": "culture_company", "question": "Show the movie titles and book titles for all companies in China.", "rationale": ["Identify the tables needed: culture_company, movie, and book_club.", "Determine the columns to select: movie titles and book titles.", "Establish the relationships between the tables using JOINs: culture_company to movie and culture_company to book_club.", "Filter the results to only include companies in China using a WHERE clause."], "gold_sql": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  'China'", "source_tables": ["culture_company", "movie", "book_club"], "pred_sql": "SELECT movie.Title AS Movie_Title, book_club.Book_Title AS Book_Title\nFROM culture_company\nJOIN movie ON culture_company.movie_id = movie.movie_id\nJOIN book_club ON culture_company.book_club_id = book_club.book_club_id\nWHERE culture_company.Company_name = 'China';", "hint": "\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant tables: 'cars_data' for horsepower and 'car_names' for car models.", "Join the 'cars_data' table with the 'car_names' table on the 'Id' and 'MakeId' columns to associate horsepower with car models.", "Select the 'Model' and 'Horsepower' columns from the joined tables.", "Order the results by 'Horsepower' in ascending order to find the minimum.", "Limit the results to 1 to get only the model with the minimum horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId ORDER BY Horsepower ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.103", "db_id": "car_1", "question": "Which distinct car models are the produced after 1980?", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data.", "We need to select distinct car models, so we will use SELECT DISTINCT.", "Join the model_list table with the car_names table on the Model column to get the car names associated with each model.", "Then, join the resulting table with the cars_data table on the MakeId to access the manufacturing year of each car model.", "Filter the results to include only those models manufactured after 1980 using the WHERE clause."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "pred_sql": "SELECT DISTINCT ml.Model \nFROM model_list ml \nJOIN car_names cn ON ml.Model = cn.Model \nJOIN cars_data cd ON cn.MakeId = cd.Id \nWHERE cd.Year > 1980;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.106", "db_id": "car_1", "question": "What is the name of each continent and how many car makers are there in each one?", "rationale": ["Identify the tables needed: continents, countries, and car_makers.", "We need to count the number of car makers for each continent, so we will use the COUNT() function.", "Join the continents table with the countries table on the ContId and Continent columns.", "Then, join the countries table with the car_makers table on the CountryId and Country columns.", "Group the results by continent to get the count of car makers for each continent."], "gold_sql": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;", "source_tables": ["countries", "car_makers", "continents"], "pred_sql": "SELECT c.Continent, COUNT(cm.Id) AS CarMakerCount\nFROM continents c\nJOIN countries co ON c.ContId = co.Continent\nJOIN car_makers cm ON co.CountryId = cm.Country\nGROUP BY c.Continent;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: 'cars_data' for car performance data and 'car_names' for car make and model information.", "We need to find the 'Accelerate' value for a specific car make and model, which is 'amc hornet sportabout'.", "Join the 'cars_data' table with the 'car_names' table on the appropriate foreign key (cars_data.Id = car_names.MakeId).", "Filter the results to only include rows where the 'Model' is 'hornet sportabout' and the 'Make' is 'amc'.", "Select the 'Accelerate' column from the resulting joined table."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT cars_data.Accelerate \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE car_names.Model = 'hornet sportabout' AND car_names.Make = 'amc'", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the relevant tables: car_makers and countries.", "We need to count distinct car makers, so we will use COUNT(DISTINCT car_makers.Id).", "To filter car makers based in France, we need to join the car_makers table with the countries table on the country identifier.", "The WHERE clause will filter the results to only include countries where the CountryName is 'France'."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(DISTINCT car_makers.Id) AS NumberOfCarMakers\nFROM car_makers\nJOIN countries ON car_makers.Country = countries.CountryId\nWHERE countries.CountryName = 'France';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.114", "db_id": "car_1", "question": "What is the number of makers of care in France?", "rationale": ["Identify the relevant tables: We need to find the number of car makers in France, so we will use the 'car_makers' and 'countries' tables.", "Determine the relationship: The 'car_makers' table has a foreign key 'Country' that references 'countries.CountryId'. We will join these two tables on this key.", "Filter for France: We need to filter the results to only include car makers based in France. This will be done using a WHERE clause that checks for 'countries.CountryName = 'France'.", "Count distinct makers: We want the number of unique car makers, so we will use COUNT(DISTINCT car_makers.Id) to get the count of unique car maker IDs."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(DISTINCT car_makers.Id) AS NumberOfMakers\nFROM car_makers\nJOIN countries ON car_makers.Country = countries.CountryId\nWHERE countries.CountryName = 'France';", "hint": "\n"}
{"sample_id": "dev.115", "db_id": "car_1", "question": "How many car models are produced in the usa?", "rationale": ["Identify the relevant tables: model_list, car_makers, and countries.", "We need to count distinct car models, so we will use COUNT(DISTINCT ml.Model).", "Join the model_list table with the car_makers table on the Maker column.", "Join the car_makers table with the countries table on the Country column.", "Filter the results to include only those car makers based in the USA by adding a WHERE clause that checks for 'USA' in the CountryName column."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "pred_sql": "SELECT COUNT(DISTINCT ml.Model) AS NumberOfCarModels\nFROM model_list ml\nJOIN car_makers cm ON ml.Maker = cm.Id\nJOIN countries c ON cm.Country = c.CountryId\nWHERE c.CountryName = 'USA';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the countries in Europe by filtering the 'countries' table where the continent is Europe.", "Join the 'car_makers' table to the 'countries' table to find car manufacturers based in those countries.", "Create a subquery that counts the number of car manufacturers for each country by joining 'model_list' and 'car_makers' tables, grouping by the maker, and filtering to include only those with at least 3 manufacturers.", "Join this subquery back to the main query to filter countries that have at least 3 car manufacturers.", "Select the distinct country names from the resulting joined tables."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName\nFROM countries c\nJOIN car_makers cm ON c.CountryId = cm.Country\nJOIN (SELECT Maker, COUNT(*) as ManufacturerCount\n      FROM model_list ml\n      JOIN car_makers cm ON ml.Maker = cm.Id\n      GROUP BY ml.Maker\n      HAVING COUNT(*) >= 3) as subquery ON cm.Id = subquery.Maker\nWHERE c.Continent = (SELECT ContId FROM continents WHERE Continent = 'Europe')\nGROUP BY c.CountryName;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the relevant tables: 'cars_data' for horsepower and cylinders, and 'car_names' for the make of the car.", "We need to filter the results to only include car models with 3 cylinders, which will be done using a WHERE clause.", "To find the maximum horsepower, we will use the MAX() function on the 'Horsepower' column from the 'cars_data' table.", "We will join 'cars_data' with 'car_names' on the 'Id' and 'MakeId' columns to get the make of the car.", "Finally, we will group the results by the car make to ensure we get the maximum horsepower for each make."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(cars_data.Horsepower) AS MaxHorsepower, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Cylinders = 3 \nGROUP BY car_names.Make;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.133", "db_id": "car_1", "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.", "rationale": ["Identify the relevant tables: 'car_names' for car models and 'cars_data' for MPG.", "Join 'car_names' and 'cars_data' on the MakeId to access both model names and their MPG.", "Order the results by MPG in descending order to find the model with the highest fuel efficiency.", "Limit the results to 1 to get only the top model that saves the most gasoline."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, MPG FROM car_names JOIN cars_data ON car_names.MakeId = cars_data.Id ORDER BY MPG DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["Identify the relevant tables: We need to work with the 'car_makers' and 'model_list' tables to find car makers and their models.", "Join the tables: We will join 'car_makers' with 'model_list' on the 'Id' and 'Maker' columns respectively to associate each maker with their models.", "Group the results: We will group the results by the maker's Id and name to aggregate the number of models each maker has.", "Filter the results: We will use the HAVING clause to filter out makers that have more than 3 models."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(ml.ModelId) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.158", "db_id": "car_1", "question": "For a volvo model, how many cylinders does the version with least accelerate have?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car models.", "We need to filter for the model 'volvo' in the 'car_names' table.", "Join 'cars_data' and 'car_names' on the appropriate foreign key (MakeId).", "Select the 'Cylinders' column from the 'cars_data' table.", "Order the results by 'Accelerate' in ascending order to find the version with the least acceleration time.", "Limit the results to 1 to get only the top result."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT Cylinders FROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE car_names.Model = 'volvo' \nORDER BY cars_data.Accelerate ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.160", "db_id": "car_1", "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?", "rationale": ["Identify the requirement: We need to count the number of cars with an acceleration time greater than the car with the highest horsepower.", "To find the car with the most horsepower, we can use a subquery that selects the maximum horsepower from the 'cars_data' table.", "We then need to count the number of cars in the 'cars_data' table where the 'Accelerate' value is greater than the result of the subquery.", "The final SQL query combines these elements to count the cars that meet the specified condition."], "gold_sql": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "source_tables": ["cars_data"], "pred_sql": "SELECT COUNT(*) \nFROM cars_data \nWHERE Accelerate > (SELECT MAX(Horsepower) \n                    FROM cars_data)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car models.", "We need to filter the cars based on the number of cylinders, specifically those with 4 cylinders.", "We want to find the model with the largest horsepower, so we will use the MAX function on the 'Horsepower' column.", "We will join 'cars_data' with 'car_names' on the 'Id' and 'MakeId' columns to get the model names associated with the horsepower data.", "We will group the results by car model to apply the MAX function correctly and then order the results by horsepower in descending order to get the highest value first.", "Finally, we will limit the results to 1 to get only the model with the largest horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT car_names.Model, MAX(cars_data.Horsepower) AS MaxHorsepower\nFROM cars_data\nJOIN car_names ON cars_data.Id = car_names.MakeId\nWHERE cars_data.Cylinders = 4\nGROUP BY car_names.Model\nORDER BY MaxHorsepower DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.166", "db_id": "car_1", "question": "For all of the 4 cylinder cars, which model has the most horsepower?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car models.", "We need to filter the cars based on the number of cylinders, specifically looking for 4-cylinder cars.", "We want to find the model with the maximum horsepower, so we will use the MAX() function on the 'Horsepower' column.", "We will join 'cars_data' with 'car_names' on the appropriate foreign key to access the model names.", "We will group the results by car model to apply the MAX() function correctly and then order the results by horsepower in descending order to get the highest value.", "Finally, we will limit the results to 1 to get only the model with the most horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT car_names.Model, MAX(cars_data.Horsepower) AS MaxHorsepower\nFROM cars_data\nJOIN car_names ON cars_data.Id = car_names.MakeId\nWHERE cars_data.Cylinders = 4\nGROUP BY car_names.Model\nORDER BY MaxHorsepower DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.168", "db_id": "car_1", "question": "Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car make details.", "We need to select the 'MakeId' and 'Make' from the 'car_names' table.", "Join 'cars_data' with 'car_names' on the 'Id' and 'MakeId' to get the make details for each car.", "Filter the results to include only cars with less than 4 cylinders.", "Additionally, filter out cars that have horsepower equal to or greater than the minimum horsepower found in the 'cars_data' table."], "gold_sql": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  4;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT car_names.MakeId, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Cylinders < 4 \nAND cars_data.Horsepower > (SELECT MIN(Horsepower) FROM cars_data);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["Identify the relevant tables: car_makers, model_list, car_names, and cars_data.", "We need to find car makers that produce at least 2 models, so we will join car_makers with model_list on the Maker ID.", "Next, we will join model_list with car_names to get the make information.", "Then, we will join car_names with cars_data to count the number of cars produced by each maker.", "We will group the results by car maker ID and name to aggregate the counts.", "Use the HAVING clause to filter for makers that have at least 2 distinct models and more than 3 cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nJOIN car_names cn ON ml.Model = cn.Model\nJOIN cars_data cd ON cn.MakeId = cd.Id\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(DISTINCT ml.Model) >= 2 AND COUNT(cd.Id) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.180", "db_id": "flight_2", "question": "What country is Jetblue Airways affiliated with?", "rationale": ["Identify the relevant table: The 'airlines' table contains information about airlines, including their country affiliation.", "Determine the specific airline: The question asks about 'Jetblue Airways'.", "Construct the SQL query: We need to select the 'Country' column from the 'airlines' table where the 'Airline' column matches 'Jetblue Airways'."], "gold_sql": "SELECT Country FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "pred_sql": "SELECT Country FROM airlines WHERE Airline = 'Jetblue Airways';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.194", "db_id": "flight_2", "question": "Give the airline with abbreviation 'UAL'.", "rationale": ["Identify the relevant table: The 'airlines' table contains the abbreviation information.", "Determine the condition: We need to filter the results to find the airline with the abbreviation 'UAL'.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'airlines' table where the abbreviation matches 'UAL'."], "gold_sql": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  'UAL'", "source_tables": ["airlines"], "pred_sql": "SELECT * FROM airlines WHERE Abbreviation = 'UAL';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.214", "db_id": "flight_2", "question": "Give the number of Jetblue Airways flights.", "rationale": ["Identify the relevant table: The 'flights' table contains information about the flights, including the airline name.", "Determine the specific airline: The user is interested in 'Jetblue Airways'.", "Count the number of flights: Use the COUNT() function to count the number of records in the 'flights' table where the airline is 'Jetblue Airways'.", "Construct the SQL query: Combine the elements into a complete SQL query that counts the flights for Jetblue Airways."], "gold_sql": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = 'JetBlue Airways'", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT COUNT(*) AS NumberOfFlights FROM flights WHERE Airline = 'Jetblue Airways';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.225", "db_id": "flight_2", "question": "What is the code of airport that has the highest number of flights?", "rationale": ["Identify the relevant tables: 'flights' and 'airports'.", "Determine that we need to count the number of flights associated with each airport code.", "Use the 'SourceAirport' and 'DestAirport' from the 'flights' table to get all airport codes.", "Group the results by airport code to count the number of flights for each code.", "Combine the counts from both source and destination airports using UNION ALL.", "Order the results by the count of flights in descending order to find the airport with the highest number of flights.", "Limit the results to 1 to get only the airport code with the highest number of flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT SourceAirport AS AirportCode, COUNT(*) AS FlightCount\nFROM flights\nGROUP BY SourceAirport\nUNION ALL\nSELECT DestAirport AS AirportCode, COUNT(*) AS FlightCount\nFROM flights\nGROUP BY DestAirport\nORDER BY FlightCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.227", "db_id": "flight_2", "question": "What is the code of airport that has fewest number of flights?", "rationale": ["Identify the relevant tables: 'airports' and 'flights'.", "We need to find the airport code with the fewest number of flights.", "We can use the 'flights' table to count the number of flights for each airport code, both as a source and destination.", "To do this, we will group the results by 'SourceAirport' and 'DestAirport' and count the occurrences.", "We will combine the results from both source and destination using UNION to ensure we consider all flights.", "Finally, we will order the results by the count of flights in ascending order and limit the output to 1 to get the airport code with the fewest flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT AirportCode FROM flights GROUP BY SourceAirport UNION SELECT AirportCode FROM flights GROUP BY DestAirport ORDER BY COUNT(*) ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.229", "db_id": "flight_2", "question": "Which airline has most number of flights?", "rationale": ["Identify the relevant tables: 'airlines' and 'flights'.", "We need to count the number of flights for each airline, so we will use the COUNT() function on the 'FlightNo' column from the 'flights' table.", "Group the results by the 'Airline' column to aggregate the flight counts for each airline.", "Order the results in descending order based on the count of flights to find the airline with the most flights.", "Limit the results to 1 to get only the airline with the highest number of flights."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT Airline, COUNT(FlightNo) AS NumberOfFlights \nFROM flights \nGROUP BY Airline \nORDER BY NumberOfFlights DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.232", "db_id": "flight_2", "question": "What is the abbreviation of the airilne has the fewest flights and what country is it in?", "rationale": ["Identify the airline with the fewest flights by counting the number of flights for each airline in the 'flights' table.", "Use a subquery to group the flights by airline and count them, ordering the results in ascending order to find the airline with the least number of flights.", "Limit the results of the subquery to 1 to get only the airline with the fewest flights.", "Join the result of the subquery with the 'airlines' table to get the abbreviation and country of that airline."], "gold_sql": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT a.Abbreviation, a.Country\nFROM airlines a\nJOIN (\n    SELECT Airline, COUNT(*) AS FlightCount\n    FROM flights\n    GROUP BY Airline\n    ORDER BY FlightCount ASC\n    LIMIT 1\n) AS f ON a.Airline = f.Airline;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The placeholder in the LIMIT clause represents the maximum number of airport codes to return.\"\n}\n"}
{"sample_id": "dev.244", "db_id": "flight_2", "question": "Which airlines have less than 200 flights?", "rationale": ["Identify the relevant tables: 'airlines' and 'flights'.", "We need to find airlines with less than 200 flights, so we will join the 'airlines' table with the 'flights' table on the airline name.", "Group the results by airline name to count the number of flights for each airline.", "Use the HAVING clause to filter the grouped results to only include airlines with a count of flights less than 200."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT a.Airline \nFROM airlines a \nJOIN flights f ON a.Airline = f.Airline \nGROUP BY a.Airline \nHAVING COUNT(f.FlightNo) < 200;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.258", "db_id": "flight_2", "question": "Which airports do not have departing or arriving flights?", "rationale": ["Identify the airports from the 'airports' table that do not have any flights departing or arriving.", "To find these airports, we need to check which airport codes are present in the 'flights' table as either SourceAirport or DestAirport.", "We can use a subquery to select all airport codes from the 'flights' table by combining both SourceAirport and DestAirport using UNION.", "The main query will then select airport codes and names from the 'airports' table where the airport code is not in the list obtained from the subquery."], "gold_sql": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)", "source_tables": ["airports", "flights"], "pred_sql": "SELECT AirportCode, AirportName FROM airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM flights UNION SELECT DestAirport FROM flights);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.308", "db_id": "cre_Doc_Template_Mgt", "question": "Count the number of documents that use the PPT template type.", "rationale": ["Identify the tables involved: We need to count documents, so we will use the 'Documents' table and join it with the 'Templates' table to filter by template type.", "Determine the relationship: The 'Documents' table has a foreign key 'Template_ID' that links to the 'Templates' table, allowing us to join these tables on 'Template_ID'.", "Filter by template type: We need to count only those documents that are associated with the 'PPT' template type, which is indicated by the 'Template_Type_Code' in the 'Templates' table.", "Count the documents: We will use the COUNT function to count the distinct 'Document_ID's from the 'Documents' table that meet the criteria."], "gold_sql": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'", "source_tables": ["templates", "documents"], "pred_sql": "SELECT COUNT(DISTINCT d.Document_ID) AS Document_Count\nFROM Documents d\nJOIN Templates t ON d.Template_ID = t.Template_ID\nWHERE t.Template_Type_Code = 'PPT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\"\n}\n"}
{"sample_id": "dev.311", "db_id": "cre_Doc_Template_Mgt", "question": "What is the id and type code for the template used by the most documents?", "rationale": ["We need to find the template ID and type code for the template that is used by the most documents.", "To do this, we will join the 'Templates' table with the 'Documents' table on the 'Template_ID' column.", "We will group the results by 'Template_ID' and 'Template_Type_Code' to count how many documents are associated with each template.", "We will use the COUNT function to count the number of documents for each template.", "To find the template used by the most documents, we will order the results in descending order based on the count of documents.", "Finally, we will limit the results to only the top entry to get the template with the highest document count."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Templates.Template_ID, Templates.Template_Type_Code\nFROM Templates\nJOIN Documents ON Templates.Template_ID = Documents.Template_ID\nGROUP BY Templates.Template_ID, Templates.Template_Type_Code\nORDER BY COUNT(Documents.Document_ID) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\"\n}\n"}
{"sample_id": "dev.312", "db_id": "cre_Doc_Template_Mgt", "question": "Return the id and type code of the template that is used for the greatest number of documents.", "rationale": ["We need to find the template that is used for the greatest number of documents.", "To do this, we will join the 'Templates' table with the 'Documents' table on the 'Template_ID' column.", "We will group the results by 'Template_ID' and 'Template_Type_Code' to count the number of documents associated with each template.", "We will use the COUNT function to count the number of documents for each template.", "Finally, we will order the results in descending order based on the count of documents and limit the result to 1 to get the template with the greatest number of documents."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Templates.Template_ID, Templates.Template_Type_Code\nFROM Templates\nJOIN Documents ON Templates.Template_ID = Documents.Template_ID\nGROUP BY Templates.Template_ID, Templates.Template_Type_Code\nORDER BY COUNT(Documents.Document_ID) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\"\n}\n"}
{"sample_id": "dev.341", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template type codes and the number of documents using each type.", "rationale": ["Identify the tables involved: Templates and Documents.", "Determine the relationship between the tables: Documents are linked to Templates via Template_ID.", "Select the Template_Type_Code from the Templates table and count the Document_ID from the Documents table.", "Use a JOIN to combine the Templates and Documents tables based on the Template_ID.", "Group the results by Template_Type_Code to get the count of documents for each template type."], "gold_sql": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code", "source_tables": ["templates", "documents"], "pred_sql": "SELECT T.Template_Type_Code, COUNT(D.Document_ID) AS Document_Count\nFROM Templates T\nJOIN Documents D ON T.Template_ID = D.Template_ID\nGROUP BY T.Template_Type_Code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\"\n}\n"}
{"sample_id": "dev.346", "db_id": "cre_Doc_Template_Mgt", "question": "What are the codes of template types that are not used for any document?", "rationale": ["We need to find template types that are not used for any document.", "To do this, we will start from the 'Ref_Template_Types' table, which contains all template types.", "We will perform a LEFT JOIN with the 'Templates' table to include all template types, even those that do not have any associated templates.", "Next, we will perform another LEFT JOIN with the 'Documents' table to check if there are any documents associated with the templates.", "Finally, we will filter the results where 'Documents.Document_ID' is NULL, indicating that there are no documents linked to those template types."], "gold_sql": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Ref_Template_Types.Template_Type_Code \nFROM Ref_Template_Types \nLEFT JOIN Templates ON Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code \nLEFT JOIN Documents ON Templates.Template_ID = Documents.Template_ID \nWHERE Documents.Document_ID IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\"\n}\n"}
{"sample_id": "dev.361", "db_id": "cre_Doc_Template_Mgt", "question": "Show paragraph details for paragraph with text 'Korea ' .", "rationale": ["Identify the table that contains paragraph details, which is the 'Paragraphs' table.", "Determine the column that holds the text content of the paragraph, which is 'Paragraph_Text'.", "Formulate a SQL query to select all columns from the 'Paragraphs' table where 'Paragraph_Text' matches the specified text 'Korea '."], "gold_sql": "select other_details from paragraphs where paragraph_text like 'korea'", "source_tables": ["paragraphs"], "pred_sql": "SELECT * FROM Paragraphs WHERE Paragraph_Text = 'Korea ';", "hint": "\n"}
{"sample_id": "dev.367", "db_id": "cre_Doc_Template_Mgt", "question": "Show all document ids and the number of paragraphs in each document. Order by document id.", "rationale": ["We need to retrieve all document IDs and the count of paragraphs associated with each document.", "To achieve this, we will use a LEFT JOIN between the 'Documents' table and the 'Paragraphs' table on the 'Document_ID' field.", "Using COUNT(Paragraphs.Paragraph_ID) will allow us to count the number of paragraphs for each document, even if some documents have no paragraphs (hence the LEFT JOIN).", "We will group the results by 'Documents.Document_ID' to ensure we get a count for each document.", "Finally, we will order the results by 'Documents.Document_ID' to meet the requirement of ordering the output."], "gold_sql": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id", "source_tables": ["paragraphs"], "pred_sql": "SELECT Documents.Document_ID, COUNT(Paragraphs.Paragraph_ID) AS Number_of_Paragraphs\nFROM Documents\nLEFT JOIN Paragraphs ON Documents.Document_ID = Paragraphs.Document_ID\nGROUP BY Documents.Document_ID\nORDER BY Documents.Document_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of documents associated with each template from the 'Documents' table. The placeholder in the SELECT clause represents the unique identifier of the template, while the count function aggregates the total number of documents linked to each template.\"\n}\n"}
{"sample_id": "dev.439", "db_id": "wta_1", "question": "Find the highest rank of losers in all matches.", "rationale": ["We need to find the highest rank of losers in all matches.", "The 'loser_id' from the 'matches' table identifies the players who lost in each match.", "We will use a subquery to get all 'loser_id's from the 'matches' table.", "Next, we will look up the rankings of these players in the 'rankings' table using their 'player_id'.", "Finally, we will use the MIN function to find the highest rank among these losers, as a lower ranking number indicates a better rank."], "gold_sql": "SELECT min(loser_rank) FROM matches", "source_tables": ["matches"], "pred_sql": "SELECT MIN(ranking) AS highest_rank FROM rankings WHERE player_id IN (SELECT loser_id FROM matches)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\"\n}\n"}
{"sample_id": "dev.458", "db_id": "wta_1", "question": "What are the full names of all left handed players, in order of birth date?", "rationale": ["Identify the relevant table: The 'players' table contains the information about players, including their names and handedness.", "Determine the condition: We need to filter for left-handed players, which is specified in the 'hand' column.", "Select the required fields: We need the full names of the players, which can be constructed by concatenating 'first_name' and 'last_name'.", "Order the results: The results should be ordered by 'birth_date' to get the players in chronological order of their birth.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date", "source_tables": ["players"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name\nFROM players\nWHERE hand = 'left'\nORDER BY birth_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\"\n}\n"}
{"sample_id": "dev.464", "db_id": "wta_1", "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?", "rationale": ["Identify the relevant tables: matches, players, and rankings.", "We need to find the winner who has won the most matches, so we will focus on the 'matches' table and the 'winner_id' column.", "Join the 'matches' table with the 'players' table to get the names of the winners.", "Join the result with the 'rankings' table to get the rank points of the winners.", "Group the results by the winner's name to count the number of matches won by each player.", "Order the results by the count of matches won in descending order to find the player with the most wins.", "Select the winner's name and their rank points, limiting the result to the top player."], "gold_sql": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["matches"], "pred_sql": "SELECT winner_name, MAX(rank_points) AS rank_points\nFROM matches\nJOIN players ON matches.winner_id = players.player_id\nJOIN rankings ON players.player_id = rankings.player_id\nGROUP BY winner_name\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\"\n}\n"}
{"sample_id": "dev.471", "db_id": "wta_1", "question": "Find the total ranking points for each player and their first name.", "rationale": ["We need to find the total ranking points for each player along with their first name.", "The relevant tables for this query are 'players' and 'rankings'.", "We will join these two tables on the 'player_id' column, which is common to both tables.", "We will select the 'first_name' from the 'players' table and the sum of 'ranking_points' from the 'rankings' table.", "To get the total ranking points for each player, we will use the SUM() function and group the results by 'first_name'."], "gold_sql": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name", "source_tables": ["rankings", "players"], "pred_sql": "SELECT players.first_name, SUM(rankings.ranking_points) AS total_ranking_points\nFROM players\nJOIN rankings ON players.player_id = rankings.player_id\nGROUP BY players.first_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\"\n}\n"}
{"sample_id": "dev.479", "db_id": "wta_1", "question": "Find the total number of tours for each ranking date.", "rationale": ["The query needs to find the total number of tours for each ranking date.", "We will select the 'ranking_date' from the 'rankings' table.", "To count the distinct tours for each ranking date, we will use the COUNT function with DISTINCT on the 'tours' column.", "We will group the results by 'ranking_date' to get the total tours for each date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(DISTINCT tours) AS total_tours\nFROM rankings\nGROUP BY ranking_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\"\n}\n"}
{"sample_id": "dev.480", "db_id": "wta_1", "question": "How many total tours were there for each ranking date?", "rationale": ["The question asks for the total number of tours for each ranking date.", "We need to select the 'ranking_date' from the 'rankings' table.", "To count the distinct tours for each ranking date, we will use the COUNT function with DISTINCT on the 'tours' column.", "We will group the results by 'ranking_date' to get the count for each date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(DISTINCT tours) AS total_tours\nFROM rankings\nGROUP BY ranking_date;", "hint": "\n"}
{"sample_id": "dev.533", "db_id": "student_transcripts_tracking", "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to join the Students table with the Student_Enrolment table to get student details along with their enrolment information.", "To find students enrolled in 2 degree programs in one semester, we can join the Student_Enrolment table with itself (self-join) on the student_id.", "In the self-join, we ensure that the degree_program_id is different for the two records (indicating enrollment in two different programs) but the semester_id is the same (indicating they are enrolled in the same semester).", "Select the required fields: first_name, middle_name, last_name, and student_id from the Students table."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Student_Enrolment se2 ON s.student_id = se2.student_id\nWHERE se.degree_program_id != se2.degree_program_id\nAND se.semester_id = se2.semester_id;", "hint": "\n"}
{"sample_id": "dev.536", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs.", "We need to retrieve the first, middle, and last names of students, which are in the Students table.", "To find out which students are enrolled in a Bachelors program, we need to join the Students table with the Student_Enrolment table on student_id.", "Next, we join the Student_Enrolment table with the Degree_Programs table on degree_program_id to filter for Bachelors programs.", "The WHERE clause is used to filter the degree_summary_name to include 'Bachelors'.", "Finally, select the first_name, middle_name, and last_name from the resulting joined tables."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name \nFROM Students s \nJOIN Student_Enrolment se ON s.student_id = se.student_id \nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id \nWHERE dp.degree_summary_name LIKE '%Bachelors%';", "hint": "\n"}
{"sample_id": "dev.537", "db_id": "student_transcripts_tracking", "question": "Find the kind of program which most number of students are enrolled in?", "rationale": ["Identify the relevant tables: We need to find the degree programs and the number of students enrolled in each program, so we will use the Student_Enrolment and Degree_Programs tables.", "Join the tables: We will join the Student_Enrolment table with the Degree_Programs table on the degree_program_id to associate each enrolment with its corresponding program.", "Count the number of students: We will use the COUNT function to count the number of student enrolments for each degree program.", "Group the results: We will group the results by the degree program name to get the count of students for each program.", "Order the results: We will order the results in descending order based on the student count to find the program with the most students enrolled.", "Limit the results: We will limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_summary_name, COUNT(se.student_enrolment_id) AS student_count\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nGROUP BY dp.degree_summary_name\nORDER BY student_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["Identify the relevant tables: Degree_Programs and Student_Enrolment.", "We need to find the degree program with the most students enrolled, so we will join Degree_Programs with Student_Enrolment on the degree_program_id.", "Group the results by degree_program_id and degree_summary_name to count the number of students enrolled in each program.", "Use COUNT(se.student_id) to count the number of students for each program.", "Order the results in descending order based on the count of students to get the program with the most enrollments at the top.", "Limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_program_id, dp.degree_summary_name\nFROM Degree_Programs dp\nJOIN Student_Enrolment se ON dp.degree_program_id = se.degree_program_id\nGROUP BY dp.degree_program_id, dp.degree_summary_name\nORDER BY COUNT(se.student_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to count the number of enrollments for each student, so we will join the Students table with the Student_Enrolment table on the student_id.", "Use COUNT() function to count the number of enrollments for each student.", "Group the results by student_id to aggregate the counts for each student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Limit the results to 1 to get only the student with the highest number of enrollments."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name, COUNT(se.student_enrolment_id) AS number_of_enrollments\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id\nORDER BY number_of_enrollments DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["Identify the relevant tables: Courses and Student_Enrolment_Courses.", "Join the Courses table with the Student_Enrolment_Courses table on the course_id to link courses with their enrollments.", "Group the results by course name to aggregate the number of enrollments for each course.", "Count the number of enrollments for each course using COUNT on the student_course_id from the Student_Enrolment_Courses table.", "Order the results in descending order based on the count of enrollments to find the most popular course.", "Limit the results to 1 to get only the course with the highest number of enrollments."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT C.course_name\nFROM Courses C\nJOIN Student_Enrolment_Courses SEC ON C.course_id = SEC.course_id\nGROUP BY C.course_name\nORDER BY COUNT(SEC.student_course_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of course names from the 'Courses' table that are associated with student enrolments. The results are grouped by course name and ordered by the number of enrolments in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of course names to return.\"\n}\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant table: We need to retrieve last names of students, so we will focus on the 'Students' table.", "Filter students based on their address: We need to find students who live in North Carolina. This requires a subquery to the 'Addresses' table to get the 'address_id' for addresses in North Carolina.", "Exclude students who are enrolled in any degree programs: We need to ensure that these students have not registered in any degree programs, which requires another subquery to the 'Student_Enrolment' table to filter out those students who have an entry in that table."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "SELECT last_name \nFROM Students \nWHERE current_address_id IN (\n    SELECT address_id \n    FROM Addresses \n    WHERE state_province_county = 'North Carolina'\n) \nAND student_id NOT IN (\n    SELECT student_id \n    FROM Student_Enrolment\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\"\n}\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table: The 'Students' table contains the information about students, including their names and mobile phone numbers.", "Determine the columns needed: We need the 'cell_mobile_number' column to get the mobile phone number.", "Formulate the WHERE clause: We need to filter the results to find the student named 'Timmothy Ward'. This requires checking both the 'first_name' and 'last_name' columns.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to retrieve the desired information."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\"\n}\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["Identify the relevant tables: We need to look at the 'Addresses' table for address details and the 'Students' table to find out how many students are associated with each address.", "Join the 'Addresses' table with the 'Students' table on the current address ID to link students to their current addresses.", "Group the results by address ID to count the number of students associated with each address.", "Order the results in descending order based on the count of students to find the address with the most students.", "Limit the results to 1 to get only the address with the highest count of students."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT a.address_id, a.line_1, a.line_2, a.line_3\nFROM Addresses a\nJOIN Students s ON a.address_id = s.current_address_id\nGROUP BY a.address_id\nORDER BY COUNT(s.student_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\"\n}\n"}
{"sample_id": "dev.576", "db_id": "student_transcripts_tracking", "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?", "rationale": ["Identify the relevant tables: Student_Enrolment and Degree_Programs.", "We need to find semesters that had both Masters and Bachelors students enrolled.", "Join the Student_Enrolment table with the Degree_Programs table on the degree_program_id.", "Filter the results to include only those degree programs that are either 'Masters' or 'Bachelors'.", "Group the results by semester_id to aggregate the data for each semester.", "Use HAVING clause to ensure that both degree types (Masters and Bachelors) are present in the results for each semester."], "gold_sql": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT DISTINCT se.semester_id\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nWHERE dp.degree_summary_name IN ('Masters', 'Bachelors')\nGROUP BY se.semester_id\nHAVING COUNT(DISTINCT dp.degree_summary_name) = 2;", "hint": "\n"}
{"sample_id": "dev.580", "db_id": "student_transcripts_tracking", "question": "What other details can you tell me about students in reverse alphabetical order?", "rationale": ["The question asks for 'other details' about students, which corresponds to the 'other_student_details' column in the Students table.", "To retrieve this information, we will select the 'other_student_details' column from the Students table.", "The question specifies that the results should be in reverse alphabetical order, which means we need to order the results by the last name and first name of the students in descending order.", "Thus, the SQL query will select 'other_student_details' from the Students table and order the results by 'last_name' and 'first_name' in descending order."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "pred_sql": "SELECT other_student_details FROM Students ORDER BY last_name DESC, first_name DESC;", "hint": "\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve information about a section, we need to select all columns from the Sections table.", "We will use a WHERE clause to filter the results to only include the section where the section_name is 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT * FROM Sections WHERE section_name = 'h';", "hint": "\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the table that contains information about countries and their government forms, which is the 'country' table.", "Determine the specific column that indicates the type of government, which is 'GovernmentForm'.", "Formulate a query to count the number of entries in the 'country' table where the 'GovernmentForm' is 'Republic'.", "Use the COUNT() function to get the total number of countries that meet this criterion."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(*) FROM country WHERE GovernmentForm = 'Republic';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\"\n}\n"}
{"sample_id": "dev.730", "db_id": "world_1", "question": "What is the average GNP and total population in all nations whose government is US territory?", "rationale": ["Identify the required data: average GNP and total population of countries with a specific government form.", "Use the 'country' table since it contains the GNP and population data.", "Apply the AVG() function to calculate the average GNP and SUM() function to calculate the total population.", "Filter the results using a WHERE clause to include only those countries with a government form of 'US territory'."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT AVG(GNP) AS Average_GNP, SUM(Population) AS Total_Population \nFROM country \nWHERE GovernmentForm = 'US territory';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\"\n}\n"}
{"sample_id": "dev.734", "db_id": "world_1", "question": "How many type of governments are in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and regions.", "Determine the specific region: The question asks about Africa, so we will filter the results to only include countries in the 'Africa' region.", "Select distinct government forms: To find out how many types of governments exist, we will use the DISTINCT keyword to ensure we only get unique government forms."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Region = 'Africa';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\"\n}\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and regions.", "Determine the specific region of interest: The question specifies Africa, so we will filter the results to only include countries in the 'Africa' region.", "Select distinct government forms: To find out how many different forms of government exist, we will use the DISTINCT keyword to ensure we only get unique values for the GovernmentForm column."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Region = 'Africa';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\"\n}\n"}
{"sample_id": "dev.742", "db_id": "world_1", "question": "Which continent has the most diverse languages?", "rationale": ["Identify the tables involved: We need to look at the 'country' and 'countrylanguage' tables to find the continent and the languages spoken in each country.", "Join the tables: We will join 'country' and 'countrylanguage' on the 'Code' and 'CountryCode' fields respectively to associate each language with its corresponding country.", "Group by continent: We will group the results by the continent to count the number of distinct languages spoken in each continent.", "Count distinct languages: Use COUNT(DISTINCT countrylanguage.Language) to get the number of different languages spoken in each continent.", "Order the results: We will order the results in descending order based on the count of languages to find the continent with the most diverse languages.", "Limit the results: Finally, we will limit the results to 1 to get only the continent with the highest diversity of languages."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT country.Continent, COUNT(DISTINCT countrylanguage.Language) AS LanguageCount\nFROM country\nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode\nGROUP BY country.Continent\nORDER BY LanguageCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\"\n}\n"}
{"sample_id": "dev.743", "db_id": "world_1", "question": "Which continent speaks the most languages?", "rationale": ["We need to find out which continent speaks the most languages.", "To do this, we will join the 'country' table with the 'countrylanguage' table on the 'CountryCode'.", "We will count the distinct languages spoken in each continent using COUNT(DISTINCT countrylanguage.Language).", "We will group the results by continent using GROUP BY country.Continent.", "To find the continent with the most languages, we will order the results in descending order by the count of languages using ORDER BY LanguageCount DESC.", "Finally, we will limit the results to only the top continent using LIMIT 1."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT country.Continent, COUNT(DISTINCT countrylanguage.Language) AS LanguageCount\nFROM country\nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode\nGROUP BY country.Continent\nORDER BY LanguageCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\"\n}\n"}
{"sample_id": "dev.746", "db_id": "world_1", "question": "What are the names of nations speak both English and French?", "rationale": ["Identify the languages of interest: English and French.", "Use the countrylanguage table to find countries that speak English and French.", "Filter for countries where English is spoken but not as an official language.", "Use a subquery to find countries that also speak French under the same conditions.", "Join the results with the country table to get the names of the countries."], "gold_sql": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'French'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl1.CountryCode, c.Name \nFROM countrylanguage cl1 \nJOIN country c ON cl1.CountryCode = c.Code \nWHERE cl1.Language = 'English' \nAND cl1.IsOfficial = 'False' \nAND cl1.CountryCode IN (\n    SELECT cl2.CountryCode \n    FROM countrylanguage cl2 \n    WHERE cl2.Language = 'French' \n    AND cl2.IsOfficial = 'False'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["We need to find countries that have either English or Dutch as an official language.", "To do this, we will use the 'country' table to get the country names and the 'countrylanguage' table to filter by language and official status.", "We will perform a JOIN between the 'country' and 'countrylanguage' tables on the 'Code' and 'CountryCode' columns respectively.", "We will use the WHERE clause to filter for languages that are either 'English' or 'Dutch' and check that they are official languages by ensuring 'IsOfficial' is 'T'.", "Finally, we will use DISTINCT to ensure that we only get unique country names in the result."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT country.Name \nFROM country \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE countrylanguage.Language IN ('English', 'Dutch') AND countrylanguage.IsOfficial = 'T';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the requirement: We need to find the total population of countries that do not use English as an official language.", "Understand the schema: The 'country' table contains population data, and the 'countrylanguage' table indicates which languages are official in which countries.", "To find countries that do not use English, we need to select country codes from the 'countrylanguage' table where English is an official language.", "We will use a subquery to get the country codes where English is the official language.", "The main query will sum the populations of countries whose codes are not in the list obtained from the subquery."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation\nFROM country c\nWHERE c.Code NOT IN (\n    SELECT cl.CountryCode\n    FROM countrylanguage cl\n    WHERE cl.Language = 'English' AND cl.IsOfficial = 'Yes'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.767", "db_id": "world_1", "question": "How many people live in countries that do not speak English?", "rationale": ["Identify the total population of countries that do not speak English.", "To find countries that do not speak English, we need to exclude countries where English is an official language.", "We can achieve this by using a subquery that selects country codes from the countrylanguage table where the language is 'English' and it is marked as official.", "The main query will then sum the populations of countries whose codes are not in the result of the subquery."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation\nFROM country c\nWHERE c.Code NOT IN (\n    SELECT cl.CountryCode\n    FROM countrylanguage cl\n    WHERE cl.Language = 'English' AND cl.IsOfficial = 'Yes'\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.783", "db_id": "world_1", "question": "Return the codes of countries that do not speak English and do not have Republics for governments.", "rationale": ["Identify the countries that do not speak English: This can be done by selecting the country codes from the countrylanguage table where the language is 'English' and it is marked as an official language.", "Use a subquery to get the country codes that speak English officially: This subquery will return the country codes that we want to exclude from our main query.", "Identify the countries that do not have Republics for governments: This can be done by filtering the country table where the GovernmentForm does not contain the word 'Republic'.", "Combine the two conditions: We will select the country codes from the country table that are not in the list of country codes that speak English and also do not have 'Republic' in their government form."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'T') AND GovernmentForm NOT LIKE '%Republic%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.784", "db_id": "world_1", "question": "Which cities are in European countries where English is not the official language?", "rationale": ["Identify the relevant tables: 'city' and 'country' for city information and country details, and 'countrylanguage' for language information.", "We need to find cities in European countries, so we will filter the 'country' table by the 'Continent' column for 'Europe'.", "Next, we need to ensure that the cities are in countries where English is not the official language. This requires a subquery that selects country codes from the 'countrylanguage' table where English is the official language.", "The subquery will be used in the main query's WHERE clause to exclude those country codes from the results.", "Finally, we will select the city names from the 'city' table, joining it with the 'country' table on the 'CountryCode' to get the necessary information."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT city.Name \nFROM city \nJOIN country ON city.CountryCode = country.Code \nWHERE country.Continent = 'Europe' \nAND city.CountryCode NOT IN (\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language = 'English' \n    AND IsOfficial = 'Yes'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.785", "db_id": "world_1", "question": "What are the names of cities in Europe for which English is not the official language?", "rationale": ["Identify the relevant tables: We need to use the 'city' and 'country' tables to get city names and their corresponding countries.", "Filter for cities in Europe: We can do this by checking the 'Continent' column in the 'country' table.", "Exclude cities where English is an official language: We will use a subquery to find countries where English is an official language and exclude those from our main query.", "Join the 'city' and 'country' tables on the 'CountryCode' to get the necessary information about the cities and their countries."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT city.Name \nFROM city \nJOIN country ON city.CountryCode = country.Code \nWHERE country.Continent = 'Europe' \nAND city.CountryCode NOT IN (\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language = 'English' \n    AND IsOfficial = 'Yes'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.788", "db_id": "world_1", "question": "What are the name, independence year, and surface area of the country with the smallest population?", "rationale": ["Identify the required columns: Name, IndepYear, and SurfaceArea from the country table.", "Determine the condition to find the country with the smallest population, which involves using the MIN function on the Population column.", "Construct a subquery to find the minimum population from the country table.", "Use the result of the subquery to filter the main query to get the country details that match the minimum population."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\"\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the required fields: Name, year of independence (IndepYear), and surface area (SurfaceArea) from the country table.", "Determine the condition: We need to find the country with the lowest population.", "Use a subquery to find the minimum population from the country table: (SELECT MIN(Population) FROM country).", "Combine the selected fields and the condition in the main query to retrieve the desired information."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\"\n}\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["Identify the relevant tables: We need to use the 'country' table to get country names and the 'countrylanguage' table to count the languages spoken in each country.", "Join the 'country' and 'countrylanguage' tables on the 'Code' and 'CountryCode' columns respectively to associate countries with their languages.", "Use the COUNT function to count the number of languages spoken in each country.", "Group the results by country name to aggregate the language counts for each country.", "Use the HAVING clause to filter the results to only include countries that speak more than 2 languages."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Name, COUNT(cl.Language) AS LanguageCount\nFROM country c\nJOIN countrylanguage cl ON c.Code = cl.CountryCode\nGROUP BY c.Name\nHAVING COUNT(cl.Language) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\"\n}\n"}
{"sample_id": "dev.796", "db_id": "world_1", "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.", "rationale": ["Identify the columns needed: GovernmentForm and Population.", "We need to filter countries based on LifeExpectancy being greater than 72.", "We will group the results by GovernmentForm to get the total population for each form of government.", "Use SUM function to calculate the total population for each government form.", "Construct the SQL query using SELECT, FROM, WHERE, and GROUP BY clauses."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation\nFROM country\nWHERE LifeExpectancy > 72\nGROUP BY GovernmentForm;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\"\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the relevant table: The 'country' table contains the columns for government forms and population.", "Determine the columns needed: We need 'GovernmentForm' and the total population, which can be calculated using SUM(Population).", "Apply the condition: We need to filter for countries with an average life expectancy greater than 72, which is done using the WHERE clause.", "Group the results: To get the total population for each government form, we will use GROUP BY on 'GovernmentForm'."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation\nFROM country\nWHERE LifeExpectancy > 72\nGROUP BY GovernmentForm;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\"\n}\n"}
{"sample_id": "dev.801", "db_id": "world_1", "question": "Return the names and surface areas of the 5 largest countries.", "rationale": ["Identify the table needed: The 'country' table contains the names and surface areas of countries.", "Determine the required columns: We need 'Name' and 'SurfaceArea' from the 'country' table.", "Sort the results: To find the largest countries, we will order the results by 'SurfaceArea' in descending order.", "Limit the results: We only want the top 5 largest countries, so we will use 'LIMIT 5' to restrict the output."], "gold_sql": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5", "source_tables": ["country"], "pred_sql": "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\"\n}\n"}
{"sample_id": "dev.810", "db_id": "world_1", "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?", "rationale": ["Identify the relevant table: The 'country' table contains the necessary information about countries, including population and surface area.", "Determine the required fields: We need to calculate the total population and average surface area, so we will use SUM(Population) and AVG(SurfaceArea).", "Apply the filtering criteria: We need to filter the countries based on the continent (North America) and the surface area (> 3000).", "Construct the SQL query: Combine the selected fields and filtering criteria into a complete SQL statement."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT SUM(Population) AS TotalPopulation, AVG(SurfaceArea) AS AverageArea FROM country WHERE Continent = 'North America' AND SurfaceArea > 3000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\"\n}\n"}
{"sample_id": "dev.811", "db_id": "world_1", "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .", "rationale": ["Identify the continent of interest, which is North America.", "Determine the conditions for filtering countries: surface area greater than 3000.", "Select the total population and average surface area from the 'country' table.", "Use the SUM function to calculate the total population and the AVG function to calculate the average surface area for the filtered countries."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation, AVG(c.SurfaceArea) AS AverageSurfaceArea\nFROM country c\nWHERE c.Continent = 'North America' AND c.SurfaceArea > 3000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\"\n}\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the relevant table: The 'city' table contains the population data we need.", "Determine the columns needed: We need the 'Name' of the city and the 'Population'.", "Formulate the condition: We want cities where the population is between 160000 and 900000.", "Construct the SQL query: Use the SELECT statement to get the city names from the 'city' table with the specified population range."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT Name FROM city WHERE Population BETWEEN '160000' AND '900000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and populations of cities from the 'city' table that have a specific language spoken, as indicated in the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name, while the placeholder in the LIMIT clause specifies the maximum number of results to return.\"\n}\n"}
{"sample_id": "dev.921", "db_id": "dog_kennels", "question": "Find the average age of the dogs who went through treatments.", "rationale": ["Identify the tables involved: Dogs and Treatments.", "We need to find the average age of dogs that have received treatments, so we will join the Dogs table with the Treatments table on the dog_id.", "Use the AVG() function to calculate the average age of the dogs from the Dogs table after the join."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT AVG(D.age) AS average_age\nFROM Dogs D\nJOIN Treatments T ON D.dog_id = T.dog_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\"\n}\n"}
{"sample_id": "dev.924", "db_id": "dog_kennels", "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to find dogs that have not cost their owner more than 1000 for treatment, so we will join the Dogs table with the Treatments table on the dog_id.", "Use a LEFT JOIN to include all dogs, even those without treatments.", "Group the results by dog_id to aggregate treatment costs for each dog.", "Use the HAVING clause to filter groups where the total cost of treatments is less than or equal to 1000.", "Select the dog names from the Dogs table."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.name \nFROM Dogs d \nLEFT JOIN Treatments t ON d.dog_id = t.dog_id \nGROUP BY d.dog_id \nHAVING SUM(t.cost_of_treatment) <= 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\"\n}\n"}
{"sample_id": "dev.937", "db_id": "dog_kennels", "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.", "rationale": ["We need to find the owner who spent the most on treatments for their dogs.", "To do this, we will join the Owners table with the Dogs table using the owner_id, and then join the Treatments table using the dog_id.", "We will group the results by owner_id and last_name to aggregate the total treatment costs for each owner.", "We will use the SUM function to calculate the total cost of treatments for each owner.", "Finally, we will order the results in descending order based on the total treatment costs and limit the results to 1 to get the owner who spent the most."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT Owners.owner_id, Owners.last_name\nFROM Owners\nJOIN Dogs ON Owners.owner_id = Dogs.owner_id\nJOIN Treatments ON Dogs.dog_id = Treatments.dog_id\nGROUP BY Owners.owner_id, Owners.last_name\nORDER BY SUM(Treatments.cost_of_treatment) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\"\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["Identify the relevant table: The Treatments table contains information about the treatments administered by professionals.", "Determine the required fields: We need the professional_id and cell_number from the Professionals table.", "Group by professional_id: To find professionals who have done multiple types of treatments, we will group the results by professional_id.", "Count distinct treatment types: We will count the distinct treatment_type_code for each professional to ensure we are counting different types of treatments.", "Use HAVING clause: We will filter the results to include only those professionals who have administered at least two different types of treatments by using the HAVING clause with a count condition."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT professional_id, cell_number\nFROM Treatments\nGROUP BY professional_id\nHAVING COUNT(DISTINCT treatment_type_code) >= 2;", "hint": "\n"}
{"sample_id": "dev.943", "db_id": "dog_kennels", "question": "Find the id and cell phone of the professionals who operate two or more types of treatments.", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "We need to find professionals who operate two or more types of treatments, so we will join the Professionals table with the Treatments table on the professional_id.", "We will group the results by professional_id to aggregate the treatment types for each professional.", "Using COUNT(DISTINCT t.treatment_type_code), we can count the number of unique treatment types each professional operates.", "We will filter the results using HAVING to include only those professionals who have two or more distinct treatment types."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT p.professional_id, p.cell_number\nFROM Professionals p\nJOIN Treatments t ON p.professional_id = t.professional_id\nGROUP BY p.professional_id\nHAVING COUNT(DISTINCT t.treatment_type_code) >= 2;", "hint": "\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["Identify the tables needed: Owners, Dogs, and Sizes.", "Determine the fields to select: first name and last name from Owners, and size description from Sizes.", "Establish the relationships between the tables: Owners to Dogs via owner_id, and Dogs to Sizes via size_code.", "Construct the SQL query using JOINs to combine the relevant tables and select the desired fields."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\"\n}\n"}
{"sample_id": "dev.954", "db_id": "dog_kennels", "question": "List the names of the dogs of the rarest breed and the treatment dates of them.", "rationale": ["Identify the tables needed: Dogs, Breeds, and Treatments.", "We need to list the names of the dogs and their treatment dates, so we will select 'Dogs.name' and 'Treatments.date_of_treatment'.", "Join the Dogs table with the Breeds table on 'breed_code' to get breed information.", "Join the Dogs table with the Treatments table on 'dog_id' to get treatment information.", "To find the rarest breed, we will use a subquery that groups by 'breed_code' in the Dogs table, counts the number of dogs for each breed, orders them in ascending order, and limits the result to 1 to get the breed with the least number of dogs.", "Use the result of the subquery in the WHERE clause to filter the main query for dogs of the rarest breed."], "gold_sql": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT Dogs.name, Treatments.date_of_treatment\nFROM Dogs\nJOIN Breeds ON Dogs.breed_code = Breeds.breed_code\nJOIN Treatments ON Dogs.dog_id = Treatments.dog_id\nWHERE Breeds.breed_code = (\n    SELECT breed_code\n    FROM Dogs\n    GROUP BY breed_code\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\"\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need the arriving date and departing date of dogs, which are in the Dogs table.", "We also need to filter dogs that have gone through a treatment, which can be done by joining the Dogs table with the Treatments table on the dog_id.", "Select the date_arrived and date_departed columns from the Dogs table after the join."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.date_arrived, d.date_departed \nFROM Dogs d \nJOIN Treatments t ON d.dog_id = t.dog_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\"\n}\n"}
{"sample_id": "dev.960", "db_id": "dog_kennels", "question": "List the last name of the owner owning the youngest dog.", "rationale": ["Identify the relevant tables: Owners and Dogs.", "We need to find the last name of the owner, so we will select Owners.last_name.", "To find the youngest dog, we need to determine the minimum age from the Dogs table.", "We will join the Owners table with the Dogs table on the owner_id to link owners with their dogs.", "The WHERE clause will filter the results to only include the dog(s) with the minimum age found in the subquery."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.last_name \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nWHERE Dogs.age = (SELECT MIN(age) FROM Dogs);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\"\n}\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["Identify the tables needed: Breeds, Sizes, and Dogs.", "We need to find distinct combinations of breed types and size types for dogs.", "Join the Dogs table with the Breeds table on breed_code to get breed names.", "Join the Dogs table with the Sizes table on size_code to get size descriptions.", "Select distinct breed names and size descriptions from the joined tables."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT B.breed_name, S.size_description \nFROM Dogs D \nJOIN Breeds B ON D.breed_code = B.breed_code \nJOIN Sizes S ON D.size_code = S.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\"\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["Identify the required information: professional's first name and treatment description.", "Determine the relevant tables: Professionals and Treatment_Types.", "Recognize that Treatments table links Professionals and Treatment_Types through foreign keys.", "Use JOIN statements to connect the tables based on their relationships: Treatments to Professionals and Treatments to Treatment_Types.", "Select the desired columns from the joined tables."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT Professionals.first_name, Treatment_Types.treatment_type_description\nFROM Treatments\nJOIN Professionals ON Treatments.professional_id = Professionals.professional_id\nJOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code;", "hint": "\n"}
