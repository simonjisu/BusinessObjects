{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["Identify the relevant table: The question asks about staff assignments, so we will focus on the Staff_Department_Assignments table.", "Select the required columns: We need the staff_id and staff_name, which are in the Staff table, but we will join it with Staff_Department_Assignments to get the names.", "Order the results: To find the staff who has been assigned for the least amount of time, we will order by the date_assigned_from column in ascending order.", "Limit the results: Since we only need the staff with the least amount of time assigned, we will limit the results to 1."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name \nFROM Staff_Department_Assignments \nORDER BY date_assigned_from ASC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4753", "db_id": "department_store", "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.", "rationale": ["Identify the Customers table to get customer IDs.", "Join the Customer_Orders table to link customers with their orders.", "Filter the orders to find those that have a status of 'Cancelled'.", "Use a subquery to find the order IDs of cancelled orders.", "Ensure that we only select customers who made orders after the cancelled ones by comparing order dates."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "pred_sql": "SELECT DISTINCT c.customer_id \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nWHERE co.order_id IN (\n    SELECT co2.order_id \n    FROM Customer_Orders co2 \n    WHERE co2.order_status_code = 'Cancelled'\n) \nAND co.order_date > (\n    SELECT MIN(co3.order_date) \n    FROM Customer_Orders co3 \n    WHERE co3.order_status_code = 'Cancelled'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\"\n}\n"}
{"sample_id": "train.4755", "db_id": "department_store", "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?", "rationale": ["Identify the relevant table: Staff_Department_Assignments contains the staff assignments and their dates.", "We need to find the minimum assignment date for any staff with the job title code 'Clerical'.", "Use a subquery to get the earliest date assigned to Clerical staff.", "Select staff_id from Staff_Department_Assignments where their assignment date is earlier than the date obtained from the subquery."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "pred_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_from < (SELECT MIN(date_assigned_from) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical')", "hint": "\n"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["Identify the relevant table: Customers.", "Determine the columns needed: customer_id and customer_name.", "Use the WHERE clause to filter customers based on their address containing 'TN'.", "Utilize the LIKE operator to match the address pattern."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name FROM Customers WHERE customer_address LIKE '%TN%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\"\n}\n"}
{"sample_id": "train.4760", "db_id": "department_store", "question": "What are the names and genders of staff who were assigned in 2016?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "We need to retrieve staff names and genders, so we will select staff_name and staff_gender from the Staff table.", "To find out which staff were assigned in 2016, we need to join the Staff table with the Staff_Department_Assignments table on staff_id.", "We will filter the results based on the date_assigned_from and date_assigned_to columns to ensure they fall within the year 2016."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name, staff_gender \nFROM Staff \nJOIN Staff_Department_Assignments ON Staff.staff_id = Staff_Department_Assignments.staff_id \nWHERE date_assigned_from >= '2016-01-01' AND date_assigned_to <= '2016-12-31';", "hint": "\n"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "We need to find staff members who have been assigned multiple jobs, which implies looking for staff members with multiple distinct job titles.", "Join the Staff table with the Staff_Department_Assignments table on staff_id to link staff members with their job assignments.", "Group the results by staff_id to aggregate the job assignments for each staff member.", "Use the HAVING clause to filter groups where the count of distinct job_title_code is greater than 1, indicating multiple job assignments."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name\nFROM Staff\nJOIN Staff_Department_Assignments ON Staff.staff_id = Staff_Department_Assignments.staff_id\nGROUP BY Staff.staff_id\nHAVING COUNT(DISTINCT job_title_code) > 1;", "hint": "\n"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["Identify the relevant table: Customers.", "Select the columns needed: customer_id and customer_name.", "Filter the results based on the address containing 'WY': use the LIKE operator with '%WY%'.", "Add a condition to exclude customers using a credit card: use the condition payment_method_code != 'CREDIT_CARD'.", "Combine these conditions in the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name FROM Customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'CREDIT_CARD';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\"\n}\n"}
{"sample_id": "train.4793", "db_id": "department_store", "question": "Find the average price of all product clothes.", "rationale": ["Identify the table that contains product information, which is the 'Products' table.", "Determine the column that holds the price of the products, which is 'product_price'.", "To find the average price, use the AVG() function.", "Filter the products to only include those that are classified as clothes by using a WHERE clause on 'product_type_code'.", "Construct the SQL query to select the average price of products where the type code is 'clothes'."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "pred_sql": "SELECT AVG(product_price) AS average_price\nFROM Products\nWHERE product_type_code = 'clothes';", "hint": "\n"}
{"sample_id": "train.4795", "db_id": "department_store", "question": "Find the name of the most expensive hardware product.", "rationale": ["Identify the relevant table: Products, which contains product details including name and price.", "Filter the products to only include those of type 'hardware' using the product_type_code column.", "Sort the filtered results by product_price in descending order to get the most expensive product at the top.", "Limit the results to 1 to retrieve only the most expensive hardware product."], "gold_sql": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1", "source_tables": ["products"], "pred_sql": "SELECT product_name FROM Products WHERE product_type_code = 'hardware' ORDER BY product_price DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["Identify the relevant table: The 'product' table contains the 'max_page_size' and 'product_id' columns.", "Group the results by 'max_page_size' to aggregate products with the same page size.", "Use the COUNT function to count the number of products for each 'max_page_size'.", "Filter the results using HAVING to only include those with more than 3 products."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size\nFROM product\nGROUP BY max_page_size\nHAVING COUNT(product_id) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4903", "db_id": "store_product", "question": "What is the maximum page size for everything that has more than 3 products listed?", "rationale": ["Identify the relevant tables: product, store_product, and store.", "We need to find the maximum page size for products that are listed in stores with more than 3 products.", "Join the product table with the store_product table to link products to stores.", "Join the store table to get store details.", "Group the results by store to count the number of products per store.", "Use the HAVING clause to filter stores that have more than 3 products listed.", "Select the maximum page size from the product table for the filtered stores."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT MAX(p.max_page_size) \nFROM product p \nJOIN store_product sp ON p.product_id = sp.Product_ID \nJOIN store s ON sp.Store_ID = s.Store_ID \nGROUP BY s.Store_ID \nHAVING COUNT(sp.Product_ID) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4913", "db_id": "store_product", "question": "What is the total number of residents for the districts with the 3 largest areas?", "rationale": ["Identify the relevant table: The question pertains to districts and their populations, so we will use the 'district' table.", "Determine the required data: We need the total number of residents, which corresponds to the 'City_Population' column in the 'district' table.", "Find the districts with the largest areas: We will order the districts by 'City_Area' in descending order and limit the results to the top 3 districts.", "Calculate the total population: We will sum the 'City_Population' of the districts identified in the previous step."], "gold_sql": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3", "source_tables": ["district"], "pred_sql": "SELECT SUM(City_Population) AS Total_Residents\nFROM district\nWHERE District_ID IN (\n    SELECT District_ID\n    FROM district\n    ORDER BY City_Area DESC\n    LIMIT 3\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\"\n}\n"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["Identify the relevant tables: store, store_district, and district are needed to find store names based on district.", "Join the store table with the store_district table on Store_ID to link stores with their respective districts.", "Join the resulting table with the district table on District_ID to access district names.", "Filter the results to only include stores located in 'Khanewal District' by using a WHERE clause."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT store.Store_Name \nFROM store \nJOIN store_district ON store.Store_ID = store_district.Store_ID \nJOIN district ON store_district.District_ID = district.District_ID \nWHERE district.District_name = 'Khanewal';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\"\n}\n"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["We need to find the city with the most number of stores, which involves counting the stores in each city.", "To do this, we will join the 'store', 'store_district', and 'district' tables to associate stores with their respective cities.", "We will count the number of stores for each city using COUNT(s.Store_ID) and group the results by the city name (d.Headquartered_City).", "To find the city with the most stores, we will order the results in descending order based on the count of stores and limit the output to 1."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT d.Headquartered_City, COUNT(s.Store_ID) AS Number_of_Stores\nFROM store s\nJOIN store_district sd ON s.Store_ID = sd.Store_ID\nJOIN district d ON sd.District_ID = d.District_ID\nGROUP BY d.Headquartered_City\nORDER BY Number_of_Stores DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\"\n}\n"}
{"sample_id": "train.4930", "db_id": "store_product", "question": "Find products with max page size as \"A4\" and pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to filter products based on two conditions: max page size must be 'A4' and pages per minute color must be less than 5.", "Construct the SQL SELECT statement: We will select all relevant columns from the 'product' table.", "Add the WHERE clause: This will include the conditions identified earlier to filter the results accordingly."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT product.product_id, product.product, product.dimensions, product.dpi, product.pages_per_minute_color, product.max_page_size, product.interface \nFROM product \nWHERE product.max_page_size = 'A4' \nAND product.pages_per_minute_color < '5';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4932", "db_id": "store_product", "question": "Find products with max page size as \"A4\" or pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the columns we need for the query.", "Determine the conditions: We need to find products where the max page size is 'A4' or the pages per minute for color is less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table where either of the conditions is met."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < '5';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4935", "db_id": "store_product", "question": "What are all of the products whose name includes the substring \"Scanner\"?", "rationale": ["Identify the table that contains product names or descriptions, which is the 'product' table.", "Determine the requirement to filter products based on a substring in their name, specifically 'Scanner'.", "Use the SQL LIKE operator to search for the substring 'Scanner' within the 'product' column.", "Construct the SQL query to select all columns from the 'product' table where the 'product' column contains the substring 'Scanner'."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE product LIKE '%Scanner%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4937", "db_id": "store_product", "question": "What is the most common maximum page size?", "rationale": ["Identify the column of interest: 'max_page_size' from the 'product' table.", "To find the most common maximum page size, we need to group the results by 'max_page_size'.", "Count the occurrences of each 'max_page_size' using COUNT(*) function.", "Order the results in descending order based on the count to get the most common size at the top.", "Limit the results to 1 to get only the most common maximum page size."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1", "source_tables": ["product"], "pred_sql": "SELECT max_page_size\nFROM product\nGROUP BY max_page_size\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4938", "db_id": "store_product", "question": "Find the name of the products that are not using the most frequently-used max page size.", "rationale": ["Identify the products from the 'product' table.", "Determine the most frequently-used max page size by grouping the products by 'max_page_size' and counting occurrences.", "Order the results by the count in descending order to find the most common max page size.", "Use a subquery to get the most common max page size.", "Select products whose 'max_page_size' is not equal to the most common one."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "pred_sql": "SELECT product.product \nFROM product \nWHERE product.max_page_size != (SELECT max_page_size \n                                  FROM product \n                                  GROUP BY max_page_size \n                                  ORDER BY COUNT(*) DESC \n                                  LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["Identify the table needed: The 'College' table contains the enrollment numbers.", "Determine the required calculation: We need to calculate the average enrollment for each college.", "Use the AVG() function to compute the average of the 'enr' column.", "Group the results by 'cName' to get the average enrollment for each college."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "pred_sql": "SELECT cName, AVG(enr) AS average_enrollment FROM College GROUP BY cName;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["The question asks for the average training hours of players.", "To find the average, we will use the AVG() function in SQL.", "We need to select from the Player table, assuming there is a column for training hours, which is not explicitly mentioned in the schema provided.", "Since the schema does not include a training_hours column, we cannot directly answer the question with the given tables."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_training_hours FROM Player", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.4956", "db_id": "soccer_2", "question": "Find the name and training hours of players whose hours are below 1500.", "rationale": ["Identify the relevant table: The Player table contains the names of players and their training hours.", "Determine the columns needed: We need the player's name (pName) and their training hours.", "Apply the filter: We need to filter players whose training hours are below 1500.", "Construct the SQL query: Use SELECT to get the required columns from the Player table with the specified condition."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "pred_sql": "SELECT pName, training_hours FROM Player WHERE training_hours < 1500;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.4961", "db_id": "soccer_2", "question": "What are the different types of player positions?", "rationale": ["The user wants to know the different types of player positions.", "To find the different player positions, we need to select the distinct values from the 'pPos' column in the 'Tryout' table.", "Using the DISTINCT keyword ensures that we only get unique player positions without duplicates."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT pPos FROM Tryout;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["Identify the relevant table: The 'Tryout' table contains information about players and their decisions after tryouts.", "Determine the condition for acceptance: We need to count the number of players whose decision is 'accepted'.", "Use the COUNT function to count the number of accepted players.", "Construct the SQL query to select the count from the Tryout table where the decision is 'accepted'."], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) AS accepted_students\nFROM Tryout\nWHERE decision = 'accepted';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\"\n}\n"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["Identify the relevant table: The Player table contains information about players, but it does not have a column for training hours. Therefore, we need to assume that training hours are either part of the Player table or need to be calculated based on other data.", "Determine the aggregation functions needed: We need to find the maximum, average, and minimum training hours, which can be done using the MAX(), AVG(), and MIN() functions respectively.", "Construct the SQL query: Since the hint mentions a virtual table related to high school attendance, we might need to consider that players' training hours could be indirectly related to their high school performance. However, without a direct column for training hours in the provided schema, we will assume a hypothetical column 'training_hours' exists in the Player table for the sake of this query.", "Write the final SQL query: The final SQL query will select the maximum, average, and minimum training hours from the Player table."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT MAX(training_hours) AS max_hours, AVG(training_hours) AS avg_hours, MIN(training_hours) AS min_hours FROM Player;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.4967", "db_id": "soccer_2", "question": "What is the average, maximum, and minimum for the number of hours spent training?", "rationale": ["Identify the relevant data needed to answer the question about training hours.", "Determine that we need to calculate average, maximum, and minimum values for the training hours.", "Assume there is a table named 'Training' that contains a column 'training_hours' for the number of hours spent training.", "Construct the SQL query to select the average, maximum, and minimum of the 'training_hours' column from the 'Training' table."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_training_hours, MAX(training_hours) AS max_training_hours, MIN(training_hours) AS min_training_hours FROM Training;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.4970", "db_id": "soccer_2", "question": "What are the names of players whose training hours is between 500 and 1500?", "rationale": ["Identify the relevant table: The question asks for player names, so we will focus on the Player table.", "Determine the condition: The question specifies a range for training hours (between 500 and 1500).", "Assume there is a column 'training_hours' in the Player table (not explicitly mentioned in the schema but inferred from the question).", "Construct the SQL query to select player names where training hours fall within the specified range."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE training_hours BETWEEN 500 AND 1500;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.4971", "db_id": "soccer_2", "question": "What are the names of players who train between 500 and 1500 hours?", "rationale": ["Identify the relevant tables: Player and Tryout.", "Determine the necessary columns: We need the names of players, which is in the Player table under pName.", "Understand the filtering criteria: We need to filter players based on their training hours, which suggests a need for a Training table that is not explicitly mentioned in the schema but is implied by the question.", "Use a subquery to filter players based on their training hours between 500 and 1500.", "Join the results of the subquery with the Player table to get the names of the players who meet the criteria."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE pPos IN ('position1', 'position2')) AND pID IN (SELECT pID FROM Training WHERE hours BETWEEN 500 AND 1500);", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.4975", "db_id": "soccer_2", "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?", "rationale": ["Identify the relevant table: College.", "Determine the columns needed: cName and enr.", "Set the condition for enrollment: enr > '10000'.", "Set the condition for the state: state = 'Louisiana'.", "Combine the conditions using AND in the WHERE clause."], "gold_sql": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = 'LA'", "source_tables": ["college"], "pred_sql": "SELECT cName, enr FROM College WHERE enr > '10000' AND state = 'Louisiana';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of colleges located in a specific state that have an enrollment number either less than or greater than a specified value. The placeholders in the WHERE clauses represent the enrollment numbers and the state name.\"\n}\n"}
{"sample_id": "train.4981", "db_id": "soccer_2", "question": "What are the name of the players who received a card in descending order of the hours of training?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find players who received a card, which is indicated by the decision in the Tryout table.", "We will filter the Player table based on the pID from the Tryout table where the decision is 'received card'.", "To order the players by the hours of training, we will use a subquery to get the maximum high school attended by players grouped by their position.", "Finally, we will order the results in descending order based on the training hours derived from the subquery."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE decision = 'received card') ORDER BY (SELECT MAX(HS) FROM Player GROUP BY pPos) DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["Identify the relevant table: The 'Tryout' table contains the information about players and their positions during tryouts.", "Determine the required information: We need to find out which position is the most popular among players.", "Use the COUNT function: To find the most popular position, we can count the number of players for each position.", "Group the results: We will group the results by 'pPos' to aggregate the counts for each position.", "Order the results: We will order the results in descending order based on the count of players for each position.", "Limit the results: To get only the most popular position, we will limit the results to 1."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["Identify the relevant table: The Tryout table contains the information about the positions players are trying out for.", "Count the occurrences of each position: Use COUNT(*) to count how many players are trying out for each position.", "Group the results by position: Use GROUP BY pPos to aggregate the counts for each position.", "Order the results: Use ORDER BY position_count DESC to sort the positions by the number of players trying out for them, in descending order.", "Limit the results to the top position: Use LIMIT 1 to get only the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["Identify the relevant table: The question pertains to players and their positions, so we will focus on the Tryout table.", "Determine the required information: We need to find the minimum hours of students playing in different positions.", "Assume there is a column for hours in the Tryout table (not explicitly mentioned in the schema), as the question implies a need for hours played.", "Group the results by position (pPos) to get the minimum hours for each position.", "Construct the SQL query to select the position and the minimum hours, grouping by position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(hours) AS min_hours\nFROM Tryout\nGROUP BY pPos;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["Identify the relevant table: The 'Tryout' table contains the position ('pPos') and the players' practice times (assumed to be a column, though not explicitly mentioned in the schema).", "Determine the aggregation needed: We need to find the minimum practice time for each position, which requires using the MIN() function.", "Group the results by position: To get the minimum practice time for each position, we will use GROUP BY on the 'pPos' column.", "Construct the SQL query: Combine the SELECT statement with the aggregation and grouping to form the complete SQL query."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(practice_time) AS min_practice_time\nFROM Tryout\nGROUP BY pPos;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["Identify the tables involved: Player and Tryout.", "We need to select the names of students (Player.pName) and the position they practiced for (Tryout.pPos).", "Join the Player table with the Tryout table on the common column pID.", "Filter the results to include only those records where the decision in Tryout is 'yes'."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT Player.pName, Tryout.pPos \nFROM Player \nJOIN Tryout ON Player.pID = Tryout.pID \nWHERE Tryout.decision = 'yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find the names of students (players) who successfully tried out for a specific position, which is 'striker'.", "To do this, we will join the Player table with the Tryout table on the player ID (pID).", "We will filter the results to include only those records where the position (pPos) is 'striker' and the decision is 'successful'.", "Finally, we will select the names of the players (pName) from the filtered results."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT Player.pName \nFROM Player \nJOIN Tryout ON Player.pID = Tryout.pID \nWHERE Tryout.pPos = 'striker' AND Tryout.decision = 'successful';", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find players who were rejected, so we will filter the Tryout table by the 'decision' column.", "To calculate the average, we will use the AVG() function on the practice hours, which we assume is a column in the Player table (not explicitly mentioned in the schema).", "Join the Player and Tryout tables on the pID to correlate players with their tryout decisions.", "Construct the SQL query to select the average practice hours for players with a rejection decision."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT AVG(practice_hours) AS average_practice_hours\nFROM Player\nJOIN Tryout ON Player.pID = Tryout.pID\nWHERE Tryout.decision = 'rejected';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.5018", "db_id": "soccer_2", "question": "Which college has any student who is a goalie and succeeded in the tryout.", "rationale": ["Identify the relevant tables: College, Player, and Tryout.", "We need to find colleges that have players who are goalies and have succeeded in their tryouts.", "This requires joining the College table with the Tryout table on the college name, and the Tryout table with the Player table on the player ID.", "We will filter the results where the position (pPos) is 'goalie' and the decision is 'succeeded'.", "Finally, we will select distinct college names to avoid duplicates."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT College.cName \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nJOIN Player ON Tryout.pID = Player.pID \nWHERE Tryout.pPos = 'goalie' AND Tryout.decision = 'succeeded';", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find the state and enrollment of colleges where students got accepted in the tryout decision.", "This requires a JOIN between the College and Tryout tables on the college name (cName).", "We filter the results to include only those records where the decision is 'accepted'.", "Finally, we select the state and enrollment number from the College table."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT College.state, College.enr \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.decision = 'accepted';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["We need to find the total number of students enrolled in colleges that have accepted students during tryouts.", "To do this, we will join the College table with the Tryout table on the college name (cName).", "We will filter the results to only include tryouts where the decision was 'accepted'.", "Next, we will group the results by the state of the colleges to get the total enrollment per state.", "Finally, we will sum the enrollment numbers for each state to get the total number of students enrolled in those colleges."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT College.state, SUM(CAST(College.enr AS INTEGER)) AS total_enrollment\nFROM College\nJOIN Tryout ON College.cName = Tryout.cName\nWHERE Tryout.decision = 'accepted'\nGROUP BY College.state;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.5026", "db_id": "soccer_2", "question": "Find the names of schools that have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant tables: We need to look at the Tryout table to find the colleges where players are trying out for specific positions.", "We are interested in the positions 'goalie' and 'mid'.", "We will use the SQL SELECT statement to retrieve distinct college names (cName) from the Tryout table.", "We will filter the results using a WHERE clause to include only those records where the position (pPos) is either 'goalie' or 'mid'.", "To ensure we only get colleges that have players in both positions, we will group the results by college name and use the HAVING clause to count distinct player IDs (pID) that meet the criteria."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT cName \nFROM Tryout \nWHERE pPos IN ('goalie', 'mid') \nGROUP BY cName \nHAVING COUNT(DISTINCT pID) > 0;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.5028", "db_id": "soccer_2", "question": "Find the names of states that have some college students playing in goalie and mid positions.", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find states where colleges have students trying out for specific positions (goalie and mid).", "Use a JOIN to connect the College table with the Tryout table based on the college name (cName).", "Filter the results to include only those rows where the position (pPos) is either 'goalie' or 'mid'.", "Select distinct states to avoid duplicates in the results."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT College.state \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.pPos IN ('goalie', 'mid');", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.5029", "db_id": "soccer_2", "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find states that have colleges with players trying out for specific positions (goalie and mid-field).", "Join the College table with the Tryout table on the college name (cName).", "Use a WHERE clause to filter the positions to 'goalie' and 'mid-field'.", "Select distinct states from the resulting joined table to avoid duplicates."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT College.state \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.pPos IN ('goalie', 'mid-field');", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["Identify the requirement: We need to count the number of schools that have students trying out for the positions of goalie and mid.", "Understand the schema: The relevant table for this query is the 'Tryout' table, which contains the college names and player positions.", "Use the COUNT function to count distinct college names (cName) to avoid duplicates.", "Filter the results using a WHERE clause to include only those records where the position (pPos) is either 'goalie' or 'mid'.", "The final SQL query will select the count of distinct college names from the Tryout table where the position is in the specified list."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(DISTINCT cName) AS school_count\nFROM Tryout\nWHERE pPos IN ('goalie', 'mid');", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.5037", "db_id": "soccer_2", "question": "What is the count of states with college students playing in the mid position but not as goalies?", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to count distinct states from the College table where players are trying out for the 'mid' position.", "Join the College table with the Tryout table on the college name (cName).", "Filter the results to include only those players trying out for the 'mid' position.", "Additionally, exclude players who are trying out for the 'goalie' position by using a subquery that selects pIDs of players in the 'goalie' position.", "Count the distinct states from the filtered results."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')", "source_tables": ["tryout", "college"], "pred_sql": "SELECT COUNT(DISTINCT College.state) \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.pPos = 'mid' \nAND Tryout.pID NOT IN (\n    SELECT pID \n    FROM Tryout \n    WHERE pPos = 'goalie'\n);", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["Identify the requirement: We need to find states with colleges that have enrollments less than some other college.", "Understand the schema: The College table contains the columns 'cName', 'state', and 'enr'.", "Use a subquery to find the minimum enrollment number from the College table, which represents the enrollment of some other college.", "Select distinct states from the College table where the enrollment number is less than the minimum enrollment found in the subquery."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE enr < (SELECT MIN(enr) FROM College)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of colleges located in a specific state that have an enrollment number either less than or greater than a specified value. The placeholders in the WHERE clauses represent the enrollment numbers and the state name.\"\n}\n"}
{"sample_id": "train.5102", "db_id": "cre_Drama_Workshop_Groups", "question": "Show the minimum, average, maximum order quantity of all invoices.", "rationale": ["Identify the relevant table: The 'Invoice_Items' table contains the 'Order_Quantity' column which is needed for the calculations.", "Determine the required calculations: We need to find the minimum, average, and maximum of the 'Order_Quantity'.", "Construct the SQL query: Use the aggregate functions MIN(), AVG(), and MAX() on the 'Order_Quantity' column from the 'Invoice_Items' table."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "pred_sql": "SELECT MIN(Order_Quantity) AS Min_Quantity, AVG(Order_Quantity) AS Avg_Quantity, MAX(Order_Quantity) AS Max_Quantity\nFROM Invoice_Items;", "hint": "\n"}
{"sample_id": "train.5118", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the payment method code used by the most orders?", "rationale": ["Identify the relevant table: Invoices contains the payment_method_code and Order_ID.", "Group the results by payment_method_code to count the number of orders associated with each payment method.", "Use COUNT(Order_ID) to count the number of orders for each payment method.", "Order the results in descending order to get the payment method with the most orders at the top.", "Limit the results to 1 to get only the payment method code used by the most orders."], "gold_sql": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices"], "pred_sql": "SELECT payment_method_code\nFROM Invoices\nGROUP BY payment_method_code\nORDER BY COUNT(Order_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5127", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the descriptions of the service types that cost more than 100.", "rationale": ["Identify the relevant tables: We need to retrieve service type descriptions, which are in the Ref_Service_Types table, and we also need to check the price of services, which is in the Services table.", "Join the tables: We will join the Services table with the Ref_Service_Types table on the Service_Type_Code to get the descriptions of the service types associated with the services.", "Filter the results: We need to filter the results to only include services that cost more than 100. This will be done in the WHERE clause by checking the Product_Price in the Services table."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT Ref_Service_Types.Service_Type_Description \nFROM Services \nJOIN Ref_Service_Types ON Services.Service_Type_Code = Ref_Service_Types.Service_Type_Code \nWHERE Services.Product_Price > 100;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the descriptions of service types associated with a specific product name from the 'Services' table, ensuring that the same product name is used in both parts of the query. The placeholders represent the product name that the user can specify to filter the results accordingly.\"\n}\n"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["Identify the relevant tables: Drama_Workshop_Groups and Services.", "We need to find workshop groups that offer services related to a specific product name, which is 'film'.", "Join the Drama_Workshop_Groups table with the Services table on the Workshop_Group_ID to link the groups with their services.", "Filter the results to only include services where the Product_Name is 'film'.", "Select the distinct Store_Name from the resulting joined table to avoid duplicates."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "pred_sql": "SELECT DISTINCT Drama_Workshop_Groups.Store_Name \nFROM Drama_Workshop_Groups \nJOIN Services ON Drama_Workshop_Groups.Workshop_Group_ID = Services.Workshop_Group_ID \nWHERE Services.Product_Name = 'film';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular product. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5142", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the order details of the products with price higher than 2000?", "rationale": ["Identify the relevant tables: Order_Items and Products are needed to get order details and product information.", "Determine the columns needed: We need Order_Item_ID, Order_ID, Product_ID, Order_Quantity from Order_Items and Product_Name, Product_Price from Products.", "Establish the relationship: Use a JOIN to connect Order_Items with Products on Product_ID.", "Apply the filter: Use a WHERE clause to filter products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_Items.Order_Item_ID, Order_Items.Order_ID, Order_Items.Product_ID, Order_Items.Order_Quantity, Products.Product_Name, Products.Product_Price \nFROM Order_Items \nJOIN Products ON Order_Items.Product_ID = Products.Product_ID \nWHERE Products.Product_Price > 2000;", "hint": "\n"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["Identify the relevant tables: Order_Items and Products are needed to get order details and product prices.", "Determine the columns needed: Order_Item_ID, Order_ID, Product_ID, Order_Quantity from Order_Items and Product_Name, Product_Price from Products.", "Join the Order_Items table with the Products table on Product_ID to access product details for each order item.", "Apply a filter to select only those products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_Items.Order_Item_ID, Order_Items.Order_ID, Order_Items.Product_ID, Order_Items.Order_Quantity, Products.Product_Name, Products.Product_Price \nFROM Order_Items \nJOIN Products ON Order_Items.Product_ID = Products.Product_ID \nWHERE Products.Product_Price > 2000;", "hint": "\n"}
{"sample_id": "train.5160", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the most frequent status of bookings?", "rationale": ["Identify the relevant table: The question pertains to the status of bookings, so we will focus on the 'Bookings' table.", "Determine the required information: We need to find the most frequent status of bookings, which implies counting occurrences of each status code.", "Use the COUNT function: We will count the number of bookings for each status code using COUNT(*) and group the results by 'Status_Code'.", "Sort the results: To find the most frequent status, we will order the results in descending order based on the count of bookings.", "Limit the results: Since we only want the most frequent status, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Frequency\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most common status code, which implies counting occurrences of each status code.", "Use the COUNT function: We will count the number of bookings for each status code.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each unique status code.", "Order the results: To find the most common status code, we will order the results in descending order based on the count.", "Limit the results: Since we only need the most common status code, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Count\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["Identify the relevant tables: We need to find workshop groups and their bookings, so we will use the Drama_Workshop_Groups and Bookings tables.", "Determine the relationship: The Drama_Workshop_Groups table is linked to the Bookings table through the Workshop_Group_ID.", "Filter the results: We need to filter the bookings to only include those with a status code of 'stop'.", "Select the desired information: We want the names of the workshop groups, which are stored in the Store_Name column of the Drama_Workshop_Groups table.", "Use DISTINCT to ensure we only get unique workshop group names."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "pred_sql": "SELECT DISTINCT DWG.Store_Name \nFROM Drama_Workshop_Groups DWG \nJOIN Bookings B ON DWG.Workshop_Group_ID = B.Workshop_Group_ID \nWHERE B.Status_Code = 'stop';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular product. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5171", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the description of the service type that offers not only the photo product but also the film product.", "rationale": ["Identify the relevant tables: We need to retrieve service type descriptions from the Ref_Service_Types table and link it to the Services table where the products are defined.", "Use a JOIN to connect the Services table with the Ref_Service_Types table based on the Service_Type_Code.", "Filter the results to include only those services that offer both 'photo' and 'film' products. This can be done using a WHERE clause with an IN condition.", "To ensure that we only get service types that offer both products, we can use GROUP BY on the service type description and use HAVING to count distinct product names, ensuring it equals 2."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT DISTINCT rst.Service_Type_Description\nFROM Services s\nJOIN Ref_Service_Types rst ON s.Service_Type_Code = rst.Service_Type_Code\nWHERE s.Product_Name IN ('photo', 'film')\nGROUP BY rst.Service_Type_Description\nHAVING COUNT(DISTINCT s.Product_Name) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the descriptions of service types associated with a specific product name from the 'Services' table, ensuring that the same product name is used in both parts of the query. The placeholders represent the product name that the user can specify to filter the results accordingly.\"\n}\n"}
{"sample_id": "train.5459", "db_id": "voter_2", "question": "Find the average age of female students.", "rationale": ["Identify the table needed: The 'Student' table contains the necessary information about students, including their age and sex.", "Determine the condition: We need to filter the results to include only female students, which is specified by the condition 'Sex = 'Female' in the WHERE clause.", "Calculate the average: Use the AVG() function to calculate the average age of the filtered results.", "Select the average age: The final output should be labeled as 'Average_Age' for clarity."], "gold_sql": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  'F'", "source_tables": ["student"], "pred_sql": "SELECT AVG(Age) AS Average_Age FROM Student WHERE Sex = 'Female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\"\n}\n"}
{"sample_id": "train.5466", "db_id": "voter_2", "question": "What are the distinct president votes on 08/30/2015?", "rationale": ["Identify the relevant table for the query, which is 'Voting_record' since we are interested in voting data.", "We need to select distinct values for the 'President_Vote' column to get unique votes.", "We need to filter the results based on the 'Registration_Date' to only include votes cast on '08/30/2015'.", "The date format in SQL should be 'YYYY-MM-DD', so '08/30/2015' will be converted to '2015-08-30'.", "Construct the SQL query using SELECT DISTINCT to get unique president votes on the specified date."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote \nFROM Voting_record \nWHERE Registration_Date = '2015-08-30';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\"\n}\n"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["Identify the table that contains the president votes, which is the Voting_record table.", "We need to select distinct president votes, so we will use the DISTINCT keyword.", "The query should filter the records based on the date of registration, which is provided as '08/30/2015'.", "In SQLite, the date format should be 'YYYY-MM-DD', so we will convert '08/30/2015' to '2015-08-30'.", "Construct the SQL query to select distinct President_Vote from Voting_record where Registration_Date matches the specified date."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT Voting_record.President_Vote \nFROM Voting_record \nWHERE Registration_Date = '2015-08-30';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\"\n}\n"}
{"sample_id": "train.5476", "db_id": "voter_2", "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for student details and the 'Voting_record' table for voting details.", "Determine the columns needed: We need the distinct ages of students, so we will select the 'Age' column from the 'Student' table.", "Establish the relationship between tables: We will join the 'Student' table with the 'Voting_record' table on the 'StuID' column, which is common to both tables.", "Apply the necessary filters: We need to filter for students who have cast a vote for the secretary, which means 'Secretary_Vote' should not be null. Additionally, we need to specify the election cycle as 'fall'.", "Construct the SQL query: Combine all the elements into a complete SQL query that selects distinct ages from the joined tables with the specified conditions."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Age FROM Student INNER JOIN Voting_record ON Student.StuID = Voting_record.StuID WHERE Secretary_Vote IS NOT NULL AND Election_Cycle = 'fall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\"\n}\n"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for advisor information and the 'Voting_record' table for voting details.", "Determine the relationship: The 'Voting_record' table has a foreign key 'StuID' that links to the 'Student' table, allowing us to join these tables on 'StuID'.", "Specify the selection criteria: We want to find students who have cast a vote for treasurer, which means we need to check if 'Treasurer_Vote' is not null.", "Additionally, we need to filter for the spring election cycle, which is indicated by the 'Election_Cycle' column.", "Use DISTINCT to ensure we only get unique advisors, as multiple students may have the same advisor."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Advisor \nFROM Student S \nJOIN Voting_record V ON S.StuID = V.StuID \nWHERE V.Treasurer_Vote IS NOT NULL \nAND V.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.\"\n}\n"}
{"sample_id": "train.5486", "db_id": "voter_2", "question": "How many male (sex is M) students have class senator votes in the fall election cycle?", "rationale": ["Identify the relevant tables: Student and Voting_record.", "We need to count male students, so we will filter the Student table by Sex = 'M'.", "We need to check for class senator votes, which means we will look at the Class_Senator_Vote column in the Voting_record table.", "We will join the Student and Voting_record tables on StuID to combine the relevant information.", "We need to filter the records for the fall election cycle, so we will add a condition for Election_Cycle.", "Finally, we will count the distinct StuID from the Student table where the conditions are met."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Student.Sex = 'M' \nAND Voting_record.Election_Cycle = 'fall' \nAND Voting_record.Class_Senator_Vote IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\"\n}\n"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["Identify the relevant tables: Student and Voting_record.", "Determine the columns needed: Average age from Student and filtering based on city code and voting record.", "Join the Student table with the Voting_record table on StuID to combine student information with their voting records.", "Filter the results to include only students from the city code 'NYC'.", "Further filter to include only those who have cast a vote for secretary in the specified election cycle (spring).", "Use the AVG() function to calculate the average age of the filtered students."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(Age) AS Average_Age\nFROM Student\nJOIN Voting_record ON Student.StuID = Voting_record.StuID\nWHERE Student.city_code = 'NYC' AND Voting_record.Secretary_Vote IS NOT NULL AND Voting_record.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\"\n}\n"}
{"sample_id": "train.5492", "db_id": "voter_2", "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.", "rationale": ["Identify the relevant tables: Student and Voting_record.", "We need to find the average age of female students, so we will filter the Student table by Sex = 'F'.", "We also need to ensure that these students have voted for the secretary, which means we will check that Secretary_Vote is not null in the Voting_record table.", "The query must join the Student and Voting_record tables on the StuID column to combine the relevant data.", "Finally, we will calculate the average age using the AVG() function and filter for the spring election cycle."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(Age) AS Average_Age\nFROM Student\nJOIN Voting_record ON Student.StuID = Voting_record.StuID\nWHERE Sex = 'F' AND Secretary_Vote IS NOT NULL AND Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\"\n}\n"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["We need to find distinct first names of students who voted for the vice president.", "To do this, we will join the Student table with the Voting_record table on the StuID column, which is the unique identifier for students.", "We will filter the results to include only those records where the Vice_President_Vote is not null, indicating that the student has cast a vote for vice president.", "Additionally, we will filter out students whose city code is 'PIT' by using the condition Student.city_code != 'PIT'.", "Finally, we will select distinct first names (Fname) from the resulting dataset."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Student.Fname \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Voting_record.Vice_President_Vote IS NOT NULL \nAND Student.city_code != 'PIT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\"\n}\n"}
{"sample_id": "train.5495", "db_id": "voter_2", "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?", "rationale": ["Identify the relevant tables: We need to retrieve data from the Student table and the Voting_record table.", "Determine the necessary columns: We want the distinct first names of students, which is in the Student table (Fname).", "Establish the relationship between tables: We will join the Student table with the Voting_record table on the StuID column, which is the unique identifier for students in both tables.", "Apply the filtering conditions: We need to filter for students who have voted for the vice president (i.e., Vice_President_Vote is not null) and also ensure that the city code is not 'PIT'.", "Construct the SQL query: Combine all the elements into a complete SQL query that selects distinct first names based on the specified conditions."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Student.Fname \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Voting_record.Vice_President_Vote IS NOT NULL \nAND Student.city_code != 'PIT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\"\n}\n"}
{"sample_id": "train.5496", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is not 2192.", "rationale": ["Identify the relevant tables: We need to retrieve data from the 'Student' and 'Voting_record' tables.", "Determine the columns needed: We need the distinct last names of students, which is in the 'LName' column of the 'Student' table.", "Establish the relationship: We need to join the 'Student' table with the 'Voting_record' table on the 'StuID' column, which is common to both tables.", "Set the conditions: We want students who have cast a vote for president (i.e., 'President_Vote' is not null) and whose advisor is not '2192'.", "Construct the SQL query: Using the SELECT statement to get distinct last names, applying the JOIN, and adding the WHERE clause for the conditions."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Student.LName \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Voting_record.President_Vote IS NOT NULL \nAND Student.Advisor != '2192';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\"\n}\n"}
{"sample_id": "train.5499", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes and have 8741 as the advisor?", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for last names and the 'Voting_record' table for voting information.", "We need to find students who have cast a vote for president, which means we will check the 'President_Vote' column in the 'Voting_record' table.", "We also need to filter students based on their advisor, specifically those with '8741' as their advisor in the 'Student' table.", "To get the distinct last names, we will use the DISTINCT keyword in our SELECT statement.", "We will join the 'Student' table with the 'Voting_record' table on the StuID to correlate students with their voting records."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student INNER JOIN Voting_record ON Student.StuID = Voting_record.StuID WHERE President_Vote IS NOT NULL AND Advisor = '8741';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\"\n}\n"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and gender.", "Filter the records: We need to focus on female students, so we will add a WHERE clause to filter by 'Sex = 'F' '.", "Group the results: To find the most common major, we will group the results by the 'Major' column.", "Count occurrences: We will use COUNT(*) to count how many students are in each major.", "Order the results: To find the most common major, we will order the results in descending order based on the count of students in each major.", "Limit the results: Since we only want the most common major, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as MajorCount\nFROM Student\nWHERE Sex = 'F'\nGROUP BY Major\nORDER BY MajorCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\"\n}\n"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["We need to find the major studied by the most female students.", "To do this, we will select the 'Major' column from the 'Student' table.", "We will count the number of female students in each major using COUNT(*) and filter the results where 'Sex' is 'Female'.", "We will group the results by 'Major' to get the count of female students for each major.", "To find the major with the most female students, we will order the results in descending order based on the count of female students.", "Finally, we will limit the results to 1 to get the major with the highest count."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) AS Female_Student_Count\nFROM Student\nWHERE Sex = 'Female'\nGROUP BY Major\nORDER BY Female_Student_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\"\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to count the number of products, so we will use the COUNT() function.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to filter by category.", "Add a WHERE clause to filter for the product category description 'Spices'.", "Add another condition in the WHERE clause to filter for products with a typical selling price greater than 1000."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT COUNT(*) FROM Products \nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code \nWHERE Ref_Product_Categories.product_category_description = 'Spices' \nAND Products.typical_selling_price > 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the relevant tables: We need to get product category descriptions from the Ref_Product_Categories table and filter products based on their descriptions from the Products table.", "Determine the relationship: The Products table has a foreign key relationship with the Ref_Product_Categories table through the product_category_code.", "Formulate the query: We will select distinct product category descriptions from Ref_Product_Categories where the corresponding products have descriptions containing the letter 't'.", "Use the LIKE operator to filter product descriptions that contain the letter 't'.", "Join the two tables on the product_category_code to link products to their respective categories."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description \nFROM Ref_Product_Categories rpc \nJOIN Products p ON rpc.product_category_code = p.product_category_code \nWHERE p.product_description LIKE '%t%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["Identify the relevant tables: Products, Product_Characteristics, and Characteristics are needed to find the distinct characteristic names for the product 'cumin'.", "Use a JOIN operation to connect these tables based on their foreign key relationships: Products to Product_Characteristics via product_id, and Product_Characteristics to Characteristics via characteristic_id.", "Filter the results to only include the product with the name 'cumin' using a WHERE clause.", "Count the distinct characteristic names using COUNT(DISTINCT ...) to ensure we only get unique names."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT Characteristics.characteristic_name) AS distinct_characteristic_count\nFROM Products\nJOIN Product_Characteristics ON Products.product_id = Product_Characteristics.product_id\nJOIN Characteristics ON Product_Characteristics.characteristic_id = Characteristics.characteristic_id\nWHERE Products.product_name = 'cumin';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\"\n}\n"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["Identify the tables involved: Products, Ref_Colors, Product_Characteristics, and Characteristics.", "We need to count the products that either have a color described as 'white' or have a characteristic with the name 'hot'.", "Join the Products table with the Ref_Colors table to filter by color description.", "Join the Products table with the Product_Characteristics table to access the characteristics of each product.", "Join the Product_Characteristics table with the Characteristics table to filter by characteristic name.", "Use a WHERE clause to specify the conditions for color description and characteristic name.", "Use COUNT(DISTINCT p.product_id) to ensure we count each product only once, regardless of how many characteristics it has."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT p.product_id) \nFROM Products p \nLEFT JOIN Ref_Colors c ON p.color_code = c.color_code \nLEFT JOIN Product_Characteristics pc ON p.product_id = pc.product_id \nLEFT JOIN Characteristics ch ON pc.characteristic_id = ch.characteristic_id \nWHERE c.color_description = 'white' OR ch.characteristic_name = 'hot';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\"\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the relationship between the tables: Products has a foreign key to Ref_Product_Categories via product_category_code.", "We need to filter products that are related to 'Herb', so we will use a WHERE clause with a LIKE condition on the product_name.", "Select the unit_of_measure from Ref_Product_Categories, which is linked to the Products table through the product_category_code."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT Ref_Product_Categories.unit_of_measure \nFROM Products \nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code \nWHERE Products.product_name LIKE '%Herb%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\"\n}\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the columns needed: unit of measurement from Ref_Product_Categories and product category code from Products.", "Join the Products table with Ref_Product_Categories on the product_category_code.", "Filter the results to only include the product named 'chervil'.", "Construct the SQL SELECT statement to retrieve the desired columns."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT pc.product_category_code, p.product_category_code \nFROM Products p \nJOIN Ref_Product_Categories pc ON p.product_category_code = pc.product_category_code \nWHERE p.product_name = 'chervil';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["We need to find the description of the color for most products.", "To do this, we will join the 'Products' table with the 'Ref_Colors' table on the 'color_code' column.", "We will count the number of products associated with each color description using COUNT(p.product_id).", "We will group the results by the color description to aggregate the product counts.", "To find the color with the most products, we will order the results in descending order by the product count.", "Finally, we will limit the results to 1 to get the color description for the most products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT c.color_description, COUNT(p.product_id) AS product_count\nFROM Products p\nJOIN Ref_Colors c ON p.color_code = c.color_code\nGROUP BY c.color_description\nORDER BY product_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\"\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["We need to find the description of the color used by the least number of products.", "To do this, we will join the Ref_Colors table with the Products table on the color_code.", "We will group the results by color_code to count how many products are associated with each color.", "Next, we will order the results by the count of products in ascending order to get the color with the least products first.", "Finally, we will limit the results to 1 to get only the color description used by the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT c.color_description\nFROM Ref_Colors c\nJOIN Products p ON c.color_code = p.color_code\nGROUP BY c.color_code\nORDER BY COUNT(p.product_id) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\"\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To do this, we will join the 'Characteristics' table with the 'Product_Characteristics' table to link characteristics to products.", "Next, we will join the 'Products' table to ensure we are counting the products associated with each characteristic.", "We will group the results by the characteristic name to aggregate the product counts for each characteristic.", "Finally, we will use the HAVING clause to filter the results to only include characteristics that are linked to two or more distinct products."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT c.characteristic_name\nFROM Characteristics c\nJOIN Product_Characteristics pc ON c.characteristic_id = pc.characteristic_id\nJOIN Products p ON pc.product_id = p.product_id\nGROUP BY c.characteristic_name\nHAVING COUNT(DISTINCT p.product_id) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\"\n}\n"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to query.", "Select the 'Builder' column: We want to list the builders, so we will select this column.", "Use DISTINCT to avoid duplicate entries: Since multiple railways can have the same builder, we will use DISTINCT to ensure each builder is listed only once.", "Order the results: We need the results in ascending alphabetical order, so we will use ORDER BY Builder ASC.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "pred_sql": "SELECT DISTINCT Builder FROM railway ORDER BY Builder ASC;", "hint": "\n"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["Identify the relevant tables: railway and train.", "We need to find the railway associated with the most trains, so we will join the railway table with the train table on the Railway_ID.", "We will group the results by Railway_ID and Builder to count the number of trains associated with each railway.", "Use COUNT(train.Train_ID) to count the number of trains for each railway.", "Order the results in descending order based on the count of trains to get the railway with the most trains at the top.", "Limit the results to 1 to get only the railway associated with the most trains."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "pred_sql": "SELECT railway.Railway_ID, railway.Builder \nFROM railway \nJOIN train ON railway.Railway_ID = train.Railway_ID \nGROUP BY railway.Railway_ID, railway.Builder \nORDER BY COUNT(train.Train_ID) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["We need to find the most common builder of railways, which means we need to count how many railways each builder has constructed.", "To do this, we will select the 'Builder' column from the 'railway' table and use the COUNT() function to count the occurrences of each builder.", "We will group the results by the 'Builder' column to aggregate the counts for each builder.", "Next, we will order the results in descending order based on the count of railways built by each builder, so that the most common builder appears first.", "Finally, we will limit the results to just one entry to get the most common builder."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "pred_sql": "SELECT Builder, COUNT(*) as BuilderCount \nFROM railway \nGROUP BY Builder \nORDER BY BuilderCount DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["Identify the relevant table: The 'Student' table contains the last names and other details of students.", "Determine the criteria for selection: We need students who are either female, live in a city with the code 'BAL', or are male and under 20 years old.", "Construct the WHERE clause: The conditions can be combined using OR operators to filter the students based on the specified criteria.", "Select the last names: We only need the 'LName' column from the 'Student' table that meets the criteria."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "pred_sql": "SELECT LName FROM Student WHERE (Sex = 'Female' OR city_code = 'BAL' OR (Sex = 'Male' AND Age < '20'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of last names of students from the 'Student' table based on specific criteria. It includes students of a certain gender residing in a specific city, as well as students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age criteria.\"\n}\n"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["Identify the tables involved: Dorm and Has_amenity.", "We need to count the amenities for each dorm, so we will use a JOIN between Dorm and Has_amenity on the dormid.", "We need to filter the dorms based on their capacity, specifically those that can accommodate more than 100 students, which will be done in the WHERE clause.", "We will group the results by dorm name to get the count of amenities for each dorm.", "Finally, we will select the dorm name and the count of amenities as the output."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "pred_sql": "SELECT Dorm.dorm_name, COUNT(Has_amenity.amenid) AS amenity_count\nFROM Dorm\nJOIN Has_amenity ON Dorm.dormid = Has_amenity.dormid\nWHERE Dorm.student_capacity > 100\nGROUP BY Dorm.dorm_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\"\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables involved: We need to count students living in male dorms, so we will use the 'Lives_in' and 'Dorm' tables.", "Determine the relationship: The 'Lives_in' table links students to dorms, and the 'Dorm' table contains information about the dorms, including their gender designation.", "Filter for male dorms: We will add a WHERE clause to filter the dorms by gender, specifically looking for those designated as 'male'.", "Count the distinct students: We will use COUNT(DISTINCT Lives_in.stuid) to get the total number of unique students living in these male dorms."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(DISTINCT Lives_in.stuid) AS total_students\nFROM Lives_in\nJOIN Dorm ON Lives_in.dormid = Dorm.dormid\nWHERE Dorm.gender = 'male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\"\n}\n"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["Identify the dormitory with the most amenities by counting the number of amenities for each dormitory using the Has_amenity table.", "Use a subquery to select the dormid from the Has_amenity table, grouping by dormid and ordering by the count of amenities in descending order, limiting the result to the top one.", "Next, find the students who live in that dormitory by using the Lives_in table to match the dormid from the previous step.", "Finally, select the first names of those students from the Student table using their StuID."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT Fname FROM Student WHERE StuID IN (SELECT stuid FROM Lives_in WHERE dormid = (SELECT dormid FROM Has_amenity GROUP BY dormid ORDER BY COUNT(amenid) DESC LIMIT 1));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\"\n}\n"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["Identify the required fields: first name and age of students.", "Determine the relationships between tables: Students live in Dorms, and Dorms have amenities.", "Use JOINs to connect the Student table with Lives_in, Dorm, Has_amenity, and Dorm_amenity tables.", "Filter the results to only include dorms that have a 'TV Lounge' amenity."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "pred_sql": "SELECT Student.Fname, Student.Age \nFROM Student \nJOIN Lives_in ON Student.StuID = Lives_in.stuid \nJOIN Dorm ON Lives_in.dormid = Dorm.dormid \nJOIN Has_amenity ON Dorm.dormid = Has_amenity.dormid \nJOIN Dorm_amenity ON Has_amenity.amenid = Dorm_amenity.amenid \nWHERE Dorm_amenity.amenity_name = 'TV Lounge';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\"\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the goal: We need to find the emails of customers who have filed complaints about the product with the greatest number of complaints.", "To achieve this, we will need to join the Customers table with the Complaints table on the customer_id.", "Next, we need to determine which product has the greatest number of complaints. This can be done by grouping the Complaints table by product_id and counting the number of complaints for each product.", "We will order the results of this grouping in descending order and limit the results to 1 to get the product with the highest count of complaints.", "Finally, we will use this product_id in our main query to filter the customers who have filed complaints about that product. We will select the distinct email addresses of these customers."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT DISTINCT c.email_address\nFROM Customers c\nJOIN Complaints co ON c.customer_id = co.customer_id\nWHERE co.product_id = (\n    SELECT product_id\n    FROM Complaints\n    GROUP BY product_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\"\n}\n"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["Identify the products that have been complained about by customers.", "Join the Products table with the Complaints table using the product_id to get the relevant products for each complaint.", "To find the customer who has filed the least amount of complaints, we need to group the Complaints by customer_id and count the number of complaints for each customer.", "Order the results of this count in ascending order to find the customer with the least complaints.", "Use a subquery to select the customer_id of the customer with the least complaints, limiting the result to 1.", "Finally, filter the main query to only include products associated with this customer."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT p.product_name \nFROM Products p \nJOIN Complaints c ON p.product_id = c.product_id \nWHERE c.customer_id = (\n    SELECT customer_id \n    FROM Complaints \n    GROUP BY customer_id \n    ORDER BY COUNT(complaint_id) ASC \n    LIMIT 1\n)\nGROUP BY p.product_id;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\"\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the relevant tables: Staff, Complaints, and Products.", "We need to find the staff member in charge of a complaint related to the product with the lowest price.", "Join the Staff table with the Complaints table on staff_id to get the staff handling the complaints.", "Join the Complaints table with the Products table on product_id to access product details related to the complaints.", "Use a subquery to find the minimum product price from the Products table.", "Filter the results to only include the staff member handling the complaint for the product with the lowest price."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT Staff.last_name \nFROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nJOIN Products ON Complaints.product_id = Products.product_id \nWHERE Products.product_price = (\n    SELECT MIN(product_price) \n    FROM Products\n)", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\"\n}\n"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["Identify the relevant table: The Complaints table contains the complaint status information.", "We need to count the number of records for each complaint status, so we will use the COUNT() function.", "Group the results by complaint_status_code to aggregate the counts for each status.", "Use the HAVING clause to filter the results to only include those complaint statuses that have more than 3 records."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "pred_sql": "SELECT complaint_status_code, COUNT(*) as complaint_count \nFROM Complaints \nGROUP BY complaint_status_code \nHAVING COUNT(*) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\"\n}\n"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["Identify the most common customer type by grouping the Customers table by customer_type_code and counting occurrences.", "Use a subquery to find the customer_type_code that has the highest count.", "Count the total number of customers that have this most common customer_type_code."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) AS customer_count\nFROM Customers\nWHERE customer_type_code = (\n    SELECT customer_type_code\n    FROM Customers\n    GROUP BY customer_type_code\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique town or city names from the 'Customers' table, filtered by a specific customer type code. The results are grouped by town or city and ordered by the count of occurrences, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the customer type code and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to find the first names of staff members, so we will select the 'first_name' column from the Staff table.", "To determine which staff members have handled the greatest number of complaints, we will need to count the number of complaints associated with each staff member.", "This can be done by grouping the Complaints table by 'staff_id' and counting the 'complaint_id' for each group.", "We will then order the results by the count of complaints in descending order to get the staff who handled the most complaints at the top.", "Finally, we will limit the results to the top 5 staff members and use their 'staff_id' to retrieve their first names from the Staff table."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Complaints GROUP BY staff_id ORDER BY COUNT(complaint_id) DESC LIMIT 5)", "hint": "\n"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["Identify the table that contains the staff members' first names, which is the 'Staff' table.", "Determine the relationship between staff members and complaints, which is through the 'Complaints' table where 'staff_id' is a foreign key.", "To find the staff members who have handled the most complaints, we need to count the number of complaints associated with each staff member.", "Use a subquery to group the complaints by 'staff_id' and count the number of complaints for each staff member.", "Order the results of the subquery in descending order based on the count of complaints to get the staff members with the most complaints at the top.", "Limit the results of the subquery to the top 5 staff members.", "Finally, select the 'first_name' of these top 5 staff members from the 'Staff' table using the 'staff_id' from the subquery."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name \nFROM Staff \nWHERE staff_id IN (\n    SELECT staff_id \n    FROM Complaints \n    GROUP BY staff_id \n    ORDER BY COUNT(complaint_id) DESC \n    LIMIT 5\n)", "hint": "\n"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The user wants to see all investor details, which means we need to select all columns from the Investors table.", "The SQL command to retrieve all columns from a table is 'SELECT *'.", "We specify the table we are selecting from, which in this case is 'Investors'."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "pred_sql": "SELECT * FROM Investors;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["We need to show details of all investors who have made transactions with a share count greater than 100.", "To do this, we will select the investor_id and Investor_details from the Investors table.", "We will join the Investors table with the Transactions table on the investor_id to link investors with their transactions.", "We will apply a filter in the WHERE clause to only include transactions where the share_count is greater than 100."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "pred_sql": "SELECT Investors.investor_id, Investors.Investor_details \nFROM Investors \nJOIN Transactions ON Investors.investor_id = Transactions.investor_id \nWHERE Transactions.share_count > 100;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["Identify the relevant tables: Lots, Transactions, and Transactions_Lots.", "We need to retrieve lot details, so we will select 'lot_details' from the Lots table.", "To link lots with transactions, we will use the Transactions_Lots table, which connects Transactions and Lots.", "We need to filter transactions based on the share count, specifically those with a share count smaller than 50.", "Construct the SQL query using JOINs to connect the tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT Lots.lot_details \nFROM Lots \nJOIN Transactions_Lots ON Lots.lot_id = Transactions_Lots.lot_id \nJOIN Transactions ON Transactions_Lots.transaction_id = Transactions.transaction_id \nWHERE Transactions.share_count < 50;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["We need to calculate the average transaction amount for different transaction types.", "To do this, we will select the transaction type description from the Ref_Transaction_Types table and the average of the transaction amounts from the Transactions table.", "We will join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to get the descriptions of the transaction types.", "We will use the AVG() function to calculate the average amount of transactions.", "Finally, we will group the results by the transaction type description to get the average for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["We need to show the maximum and minimum share count of different transaction types.", "To achieve this, we will select the transaction type description from the Ref_Transaction_Types table.", "We will also select the maximum and minimum share count from the Transactions table.", "To link these two tables, we will use a JOIN on the transaction_type_code.", "We will group the results by the transaction type description to get the max and min share counts for each type."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, MAX(t.share_count) AS max_share_count, MIN(t.share_count) AS min_share_count\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["We need to retrieve details of all sales and purchases, which are stored in the Sales and Purchases tables respectively.", "To get the details from both tables, we will perform a LEFT JOIN between the Sales table and the Transactions table using the sales_transaction_id and transaction_id columns.", "Next, we will also perform a LEFT JOIN between the Purchases table and the Transactions table using the purchase_transaction_id and transaction_id columns.", "This will allow us to gather all relevant details from both the Sales and Purchases tables in a single query."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "pred_sql": "SELECT Sales.sales_transaction_id, Sales.sales_details, Purchases.purchase_transaction_id, Purchases.purchase_details\nFROM Sales\nLEFT JOIN Transactions ON Sales.sales_transaction_id = Transactions.transaction_id\nLEFT JOIN Purchases ON Purchases.purchase_transaction_id = Transactions.transaction_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
