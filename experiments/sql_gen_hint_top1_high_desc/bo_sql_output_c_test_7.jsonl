{"sample_id": "dev.924", "db_id": "dog_kennels", "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to list dog names, so we will select the 'name' column from the Dogs table.", "To find the total treatment cost for each dog, we will join the Dogs table with the Treatments table on the dog_id.", "We will group the results by dog_id to aggregate the treatment costs for each dog.", "We will use the HAVING clause to filter out dogs whose total treatment cost exceeds 1000."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.name\nFROM Dogs d\nJOIN Treatments t ON d.dog_id = t.dog_id\nGROUP BY d.dog_id\nHAVING SUM(t.cost_of_treatment) <= 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.\"\n}\n"}
{"sample_id": "dev.937", "db_id": "dog_kennels", "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.", "rationale": ["We need to find the owner who spent the most on treatments for their dogs.", "To do this, we will join the Owners table with the Dogs table to link each dog to its owner.", "Next, we will join the Treatments table to get the treatment costs associated with each dog.", "We will group the results by owner to aggregate the total treatment costs for each owner.", "Finally, we will order the results by the total treatment costs in descending order and limit the results to the top owner."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT Owners.owner_id, Owners.last_name\nFROM Owners\nJOIN Dogs ON Owners.owner_id = Dogs.owner_id\nJOIN Treatments ON Dogs.dog_id = Treatments.dog_id\nGROUP BY Owners.owner_id, Owners.last_name\nORDER BY SUM(Treatments.cost_of_treatment) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["Identify the relevant tables: Treatments and Professionals.", "We need to find professionals who have administered treatments, so we will join the Treatments table with the Professionals table on the professional_id.", "We want to count the number of distinct treatment types each professional has administered, so we will use COUNT(DISTINCT treatment_type_code).", "We will group the results by professional_id to aggregate the counts for each professional.", "Finally, we will filter the results using HAVING to only include professionals who have administered at least two different treatment types."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT professional_id, cell_number\nFROM Treatments\nJOIN Professionals ON Treatments.professional_id = Professionals.professional_id\nGROUP BY professional_id\nHAVING COUNT(DISTINCT treatment_type_code) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\"\n}\n"}
{"sample_id": "dev.943", "db_id": "dog_kennels", "question": "Find the id and cell phone of the professionals who operate two or more types of treatments.", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "We need to find professionals who have administered two or more types of treatments, so we will join the Professionals table with the Treatments table on the professional_id.", "We will group the results by professional_id to count the number of distinct treatment types each professional has administered.", "Using the HAVING clause, we will filter the groups to include only those with a count of two or more distinct treatment types.", "Finally, we will select the professional_id and cell_number from the filtered results."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT p.professional_id, p.cell_number\nFROM Professionals p\nJOIN Treatments t ON p.professional_id = t.professional_id\nGROUP BY p.professional_id\nHAVING COUNT(DISTINCT t.treatment_type_code) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\"\n}\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["Identify the required information: owner's first name, last name, and dog's size.", "Determine the relevant tables: Owners, Dogs, and Sizes.", "Establish relationships between the tables: Owners to Dogs (via owner_id) and Dogs to Sizes (via size_code).", "Use JOIN clauses to combine the tables based on these relationships.", "Select the appropriate columns from the combined tables."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.954", "db_id": "dog_kennels", "question": "List the names of the dogs of the rarest breed and the treatment dates of them.", "rationale": ["Identify the tables needed: Dogs, Breeds, and Treatments.", "We need to list the names of the dogs and their treatment dates, so we will select 'Dogs.name' and 'Treatments.date_of_treatment'.", "Join the Dogs table with the Breeds table on 'breed_code' to access breed information.", "Join the Dogs table with the Treatments table on 'dog_id' to access treatment information.", "To find the rarest breed, we will group the Dogs by 'breed_code' and count the number of dogs in each breed, ordering by the count in ascending order.", "Use a subquery to select the 'breed_code' of the rarest breed (the one with the least number of dogs) and limit the result to 1.", "Finally, filter the main query to only include dogs of the rarest breed."], "gold_sql": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT Dogs.name, Treatments.date_of_treatment\nFROM Dogs\nJOIN Breeds ON Dogs.breed_code = Breeds.breed_code\nJOIN Treatments ON Dogs.dog_id = Treatments.dog_id\nWHERE Breeds.breed_code = (\n    SELECT breed_code\n    FROM Dogs\n    GROUP BY breed_code\n    ORDER BY COUNT(*) ASC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to retrieve the arriving and departing dates of dogs that have undergone treatment.", "The Dogs table contains the columns date_arrived and date_departed, while the Treatments table links to the Dogs table via dog_id.", "Use a JOIN operation to connect the Dogs table with the Treatments table based on the dog_id.", "Select the date_arrived and date_departed columns from the Dogs table."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.date_arrived, d.date_departed \nFROM Dogs d \nJOIN Treatments t ON d.dog_id = t.dog_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.\"\n}\n"}
{"sample_id": "dev.960", "db_id": "dog_kennels", "question": "List the last name of the owner owning the youngest dog.", "rationale": ["We need to find the last name of the owner who owns the youngest dog.", "To do this, we will join the Owners table with the Dogs table on the owner_id.", "We will then order the results by the date_of_birth of the dogs in descending order, so the youngest dog appears first.", "Finally, we will limit the results to just one entry to get the owner of the youngest dog."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.last_name \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nORDER BY Dogs.date_of_birth DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["Identify the tables needed: Breeds and Sizes are required to get breed and size information, respectively.", "The Dogs table is needed to link the breeds and sizes to the specific dogs.", "Use JOIN to connect the Dogs table with the Breeds and Sizes tables based on their respective foreign keys.", "Select DISTINCT to ensure unique combinations of breed names and size descriptions."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT Breeds.breed_name, Sizes.size_description \nFROM Dogs \nJOIN Breeds ON Dogs.breed_code = Breeds.breed_code \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["Identify the required fields: professional's first name and treatment description.", "Determine the relevant tables: Professionals for first names, Treatments for treatment records, and Treatment_Types for treatment descriptions.", "Establish relationships between tables using JOINs: Treatments to Professionals and Treatments to Treatment_Types.", "Add a condition to filter treatments that cost less than the average treatment cost, which requires a subquery to calculate the average cost from the Treatments table."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT Professionals.first_name, Treatment_Types.treatment_type_description \nFROM Treatments \nJOIN Professionals ON Treatments.professional_id = Professionals.professional_id \nJOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code \nWHERE Treatments.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\"\n}\n"}
