{"sample_id": "train.6777", "db_id": "activity_1", "question": "Show the names of all the activities Mark Giuliano participates in.", "rationale": ["Identify the tables involved: Activity, Faculty_Participates_in, and Faculty.", "We need to find activities associated with a specific faculty member, Mark Giuliano.", "Join the Activity table with Faculty_Participates_in on actid to link activities to faculty participation.", "Join the Faculty table to get the names of faculty members using FacID.", "Filter the results to only include activities where the faculty member's first name is 'Mark' and last name is 'Giuliano'.", "Select the activity names from the resulting joined tables."], "gold_sql": "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  'Mark' AND T1.lname  =  'Giuliano'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Activity.activity_name \nFROM Activity \nJOIN Faculty_Participates_in ON Activity.actid = Faculty_Participates_in.actid \nJOIN Faculty ON Faculty_Participates_in.FacID = Faculty.FacID \nWHERE Faculty.Fname = 'Mark' AND Faculty.Lname = 'Giuliano';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\"\n}\n"}
{"sample_id": "train.6779", "db_id": "activity_1", "question": "Show the first and last name of all the faculty members who participated in some activity, together with the number of activities they participated in.", "rationale": ["Identify the required information: first name, last name of faculty members, and the count of activities they participated in.", "Determine the relevant tables: 'Faculty' for faculty member details and 'Faculty_Participates_in' for their participation in activities.", "Join the 'Faculty' table with 'Faculty_Participates_in' on the faculty ID to link faculty members with their activities.", "Use COUNT() function to count the number of activities each faculty member participated in.", "Group the results by faculty ID to ensure each faculty member's activities are counted correctly."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname, Faculty.Lname, COUNT(Faculty_Participates_in.actid) AS activity_count\nFROM Faculty\nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID\nGROUP BY Faculty.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\"\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: We need to find students who participate in activities, so we will use the 'Participates_in' and 'Student' tables.", "Determine the columns needed: We need the student IDs (stuid) from the 'Participates_in' table and we need to filter based on the age of the students from the 'Student' table.", "Join the tables: We will join 'Participates_in' with 'Student' on the student ID to get the necessary information about the students who participate in activities.", "Apply the age filter: We will add a WHERE clause to filter students who are under 20 years old.", "Select distinct student IDs: Since we only want unique student IDs, we will use DISTINCT in our SELECT statement."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT DISTINCT Participates_in.stuid \nFROM Participates_in \nJOIN Student ON Participates_in.stuid = Student.StuID \nWHERE Student.Age < 20;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clauses represent the names of the activities being queried.\"\n}\n"}
{"sample_id": "train.6797", "db_id": "activity_1", "question": "Find the first names of professors who are not playing Canoeing or Kayaking.", "rationale": ["Identify the table that contains faculty information, which is the Faculty table.", "We need to select the first names of faculty members, so we will select the Fname column from the Faculty table.", "We need to filter out faculty members who are participating in the activities 'Canoeing' or 'Kayaking'.", "To do this, we will use a subquery that selects the FacID from the Faculty_Participates_in table where the activity name is either 'Canoeing' or 'Kayaking'.", "We will join the Faculty_Participates_in table with the Activity table to get the activity names.", "Finally, we will use the NOT IN clause to exclude those faculty members from our main query."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty F \nWHERE F.FacID NOT IN (\n    SELECT FP.FacID \n    FROM Faculty_Participates_in FP \n    JOIN Activity A ON FP.actid = A.actid \n    WHERE A.activity_name IN ('Canoeing', 'Kayaking')\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the main entities involved: Faculty and Activities.", "We need to find faculty members who do not participate in specific activities (Canoeing and Kayaking).", "Start by selecting the first names of faculty members from the Faculty table.", "Use a subquery to find faculty IDs from the Faculty_Participates_in table who are participating in Canoeing or Kayaking.", "Join the Faculty_Participates_in table with the Activity table to filter by activity names.", "Use the NOT IN clause to exclude those faculty IDs from the main selection of faculty first names."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty F \nWHERE F.FacID NOT IN (\n    SELECT FP.FacID \n    FROM Faculty_Participates_in FP \n    JOIN Activity A ON FP.actid = A.actid \n    WHERE A.activity_name IN ('Canoeing', 'Kayaking')\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6799", "db_id": "activity_1", "question": "Find the first names of the faculty members who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables needed: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members who participate in specific activities (Canoeing and Kayaking).", "Join the Faculty table with Faculty_Participates_in on FacID to get the activities they participate in.", "Join the result with the Activity table on actid to filter by activity names.", "Use a WHERE clause to specify the activities of interest: Canoeing and Kayaking.", "Select the first names of the faculty members from the Faculty table."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname \nFROM Faculty \nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID \nJOIN Activity ON Faculty_Participates_in.actid = Activity.actid \nWHERE Activity.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the relevant tables: We need to find students participating in specific activities, so we will use the 'Participates_in' and 'Activity' tables.", "Determine the relationship: The 'Participates_in' table links students to activities through 'stuid' and 'actid', while the 'Activity' table contains the names of the activities.", "Use a JOIN operation: We will join 'Participates_in' with 'Activity' on 'actid' to access the activity names associated with each student.", "Filter the results: We will use a WHERE clause to filter for the activities 'Canoeing' and 'Kayaking'.", "Select the student IDs: Finally, we will select the 'stuid' from the resulting joined table."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT p.stuid \nFROM Participates_in p \nJOIN Activity a ON p.actid = a.actid \nWHERE a.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clauses represent the names of the activities being queried.\"\n}\n"}
{"sample_id": "train.6825", "db_id": "flight_4", "question": "Find the number of routes operated by American Airlines.", "rationale": ["Identify the relevant table: The 'routes' table contains information about the routes operated by airlines.", "Determine the specific airline: The query is focused on 'American Airlines'.", "Count the number of routes: Use the COUNT() function to count the number of entries in the 'routes' table where the airline is 'American Airlines'.", "Construct the SQL query: Combine the elements into a complete SQL statement that selects the count of routes for 'American Airlines'."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT COUNT(*) AS number_of_routes \nFROM routes \nWHERE airline = 'American Airlines';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.6826", "db_id": "flight_4", "question": "How many routes does American Airlines operate?", "rationale": ["Identify the relevant table: The 'routes' table contains information about the routes operated by airlines.", "Determine the specific airline: The question asks about 'American Airlines'.", "Count the number of routes: Use the COUNT() function to count the number of entries in the 'routes' table where the airline is 'American Airlines'.", "Construct the SQL query: Combine the elements into a complete SQL query that counts the routes for American Airlines."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT COUNT(*) AS route_count \nFROM routes \nWHERE airline = 'American Airlines';", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.6831", "db_id": "flight_4", "question": "Find the name, city, and country of the airport that has the highest latitude.", "rationale": ["Identify the relevant table: The 'airports' table contains the necessary information about airports, including their names, cities, and countries.", "Determine the criteria for selection: We need to find the airport with the highest latitude, which corresponds to the highest value in the 'y' column of the 'airports' table.", "Construct the SQL query: We will select the 'name', 'city', and 'country' columns from the 'airports' table, order the results by the 'y' column in descending order to get the highest latitude first, and limit the results to 1 to get only the top result."], "gold_sql": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT 1", "source_tables": ["airports"], "pred_sql": "SELECT name, city, country FROM airports ORDER BY y DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.6834", "db_id": "flight_4", "question": "What is the name and city of the airport that the most routes end at?", "rationale": ["We need to find the airport that has the most routes ending at it.", "The relevant tables are 'airports' for airport details and 'routes' for route information.", "We will join the 'airports' table with the 'routes' table on the destination airport ID (dst_apid).", "We will group the results by the destination airport ID to count the number of routes for each airport.", "We will order the results in descending order based on the count of routes to find the airport with the most routes.", "Finally, we will limit the results to 1 to get only the top airport."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT a.name, a.city \nFROM airports a \nJOIN routes r ON a.apid = r.dst_apid \nGROUP BY r.dst_apid \nORDER BY COUNT(r.rid) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.6838", "db_id": "flight_4", "question": "What is the name and city of the airport from most of the routes start?", "rationale": ["Identify the relevant tables: We need information from the 'routes' and 'airports' tables.", "Determine the required fields: We need the name and city of the airport, which are in the 'airports' table.", "Establish the relationship: The 'routes' table has a foreign key 'src_apid' that links to 'airports.apid'.", "Group the results: We will group by 'src_apid' to count the number of routes starting from each airport.", "Order the results: We will order the grouped results by the count of routes in descending order to find the airport with the most routes.", "Limit the results: We will limit the output to 1 to get the airport with the most routes."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, airports.city \nFROM routes \nJOIN airports ON routes.src_apid = airports.apid \nGROUP BY routes.src_apid \nORDER BY COUNT(routes.rid) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.6841", "db_id": "flight_4", "question": "Which countries has the most number of airlines?", "rationale": ["Identify the relevant table: The 'airlines' table contains information about airlines, including their country and active status.", "Filter for active airlines: We need to count only those airlines that are currently active, which is indicated by the 'active' column in the 'airlines' table.", "Group by country: To find out how many airlines are in each country, we will group the results by the 'country' column.", "Count the number of airlines: We will use the COUNT function to count the number of airlines in each country.", "Order the results: We want the countries with the most airlines first, so we will order the results by the count of airlines in descending order."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country, COUNT(*) as airline_count \nFROM airlines \nWHERE active = 1 \nGROUP BY country \nORDER BY airline_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, sorted by the number of active airlines in descending order.\"\n}\n"}
{"sample_id": "train.6842", "db_id": "flight_4", "question": "What is the name of the country with the most number of home airlines?", "rationale": ["Identify the relevant table: The airlines table contains information about airlines, including their country and whether they are active.", "Filter for active airlines: We need to consider only those airlines that are currently active, which is indicated by the 'active' column in the airlines table.", "Group by country: To find the number of home airlines per country, we will group the results by the 'country' column.", "Count the number of airlines: We will use the COUNT function to count the number of active airlines in each country.", "Sort the results: We will order the results in descending order based on the count of active airlines to find the country with the most.", "Limit the results: Since we only want the country with the most home airlines, we will limit the results to 1."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country FROM airlines WHERE active = 1 GROUP BY country ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, sorted by the number of active airlines in descending order.\"\n}\n"}
{"sample_id": "train.6858", "db_id": "flight_4", "question": "What are the cities that have more than 2 airports sorted by number of airports?", "rationale": ["Identify the relevant table: The 'airports' table contains information about airports, including their cities.", "We need to group the results by city to count the number of airports in each city.", "Use the COUNT function to count the number of airports for each city.", "Apply a HAVING clause to filter cities that have more than 2 airports.", "Sort the results in descending order based on the count of airports."], "gold_sql": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)", "source_tables": ["airports"], "pred_sql": "SELECT city, COUNT(*) as airport_count \nFROM airports \nGROUP BY city \nHAVING COUNT(*) > 2 \nORDER BY airport_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities that have more than a specified number of airports. The placeholder in the HAVING clause represents the minimum count of airports required for a city to be included in the results.\"\n}\n"}
{"sample_id": "train.6862", "db_id": "flight_4", "question": "For each  airport name, how many routes start at that airport, ordered from most to least?", "rationale": ["We need to count the number of routes that start at each airport.", "To do this, we will join the 'airports' table with the 'routes' table on the airport ID, specifically matching the source airport ID in the routes table.", "We will use a LEFT JOIN to ensure we include all airports, even those with no routes.", "We will group the results by the airport name to get the count of routes for each airport.", "Finally, we will order the results by the count of routes in descending order to show the airports with the most routes first."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, COUNT(routes.rid) AS route_count\nFROM airports\nLEFT JOIN routes ON airports.apid = routes.src_apid\nGROUP BY airports.name\nORDER BY route_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.6867", "db_id": "flight_4", "question": "For each country and airline name, how many routes are there?", "rationale": ["Identify the tables involved: routes, airlines, and airports.", "We need to count the number of routes, so we will use the COUNT() function on the route identifier (rid) from the routes table.", "To get the country and airline name, we will join the routes table with the airlines table on the airline ID (alid) and with the airports table on the source airport ID (src_apid).", "We will group the results by country and airline name to get the count of routes for each combination.", "The final SQL query will select the country, airline name, and the count of routes, grouping by country and airline."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT a.country, r.airline, COUNT(r.rid) AS route_count \nFROM routes r \nJOIN airlines a ON r.alid = a.alid \nJOIN airports ap ON r.src_apid = ap.apid \nGROUP BY a.country, r.airline;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.6868", "db_id": "flight_4", "question": "What is the total number of routes for each country and airline in that country?", "rationale": ["Identify the tables needed: routes, airports, and airlines.", "We need to count the total number of routes, so we will use the COUNT() function on the route identifier (rid).", "To get the country and airline information, we will join the routes table with the airports table (to get the country) and the airlines table (to get the airline name).", "The join condition for airports is based on the source airport ID (src_apid) in the routes table matching the airport ID (apid) in the airports table.", "The join condition for airlines is based on the airline ID (alid) in the routes table matching the airline ID (alid) in the airlines table.", "We will group the results by country and airline to get the total routes for each combination.", "Finally, we will order the results by country and the total number of routes in descending order."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT a.country, r.airline, COUNT(r.rid) AS total_routes\nFROM routes r\nJOIN airports a ON r.src_apid = a.apid\nJOIN airlines al ON r.alid = al.alid\nGROUP BY a.country, r.airline\nORDER BY a.country, total_routes DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.6873", "db_id": "flight_4", "question": "Find the number of routes that have destination John F Kennedy International Airport.", "rationale": ["Identify the relevant table: The 'routes' table contains information about routes including destination airports.", "Determine the condition: We need to find routes where the destination airport is 'John F Kennedy International Airport'.", "Construct the SQL query: Use a SELECT statement to count the number of routes that meet the condition."], "gold_sql": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'", "source_tables": ["airports", "routes"], "pred_sql": "SELECT COUNT(*) AS route_count \nFROM routes \nWHERE dst_ap = 'John F Kennedy International Airport';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.6880", "db_id": "flight_4", "question": "What is the name of the airline with the most routes?", "rationale": ["Identify the relevant table: The 'routes' table contains information about airlines and their routes.", "Determine the required information: We need the name of the airline with the most routes.", "Use the COUNT function: To find the number of routes for each airline, we will use COUNT(*) and group the results by airline name.", "Group the results: We will group the results by the 'airline' column to aggregate the route counts for each airline.", "Order the results: To find the airline with the most routes, we will order the results in descending order based on the route count.", "Limit the results: Since we only need the airline with the most routes, we will limit the results to 1."], "gold_sql": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT airline, COUNT(*) as route_count \nFROM routes \nGROUP BY airline \nORDER BY route_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.6883", "db_id": "flight_4", "question": "Find the busiest destination airport that runs most number of routes in China.", "rationale": ["Identify the relevant tables: 'routes' for route information and 'airports' for airport details.", "We need to find the busiest destination airport in China, which means we will focus on the 'dst_apid' and 'dst_ap' columns from the 'routes' table and the 'airports' table.", "Join the 'routes' table with the 'airports' table on the destination airport ID to get the airport names and their corresponding details.", "Filter the results to include only those airports located in China by checking the 'country' column in the 'airports' table.", "Group the results by destination airport ID and name to count the number of routes to each destination airport.", "Order the results by the count of routes in descending order to find the busiest airport.", "Limit the results to 1 to get only the busiest destination airport."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT dst_apid, dst_ap, COUNT(rid) AS route_count \nFROM routes \nJOIN airports ON routes.dst_apid = airports.apid \nWHERE airports.country = 'China' \nGROUP BY dst_apid, dst_ap \nORDER BY route_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.6884", "db_id": "flight_4", "question": "What is the name of the airport that is the destination of the most number of routes that start in China?", "rationale": ["Identify the destination airport from the routes table.", "Count the number of routes for each destination airport.", "Filter the routes to only include those that start from airports in China.", "Group the results by destination airport name to aggregate the counts.", "Order the results by the count of routes in descending order to find the most popular destination.", "Limit the results to the top entry to get the destination airport with the most routes."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT dst_ap, COUNT(*) as route_count\nFROM routes\nJOIN airports ON routes.dst_apid = airports.apid\nWHERE src_apid IN (\n    SELECT apid\n    FROM airports\n    WHERE country = 'China'\n)\nGROUP BY dst_ap\nORDER BY route_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.6980", "db_id": "culture_company", "question": "Show all publishers which do not have a book in 1989.", "rationale": ["Identify the main goal: to find all publishers that do not have a book published in 1989.", "Use the 'book_club' table to access the 'Publisher' and 'Year' columns.", "Create a subquery to find all publishers that have books published in 1989.", "Use the DISTINCT keyword to ensure that each publisher is listed only once.", "In the main query, select distinct publishers from the 'book_club' table where the publisher is not in the list generated by the subquery."], "gold_sql": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  1989", "source_tables": ["book_club"], "pred_sql": "SELECT DISTINCT Publisher FROM book_club WHERE Publisher NOT IN (SELECT DISTINCT Publisher FROM book_club WHERE Year = '1989');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the publishers of books discussed in the 'book_club' table, excluding those publishers whose books were published in a specific year. The placeholder in the WHERE clause represents the year to be excluded.\"\n}\n"}
{"sample_id": "train.6990", "db_id": "culture_company", "question": "Show all director names who have a movie in the year 1999 or 2000.", "rationale": ["Identify the table that contains the information about movies, which is the 'movie' table.", "Determine the relevant column that contains the director's names, which is 'Director'.", "Identify the column that contains the year of the movie, which is 'Year'.", "Use the SQL 'SELECT' statement to retrieve distinct director names from the 'movie' table.", "Apply a 'WHERE' clause to filter the results for movies released in the years 1999 or 2000 using the 'IN' operator."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6991", "db_id": "culture_company", "question": "Which directors had a movie in either 1999 or 2000?", "rationale": ["Identify the relevant table: The question pertains to movies and their directors, so we will focus on the 'movie' table.", "Determine the columns needed: We need the 'Director' column to answer the question about which directors had movies in the specified years.", "Filter the results: We need to filter the movies to only include those released in 1999 or 2000. This can be done using a WHERE clause with the IN operator.", "Select distinct directors: Since the same director may have multiple movies in those years, we will use DISTINCT to ensure each director is listed only once."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6996", "db_id": "culture_company", "question": "Show the movie titles and book titles for all companies in China.", "rationale": ["Identify the tables involved: culture_company, movie, and book_club.", "Determine the columns needed: movie titles from the movie table and book titles from the book_club table.", "Establish the relationships between the tables using JOINs: culture_company to movie and culture_company to book_club.", "Filter the results to only include companies based in China using a WHERE clause."], "gold_sql": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  'China'", "source_tables": ["culture_company", "movie", "book_club"], "pred_sql": "SELECT movie.Title AS Movie_Title, book_club.Book_Title AS Book_Title\nFROM culture_company\nJOIN movie ON culture_company.movie_id = movie.movie_id\nJOIN book_club ON culture_company.book_club_id = book_club.book_club_id\nWHERE culture_company.Company_name = 'China';", "hint": "\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant tables: We need to find the car model and its horsepower, which are in the 'cars_data' and 'car_names' tables.", "Join the 'cars_data' table with the 'car_names' table on the 'MakeId' to get the model names along with their horsepower.", "Use the ORDER BY clause to sort the results by horsepower in ascending order, so that the model with the minimum horsepower comes first.", "Limit the results to 1 to get only the model with the minimum horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId ORDER BY Horsepower ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\"\n}\n"}
{"sample_id": "dev.103", "db_id": "car_1", "question": "Which distinct car models are the produced after 1980?", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data are needed to find car models and their production years.", "We need to select distinct car models, so we will use SELECT DISTINCT on model_list.Model.", "To filter the models produced after 1980, we will add a WHERE clause that checks if cars_data.Year is greater than 1980.", "We need to join the tables appropriately: model_list to car_names on the Model column, and car_names to cars_data on MakeId to access the Year information.", "Construct the SQL query with the selected columns, joins, and the WHERE condition."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "pred_sql": "SELECT DISTINCT model_list.Model \nFROM model_list \nJOIN car_names ON model_list.Model = car_names.Model \nJOIN cars_data ON car_names.MakeId = cars_data.Id \nWHERE cars_data.Year > 1980;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\"\n}\n"}
{"sample_id": "dev.106", "db_id": "car_1", "question": "What is the name of each continent and how many car makers are there in each one?", "rationale": ["We need to retrieve the names of continents and the count of car makers in each continent.", "Start by selecting the 'Continent' from the 'continents' table.", "To count the car makers, we will join the 'countries' table on the continent's ID to get the countries belonging to each continent.", "Next, we join the 'car_makers' table to get the car makers associated with those countries.", "We will use the COUNT function to count the number of car makers for each continent.", "Finally, we group the results by continent to get the count for each one."], "gold_sql": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;", "source_tables": ["countries", "car_makers", "continents"], "pred_sql": "SELECT c.Continent, COUNT(cm.Id) AS CarMakerCount\nFROM continents c\nJOIN countries co ON c.ContId = co.Continent\nJOIN car_makers cm ON co.CountryId = cm.Country\nGROUP BY c.Continent;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'countries' table that belong to a specific continent. It joins the 'continents' table to filter countries by continent and the 'car_makers' table to ensure that the countries have car makers associated with them. The placeholders in the WHERE clause represent the continent's name and the minimum count of car makers per country.\"\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: We need to find the accelerate time for a specific car make, which involves the 'cars_data', 'car_names', 'model_list', and 'car_makers' tables.", "Determine the relationships: 'car_names' is linked to 'model_list' through the 'Model' column, 'model_list' is linked to 'car_makers' through the 'Maker' column, and 'cars_data' is linked to 'car_names' through the 'MakeId' column.", "Filter the results: We need to filter the results to only include the car make 'AMC Hornet Sportabout (SW)'.", "Select the desired column: We want to retrieve the 'Accelerate' column from the 'cars_data' table."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT cars_data.Accelerate \nFROM car_names \nJOIN model_list ON car_names.Model = model_list.Model \nJOIN car_makers ON model_list.Maker = car_makers.Id \nJOIN cars_data ON car_names.MakeId = cars_data.Id \nWHERE car_makers.FullName = 'AMC Hornet Sportabout (SW)';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\"\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the relevant tables: car_makers and countries.", "We need to count the distinct car makers based in France.", "Join the car_makers table with the countries table on the country identifier.", "Filter the results to include only those car makers whose country is France.", "Use COUNT(DISTINCT car_makers.Id) to get the number of unique car makers in France."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(DISTINCT car_makers.Id) AS NumberOfCarMakers\nFROM car_makers\nJOIN countries ON car_makers.Country = countries.CountryId\nWHERE countries.Country = 'France';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\"\n}\n"}
{"sample_id": "dev.114", "db_id": "car_1", "question": "What is the number of makers of care in France?", "rationale": ["Identify the relevant tables: 'car_makers' for car makers and 'countries' for country information.", "We need to count the distinct car makers based in France, so we will use COUNT(DISTINCT car_makers.Id).", "Join the 'car_makers' table with the 'countries' table on the country identifier.", "Filter the results to include only those records where the country name is 'France'.", "Construct the SQL query to select the count of distinct car makers from the joined tables with the specified filter."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(DISTINCT car_makers.Id) AS NumberOfMakers\nFROM car_makers\nJOIN countries ON car_makers.Country = countries.CountryId\nWHERE countries.CountryName = 'France';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. It filters the results to show only those countries that have more than a specified number of car makers, represented by a placeholder in the HAVING clause.\"\n}\n"}
{"sample_id": "dev.115", "db_id": "car_1", "question": "How many car models are produced in the usa?", "rationale": ["Identify the relevant tables: car_makers, countries, and model_list.", "We need to count the distinct car models produced in the USA.", "Join the car_makers table with the countries table to filter for car makers based in the USA.", "Join the model_list table to get the car models associated with those car makers.", "Use COUNT(DISTINCT model_list.Model) to count the unique car models produced by USA-based car makers."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "pred_sql": "SELECT COUNT(DISTINCT model_list.Model) AS NumberOfCarModels\nFROM car_makers\nJOIN countries ON car_makers.Country = countries.CountryId\nJOIN model_list ON car_makers.Id = model_list.Maker\nWHERE countries.Country = 'USA';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\"\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the relevant tables: countries, car_makers, and model_list.", "We need to filter countries that belong to Europe, so we will join the countries table with the continents table to get the ContId for Europe.", "Next, we join the car_makers table to the countries table to link car manufacturers to their respective countries.", "Then, we join the model_list table to the car_makers table to count the number of car models associated with each car maker.", "We group the results by country name to aggregate the count of car manufacturers per country.", "Finally, we use the HAVING clause to filter countries that have at least 3 car manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName\nFROM countries c\nJOIN car_makers cm ON c.CountryId = cm.Country\nJOIN model_list ml ON cm.Id = ml.Maker\nWHERE c.Continent = (SELECT ContId FROM continents WHERE Continent = 'Europe')\nGROUP BY c.CountryName\nHAVING COUNT(DISTINCT ml.Model) >= 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\"\n}\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the relevant tables: cars_data for horsepower and cylinders, car_names for car make.", "We need to filter the cars_data table to only include entries with 3 cylinders.", "We will join the cars_data table with the car_names table to get the make of the car models.", "We will use the MAX function to find the maximum horsepower among the filtered results.", "Finally, we will group the results by car make to get the maximum horsepower for each make."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(cars_data.Horsepower) AS MaxHorsepower, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Cylinders = 3 \nGROUP BY car_names.Make;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\"\n}\n"}
{"sample_id": "dev.133", "db_id": "car_1", "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.", "rationale": ["Identify the relevant tables: car_names and cars_data are essential for finding the car models and their MPG.", "Join the car_names table with the model_list to link car names to their respective makers and models.", "Join the resulting table with cars_data to access the MPG values for each car model.", "Use the MAX function to find the maximum MPG value.", "Group the results by car model to ensure we can apply the MAX function correctly.", "Order the results by the maximum MPG in descending order to get the highest value at the top.", "Limit the results to 1 to get only the model that saves the most gasoline."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT car_names.Model, MAX(cars_data.MPG) AS Max_MPG \nFROM car_names \nJOIN model_list ON car_names.Model = model_list.Model \nJOIN cars_data ON car_names.MakeId = cars_data.Id \nGROUP BY car_names.Model \nORDER BY Max_MPG DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\"\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["Identify the relevant tables: car_makers and model_list.", "We need to join car_makers with model_list to associate makers with their models.", "Group the results by car_makers.Id and car_makers.Maker to count the number of models for each maker.", "Use the HAVING clause to filter out makers with more than 3 models."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "SELECT car_makers.Id, car_makers.Maker \nFROM car_makers \nJOIN model_list ON car_makers.Id = model_list.Maker \nGROUP BY car_makers.Id, car_makers.Maker \nHAVING COUNT(model_list.ModelId) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\"\n}\n"}
{"sample_id": "dev.158", "db_id": "car_1", "question": "For a volvo model, how many cylinders does the version with least accelerate have?", "rationale": ["Identify the relevant tables: cars_data, car_names, model_list, and car_makers.", "We need to filter for the car maker 'Volvo'.", "Join the tables on their respective foreign keys to access the necessary columns.", "Select the 'Cylinders' column from the cars_data table.", "Order the results by the 'Accelerate' column in ascending order to find the version with the least acceleration.", "Limit the results to 1 to get only the top result."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT Cylinders FROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nJOIN model_list ON car_names.Model = model_list.Model \nJOIN car_makers ON model_list.Maker = car_makers.Id \nWHERE car_makers.Maker = 'Volvo' \nORDER BY Accelerate ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\"\n}\n"}
{"sample_id": "dev.160", "db_id": "car_1", "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?", "rationale": ["Identify the requirement: We need to count the number of cars with an 'Accelerate' value greater than the maximum 'Horsepower' of any car.", "To find the maximum horsepower, we will use a subquery: SELECT MAX(Horsepower) FROM cars_data.", "We will then use this subquery in the WHERE clause of our main query to filter cars based on their accelerate value.", "Finally, we will count the number of cars that meet this condition using COUNT(*) in the main query."], "gold_sql": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "source_tables": ["cars_data"], "pred_sql": "SELECT COUNT(*) \nFROM cars_data \nWHERE Accelerate > (SELECT MAX(Horsepower) \n                     FROM cars_data)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\"\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables: cars_data for car specifications, car_names for car make and model, and model_list for linking car models to makers.", "Filter the cars_data table to only include entries with 4 cylinders using a WHERE clause.", "Select the model name and the maximum horsepower from the filtered results.", "Group the results by model to ensure we get the maximum horsepower for each model.", "Order the results by horsepower in descending order to get the model with the largest horsepower at the top.", "Limit the results to 1 to get only the top model with the largest horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT model_list.Model, MAX(cars_data.Horsepower) AS MaxHorsepower\nFROM cars_data\nJOIN car_names ON cars_data.Id = car_names.MakeId\nJOIN model_list ON car_names.Model = model_list.Model\nWHERE cars_data.Cylinders = 4\nGROUP BY model_list.Model\nORDER BY MaxHorsepower DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\"\n}\n"}
{"sample_id": "dev.166", "db_id": "car_1", "question": "For all of the 4 cylinder cars, which model has the most horsepower?", "rationale": ["Identify the relevant tables: cars_data for car specifications, car_names for car make and model, and model_list for linking car models to their makers.", "Filter the cars_data table to only include entries where the number of cylinders is 4.", "Join the cars_data table with car_names to get the model names associated with each car entry.", "Join the resulting table with model_list to ensure we can group by model names.", "Use the MAX function to find the maximum horsepower for the filtered 4-cylinder cars.", "Group the results by model name to aggregate horsepower values for each model.", "Order the results by maximum horsepower in descending order to get the model with the highest horsepower at the top.", "Limit the results to 1 to get only the top model."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT model_list.Model, MAX(cars_data.Horsepower) AS MaxHorsepower\nFROM cars_data\nJOIN car_names ON cars_data.Id = car_names.MakeId\nJOIN model_list ON car_names.Model = model_list.Model\nWHERE cars_data.Cylinders = 4\nGROUP BY model_list.Model\nORDER BY MaxHorsepower DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\"\n}\n"}
{"sample_id": "dev.168", "db_id": "car_1", "question": "Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?", "rationale": ["Identify the relevant tables: cars_data and car_names are needed to get the make ids and names of the cars.", "We need to filter cars based on horsepower and cylinder count.", "First, we need to find the minimum horsepower from the cars_data table.", "Then, we filter the cars_data table to find cars with horsepower greater than this minimum.", "Next, we also filter for cars that have less than 4 cylinders.", "Finally, we join the cars_data table with the car_names table to get the make ids and names of the filtered cars."], "gold_sql": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  4;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT car_names.MakeId, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Horsepower > (SELECT MIN(Horsepower) FROM cars_data) \nAND cars_data.Cylinders < 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\"\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["Identify the relevant tables: car_makers, model_list, car_names, and cars_data.", "Join the car_makers table with model_list to get the models produced by each maker.", "Join the model_list with car_names to link models to their respective makes.", "Join car_names with cars_data to count the number of cars associated with each make.", "Group the results by car maker's Id and Maker name to aggregate the counts.", "Use the HAVING clause to filter for car makers that produce at least 2 distinct models and have more than 3 cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nJOIN car_names cn ON ml.Model = cn.Model\nJOIN cars_data cd ON cn.MakeId = cd.Id\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(DISTINCT ml.Model) >= 2 AND COUNT(DISTINCT cd.Id) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\"\n}\n"}
{"sample_id": "dev.180", "db_id": "flight_2", "question": "What country is Jetblue Airways affiliated with?", "rationale": ["Identify the relevant table: The question pertains to the airline 'Jetblue Airways', so we will focus on the 'airlines' table.", "Determine the required column: We need to find out the 'Country' associated with 'Jetblue Airways'.", "Construct the SQL query: We will select the 'Country' from the 'airlines' table where the 'Airline' is 'Jetblue Airways'."], "gold_sql": "SELECT Country FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "pred_sql": "SELECT Country FROM airlines WHERE Airline = 'Jetblue Airways';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\"\n}\n"}
{"sample_id": "dev.194", "db_id": "flight_2", "question": "Give the airline with abbreviation 'UAL'.", "rationale": ["Identify the relevant table: The 'airlines' table contains the information about airlines, including their abbreviations.", "Determine the specific information needed: We need to retrieve the airline name, abbreviation, and country for the airline with the abbreviation 'UAL'.", "Construct the SQL query: Use a SELECT statement to get the desired columns from the 'airlines' table, and apply a WHERE clause to filter the results for the abbreviation 'UAL'."], "gold_sql": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  'UAL'", "source_tables": ["airlines"], "pred_sql": "SELECT Airline, Abbreviation, Country FROM airlines WHERE Abbreviation = 'UAL';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\"\n}\n"}
{"sample_id": "dev.214", "db_id": "flight_2", "question": "Give the number of Jetblue Airways flights.", "rationale": ["Identify the airline of interest, which is 'Jetblue Airways'.", "Determine that we need to count the number of flights operated by this airline.", "Construct a SQL query that selects the count of flights from the 'flights' table where the 'Airline' column matches 'Jetblue Airways'."], "gold_sql": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = 'JetBlue Airways'", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT COUNT(*) AS NumberOfFlights\nFROM flights\nWHERE Airline = 'Jetblue Airways';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\"\n}\n"}
{"sample_id": "dev.225", "db_id": "flight_2", "question": "What is the code of airport that has the highest number of flights?", "rationale": ["We need to find the airport code with the highest number of flights.", "To do this, we will count the number of flights for each airport by grouping the results based on the SourceAirport.", "We will use the COUNT function to count the number of flights for each airport.", "Next, we will order the results in descending order based on the count of flights to get the airport with the highest number of flights at the top.", "Finally, we will limit the results to just one entry to get the airport code with the highest number of flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT SourceAirport AS AirportCode, COUNT(*) AS FlightCount\nFROM flights\nGROUP BY SourceAirport\nORDER BY FlightCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\"\n}\n"}
{"sample_id": "dev.227", "db_id": "flight_2", "question": "What is the code of airport that has fewest number of flights?", "rationale": ["Identify the relevant table: The 'flights' table contains information about flights, including the source airport.", "Group the data: We need to group the flights by the SourceAirport to count the number of flights for each airport.", "Count the flights: Use COUNT(*) to count the number of flights for each SourceAirport.", "Order the results: We want to find the airport with the fewest flights, so we will order the results in ascending order based on the count of flights.", "Limit the results: Since we only want the airport with the fewest flights, we will limit the results to 1."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT SourceAirport AS AirportCode\nFROM flights\nGROUP BY SourceAirport\nORDER BY COUNT(*) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of airlines from the 'airlines' table that operate fewer flights than a specified number. The placeholder in the HAVING clause represents the maximum number of flights an airline can operate.\"\n}\n"}
{"sample_id": "dev.229", "db_id": "flight_2", "question": "Which airline has most number of flights?", "rationale": ["Identify the main goal: to find the airline with the most number of flights.", "Use the `flights` table to count the number of flights for each airline.", "Group the results by the `Airline` column to aggregate the flight counts.", "Use the `COUNT(FlightNo)` function to count the number of flights for each airline.", "To find the airline with the maximum number of flights, use a subquery that selects the maximum flight count from the grouped results.", "Incorporate the `HAVING` clause to filter the airlines that match the maximum flight count."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT Airline, COUNT(FlightNo) AS FlightCount\nFROM flights\nGROUP BY Airline\nHAVING COUNT(FlightNo) = (\n    SELECT MAX(FlightCount)\n    FROM (\n        SELECT COUNT(FlightNo) AS FlightCount\n        FROM flights\n        GROUP BY Airline\n    )\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\"\n}\n"}
{"sample_id": "dev.232", "db_id": "flight_2", "question": "What is the abbreviation of the airilne has the fewest flights and what country is it in?", "rationale": ["Identify the airline with the fewest flights by counting the number of flights for each airline.", "Use a subquery to group the flights by airline and count them, ordering the results in ascending order to find the airline with the least flights.", "Limit the results of the subquery to 1 to get only the airline with the fewest flights.", "Join the result of the subquery with the airlines table to get the abbreviation and country of that airline."], "gold_sql": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT a.Abbreviation, a.Country \nFROM airlines a \nJOIN (\n    SELECT Airline, COUNT(*) AS flight_count \n    FROM flights \n    GROUP BY Airline \n    ORDER BY flight_count ASC \n    LIMIT 1\n) f ON a.Airline = f.Airline;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\"\n}\n"}
{"sample_id": "dev.244", "db_id": "flight_2", "question": "Which airlines have less than 200 flights?", "rationale": ["We need to find airlines with fewer than 200 flights.", "To do this, we will select the 'Airline' from the 'flights' table.", "We will count the number of flights for each airline using COUNT(FlightNo).", "We will group the results by 'Airline' to get the count for each airline.", "Finally, we will use the HAVING clause to filter the results to only include airlines with a flight count less than 200."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT Airline, COUNT(FlightNo) AS FlightCount \nFROM flights \nGROUP BY Airline \nHAVING FlightCount < 200;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of airlines from the 'airlines' table that operate fewer flights than a specified number. The placeholder in the HAVING clause represents the maximum number of flights an airline can operate.\"\n}\n"}
{"sample_id": "dev.258", "db_id": "flight_2", "question": "Which airports do not have departing or arriving flights?", "rationale": ["Identify the airports from the 'airports' table.", "Use LEFT JOIN to connect the 'airports' table with the 'flights' table twice: once for departing flights (using SourceAirport) and once for arriving flights (using DestAirport).", "In the WHERE clause, check for NULL values in both the departing and arriving flight numbers to find airports without any flights.", "Select the AirportName from the resulting dataset."], "gold_sql": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)", "source_tables": ["airports", "flights"], "pred_sql": "SELECT AirportName \nFROM airports \nLEFT JOIN flights AS departing ON airports.AirportCode = departing.SourceAirport \nLEFT JOIN flights AS arriving ON airports.AirportCode = arriving.DestAirport \nWHERE departing.FlightNo IS NULL AND arriving.FlightNo IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of airlines from the 'airlines' table that operate fewer flights than a specified number. The placeholder in the HAVING clause represents the maximum number of flights an airline can operate.\"\n}\n"}
{"sample_id": "dev.308", "db_id": "cre_Doc_Template_Mgt", "question": "Count the number of documents that use the PPT template type.", "rationale": ["Identify the tables involved: Documents, Templates, and Ref_Template_Types.", "We need to count the number of documents, so we will use the COUNT function.", "To find documents that use the PPT template type, we need to join the Documents table with the Templates table on Template_ID.", "Next, we join the Templates table with the Ref_Template_Types table on Template_Type_Code to filter by the template type.", "We will filter the results where the Template_Type_Description is 'PPT'.", "Finally, we will count the distinct Document_IDs to get the number of documents that use the PPT template type."], "gold_sql": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'", "source_tables": ["templates", "documents"], "pred_sql": "SELECT COUNT(DISTINCT d.Document_ID) AS Document_Count\nFROM Documents d\nJOIN Templates t ON d.Template_ID = t.Template_ID\nJOIN Ref_Template_Types r ON t.Template_Type_Code = r.Template_Type_Code\nWHERE r.Template_Type_Description = 'PPT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of paragraphs associated with each document from the 'Paragraphs' table. The results are grouped by the document identifier, allowing users to see how many paragraphs belong to each document, sorted by the document ID.\"\n}\n"}
{"sample_id": "dev.311", "db_id": "cre_Doc_Template_Mgt", "question": "What is the id and type code for the template used by the most documents?", "rationale": ["Identify the relevant tables: Templates and Documents.", "We need to find the Template_ID and Template_Type_Code from the Templates table.", "Join the Templates table with the Documents table on Template_ID to associate templates with their documents.", "Group the results by Template_ID and Template_Type_Code to count the number of documents associated with each template.", "Order the results by the count of documents in descending order to find the template used by the most documents.", "Limit the results to 1 to get only the top template."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Templates.Template_ID, Templates.Template_Type_Code\nFROM Templates\nJOIN Documents ON Templates.Template_ID = Documents.Template_ID\nGROUP BY Templates.Template_ID, Templates.Template_Type_Code\nORDER BY COUNT(Documents.Document_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.312", "db_id": "cre_Doc_Template_Mgt", "question": "Return the id and type code of the template that is used for the greatest number of documents.", "rationale": ["We need to find the template that is used for the greatest number of documents.", "To do this, we will join the Templates table with the Documents table on the Template_ID column.", "Next, we will group the results by Template_ID and Template_Type_Code to count the number of documents associated with each template.", "We will use the COUNT function to count the number of Document_IDs for each template.", "Finally, we will order the results in descending order based on the count and limit the results to 1 to get the template with the greatest number of documents."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Templates.Template_ID, Templates.Template_Type_Code\nFROM Templates\nJOIN Documents ON Templates.Template_ID = Documents.Template_ID\nGROUP BY Templates.Template_ID, Templates.Template_Type_Code\nORDER BY COUNT(Documents.Document_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.341", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template type codes and the number of documents using each type.", "rationale": ["Identify the tables involved: Ref_Template_Types, Templates, and Documents.", "We need to count the number of documents associated with each template type code.", "Join Ref_Template_Types with Templates on Template_Type_Code to get the templates for each type.", "Join the resulting table with Documents on Template_ID to get the documents for each template.", "Use COUNT() to count the number of Document_IDs for each Template_Type_Code.", "Group the results by Template_Type_Code to get the count for each type."], "gold_sql": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Ref_Template_Types.Template_Type_Code, COUNT(Documents.Document_ID) AS Document_Count\nFROM Ref_Template_Types\nLEFT JOIN Templates ON Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code\nLEFT JOIN Documents ON Templates.Template_ID = Documents.Template_ID\nGROUP BY Ref_Template_Types.Template_Type_Code;", "hint": "\n"}
{"sample_id": "dev.346", "db_id": "cre_Doc_Template_Mgt", "question": "What are the codes of template types that are not used for any document?", "rationale": ["We need to find template types that are not used for any document.", "To do this, we will start by selecting the 'Template_Type_Code' from the 'Ref_Template_Types' table.", "We will perform a LEFT JOIN with the 'Templates' table on 'Template_Type_Code' to include all template types, even those that do not have corresponding templates.", "Next, we will perform another LEFT JOIN with the 'Documents' table on 'Template_ID' to include all templates, even those that do not have corresponding documents.", "Finally, we will filter the results where 'Document_ID' from the 'Documents' table is NULL, indicating that there are no documents associated with those template types."], "gold_sql": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Ref_Template_Types.Template_Type_Code\nFROM Ref_Template_Types\nLEFT JOIN Templates ON Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code\nLEFT JOIN Documents ON Templates.Template_ID = Documents.Template_ID\nWHERE Documents.Document_ID IS NULL;", "hint": "\n"}
{"sample_id": "dev.361", "db_id": "cre_Doc_Template_Mgt", "question": "Show paragraph details for paragraph with text 'Korea ' .", "rationale": ["Identify the table to query: The question asks for paragraph details, which are stored in the 'Paragraphs' table.", "Determine the condition: The user wants paragraphs that contain the text 'Korea'.", "Use the LIKE operator: Since we are looking for a specific text within the paragraph, we can use the LIKE operator with wildcards to match any paragraph that contains 'Korea'.", "Construct the SQL query: Combine the selected columns and the condition to form the complete SQL query."], "gold_sql": "select other_details from paragraphs where paragraph_text like 'korea'", "source_tables": ["paragraphs"], "pred_sql": "SELECT * FROM Paragraphs WHERE Paragraph_Text LIKE '%Korea%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of paragraphs associated with each document from the 'Paragraphs' table. The results are grouped by the document identifier, allowing users to see how many paragraphs belong to each document, sorted by the document ID.\"\n}\n"}
{"sample_id": "dev.367", "db_id": "cre_Doc_Template_Mgt", "question": "Show all document ids and the number of paragraphs in each document. Order by document id.", "rationale": ["We need to retrieve all document IDs and the count of paragraphs associated with each document.", "To achieve this, we will use the 'Paragraphs' table, which contains the 'Document_ID' and 'Paragraph_ID'.", "We will use the COUNT() function to count the number of paragraphs for each document.", "We will group the results by 'Document_ID' to get the count for each document.", "Finally, we will order the results by 'Document_ID' to meet the requirement of ordering the output."], "gold_sql": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id", "source_tables": ["paragraphs"], "pred_sql": "SELECT Document_ID, COUNT(Paragraph_ID) AS Number_of_Paragraphs\nFROM Paragraphs\nGROUP BY Document_ID\nORDER BY Document_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of paragraphs associated with each document from the 'Paragraphs' table. The results are grouped by the document identifier, allowing users to see how many paragraphs belong to each document, sorted by the document ID.\"\n}\n"}
{"sample_id": "dev.439", "db_id": "wta_1", "question": "Find the highest rank of losers in all matches.", "rationale": ["Identify the relevant table: The 'matches' table contains information about the matches, including the ranks of the losers.", "Determine the required information: We need to find the highest rank of losers, which is represented by the 'loser_rank' column in the 'matches' table.", "Use the MAX() function: To find the highest rank, we can use the SQL aggregate function MAX() on the 'loser_rank' column.", "Construct the SQL query: The query will select the maximum value from the 'loser_rank' column in the 'matches' table."], "gold_sql": "SELECT min(loser_rank) FROM matches", "source_tables": ["matches"], "pred_sql": "SELECT MAX(loser_rank) AS highest_rank FROM matches;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct names of winners from the 'matches' table who participated in a specific tournament and played with a specified hand. The placeholders in the WHERE clause represent the tournament's name and the winning player's hand.\"\n}\n"}
{"sample_id": "dev.458", "db_id": "wta_1", "question": "What are the full names of all left handed players, in order of birth date?", "rationale": ["Identify the table that contains player information, which is the 'players' table.", "We need to select the full names of players, which requires concatenating the 'first_name' and 'last_name' columns.", "Filter the results to include only left-handed players by using a WHERE clause on the 'hand' column.", "Order the results by the 'birth_date' column to get the players in order of their birth dates."], "gold_sql": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date", "source_tables": ["players"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name\nFROM players\nWHERE hand = 'left'\nORDER BY birth_date;", "hint": "\n"}
{"sample_id": "dev.464", "db_id": "wta_1", "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?", "rationale": ["Identify the relevant tables: 'matches', 'players', and 'rankings' are needed to get the winner's name and rank points.", "We need to find the winner who has won the most matches, so we will count the occurrences of each winner in the 'matches' table.", "Join the 'matches' table with the 'players' table to get the winner's name using the winner_id.", "Join the result with the 'rankings' table to get the rank points of the winner.", "Group the results by winner_name to count the number of matches won by each player.", "Order the results by the count of matches won in descending order to get the player with the most wins at the top.", "Select the winner's name and their rank points, and limit the result to 1 to get the top winner."], "gold_sql": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["matches"], "pred_sql": "SELECT winner_name, MAX(winner_rank_points) AS rank_points\nFROM matches\nJOIN players ON matches.winner_id = players.player_id\nJOIN rankings ON players.player_id = rankings.player_id\nGROUP BY winner_name\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct names of winners from the 'matches' table who participated in a specific tournament and played with a specified hand. The placeholders in the WHERE clause represent the tournament's name and the winning player's hand.\"\n}\n"}
{"sample_id": "dev.471", "db_id": "wta_1", "question": "Find the total ranking points for each player and their first name.", "rationale": ["Identify the required fields: first name of the player and total ranking points.", "The first name is in the 'players' table and the ranking points are in the 'rankings' table.", "To get the total ranking points for each player, we need to sum the 'ranking_points' from the 'rankings' table.", "We will join the 'players' table with the 'rankings' table on the 'player_id' field, which is common in both tables.", "We will group the results by 'player_id' and 'first_name' to ensure we get the total points for each player individually."], "gold_sql": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name", "source_tables": ["rankings", "players"], "pred_sql": "SELECT players.first_name, SUM(rankings.ranking_points) AS total_ranking_points\nFROM players\nJOIN rankings ON players.player_id = rankings.player_id\nGROUP BY players.player_id, players.first_name;", "hint": "\n"}
{"sample_id": "dev.479", "db_id": "wta_1", "question": "Find the total number of tours for each ranking date.", "rationale": ["Identify the relevant table: The 'rankings' table contains the 'ranking_date' and 'tours' columns.", "We need to count the number of tours for each ranking date, which suggests using the COUNT() function.", "Group the results by 'ranking_date' to get the total number of tours for each date.", "Construct the SQL query using SELECT, COUNT, FROM, and GROUP BY clauses."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(tours) AS total_tours\nFROM rankings\nGROUP BY ranking_date;", "hint": "\n"}
{"sample_id": "dev.480", "db_id": "wta_1", "question": "How many total tours were there for each ranking date?", "rationale": ["The question asks for the total number of tours for each ranking date.", "We need to select the 'ranking_date' from the 'rankings' table.", "To count the distinct tours for each ranking date, we will use the COUNT function with DISTINCT on the 'tours' column.", "We will group the results by 'ranking_date' to get the count for each date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(DISTINCT tours) AS total_tours\nFROM rankings\nGROUP BY ranking_date;", "hint": "\n"}
{"sample_id": "dev.533", "db_id": "student_transcripts_tracking", "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment are needed to get student details and their enrolment information.", "Join the Students table with the Student_Enrolment table to link students with their degree programs.", "To find students enrolled in two different degree programs in the same semester, we need to join the Student_Enrolment table with itself (self-join) on the student_id.", "In the self-join, ensure that the degree_program_id is different for the two enrolments but the semester_id is the same.", "Group the results by student_id to aggregate the enrolments for each student.", "Use HAVING clause to filter the groups to only those students who have exactly 2 distinct degree programs."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Student_Enrolment se2 ON s.student_id = se2.student_id\nWHERE se.degree_program_id != se2.degree_program_id\nAND se.semester_id = se2.semester_id\nGROUP BY s.student_id\nHAVING COUNT(DISTINCT se.degree_program_id) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\"\n}\n"}
{"sample_id": "dev.536", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs.", "We need to join these tables to get the names of students enrolled in a Bachelors program.", "The Students table contains the first, middle, and last names of the students.", "The Student_Enrolment table links students to their degree programs.", "The Degree_Programs table contains the information about the degree programs, including the name.", "Use a JOIN to connect Students to Student_Enrolment on student_id, and Student_Enrolment to Degree_Programs on degree_program_id.", "Filter the results to include only those degree programs that have 'Bachelors' in their name using a WHERE clause with LIKE.", "Select distinct names to avoid duplicates."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT DISTINCT s.first_name, s.middle_name, s.last_name\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nWHERE dp.degree_summary_name LIKE '%Bachelors%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\"\n}\n"}
{"sample_id": "dev.537", "db_id": "student_transcripts_tracking", "question": "Find the kind of program which most number of students are enrolled in?", "rationale": ["Identify the relevant tables: We need to find the degree programs and the number of students enrolled in each program, so we will use the Student_Enrolment and Degree_Programs tables.", "Join the tables: We will join the Student_Enrolment table with the Degree_Programs table on the degree_program_id to associate each enrolment with its corresponding degree program.", "Count the number of students: We will use COUNT() to count the number of student enrolments for each degree program.", "Group the results: We will group the results by the degree program name to get the count of students for each program.", "Order the results: We will order the results by the count of students in descending order to find the program with the most enrolments.", "Limit the results: We will limit the results to 1 to get only the program with the highest number of students enrolled."], "gold_sql": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_summary_name, COUNT(se.student_enrolment_id) AS student_count\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nGROUP BY dp.degree_summary_name\nORDER BY student_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\"\n}\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["Identify the relevant tables: Degree_Programs and Student_Enrolment are needed to find the degree programs and their enrolments.", "Join the Degree_Programs table with the Student_Enrolment table on the degree_program_id to associate each enrolment with its corresponding program.", "Group the results by degree_program_id and degree_summary_name to count the number of students enrolled in each program.", "Use COUNT() to count the number of student enrolments for each program.", "Order the results by the count of students in descending order to find the program with the most enrolments.", "Limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_program_id, dp.degree_summary_name, COUNT(se.student_enrolment_id) AS student_count\nFROM Degree_Programs dp\nJOIN Student_Enrolment se ON dp.degree_program_id = se.degree_program_id\nGROUP BY dp.degree_program_id, dp.degree_summary_name\nORDER BY student_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\"\n}\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment are needed to get student details and their enrolment counts.", "Join the Students table with the Student_Enrolment table on the student_id to link students with their enrolments.", "Use COUNT() to count the number of enrolments for each student.", "Group the results by student_id and their names to aggregate the enrolment counts correctly.", "Order the results by the count of enrolments in descending order to find the student with the most enrolments.", "Limit the results to 1 to get only the student with the highest enrolment count."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name, COUNT(se.student_enrolment_id) AS number_of_enrolments\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id, s.first_name, s.middle_name, s.last_name\nORDER BY number_of_enrolments DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\"\n}\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["Identify the relevant tables: Courses, Student_Enrolment_Courses, and Student_Enrolment are needed to find the course with the most enrollments.", "Join the Courses table with the Student_Enrolment_Courses table on course_id to link courses with their enrollments.", "Join the resulting table with the Student_Enrolment table to access the enrollment records.", "Group the results by course_id to count the number of enrollments for each course.", "Order the results by the count of enrollments in descending order to get the course with the most enrollments at the top.", "Limit the results to 1 to get only the course with the highest number of enrollments."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT Courses.course_name\nFROM Courses\nJOIN Student_Enrolment_Courses ON Courses.course_id = Student_Enrolment_Courses.course_id\nJOIN Student_Enrolment ON Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id\nGROUP BY Courses.course_id\nORDER BY COUNT(Student_Enrolment.student_enrolment_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\"\n}\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant tables: Students and Addresses for student information and their current address.", "Join the Students table with the Addresses table on the current_address_id to access the state information.", "Filter the results to include only those students whose current address is in 'North Carolina'.", "Use the EXCEPT clause to exclude students who are enrolled in any degree programs by joining the Students table with the Student_Enrolment table and selecting their last names."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "SELECT last_name FROM Students\nJOIN Addresses ON Students.current_address_id = Addresses.address_id\nWHERE Addresses.state_province_county = 'North Carolina'\nEXCEPT\nSELECT Students.last_name FROM Students\nJOIN Student_Enrolment ON Students.student_id = Student_Enrolment.student_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\"\n}\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table: The question asks for the mobile phone number of a student, which is found in the Students table.", "Determine the columns needed: We need the 'cell_mobile_number' column from the Students table.", "Filter the results: We need to filter the results to find the student named 'Timmothy Ward'. This requires checking both the 'first_name' and 'last_name' columns.", "Construct the SQL query: Using the SELECT statement to retrieve the 'cell_mobile_number' where the first name is 'Timmothy' and the last name is 'Ward'."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\"\n}\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["Identify the relevant tables: 'Addresses' for address details and 'Students' for student information.", "Join the 'Addresses' table with the 'Students' table on the current address ID to associate students with their addresses.", "Group the results by address ID and address lines to count the number of students at each address.", "Order the results by the count of students in descending order to find the address with the most students.", "Limit the results to 1 to get only the address with the highest count of students."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT a.address_id, a.line_1, a.line_2, a.line_3\nFROM Addresses a\nJOIN Students s ON a.address_id = s.current_address_id\nGROUP BY a.address_id, a.line_1, a.line_2, a.line_3\nORDER BY COUNT(s.student_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\"\n}\n"}
{"sample_id": "dev.576", "db_id": "student_transcripts_tracking", "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?", "rationale": ["Identify the relevant tables: We need to look at the Student_Enrolment table to find the semesters in which students are enrolled.", "Join the Degree_Programs table to filter the results based on the degree programs (Masters and Bachelors).", "Use a WHERE clause to specify that we want semesters where the degree_summary_name is either 'Masters' or 'Bachelors'.", "Select distinct semester_id to ensure we only get unique semester IDs that meet the criteria."], "gold_sql": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT DISTINCT se.semester_id\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nWHERE dp.degree_summary_name IN ('Masters', 'Bachelors');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. The placeholders in the query represent the name of the degree program, allowing users to specify which program they are interested in to retrieve the relevant semesters.\"\n}\n"}
{"sample_id": "dev.580", "db_id": "student_transcripts_tracking", "question": "What other details can you tell me about students in reverse alphabetical order?", "rationale": ["The query needs to retrieve the 'other_student_details' from the 'Students' table.", "To present the students in reverse alphabetical order, we will order the results by 'last_name', 'first_name', and 'middle_name' in descending order.", "The final SQL query selects the required details and applies the appropriate ordering."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "pred_sql": "SELECT other_student_details FROM Students ORDER BY last_name DESC, first_name DESC, middle_name DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\"\n}\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve the details of the section, I will select the relevant columns from the 'Sections' table.", "The WHERE clause is used to filter the results to only include the section with the name 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT section_id, section_name, section_description, other_details \nFROM Sections \nWHERE section_name = 'h';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of course names and their corresponding identifiers from the 'Courses' table, specifically for those courses that have a number of sections less than or equal to a specified threshold. The placeholder in the HAVING clause represents the maximum number of sections allowed for the courses listed.\"\n}\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms.", "Determine the condition: We need to count countries with a government form that includes 'Republic'.", "Construct the SQL query: Use the COUNT function to count the number of rows in the 'country' table where the GovernmentForm contains 'Republic'."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(*) FROM country WHERE GovernmentForm LIKE '%Republic%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\"\n}\n"}
{"sample_id": "dev.730", "db_id": "world_1", "question": "What is the average GNP and total population in all nations whose government is US territory?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including GNP and population.", "Determine the required calculations: We need to calculate the average GNP and the total population.", "Use the AVG() function to calculate the average GNP and the SUM() function to calculate the total population.", "Filter the results to include only those countries where the government form is 'US territory'.", "Construct the SQL query using the SELECT statement to retrieve the average GNP and total population from the 'country' table with the specified condition."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT AVG(GNP) AS Average_GNP, SUM(Population) AS Total_Population \nFROM country \nWHERE GovernmentForm = 'US territory';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\"\n}\n"}
{"sample_id": "dev.734", "db_id": "world_1", "question": "How many type of governments are in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and regions.", "Determine the specific region of interest: The question asks about Africa, so we will filter the results to only include countries in the 'Africa' region.", "Select distinct government forms: We want to know how many different types of governments exist, so we will use the DISTINCT keyword to get unique government forms from the 'GovernmentForm' column."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Region = 'Africa';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\"\n}\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and continent.", "Focus on the continent: We need to filter the countries to only those located in Africa.", "Count distinct government forms: We want to count the unique types of government forms present in the African countries.", "Construct the SQL query: Use COUNT(DISTINCT GovernmentForm) to get the number of different forms of government, and filter by continent using WHERE Continent = 'Africa'."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(DISTINCT GovernmentForm) AS DifferentGovernmentForms FROM country WHERE Continent = 'Africa';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\"\n}\n"}
{"sample_id": "dev.742", "db_id": "world_1", "question": "Which continent has the most diverse languages?", "rationale": ["We need to find out which continent has the most diverse languages, which means we need to count the distinct languages spoken in each continent.", "To do this, we will join the 'country' table with the 'countrylanguage' table on the 'CountryCode'.", "We will group the results by 'Continent' to count the number of distinct languages for each continent.", "We will use COUNT(DISTINCT countrylanguage.Language) to get the number of unique languages per continent.", "Finally, we will order the results in descending order based on the count of languages and limit the result to 1 to get the continent with the most diverse languages."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT country.Continent, COUNT(DISTINCT countrylanguage.Language) AS LanguageCount\nFROM country\nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode\nGROUP BY country.Continent\nORDER BY LanguageCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in countries where a specific language is spoken officially. The query filters the results based on whether the language is official, the name of the language, and the continent the country belongs to. The placeholders in the WHERE clause represent the official status of the language, the language name, and the continent name.\"\n}\n"}
{"sample_id": "dev.743", "db_id": "world_1", "question": "Which continent speaks the most languages?", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find the continent and the languages spoken.", "Join the tables: We will join 'country' and 'countrylanguage' on the 'Code' and 'CountryCode' fields respectively to associate countries with their languages.", "Filter for official languages: We need to filter the results to only include languages that are marked as official (IsOfficial = 'T').", "Group by continent: We will group the results by the continent to count the number of official languages spoken in each continent.", "Count the languages: We will count the number of languages for each continent using COUNT().", "Order the results: We will order the results in descending order based on the count of languages to find the continent with the most languages.", "Limit the results: Finally, we will limit the results to only the top entry to get the continent that speaks the most languages."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT country.Continent, COUNT(countrylanguage.Language) AS LanguageCount\nFROM country\nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode\nWHERE countrylanguage.IsOfficial = 'T'\nGROUP BY country.Continent\nORDER BY LanguageCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\"\n}\n"}
{"sample_id": "dev.746", "db_id": "world_1", "question": "What are the names of nations speak both English and French?", "rationale": ["We need to find countries that speak both English and French as official languages.", "To do this, we will join the 'country' table with the 'countrylanguage' table twice: once for English and once for French.", "In the first join (cl1), we will filter for English and check if it is an official language.", "In the second join (cl2), we will filter for French and also check if it is an official language.", "Finally, we will select the names of the countries that meet both conditions."], "gold_sql": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'French'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Name \nFROM country c \nJOIN countrylanguage cl1 ON c.Code = cl1.CountryCode \nJOIN countrylanguage cl2 ON c.Code = cl2.CountryCode \nWHERE cl1.Language = 'English' AND cl1.IsOfficial = 'T' \nAND cl2.Language = 'French' AND cl2.IsOfficial = 'T';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\"\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find the countries with specific languages.", "Determine the relationship: The 'country' table is linked to the 'countrylanguage' table through the 'Code' and 'CountryCode' columns.", "Select the required fields: We want the distinct names of countries, so we will select 'country.Name'.", "Filter the results: We need to filter the languages to include only 'English' or 'Dutch' and ensure that these languages are marked as official (IsOfficial = 'T').", "Construct the SQL query: Using JOIN to combine the two tables and applying the necessary filters to get the desired results."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT country.Name \nFROM country \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE countrylanguage.Language IN ('English', 'Dutch') AND countrylanguage.IsOfficial = 'T';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\"\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the requirement to find the total population of countries that do not use English as an official language.", "Use the 'country' table to access the population data.", "Use the 'countrylanguage' table to filter out countries where English is an official language.", "Construct a subquery to select the country codes of countries where English is an official language.", "Use the NOT IN clause to exclude these countries from the main query that sums the population."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation\nFROM country c\nWHERE c.Code NOT IN (\n    SELECT cl.CountryCode\n    FROM countrylanguage cl\n    WHERE cl.Language = 'English' AND cl.IsOfficial = 'T'\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\"\n}\n"}
{"sample_id": "dev.767", "db_id": "world_1", "question": "How many people live in countries that do not speak English?", "rationale": ["Identify the main goal: Calculate the total population of countries that do not have English as an official language.", "Use the 'country' table to access the population data of each country.", "To find countries that do not speak English, we need to filter out countries where English is an official language.", "Create a subquery that selects the country codes from the 'countrylanguage' table where the language is 'English' and it is marked as official (IsOfficial = 'T').", "Use the NOT IN clause to exclude these country codes from the main query that sums the populations of the remaining countries."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation\nFROM country c\nWHERE c.Code NOT IN (\n    SELECT cl.CountryCode\n    FROM countrylanguage cl\n    WHERE cl.Language = 'English' AND cl.IsOfficial = 'T'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\"\n}\n"}
{"sample_id": "dev.783", "db_id": "world_1", "question": "Return the codes of countries that do not speak English and do not have Republics for governments.", "rationale": ["Identify the requirement to find country codes that do not speak English and do not have Republics for governments.", "The first part of the query will filter countries based on the government form, specifically excluding those that contain 'Republic'.", "The second part of the query will exclude countries that have English as an official language by using a subquery that selects country codes from the countrylanguage table where the language is 'English' and it is marked as official.", "Combine both conditions using the AND operator to ensure both criteria are met in the final selection of country codes."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT Code FROM country WHERE GovernmentForm NOT LIKE '%Republic%' AND Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'T');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\"\n}\n"}
{"sample_id": "dev.784", "db_id": "world_1", "question": "Which cities are in European countries where English is not the official language?", "rationale": ["Identify the relevant tables: We need to use the 'city' and 'country' tables to find cities in European countries.", "Determine the condition for European countries: We can filter countries by checking if their continent is 'Europe'.", "Identify the language condition: We need to exclude countries where English is an official language. This requires a subquery on the 'countrylanguage' table.", "Construct the subquery: The subquery will select the CountryCode from 'countrylanguage' where the Language is 'English' and IsOfficial is 'T'.", "Combine the main query and the subquery: Use a JOIN between 'city' and 'country' to get the city names, and apply the conditions for continent and the subquery to filter out countries where English is official."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT city.Name \nFROM city \nJOIN country ON city.CountryCode = country.Code \nWHERE country.Continent = 'Europe' \nAND country.Code NOT IN (\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language = 'English' AND IsOfficial = 'T'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\"\n}\n"}
{"sample_id": "dev.785", "db_id": "world_1", "question": "What are the names of cities in Europe for which English is not the official language?", "rationale": ["Identify the relevant tables: 'city', 'country', and 'countrylanguage'.", "We need to find cities in Europe, so we will filter the 'country' table by the continent 'Europe'.", "We need to check if English is not an official language, which requires a LEFT JOIN on the 'countrylanguage' table for English where IsOfficial is 'T'.", "To find cities where English is not an official language, we will check for NULL values in the 'countrylanguage' table after the LEFT JOIN.", "Select the 'Name' from the 'city' table where the conditions are met."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT city.Name \nFROM city \nJOIN country ON city.CountryCode = country.Code \nLEFT JOIN countrylanguage ON country.Code = countrylanguage.CountryCode AND countrylanguage.Language = 'English' AND countrylanguage.IsOfficial = 'T' \nWHERE country.Continent = 'Europe' AND countrylanguage.Language IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\"\n}\n"}
{"sample_id": "dev.788", "db_id": "world_1", "question": "What are the name, independence year, and surface area of the country with the smallest population?", "rationale": ["Identify the required columns: Name, IndepYear, and SurfaceArea from the country table.", "Determine the condition to find the country with the smallest population, which involves using the MIN function on the Population column.", "Construct a subquery to find the minimum population from the country table.", "Use the result of the subquery to filter the main query to get the details of the country with that minimum population."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\"\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the required fields: Name, year of independence (IndepYear), and surface area (SurfaceArea) from the country table.", "Determine the condition to find the country with the lowest population, which involves using the MIN function on the Population column.", "Construct a subquery to find the minimum population from the country table.", "Use the result of the subquery to filter the main query to get the country details that match the minimum population."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\"\n}\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["Identify the relevant tables: We need to use the 'country' and 'countrylanguage' tables to get the names of countries and the languages they speak.", "Join the tables: We will join 'country' and 'countrylanguage' on the 'Code' and 'CountryCode' fields respectively to link countries with their languages.", "Filter for official languages: We need to filter the results to only include languages that are marked as official, which is indicated by 'IsOfficial' being 'T'.", "Group by country: We will group the results by the country name to aggregate the language counts for each country.", "Count the languages: We will count the number of languages spoken by each country using COUNT(countrylanguage.Language).", "Filter countries with more than 2 languages: Finally, we will use the HAVING clause to filter out countries that speak more than 2 languages."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT country.Name, COUNT(countrylanguage.Language) AS LanguageCount\nFROM country\nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode\nWHERE countrylanguage.IsOfficial = 'T'\nGROUP BY country.Name\nHAVING COUNT(countrylanguage.Language) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\"\n}\n"}
{"sample_id": "dev.796", "db_id": "world_1", "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.", "rationale": ["Identify the relevant table: The 'country' table contains the columns for government form and population, as well as life expectancy.", "Determine the columns needed: We need 'GovernmentForm' and the total population, which can be calculated using SUM(Population).", "Apply the condition: We need to filter the results to include only those countries with an average life expectancy greater than 72.", "Group the results: Since we want the total population for each government form, we will group the results by 'GovernmentForm'.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation\nFROM country\nWHERE LifeExpectancy > 72\nGROUP BY GovernmentForm;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\"\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the relevant table: The 'country' table contains the columns for GovernmentForm and Population, as well as LifeExpectancy.", "Filter the results: We need to include only those countries where the average life expectancy is greater than 72. This is done using a WHERE clause.", "Group the results: To get the total population for each government form, we will use the GROUP BY clause on the GovernmentForm column.", "Calculate the total population: We will use the SUM function to calculate the total population for each government form.", "Select the required columns: We will select the GovernmentForm and the calculated total population in the final output."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation\nFROM country\nWHERE LifeExpectancy > 72\nGROUP BY GovernmentForm;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\"\n}\n"}
{"sample_id": "dev.801", "db_id": "world_1", "question": "Return the names and surface areas of the 5 largest countries.", "rationale": ["Identify the table needed: The 'country' table contains the names and surface areas of countries.", "Determine the required columns: We need 'Name' and 'SurfaceArea' from the 'country' table.", "Sort the countries by size: To find the largest countries, we will sort by 'Population' in descending order.", "Limit the results: We only want the top 5 largest countries, so we will use 'LIMIT 5' in the query."], "gold_sql": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5", "source_tables": ["country"], "pred_sql": "SELECT Name, SurfaceArea FROM country ORDER BY Population DESC LIMIT 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\"\n}\n"}
{"sample_id": "dev.810", "db_id": "world_1", "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?", "rationale": ["Identify the relevant table: The 'country' table contains the necessary information about countries, including population and surface area.", "Determine the required fields: We need to calculate the total population and average surface area of countries.", "Apply the conditions: We need to filter countries that are in the continent of North America and have a surface area greater than 3000.", "Construct the SQL query: Use SUM() to get the total population and AVG() to get the average surface area, applying the necessary WHERE conditions."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT SUM(Population) AS TotalPopulation, AVG(SurfaceArea) AS AverageArea \nFROM country \nWHERE Continent = 'North America' AND SurfaceArea > 3000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\"\n}\n"}
{"sample_id": "dev.811", "db_id": "world_1", "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .", "rationale": ["Identify the relevant tables: We need data from the 'country' table for population and surface area.", "Determine the conditions: We are interested in countries in 'North America' with a surface area greater than 3000.", "Select the required fields: We need to calculate the total population and average surface area.", "Use aggregate functions: Use SUM() for total population and AVG() for average surface area.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter the results accordingly."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation, AVG(c.SurfaceArea) AS AverageSurfaceArea \nFROM country c \nWHERE c.Continent = 'North America' AND c.SurfaceArea > 3000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\"\n}\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the table to query: The 'city' table contains the population data.", "Determine the condition for the population: We need cities with a population between 160000 and 900000.", "Construct the SQL query using the SELECT statement to retrieve the 'Name' of the cities that meet the population criteria.", "Use the WHERE clause to filter the results based on the specified population range."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT Name FROM city WHERE Population BETWEEN '160000' AND '900000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\"\n}\n"}
{"sample_id": "dev.921", "db_id": "dog_kennels", "question": "Find the average age of the dogs who went through treatments.", "rationale": ["Identify the main goal: Calculate the average age of dogs that have received treatments.", "The relevant table for dog information is 'Dogs', which contains the 'age' column.", "The 'Treatments' table links dogs to their treatments via the 'dog_id' column.", "To find dogs that have received treatments, we can use a subquery to select 'dog_id' from the 'Treatments' table.", "The main query will then calculate the average age of dogs whose 'dog_id' is in the result of the subquery."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT AVG(age) AS average_age\nFROM Dogs\nWHERE dog_id IN (\n    SELECT dog_id\n    FROM Treatments\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.\"\n}\n"}
