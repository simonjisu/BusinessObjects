{"sample_id": "train.2612", "db_id": "inn_1", "question": "Find the name of the room with the maximum occupancy.", "rationale": ["Identify the table that contains room information, which is the 'Rooms' table.", "To find the room with the maximum occupancy, we need to select the 'roomName' from the 'Rooms' table.", "We need to determine the maximum occupancy by using a subquery that selects the maximum value from the 'maxOccupancy' column in the 'Rooms' table.", "The final query combines these elements to select the room name where the maximum occupancy matches the maximum value found."], "gold_sql": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE maxOccupancy = (SELECT MAX(maxOccupancy) FROM Rooms);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\"\n}\n"}
{"sample_id": "train.2621", "db_id": "inn_1", "question": "What is the average minimum and price of the rooms for each different decor.", "rationale": ["Identify the required information: average and minimum price of rooms based on their decor.", "The relevant table is 'Rooms', which contains the 'basePrice' and 'decor' columns.", "To calculate the average and minimum prices, we will use the AVG() and MIN() aggregate functions respectively.", "We need to group the results by the 'decor' column to get the average and minimum prices for each type of decor.", "Construct the SQL query using SELECT to specify the columns, AVG() and MIN() for calculations, and GROUP BY for grouping the results."], "gold_sql": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;", "source_tables": ["rooms"], "pred_sql": "SELECT decor, AVG(basePrice) AS average_price, MIN(basePrice) AS minimum_price \nFROM Rooms \nGROUP BY decor;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
{"sample_id": "train.2628", "db_id": "inn_1", "question": "List the name of rooms with king or queen bed.", "rationale": ["Identify the relevant table: The 'Rooms' table contains the information about room names and bed types.", "Determine the required columns: We need the 'roomName' column to list the names of the rooms.", "Specify the condition: We want rooms that have either a 'king' or 'queen' bed, which can be expressed using the IN clause.", "Order the results: The hint suggests ordering by 'basePrice', so we will include an ORDER BY clause for 'basePrice'."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE bedType IN ('king', 'queen') ORDER BY basePrice;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["We need to find the name of each room and the number of reservations made for it.", "To achieve this, we will select the 'roomName' from the 'Rooms' table.", "We also need to count the number of reservations for each room, which can be done using the COUNT() function on the 'Code' column from the 'Reservations' table.", "Since a room may not have any reservations, we will use a LEFT JOIN to include all rooms even if they have zero reservations.", "We will join the 'Rooms' table with the 'Reservations' table on the 'RoomId' and 'Room' columns respectively.", "Finally, we will group the results by 'RoomId' and 'roomName' to get the count of reservations for each room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservation_count \nFROM Rooms \nLEFT JOIN Reservations ON Rooms.RoomId = Reservations.Room \nGROUP BY Rooms.RoomId, Rooms.roomName;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\"\n}\n"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["Identify the table needed: The question asks for details of trucks, so we will use the 'Trucks' table.", "Select all columns: We need all details, so we will use SELECT *.", "Order by license number: The question specifies to order the results by the truck's license number, so we will add ORDER BY truck_licence_number."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "pred_sql": "SELECT * FROM Trucks ORDER BY truck_licence_number;", "hint": "\n"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["Identify the tables involved: Customers, Customer_Addresses, and Addresses.", "We need to find customer names, so we will select 'customer_name' from the Customers table.", "To filter customers based on their addresses, we will join the Customers table with the Customer_Addresses table on 'customer_id'.", "Next, we will join the Customer_Addresses table with the Addresses table on 'address_id' to access the state information.", "We will apply a WHERE clause to filter out customers whose addresses are in California by checking 'state_province_county' column.", "Use DISTINCT to ensure that we get unique customer names in case a customer has multiple addresses."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT DISTINCT c.customer_name \nFROM Customers c \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nJOIN Addresses a ON ca.address_id = a.address_id \nWHERE a.state_province_county != 'California';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of customer addresses grouped by state, province, or county from the 'Customer_Addresses' and 'Addresses' tables. The placeholder in the SELECT statement represents the state, province, or county being counted.\"\n}\n"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["Identify the relevant tables: Delivery_Routes, Delivery_Route_Locations, and Order_Deliveries are needed to find the route with the highest number of deliveries.", "Join Delivery_Routes with Delivery_Route_Locations on route_id to link routes with their locations.", "Join the result with Order_Deliveries on location_code to associate deliveries with their respective routes.", "Group the results by route_name to count the number of deliveries for each route.", "Order the results in descending order based on the count of deliveries to find the route with the highest number.", "Limit the results to 1 to get only the top route."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "pred_sql": "SELECT route_name\nFROM Delivery_Routes\nJOIN Delivery_Route_Locations ON Delivery_Routes.route_id = Delivery_Route_Locations.route_id\nJOIN Order_Deliveries ON Delivery_Route_Locations.location_code = Order_Deliveries.location_code\nGROUP BY route_name\nORDER BY COUNT(Order_Deliveries.actual_order_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3175", "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["Identify the relevant tables: PROFESSOR and CLASS are needed to find professors teaching a specific class.", "We need to count the number of distinct professors, so we will use COUNT(DISTINCT p.EMP_NUM).", "Join the PROFESSOR table with the CLASS table on the professor's employee number (PROF_NUM) and the class's professor number (EMP_NUM).", "Filter the results to only include classes with the CLASS_CODE 'ACCT-211'.", "Construct the SQL query to select the count of distinct professors for the specified class code."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) AS professor_count\nFROM PROFESSOR p\nJOIN CLASS c ON p.EMP_NUM = c.PROF_NUM\nWHERE c.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\"\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and PROFESSOR.", "We need to count the number of distinct professors teaching a specific class, so we will use COUNT(DISTINCT p.EMP_NUM).", "Join the CLASS table with the PROFESSOR table on the condition that CLASS.PROF_NUM matches PROFESSOR.EMP_NUM.", "Filter the results to only include the class with the code 'ACCT-211' using a WHERE clause."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) AS professor_count\nFROM CLASS c\nJOIN PROFESSOR p ON c.PROF_NUM = p.EMP_NUM\nWHERE c.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\"\n}\n"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["Identify the tables needed: EMPLOYEE, PROFESSOR, and CLASS.", "We need to join these tables to get the first names and dates of birth of professors teaching a specific course.", "The EMPLOYEE table contains the first names and dates of birth of professors.", "The PROFESSOR table links professors to their respective departments and classes they teach.", "The CLASS table contains the course codes associated with each class.", "We will join EMPLOYEE to PROFESSOR on EMP_NUM, and then join PROFESSOR to CLASS on PROF_NUM.", "Finally, we filter the results to only include professors teaching the course with the code 'ACCT-211'."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME, EMP_DOB \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\"\n}\n"}
{"sample_id": "train.3188", "db_id": "college_1", "question": "Where is the history department?", "rationale": ["Identify the relevant table: The DEPARTMENT table contains information about department names and addresses.", "Determine the specific department of interest: The user is asking for the 'history department'.", "Construct the SQL query: Use a SELECT statement to retrieve the DEPT_NAME and DEPT_ADDRESS from the DEPARTMENT table where the DEPT_NAME matches 'History'."], "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"], "pred_sql": "SELECT DEPT_NAME, DEPT_ADDRESS FROM DEPARTMENT WHERE DEPT_NAME = 'History';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the table that contains the school locations, which is the DEPARTMENT table.", "Determine the relevant column for the school code, which is SCHOOL_CODE in the DEPARTMENT table.", "Use the DISTINCT keyword to ensure that only unique addresses are returned.", "Construct the SQL query to select the DEPT_ADDRESS from the DEPARTMENT table where the SCHOOL_CODE is 'BUS'."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "\n"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["We need to find the total credit hours offered by each department.", "The relevant tables for this query are DEPARTMENT and COURSE, as the credit hours are associated with courses and departments offer these courses.", "We will join the DEPARTMENT table with the COURSE table on the DEPT_CODE column, which is common to both tables.", "We will use the SUM function to calculate the total credit hours (CRS_CREDIT) for each department.", "Finally, we will group the results by DEPARTMENT.DEPT_CODE to get the total credit hours for each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, SUM(COURSE.CRS_CREDIT) AS TOTAL_CREDIT\nFROM DEPARTMENT\nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\"\n}\n"}
{"sample_id": "train.3202", "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["The question asks for the total credits offered by the department.", "To find this, we need to sum the credits from the COURSE table, which contains the CRS_CREDIT column.", "We will join the DEPARTMENT table with the COURSE table on the DEPT_CODE to associate courses with their respective departments.", "We will use the SUM function to calculate the total credits for each department.", "Finally, we will group the results by DEPARTMENT.DEPT_CODE to get the total credits per department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, SUM(CAST(COURSE.CRS_CREDIT AS INTEGER)) AS TOTAL_CREDITS\nFROM DEPARTMENT\nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\"\n}\n"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["Identify the relevant tables: DEPARTMENT and PROFESSOR are needed to find the number of professors per school.", "Join the DEPARTMENT table with the PROFESSOR table on the DEPT_CODE to associate professors with their respective departments.", "Group the results by SCHOOL_CODE to count the number of professors in each school.", "Use COUNT(PROF_NUM) to count the number of professors in each school.", "Order the results by the count of professors in ascending order to find the school with the smallest number of professors.", "Limit the results to 1 to get only the school with the smallest amount of professors."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "pred_sql": "SELECT SCHOOL_CODE, COUNT(PROF_NUM) AS PROFESSOR_COUNT\nFROM DEPARTMENT\nJOIN PROFESSOR ON DEPARTMENT.DEPT_CODE = PROFESSOR.DEPT_CODE\nGROUP BY SCHOOL_CODE\nORDER BY PROFESSOR_COUNT ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\"\n}\n"}
{"sample_id": "train.3215", "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["We need to find the number of professors with a Ph.D. degree in each department.", "To do this, we will join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE column, as this will allow us to group professors by their respective departments.", "We will filter the results to include only those professors whose highest degree is 'Ph.D.' using a WHERE clause.", "Finally, we will use the COUNT function to count the number of professors for each department and group the results by DEPARTMENT.DEPT_CODE."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, COUNT(PROFESSOR.EMP_NUM) AS PhD_Professors\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nWHERE PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D.'\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\"\n}\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["We need to find the number of students for each department, which requires us to count the students grouped by their department.", "The relevant tables for this query are DEPARTMENT and STUDENT, as we need to relate students to their respective departments.", "We will use a LEFT JOIN to ensure that we include departments even if they have no students enrolled.", "We will group the results by DEPARTMENT.DEPT_CODE and DEPARTMENT.DEPT_NAME to get the count of students for each department.", "The COUNT function will be used to count the number of students (STU_NUM) in each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, DEPARTMENT.DEPT_NAME, COUNT(STUDENT.STU_NUM) AS STUDENT_COUNT\nFROM DEPARTMENT\nLEFT JOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE, DEPARTMENT.DEPT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\"\n}\n"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["We need to find the total number of hours completed by students in each department.", "The relevant tables are STUDENT and DEPARTMENT, as we need to aggregate student hours by department.", "We will join the STUDENT table with the DEPARTMENT table on the DEPT_CODE column to associate students with their respective departments.", "We will use the SUM function to calculate the total hours (STU_HRS) for each department.", "Finally, we will group the results by DEPARTMENT.DEPT_CODE to get the total hours for each department."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, SUM(STUDENT.STU_HRS) AS TOTAL_HOURS\nFROM STUDENT\nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\"\n}\n"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE are needed to find the department and the credits associated with courses.", "Join the DEPARTMENT table with the COURSE table on the DEPT_CODE to associate courses with their respective departments.", "Use the SUM function to calculate the total credits for each department by grouping the results by DEPARTMENT.DEPT_CODE and DEPARTMENT.DEPT_NAME.", "Order the results in descending order based on the total credits to find the department with the most credits.", "Limit the results to 1 to get only the department that offers the most credits."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, DEPARTMENT.DEPT_NAME, SUM(COURSE.CRS_CREDIT) AS TOTAL_CREDITS\nFROM DEPARTMENT\nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE, DEPARTMENT.DEPT_NAME\nORDER BY TOTAL_CREDITS DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\"\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the tables needed: STUDENT, ENROLL, and CLASS.", "Determine the relationship between the tables: STUDENT is linked to ENROLL through STU_NUM, and ENROLL is linked to CLASS through CLASS_CODE.", "Select the first name of students (STU_FNAME) from the STUDENT table.", "Filter the results to include only those students enrolled in the class with CLASS_CODE 'ACCT-211'.", "Construct the SQL query using JOINs to connect the tables and a WHERE clause to filter by the specific class code."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\"\n}\n"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["Identify the tables needed: STUDENT, ENROLL, and CLASS are required to get the first names of students enrolled in a specific class with a specific grade.", "Join the ENROLL table with the STUDENT table on the student number (STU_NUM) to get student details.", "Join the CLASS table with the ENROLL table on the class code (CLASS_CODE) to filter by the specific class (ACCT-211).", "Add a WHERE clause to filter for the class code 'ACCT-211' and the grade 'C'.", "Select the first name (STU_FNAME) of the students who meet these criteria."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211' AND ENROLL.ENROLL_GRADE = 'C';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\"\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["Identify the relevant tables: DEPARTMENT and STUDENT are needed to find the department with the most students enrolled.", "Count the number of students in each department by grouping the STUDENT table by DEPT_CODE.", "Order the results by the count of students in descending order to find the department with the most students.", "Limit the results to 1 to get only the top department.", "Select the DEPT_NAME from the DEPARTMENT table where the DEPT_CODE matches the one with the most students."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT DEPT_NAME\nFROM DEPARTMENT\nWHERE DEPT_CODE IN (\n    SELECT DEPT_CODE\n    FROM STUDENT\n    GROUP BY DEPT_CODE\n    ORDER BY COUNT(STU_NUM) DESC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\"\n}\n"}
{"sample_id": "train.3257", "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["Identify the relevant table: The CLASS table contains information about classes, including the room where they are held and the course code associated with each class.", "Determine the required columns: We need the course codes (CRS_CODE) for classes held in room KLR209.", "Construct the SQL query: Use a SELECT statement to retrieve distinct course codes from the CLASS table where the CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE\nFROM CLASS\nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about classes, including the room they are held in and the course code associated with each class.", "Determine the specific requirement: We need to find the course codes for classes held in room KLR209.", "Construct the SQL query: We will select the distinct course codes (CRS_CODE) from the CLASS table where the CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE \nFROM CLASS \nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed to find students and their grades.", "Join the STUDENT table with the ENROLL table on the student number (STU_NUM) to link students with their grades.", "Filter the results to include only those records where the grade (ENROLL_GRADE) is 'C'.", "Select the first names (STU_FNAME) of the students who meet the criteria."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\"\n}\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["Identify the relevant table: We need to find professors, so we will focus on the EMPLOYEE table.", "Determine the condition: We want professors who do not teach any class, which means we need to check which professors are not present in the CLASS table.", "Use a subquery: We can use a subquery to get the list of professor numbers (PROF_NUM) from the CLASS table and then filter out those from the EMPLOYEE table.", "Construct the SQL query: We will select the first names (EMP_FNAME) from the EMPLOYEE table where the EMP_NUM is not in the list of PROF_NUM from the CLASS table."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME \nFROM EMPLOYEE \nWHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\"\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the table that contains professor information, which is the EMPLOYEE table.", "We need to find professors who are not teaching any classes, so we will look for professors whose EMP_NUM is not present in the CLASS table.", "The CLASS table has a column PROF_NUM that indicates which professor is teaching the class.", "We will use a subquery to select all PROF_NUM from the CLASS table and then use the NOT IN clause to filter out those professors from the EMPLOYEE table.", "Finally, we will select the first names (EMP_FNAME) of the remaining professors who are not teaching any classes."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME FROM EMPLOYEE WHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\"\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors, including their highest degree obtained.", "Determine the condition: We need to count professors who have either a Ph.D. or a Masters degree.", "Construct the SQL query: Use the COUNT function to count the number of professors that meet the condition specified in the WHERE clause."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) AS total_professors\nFROM PROFESSOR\nWHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["Identify the tables needed: EMPLOYEE, PROFESSOR, and CLASS are required to find the first names of professors teaching specific courses.", "Join the EMPLOYEE table with the PROFESSOR table on EMP_NUM to get the professors' details.", "Join the resulting table with the CLASS table on the PROFESSOR's EMP_NUM to find the classes they teach.", "Filter the results using a WHERE clause to include only the courses 'CIS-220' and 'QM-261'.", "Select the first names of the professors from the EMPLOYEE table and ensure distinct results by using GROUP BY."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CRS_CODE IN ('CIS-220', 'QM-261') \nGROUP BY EMPLOYEE.EMP_FNAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\"\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the tables needed: STUDENT, CLASS, COURSE, and DEPARTMENT.", "Join the STUDENT table with the CLASS table to find which classes each student is enrolled in.", "Join the CLASS table with the COURSE table to get the department codes for the courses.", "Join the COURSE table with the DEPARTMENT table to filter by department names.", "Use a WHERE clause to specify the departments: 'Accounting' and 'Computer Info. Systems'.", "Group the results by student first name and use HAVING to ensure that only students enrolled in both departments are included."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME \nFROM STUDENT S \nJOIN CLASS C ON S.STU_NUM = (SELECT E.STU_NUM FROM ENROLL E WHERE E.CLASS_CODE = C.CLASS_CODE) \nJOIN COURSE CR ON C.CRS_CODE = CR.CRS_CODE \nJOIN DEPARTMENT D ON CR.DEPT_CODE = D.DEPT_CODE \nWHERE D.DEPT_NAME IN ('Accounting', 'Computer Info. Systems') \nGROUP BY S.STU_FNAME \nHAVING COUNT(DISTINCT D.DEPT_NAME) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\"\n}\n"}
{"sample_id": "train.3308", "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["Identify the relevant tables: PROFESSOR, EMPLOYEE, and DEPARTMENT are needed to get the professors' first names and offices, along with their department information.", "Join the PROFESSOR table with the EMPLOYEE table on the EMP_NUM to get the first names of the professors.", "Join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE to filter for the History department.", "Add a WHERE clause to filter for professors who have a Ph.D. in their highest degree.", "Select the first names and office locations of the professors that meet the criteria."], "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'History' AND PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3319", "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["Identify the tables needed: STUDENT for student names, ENROLL for enrollment records, and CLASS for class information.", "Join the STUDENT table with the ENROLL table on the student number to get the courses they are enrolled in.", "Join the resulting table with the CLASS table to access the class details.", "Filter the results to include only those students who received grades 'A' or 'C' in their enrolled classes.", "Select distinct first and last names of the students to avoid duplicates."], "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME, S.STU_LNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nJOIN CLASS C ON E.CLASS_CODE = C.CLASS_CODE \nWHERE E.ENROLL_GRADE IN ('A', 'C');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\"\n}\n"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["Identify the tables needed: PROFESSOR for professor details, EMPLOYEE for first names, and DEPARTMENT for department names.", "Join the PROFESSOR table with the EMPLOYEE table to get the first names of professors.", "Join the PROFESSOR table with the DEPARTMENT table to filter by the Computer Information Systems department.", "Select the first names and highest degrees of professors from the joined tables where the department matches 'Computer Information Systems'."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_HIGH_DEGREE \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'Computer Information Systems';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: DEPARTMENT, COURSE, and CLASS are needed to find the department name based on the class description.", "Join the DEPARTMENT table with the COURSE table on DEPT_CODE to link courses to their respective departments.", "Join the resulting table with the CLASS table on CRS_CODE to link classes to their respective courses.", "Use a WHERE clause to filter courses whose description contains the word 'Statistics' using the LIKE operator."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT D.DEPT_NAME \nFROM DEPARTMENT D \nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE \nJOIN CLASS CL ON C.CRS_CODE = CL.CRS_CODE \nWHERE C.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["We need to find the types and countries of competitions.", "The relevant table for this information is the 'competition' table.", "We will select distinct values to avoid duplicates in the results.", "The columns we are interested in are 'Competition_type' and 'Country'."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT Competition_type, Country FROM competition;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the countries that hosted competitions of two specific types. The placeholders in the query represent the types of competitions being compared.\"\n}\n"}
{"sample_id": "train.3355", "db_id": "sports_competition", "question": "Please show the names and the players of clubs.", "rationale": ["Identify the tables needed: 'club' for club names and 'player' for player names.", "Determine the relationship between the tables: 'player' has a foreign key 'Club_ID' that references 'club'.", "Use a JOIN operation to combine data from both tables based on the 'Club_ID'.", "Select the desired columns: the name of the club and the name of the player."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "pred_sql": "SELECT c.name AS club_name, p.name AS player_name \nFROM club c \nJOIN player p ON c.Club_ID = p.Club_ID;", "hint": "\n"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["We need to find the positions of players whose average points scored is greater than 20.", "To do this, we will select the 'Position' column from the 'player' table.", "We will group the results by 'Position' to calculate the average points for each position.", "We will use the HAVING clause to filter the groups where the average points is greater than 20."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "pred_sql": "SELECT Position\nFROM player\nGROUP BY Position\nHAVING AVG(Points) > 20;", "hint": "\n"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant column for player positions, which is 'Position'.", "Identify the column that contains the points scored by players, which is 'Points'.", "Formulate the condition to filter players based on their points: greater than 20 or less than 10.", "Construct the SQL query to select the 'Position' from the 'player' table where the points meet the specified conditions."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player WHERE Points > 20 OR Points < 10;", "hint": "\n"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competitions, including their type and country.", "Filter for tournament competitions: We need to focus on competitions where the type is 'tournament'.", "Count the number of tournaments per country: We will use the COUNT function to count how many tournaments each country has hosted.", "Group the results by country: We will use GROUP BY to aggregate the counts for each country.", "Order the results: To find the country with the most tournaments, we will order the results in descending order based on the count.", "Limit the results to the top entry: We will use LIMIT 1 to get only the country with the highest count."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country, COUNT(*) AS Tournament_Count\nFROM competition\nWHERE Competition_type = 'tournament'\nGROUP BY Country\nORDER BY Tournament_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the countries that hosted competitions of two specific types. The placeholders in the query represent the types of competitions being compared.\"\n}\n"}
{"sample_id": "train.3384", "db_id": "sports_competition", "question": "what is the name of the country that participated in the most tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competitions, including their type and country.", "Filter for tournament competitions: We need to focus on competitions of type 'tournament'.", "Group by country: To find out how many tournaments each country hosted, we will group the results by the 'Country' column.", "Count the number of tournaments: We will use COUNT(*) to count the number of tournaments for each country.", "Order the results: We will order the results in descending order based on the count of tournaments to find the country with the most tournaments.", "Limit the results: We will limit the results to 1 to get only the country with the highest count."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country FROM competition WHERE Competition_type = 'tournament' GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the countries that hosted competitions of two specific types. The placeholders in the query represent the types of competitions being compared.\"\n}\n"}
{"sample_id": "train.3388", "db_id": "sports_competition", "question": "What are the countries that have never participated in any friendly-type competitions?", "rationale": ["Identify the countries that have hosted competitions.", "We need to exclude countries that have hosted friendly-type competitions.", "Use a subquery to find all Competition_IDs associated with friendly-type competitions.", "Select distinct countries from the competition table where the Competition_ID is not in the list of friendly competitions."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT Country FROM competition WHERE Competition_ID NOT IN (SELECT Competition_ID FROM competition WHERE Competition_type = 'friendly')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the countries where competitions were held, excluding those countries that hosted competitions of a specific type. The placeholder in the WHERE clause represents the type of competition to be excluded.\"\n}\n"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["Identify the required fields: full name (first and last name) and salary.", "To get the full name, concatenate the first name and last name using '||'.", "Filter the employees based on the salary condition (less than 6000).", "Construct the SQL SELECT statement to retrieve the desired fields from the 'employees' table."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, SALARY \nFROM employees \nWHERE SALARY < 6000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\"\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department ID.", "To create the full name, concatenate the FIRST_NAME and LAST_NAME fields with a space in between.", "Filter the employees to exclude those whose first name contains the letter 'M'.", "Use the WHERE clause with the NOT LIKE operator to apply the filter on the FIRST_NAME field."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\"\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter the employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by DEPARTMENT_ID.", "Construct the SQL SELECT statement with the identified fields, filtering condition, and ordering."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\"\n}\n"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["Identify the required fields: full name (concatenation of first and last name), hire date, salary, and department ID.", "Filter employees whose first name does not contain the letter 'M'.", "Use the 'employees' table to retrieve the necessary information.", "Order the results by department ID in ascending order."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\"\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The 'jobs' table contains job titles and salary information.", "Determine the condition: We need to find job titles where the maximum salary is greater than 9000.", "Construct the SQL query: Use a SELECT statement to retrieve the JOB_TITLE from the jobs table where the MAX_SALARY exceeds 9000."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE FROM jobs WHERE MAX_SALARY > 9000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\"\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The question asks for job titles and salary ranges, which are found in the 'jobs' table.", "Select the required columns: We need to select 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY' from the 'jobs' table.", "Apply the filter condition: We need to filter the results to include only those jobs where the 'MAX_SALARY' is between 12000 and 18000.", "Construct the SQL query: Combine the selected columns and the filter condition into a complete SQL query."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY \nFROM jobs \nWHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\"\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["We need to retrieve the employee IDs and the final dates of employment for each employee.", "The relevant tables are 'employees' and 'job_history'.", "We will join the 'employees' table with the 'job_history' table on the EMPLOYEE_ID column.", "To find the final date of employment, we need to select the maximum END_DATE for each employee from the job_history table.", "We will use a subquery to get the maximum END_DATE for each employee and filter the results accordingly."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT e.EMPLOYEE_ID, jh.END_DATE \nFROM employees e \nJOIN job_history jh ON e.EMPLOYEE_ID = jh.EMPLOYEE_ID \nWHERE jh.END_DATE = (SELECT MAX(END_DATE) \n                     FROM job_history \n                     WHERE EMPLOYEE_ID = e.EMPLOYEE_ID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\"\n}\n"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["Identify the tables needed: 'employees' for salary and commission percentage, and 'departments' for department names.", "Join the 'employees' table with the 'departments' table on the DEPARTMENT_ID to associate employees with their respective departments.", "Filter the employees to include only those who have a non-null COMMISSION_PCT, indicating they receive a commission.", "Group the results by department name to calculate the average salary for each department.", "Use the AVG() function to calculate the average salary of employees in each department who receive a commission."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_NAME, AVG(e.SALARY) AS average_salary\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nWHERE e.COMMISSION_PCT IS NOT NULL\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.\"\n}\n"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["Identify the table needed: The 'employees' table contains salary and commission percentage information.", "Determine the condition: We need to find employees with a non-null commission percentage, which is specified by the condition 'COMMISSION_PCT IS NOT NULL'.", "Calculate the average salary: Use the AVG() function to calculate the average of the 'SALARY' column for the filtered employees.", "Construct the SQL query: Combine the SELECT statement with the AVG function and the WHERE clause to filter the results."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT AVG(SALARY) AS average_salary\nFROM employees\nWHERE COMMISSION_PCT IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.\"\n}\n"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["Identify the required columns: COUNTRY_ID from countries and the count of cities from locations.", "To get the number of cities for each country, we need to join the countries table with the locations table on the COUNTRY_ID.", "Use the COUNT function to count the number of cities for each country.", "Group the results by COUNTRY_ID to ensure we get a count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT countries.COUNTRY_ID, COUNT(locations.CITY) AS number_of_cities\nFROM countries\nJOIN locations ON countries.COUNTRY_ID = locations.COUNTRY_ID\nGROUP BY countries.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["Identify the tables needed: 'countries' for country information and 'locations' for city information.", "Determine the relationship between the tables: 'locations' has a foreign key 'COUNTRY_ID' that links to 'countries'.", "Use a JOIN to combine 'countries' and 'locations' on 'COUNTRY_ID'.", "Count the number of cities (from 'locations') for each country (from 'countries').", "Group the results by 'COUNTRY_ID' to get the count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT c.COUNTRY_ID, COUNT(l.CITY) AS CITY_COUNT\nFROM countries c\nJOIN locations l ON c.COUNTRY_ID = l.COUNTRY_ID\nGROUP BY c.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["Identify the main requirement: to return all detailed info of jobs done by employees earning a salary of 12000 or more.", "The jobs table contains the detailed information about jobs, so we will select all columns from the jobs table.", "We need to filter the jobs based on the employees' salaries, so we will use a subquery to find the job IDs of employees earning 12000 or more.", "The subquery will select the JOB_ID from the employees table where the SALARY is greater than or equal to 12000.", "Finally, we will use the IN clause to filter the jobs based on the job IDs obtained from the subquery."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "pred_sql": "SELECT j.* FROM jobs j WHERE j.JOB_ID IN (SELECT e.JOB_ID FROM employees e WHERE e.SALARY >= 12000)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\"\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the requirement: We need to find all information regarding employees who are managers.", "To determine who the managers are, we can look for employees whose EMPLOYEE_ID appears in the MANAGER_ID field of the employees table.", "We will use a subquery to select all unique MANAGER_IDs from the employees table where MANAGER_ID is not null.", "The main query will then select all columns from the employees table where the EMPLOYEE_ID is in the list of MANAGER_IDs obtained from the subquery."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT * FROM employees WHERE EMPLOYEE_ID IN (SELECT MANAGER_ID FROM employees WHERE MANAGER_ID IS NOT NULL)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["Identify the relevant table: The 'employees' table contains information about employees and their respective departments and managers.", "Group the data: We need to group the results by 'DEPARTMENT_ID' and 'MANAGER_ID' to count the number of employees under each manager in each department.", "Count employees: Use the COUNT function to count the number of employees (EMPLOYEE_ID) in each department managed by a manager.", "Filter results: Use the HAVING clause to filter the groups to only include those where the count of employees is 4 or more."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DEPARTMENT_ID\nFROM employees\nGROUP BY DEPARTMENT_ID, MANAGER_ID\nHAVING COUNT(EMPLOYEE_ID) >= 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find distinct department IDs where a manager oversees 4 or more employees.", "To achieve this, we will use the 'employees' table, which contains information about employees and their respective departments and managers.", "We will group the results by 'DEPARTMENT_ID' and 'MANAGER_ID' to count the number of employees in each department managed by each manager.", "Using the HAVING clause, we will filter the groups to include only those where the count of employees is 4 or more."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DEPARTMENT_ID\nFROM employees\nGROUP BY DEPARTMENT_ID, MANAGER_ID\nHAVING COUNT(EMPLOYEE_ID) >= 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["Identify the table to query: The 'employees' table contains the information regarding employees and their salaries.", "Determine the conditions for filtering: We need employees with salaries above the minimum salary for their job and below 2500.", "Use a subquery to find the minimum salary for each employee's job: This is done by selecting from the 'jobs' table where the job ID matches the employee's job ID.", "Combine the conditions in the WHERE clause: The final query will select all columns from the 'employees' table where the salary is greater than the minimum salary from the 'jobs' table and less than 2500."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "pred_sql": "SELECT * FROM employees WHERE SALARY > (SELECT MIN_SALARY FROM jobs WHERE jobs.JOB_ID = employees.JOB_ID) AND SALARY < 2500;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\"\n}\n"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["Identify the requirement: We need the full names and hire dates of employees who work in the same department as an employee named Clara.", "To get the full names, we will concatenate the first and last names of the employees.", "We need to filter employees based on the department of Clara. This requires a subquery to find Clara's department ID.", "The subquery selects the DEPARTMENT_ID from the employees table where the FIRST_NAME is 'Clara'.", "The main query selects the FULL_NAME and HIRE_DATE from the employees table where the DEPARTMENT_ID matches the result of the subquery."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE \nFROM employees e \nWHERE e.DEPARTMENT_ID = (SELECT e2.DEPARTMENT_ID \n                         FROM employees e2 \n                         WHERE e2.FIRST_NAME = 'Clara');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\"\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the requirement to find full names and hire dates of employees in the same department as Clara.", "Use the employees table to get the required information: first name, last name, and hire date.", "To get the full name, concatenate the first name and last name with a space in between.", "Filter employees based on the department ID of Clara, which requires a subquery to find Clara's department ID.", "Exclude Clara from the results by adding a condition to ensure the first name is not Clara."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE \nFROM employees e \nWHERE e.DEPARTMENT_ID = (SELECT e2.DEPARTMENT_ID \n                         FROM employees e2 \n                         WHERE e2.FIRST_NAME = 'Clara') \nAND e.FIRST_NAME != 'Clara';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\"\n}\n"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["We need to display the employee number and name for employees who work in a department with any employee whose name contains a 'T'.", "To achieve this, we will select the EMPLOYEE_ID, FIRST_NAME, and LAST_NAME from the employees table.", "We will use a subquery to find the DEPARTMENT_IDs of employees whose FIRST_NAME or LAST_NAME contains the letter 'T'.", "The subquery will filter employees based on their names using the LIKE operator with '%T%'.", "Finally, we will use the IN clause to filter the main query based on the DEPARTMENT_IDs obtained from the subquery."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME \nFROM employees e \nWHERE e.DEPARTMENT_ID IN (\n    SELECT e2.DEPARTMENT_ID \n    FROM employees e2 \n    WHERE e2.FIRST_NAME LIKE '%T%' OR e2.LAST_NAME LIKE '%T%'\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\"\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the columns needed: EMPLOYEE_ID and JOB_ID from the employees table.", "Determine the condition for filtering: salary must be smaller than any salary of employees with the job title 'MK_MAN'.", "To find the salary of employees with the job title 'MK_MAN', a subquery is needed that selects the minimum salary from the employees table joined with the jobs table.", "The subquery filters employees based on the job title 'MK_MAN'.", "The main query selects the EMPLOYEE_ID and JOB_ID from the employees table where the salary is less than the result of the subquery."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID \nFROM employees \nWHERE SALARY < (SELECT MIN(SALARY) \n                  FROM employees e \n                  JOIN jobs j ON e.JOB_ID = j.JOB_ID \n                  WHERE j.JOB_TITLE = 'MK_MAN');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\"\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To do this, we will use the 'employees' table which contains the necessary information about employees and their salaries.", "We will use the SUM function to calculate the total salary for each department.", "We will group the results by DEPARTMENT_ID to get the total salary for each department.", "To filter departments with more than 2 employees, we will use the HAVING clause with COUNT(EMPLOYEE_ID) > 2."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT DEPARTMENT_ID, SUM(SALARY) AS TOTAL_SALARY \nFROM employees \nGROUP BY DEPARTMENT_ID \nHAVING COUNT(EMPLOYEE_ID) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\"\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To achieve this, we will select the DEPARTMENT_ID, concatenate FIRST_NAME and LAST_NAME to create FULL_NAME, and include SALARY from the employees table.", "To find the highest salary in each department, we will use a subquery that selects the DEPARTMENT_ID and the maximum SALARY, grouping by DEPARTMENT_ID.", "We will then filter the main query to only include those employees whose DEPARTMENT_ID and SALARY match the results of the subquery."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT DEPARTMENT_ID, FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, SALARY \nFROM employees \nWHERE (DEPARTMENT_ID, SALARY) IN \n    (SELECT DEPARTMENT_ID, MAX(SALARY) \n     FROM employees \n     GROUP BY DEPARTMENT_ID);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\"\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the relevant tables: employees, departments, and locations.", "We need to retrieve the full names of employees, which requires concatenating their first and last names.", "We also need the city of the employees, which is found in the locations table.", "To get the city, we need to join the employees table with the departments table (to get the department ID) and then with the locations table (to get the city based on the location ID).", "The condition specifies that we only want employees whose first names contain the letter 'Z', which can be checked using the LIKE operator with a wildcard."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, CITY \nFROM employees \nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID \nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID \nWHERE FIRST_NAME LIKE '%Z%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\"\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "We need to join these tables to get the employee's full name and the country they are currently working in.", "The employee's full name can be constructed by concatenating the FIRST_NAME and LAST_NAME from the employees table.", "To find the country, we need to join the employees table with the departments table on DEPARTMENT_ID, then join with the locations table on LOCATION_ID, and finally join with the countries table on COUNTRY_ID.", "The WHERE clause will filter the results to only include the employee with the specified EMPLOYEE_ID."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, c.COUNTRY_NAME \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE e.EMPLOYEE_ID = ?;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\"\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "To get the department name, we will select the 'DEPARTMENT_NAME' from the 'departments' table.", "To count the number of employees in each department, we will use the COUNT function on 'EMPLOYEE_ID' from the 'employees' table.", "We will join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' to link employees to their respective departments.", "We will use a LEFT JOIN to ensure that departments with no employees are still included in the results with a count of zero.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count of employees for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["We need to retrieve the department names and the count of employees in each department.", "The relevant tables are 'departments' for department names and 'employees' for employee information.", "We will perform a LEFT JOIN between 'departments' and 'employees' on the DEPARTMENT_ID to ensure we get all departments even if they have no employees.", "We will use COUNT(e.EMPLOYEE_ID) to count the number of employees in each department.", "Finally, we will group the results by department name to get the count for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS EMPLOYEE_COUNT\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\"\n}\n"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["We need to display the full name and salary of employees working in departments located in London.", "To get the full name, we will concatenate the first name and last name from the 'employees' table.", "We will join the 'employees' table with the 'departments' table on the DEPARTMENT_ID to get department information.", "Next, we will join the 'departments' table with the 'locations' table on the LOCATION_ID to access location details.", "Finally, we will filter the results to include only those records where the city is 'London'."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\"\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the relevant tables: employees, departments, and locations.", "We need to retrieve the full names and salaries of employees, so we will select FIRST_NAME, LAST_NAME, and SALARY from the employees table.", "To get the city information, we need to join the employees table with the departments table on DEPARTMENT_ID, and then join the departments table with the locations table on LOCATION_ID.", "We will filter the results to only include employees who work in the city of London by adding a WHERE clause that checks if the CITY column in the locations table is 'London'.", "The full name of the employee can be constructed by concatenating FIRST_NAME and LAST_NAME with a space in between."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\"\n}\n"}
{"sample_id": "train.3532", "db_id": "music_1", "question": "Find the id of the song that lasts the longest.", "rationale": ["Identify the table that contains the song information, which is the 'song' table.", "To find the song that lasts the longest, we need to look for the maximum duration in the 'duration' column of the 'song' table.", "We can use a subquery to find the maximum duration and then select the 'f_id' of the song that matches this maximum duration."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT f_id FROM song WHERE duration = (SELECT MAX(duration) FROM song);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\"\n}\n"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["Identify the table that contains the relevant information: the 'song' table has the artist names and song durations.", "To find the shortest song, we need to determine the minimum duration from the 'song' table.", "We can use a subquery to find the minimum duration and then select the artist names from the 'song' table where the duration matches this minimum value."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "pred_sql": "SELECT artist_name FROM song WHERE duration = (SELECT MIN(duration) FROM song)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["Identify the relevant table: The 'song' table contains the duration of songs.", "Determine the condition: We need to find songs with a duration of 4 minutes, which is represented as '4:00'.", "Construct the SQL query: Use the COUNT function to count the number of songs that meet the duration condition."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "pred_sql": "SELECT COUNT(*) AS song_count FROM song WHERE duration = '4:00';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\"\n}\n"}
{"sample_id": "train.3549", "db_id": "music_1", "question": "What is the average rating of songs produced by female artists?", "rationale": ["Identify the tables needed: We need the 'song' table to get the ratings of songs and the 'artist' table to filter by gender.", "Join the 'song' table with the 'artist' table on the 'artist_name' column to access both song ratings and artist gender.", "Filter the results to include only female artists by adding a WHERE clause that checks if the artist's gender is 'female'.", "Use the AVG() function to calculate the average rating of the songs produced by female artists."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "pred_sql": "SELECT AVG(s.rating) AS average_rating\nFROM song s\nJOIN artist a ON s.artist_name = a.artist_name\nWHERE a.gender = 'female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\"\n}\n"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["To find the file format used by the most files, we need to count the occurrences of each format in the 'files' table.", "We will use the COUNT() function to count the number of files for each format.", "We will group the results by the 'formats' column to aggregate the counts for each format.", "To get the format that is used the most, we will order the results in descending order based on the count of files.", "Finally, we will limit the results to 1 to get only the top format."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(*) as file_count \nFROM files \nGROUP BY formats \nORDER BY file_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\"\n}\n"}
{"sample_id": "train.3556", "db_id": "music_1", "question": "What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?", "rationale": ["Identify the table to query: The question asks about files, so we will query the 'files' table.", "Determine the conditions: We need to filter files that are in the 'mp4' format and have a resolution smaller than 1000.", "Use the WHERE clause: We will use 'WHERE formats LIKE '%mp4%'' to check for the mp4 format and 'CAST(resolution AS INTEGER) < 1000' to ensure the resolution is less than 1000.", "Select the required column: We need to select the 'f_id' column from the 'files' table that meets the above conditions."], "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"], "pred_sql": "SELECT f_id FROM files WHERE formats LIKE '%mp4%' AND CAST(resolution AS INTEGER) < 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\"\n}\n"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["Identify the relevant tables: 'artist' and 'song'.", "We need to find artists who are female and have produced songs in Bangla, so we will filter the 'artist' table by gender and the 'song' table by language.", "Join the 'artist' table with the 'song' table on the artist's name to combine the relevant information.", "Select the 'country' column from the 'artist' table as the output.", "Construct the SQL query using the SELECT statement, JOIN clause, and WHERE conditions."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE artist.gender = 'female' AND song.languages LIKE '%Bangla%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\"\n}\n"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["Identify the relevant tables: 'artist' and 'song'.", "We need to find female artists, so we will filter the 'artist' table by gender = 'female'.", "We need to find artists who have sung in the language Bangla, so we will filter the 'song' table by languages LIKE '%Bangla%'.", "Join the 'artist' table with the 'song' table on the artist's name to combine the relevant information.", "Select the distinct countries of the filtered female artists."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT DISTINCT artist.country \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE artist.gender = 'female' AND song.languages LIKE '%Bangla%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\"\n}\n"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["Identify the relevant tables: 'artist' and 'song'.", "We need to find the artist who sang the song with the smallest resolution, so we will join the 'artist' table with the 'song' table on the artist's name.", "To find the smallest resolution, we will use a subquery that selects the minimum resolution from the 'song' table.", "Finally, we will select the gender and name of the artist from the joined tables where the song's resolution matches the smallest resolution found."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.gender, artist.artist_name \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.resolution = (SELECT MIN(resolution) FROM song)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3567", "db_id": "music_1", "question": "For each file format, return the number of artists who released songs in that format.", "rationale": ["We need to count the number of distinct artists for each file format.", "The relevant tables are 'files' and 'song' since we need to access the file formats and the artists associated with the songs.", "We will join the 'files' table with the 'song' table on the 'f_id' column to link songs to their respective file formats.", "We will group the results by the 'formats' column to get the count of artists for each format.", "Finally, we will use COUNT(DISTINCT artist_name) to ensure we count each artist only once per format."], "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(DISTINCT artist_name) AS artist_count \nFROM files \nJOIN song ON files.f_id = song.f_id \nGROUP BY formats;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3576", "db_id": "music_1", "question": "What are the names and genders of all artists who released songs in the month of March?", "rationale": ["Identify the tables needed: We need information from the 'artist' table for names and genders, and from the 'song' table to filter by release date.", "Determine the relationship between the tables: The 'artist' table can be joined with the 'song' table on the 'artist_name' column.", "Filter the songs released in March: Use the strftime function to extract the month from the 'releasedate' column and check if it equals '03'.", "Select the required columns: We need to select 'artist_name' and 'gender' from the 'artist' table."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.gender \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE strftime('%m', song.releasedate) = '03';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["Identify the relevant table: The 'song' table contains the 'languages' column which is needed to answer the question.", "Count the occurrences of each language: Use COUNT(*) to count how many times each language appears in the songs.", "Group the results by language: Use GROUP BY languages to aggregate the counts for each unique language.", "Order the results: Use ORDER BY language_count DESC to sort the languages by their count in descending order, showing the most used languages first."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "pred_sql": "SELECT languages, COUNT(*) as language_count \nFROM song \nGROUP BY languages \nORDER BY language_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\"\n}\n"}
{"sample_id": "train.3590", "db_id": "music_1", "question": "What are the names of all male British artists?", "rationale": ["Identify the relevant table: The 'artist' table contains information about artists, including their country and gender.", "Determine the conditions: We need to filter artists who are from Britain and are male.", "Construct the SQL query: Use a SELECT statement to retrieve the 'artist_name' from the 'artist' table where the conditions are met."], "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"], "pred_sql": "SELECT artist_name FROM artist WHERE country = 'Britain' AND gender = 'male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3598", "db_id": "music_1", "question": "What is the average rating and resolution of all bangla songs?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "We need to calculate the average rating of songs, so we will use the AVG() function on the 'rating' column from the 'song' table.", "We also need the resolution of the songs, which is found in the 'files' table, so we will select the 'resolution' column.", "To get the average rating and resolution for Bangla songs, we will filter the results using a WHERE clause on the 'genre_is' column in the 'song' table to only include 'Bangla'.", "We will join the 'song' table with the 'files' table on the 'f_id' column to access the resolution of the songs.", "Finally, we will select the average rating and the maximum resolution (as a representative resolution) for the Bangla songs."], "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"], "pred_sql": "SELECT AVG(s.rating) AS average_rating, MAX(f.resolution) AS max_resolution\nFROM song s\nJOIN files f ON s.f_id = f.f_id\nWHERE s.genre_is = 'Bangla';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\"\n}\n"}
{"sample_id": "train.3599", "db_id": "music_1", "question": "What are the maximum and minimum resolution of songs whose duration is 3 minutes?", "rationale": ["Identify the requirement: We need to find the maximum and minimum resolution of songs with a specific duration (3 minutes).", "Determine the relevant table: The 'song' table contains the resolution and duration of songs.", "Formulate the SQL query: We will use the MAX() and MIN() functions to get the maximum and minimum resolution respectively, and filter the results using a WHERE clause to specify the duration as '3 minutes'.", "Construct the final SQL query to select the maximum and minimum resolution from the 'song' table where the duration is '3 minutes'."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "pred_sql": "SELECT MAX(resolution) AS max_resolution, MIN(resolution) AS min_resolution \nFROM song \nWHERE duration = '3 minutes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\"\n}\n"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["Identify the columns needed: languages, maximum duration, and maximum resolution.", "Use the MAX() function to get the maximum values for duration and resolution.", "Group the results by languages to aggregate the data accordingly.", "Order the results by languages for better readability."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "pred_sql": "SELECT languages, MAX(duration) AS max_duration, MAX(resolution) AS max_resolution\nFROM song\nGROUP BY languages\nORDER BY languages;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\"\n}\n"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["Identify the relevant tables: 'song' and 'files' are needed to get song ratings and durations.", "Use the MIN() function to find the shortest duration and lowest rating for songs.", "Join the 'song' table with the 'files' table on the foreign key 'f_id' to access both duration and rating.", "Group the results by genre using GROUP BY on 'song.genre_is'.", "Order the results by genre using ORDER BY on 'song.genre_is'."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "pred_sql": "SELECT song.genre_is, MIN(files.duration) AS shortest_duration, MIN(song.rating) AS lowest_rating \nFROM song \nJOIN files ON song.f_id = files.f_id \nGROUP BY song.genre_is \nORDER BY song.genre_is;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\"\n}\n"}
{"sample_id": "train.3607", "db_id": "music_1", "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "rationale": ["Identify the tables involved: 'artist' and 'song'.", "We need to find artists who have released songs with a resolution greater than 900.", "Join the 'artist' table with the 'song' table on the 'artist_name' column to link artists with their songs.", "Use a WHERE clause to filter songs based on the resolution condition (> 900).", "Select the distinct artist names and their countries to avoid duplicates."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"], "pred_sql": "SELECT DISTINCT artist.artist_name, artist.country \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.resolution > 900;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.3619", "db_id": "music_1", "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.", "rationale": ["Identify the tables involved: 'artist' and 'song'.", "We need to find artists who have songs in the Bangla language, so we will filter the 'song' table based on the 'languages' column.", "Join the 'artist' table with the 'song' table on the 'artist_name' column to associate artists with their songs.", "Count the number of songs for each artist that meet the language criteria using COUNT() function.", "Group the results by artist name to aggregate the song counts for each artist.", "Order the results by the song count in descending order to get the top artists.", "Limit the results to the top 3 artists."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, COUNT(song.song_name) AS song_count\nFROM artist\nJOIN song ON artist.artist_name = song.artist_name\nWHERE song.languages LIKE '%Bangla%'\nGROUP BY artist.artist_name\nORDER BY song_count DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\"\n}\n"}
{"sample_id": "train.3623", "db_id": "music_1", "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?", "rationale": ["Identify the relevant tables: 'song' and 'files' are needed to get the duration, file size, and format of the songs.", "Determine the columns to select: We need 'duration' from the 'song' table, and 'file_size' and 'formats' from the 'files' table.", "Establish the relationship between the tables: The 'song' table is linked to the 'files' table through the 'f_id' column.", "Apply the filter for the genre: We need to filter the results to include only those songs where the genre is 'pop'.", "Order the results: The final output should be ordered by the song title, which corresponds to the 'song_name' column in the 'song' table."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT song.duration, files.file_size, files.formats \nFROM song \nJOIN files ON song.f_id = files.f_id \nWHERE song.genre_is = 'pop' \nORDER BY song.song_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\"\n}\n"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["Identify the required columns: duration, file size, and song format.", "Determine the relevant tables: song and files.", "Establish the relationship between the tables using the foreign key: song.f_id = files.f_id.", "Filter the results to include only pop songs by using the WHERE clause: song.genre_is = 'pop'.", "Order the results alphabetically by song title using ORDER BY clause: ORDER BY song.song_name ASC."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT song.duration, files.file_size, files.formats \nFROM song \nJOIN files ON song.f_id = files.f_id \nWHERE song.genre_is = 'pop' \nORDER BY song.song_name ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\"\n}\n"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["Identify the relevant tables: 'salary' for salary records and 'team' for team names.", "Join the 'salary' table with the 'team' table on 'team_id' to associate salaries with the correct team.", "Filter the results to include only the team named 'Boston Red Stockings'.", "Use the AVG() function to calculate the average salary of the players in that team."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "pred_sql": "SELECT AVG(s.salary) AS average_salary\nFROM salary s\nJOIN team t ON s.team_id = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their birth countries.", "Select the 'birth_country' column and count the number of players from each country using COUNT(player_id).", "Group the results by 'birth_country' to aggregate the player counts for each country.", "Order the results in ascending order based on the player count to find the countries with the least players.", "Limit the results to the top 3 countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["We need to find the highest salary for each team, which requires us to aggregate salary data by team.", "The relevant tables for this query are 'salary' for salary information and 'team' for team details.", "We will join the 'salary' table with the 'team' table on the 'team_id' to get the team names along with their salaries.", "To get the maximum salary for each team, we will use the MAX() function and group the results by team ID and name.", "The final output should include the team name, team ID, and the maximum salary."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nGROUP BY team.team_id, team.name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3658", "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["We need to retrieve the team name, team id, and the maximum salary for each team.", "The relevant tables for this query are 'team' and 'salary'.", "We will join the 'team' table with the 'salary' table on the 'team_id' column to associate each salary with the corresponding team.", "To find the maximum salary for each team, we will use the MAX() function on the 'salary' column from the 'salary' table.", "We will group the results by 'team.team_id' and 'team.name' to ensure we get the maximum salary for each team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM team\nJOIN salary ON team.team_id = salary.team_id\nGROUP BY team.team_id, team.name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["We need to find the team with the lowest average salary.", "To do this, we will join the 'salary' table with the 'team' table using the 'team_id' as the common key.", "We will group the results by 'team_id' to calculate the average salary for each team.", "Next, we will order the results by the average salary in ascending order to get the team with the lowest average salary at the top.", "Finally, we will limit the results to only one entry to get the team with the lowest average salary."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nGROUP BY team.team_id\nORDER BY AVG(salary.salary) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["We need to find players who won awards in both 1960 and 1961.", "To do this, we will use the player_award table, which contains information about players and the awards they received.", "We will join the player_award table to itself (pa1 and pa2) on the player_id to find players who have entries for both years.", "We will also join the player table to get the first and last names of the players.", "Finally, we will filter the results to only include those who won awards in 1960 and 1961 using the WHERE clause."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.name_first, p.name_last\nFROM player_award pa1\nJOIN player_award pa2 ON pa1.player_id = pa2.player_id\nJOIN player p ON pa1.player_id = p.player_id\nWHERE pa1.year = 1960 AND pa2.year = 1961;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\"\n}\n"}
{"sample_id": "train.3663", "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["Identify the relevant table: The 'player' table contains the first name, last name, weight, and height of players.", "Determine the columns to select: We need to select 'name_given' for the first name and 'name_last' for the last name.", "Establish the conditions: We want players with a weight greater than 220 or a height shorter than 75.", "Construct the SQL query: Use a SELECT statement to retrieve the names from the 'player' table with the specified conditions in the WHERE clause."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_given, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\"\n}\n"}
{"sample_id": "train.3664", "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["Identify the relevant table: The 'player' table contains the information about players including their names, weight, and height.", "Determine the columns needed: We need the first name (name_given) and last name (name_last) of the players.", "Set the conditions: We want players who have a weight greater than 220 or a height less than 75.", "Construct the SQL query: Use a SELECT statement to retrieve the required columns from the 'player' table with the specified conditions in the WHERE clause."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_given, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\"\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) of the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include the Boston Red Stockings.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings'", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) for the team Boston Red Stockings in the postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include the Boston Red Stockings.", "Use the MAX function to get the maximum wins for this team."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings'", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\"\n}\n"}
