{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["We need to find the IDs of students who have attended courses.", "The relevant table for attendance is 'Student_Course_Attendance', which contains the 'student_id' of students who attended courses.", "To get unique student IDs, we will use the DISTINCT keyword to avoid duplicates in the results."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.68", "db_id": "student_assessment", "question": "What details do we have on the students who registered for courses most recently?", "rationale": ["Identify the relevant tables: Students, Student_Course_Registrations, and Courses.", "Join the Students table with the Student_Course_Registrations table to link students to their course registrations.", "Join the result with the Courses table to retrieve course names associated with the registrations.", "Select the necessary details: student ID, student details, registration date, and course name.", "Order the results by registration date in descending order to get the most recent registrations first.", "Limit the results to a reasonable number (e.g., 10) to focus on the most recent registrations."], "gold_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT s.student_id, s.student_details, scr.registration_date, c.course_name \nFROM Students s \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nJOIN Courses c ON scr.course_id = c.course_id \nORDER BY scr.registration_date DESC \nLIMIT 10;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["Identify the relevant tables: Candidates, Student_Course_Attendance, and Student_Course_Registrations.", "Join the Candidates table with Student_Course_Attendance on candidate_id and student_id to link candidates with their course attendance.", "Join the result with Student_Course_Registrations to ensure we are looking at the correct course registrations.", "Order the results by date_of_attendance in descending order to get the most recent attendance first.", "Limit the results to 1 to get only the most recent candidate who accessed the course."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT DISTINCT c.candidate_id\nFROM Candidates c\nJOIN Student_Course_Attendance sca ON c.candidate_id = sca.student_id\nJOIN Student_Course_Registrations scr ON sca.student_id = scr.student_id AND sca.course_id = scr.course_id\nORDER BY sca.date_of_attendance DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.78", "db_id": "student_assessment", "question": "What are the details of the student who registered for the most number of courses?", "rationale": ["Identify the relevant tables: Students and Student_Course_Registrations.", "Join the Students table with the Student_Course_Registrations table to link students to their course registrations.", "Group the results by student_id to count the number of courses each student is registered for.", "Order the results in descending order based on the count of registered courses to find the student with the most registrations.", "Limit the results to 1 to get only the student with the highest number of course registrations."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT s.student_id, s.student_details \nFROM Students s \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nGROUP BY s.student_id \nORDER BY COUNT(scr.course_id) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["We need to retrieve the course ID and course names along with the count of registered students for each course.", "To achieve this, we will select the 'course_id' and 'course_name' from the 'Courses' table.", "We will also count the number of students registered for each course using the COUNT function on 'student_id' from the 'Student_Course_Registrations' table.", "To link the courses with their registrations, we will perform a LEFT JOIN between the 'Courses' table and the 'Student_Course_Registrations' table on the 'course_id'.", "Finally, we will group the results by 'course_id' and 'course_name' to get the count of students for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT Courses.course_id, Courses.course_name, COUNT(Student_Course_Registrations.student_id) AS student_count\nFROM Courses\nLEFT JOIN Student_Course_Registrations ON Courses.course_id = Student_Course_Registrations.course_id\nGROUP BY Courses.course_id, Courses.course_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.89", "db_id": "student_assessment", "question": "What is the id of the student who most recently registered course 301?", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Filter the records to only include those where the 'course_id' is '301'.", "Order the results by 'registration_date' in descending order to get the most recent registration first.", "Limit the results to 1 to get only the most recent student who registered for the course."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.92", "db_id": "student_assessment", "question": "What are the different cities where people live?", "rationale": ["We need to find the unique cities where people live.", "To do this, we will join the 'Addresses' table with the 'People_Addresses' table to link addresses to people.", "Next, we will join the 'Students' table to ensure we are only considering addresses associated with students.", "Finally, we will select distinct cities from the resulting joined table to avoid duplicates."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id", "source_tables": ["addresses", "people_addresses"], "pred_sql": "SELECT DISTINCT Addresses.city FROM Addresses JOIN People_Addresses ON Addresses.address_id = People_Addresses.address_id JOIN Students ON People_Addresses.person_id = Students.student_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique cities where students are located, by joining the 'Addresses', 'People_Addresses', and 'Students' tables. The placeholders in the query represent the necessary identifiers for the relationships between these tables.\"\n}\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant tables: Students, Student_Course_Registrations, and Courses.", "Join the Students table with the Student_Course_Registrations table to link students to their course registrations.", "Join the result with the Courses table to filter for the course named 'Statistics'.", "Select the student_id from the Students table.", "Order the results by the registration_date from the Student_Course_Registrations table."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT s.student_id \nFROM Students s \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nJOIN Courses c ON scr.course_id = c.course_id \nWHERE c.course_name = 'Statistics' \nORDER BY scr.registration_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant tables: Students, Student_Course_Registrations, and Courses.", "Join the Students table with the Student_Course_Registrations table to link students to their course registrations.", "Join the result with the Courses table to filter for the course named 'Statistics'.", "Select the student_id from the resulting joined table.", "Order the results by the registration_date to get the ids in the order of registration."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT s.student_id \nFROM Students s \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nJOIN Courses c ON scr.course_id = c.course_id \nWHERE c.course_name = 'Statistics' \nORDER BY scr.registration_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\"\n}\n"}
{"sample_id": "train.387", "db_id": "flight_1", "question": "Show origins of all flights with destination Honolulu.", "rationale": ["Identify the table that contains the relevant information: the 'flight' table.", "Determine the columns needed: we need the 'origin' column for the flights.", "Specify the condition: we want flights where the 'destination' is 'Honolulu'.", "Construct the SQL query using the SELECT statement to retrieve the 'origin' from the 'flight' table with the specified condition."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight WHERE destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the required columns: We need the 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We want flights that depart from 'LA' and arrive in 'Honolulu'.", "Construct the SQL query using SELECT to retrieve the specified columns from the 'flight' table with the appropriate WHERE clause."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.400", "db_id": "flight_1", "question": "What are the numbers of the shortest flights?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their distances.", "Determine the requirement: The user wants to find the shortest flights, which means we need to sort the flights by distance.", "Construct the SQL query: We will select the flight number (flno) from the flight table, order the results by distance in ascending order, and limit the results to the shortest flight."], "gold_sql": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT 3", "source_tables": ["flight"], "pred_sql": "SELECT flno FROM flight ORDER BY distance ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.408", "db_id": "flight_1", "question": "What place has the most flights coming from there?", "rationale": ["Identify the table that contains flight information, which is the 'flight' table.", "We need to find the place with the most flights coming from there, which means we need to count the number of flights grouped by their origin.", "Use the COUNT() function to count the number of flights for each origin.", "Group the results by the 'origin' column to aggregate the flight counts.", "Order the results in descending order based on the flight count to get the place with the most flights at the top.", "Limit the results to 1 to get only the top place."], "gold_sql": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "pred_sql": "SELECT origin, COUNT(*) AS flight_count \nFROM flight \nGROUP BY origin \nORDER BY flight_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables needed: 'aircraft' for aircraft names and 'flight' for flight counts.", "Use a LEFT JOIN to connect 'aircraft' and 'flight' on the aircraft ID (aid) since we want to include all aircraft even if they have no flights.", "Select the aircraft name and count the number of flights (flno) associated with each aircraft.", "Group the results by aircraft name to get the count of flights for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT aircraft.name, COUNT(flight.flno) AS flight_count\nFROM aircraft\nLEFT JOIN flight ON aircraft.aid = flight.aid\nGROUP BY aircraft.name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.429", "db_id": "flight_1", "question": "Show names for all employees who do not have certificate of Boeing 737-800.", "rationale": ["Identify the main table to query from, which is the 'employee' table to get employee names.", "We need to find employees who do not have a certificate for the Boeing 737-800.", "To do this, we will use a subquery to find all employee IDs (eid) that have a certificate for the Boeing 737-800.", "The subquery will first find the aircraft ID (aid) for the Boeing 737-800 from the 'aircraft' table.", "Then, we will use this aircraft ID to find all employee IDs from the 'certificate' table who hold a certificate for that aircraft.", "Finally, we will select names from the 'employee' table where the employee ID is not in the list of IDs returned by the subquery."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT name FROM employee WHERE eid NOT IN (SELECT eid FROM certificate WHERE aid IN (SELECT aid FROM aircraft WHERE name = 'Boeing 737-800'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\"\n}\n"}
{"sample_id": "train.433", "db_id": "flight_1", "question": "Show the name and distance of the aircrafts with more than 5000 distance and which at least 5 people have its certificate.", "rationale": ["Identify the relevant tables: 'aircraft' for aircraft details and 'certificate' for certification details.", "We need to select the 'name' and 'distance' from the 'aircraft' table.", "We need to filter aircrafts with a distance greater than 5000.", "We need to join the 'aircraft' table with the 'certificate' table on the aircraft ID ('aid').", "We will group the results by aircraft ID to count the number of certificates associated with each aircraft.", "Finally, we will use the HAVING clause to filter groups that have at least 5 certificates."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name, a.distance \nFROM aircraft a \nJOIN certificate c ON a.aid = c.aid \nWHERE a.distance > 5000 \nGROUP BY a.aid \nHAVING COUNT(c.eid) >= 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.434", "db_id": "flight_1", "question": "What is the name and distance of every aircraft that can cover a distance of more than 5000 and which at least 5 people can fly?", "rationale": ["Identify the relevant table: 'aircraft' contains the information about aircraft names and their distances.", "Determine the condition: we need aircraft that can cover a distance of more than 5000.", "Construct the SQL query to select the 'name' and 'distance' columns from the 'aircraft' table where the 'distance' is greater than 5000."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT name, distance FROM aircraft WHERE distance > 5000", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.437", "db_id": "flight_1", "question": "What is the salary and name of the employee who has the most number of certificates on aircrafts with distance more than 5000?", "rationale": ["Identify the relevant tables: employee, certificate, and aircraft.", "We need to find employees who hold certificates for aircraft with a distance greater than 5000.", "Join the employee table with the certificate table on employee ID (eid) and then join with the aircraft table on aircraft ID (aid).", "Filter the results to include only those aircraft where the distance is greater than 5000.", "Group the results by employee ID to count the number of certificates each employee holds.", "Order the results by the count of certificates in descending order to find the employee with the most certificates.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.name, e.salary\nFROM employee e\nJOIN certificate c ON e.eid = c.eid\nJOIN aircraft a ON c.aid = a.aid\nWHERE a.distance > 5000\nGROUP BY e.eid\nORDER BY COUNT(c.aid) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The question asks for all the different food allergies.", "To find different allergies, we need to select distinct values from the Allergy column in the Allergy_Type table.", "The SQL query will use the SELECT statement with DISTINCT to ensure that we get unique allergy names."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Allergy_Type;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\"\n}\n"}
{"sample_id": "train.456", "db_id": "allergy_1", "question": "Which allergy type is most common?", "rationale": ["Identify the relevant tables: We need to find the most common allergy type, which involves the Allergy_Type and Has_Allergy tables.", "Join the tables: We will join the Has_Allergy table with the Allergy_Type table on the Allergy column to get the allergy types associated with each allergy.", "Group by allergy type: We will group the results by AllergyType to count how many students have each type of allergy.", "Count the occurrences: Use COUNT(*) to count the number of students for each allergy type.", "Order the results: We will order the results in descending order based on the count of students to find the most common allergy type.", "Limit the results: Finally, we will limit the results to 1 to get only the most common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(*) as AllergyCount \nFROM Has_Allergy \nJOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy \nGROUP BY AllergyType \nORDER BY AllergyCount DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\"\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["We need to find the least common allergy type.", "To do this, we will count the occurrences of each allergy type.", "We will join the Has_Allergy table with the Allergy_Type table to get the allergy types associated with each allergy.", "We will group the results by AllergyType to get the count of each type.", "Finally, we will order the results by the count in ascending order and limit the result to 1 to get the least common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(*) AS AllergyCount\nFROM Has_Allergy\nJOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy\nGROUP BY AllergyType\nORDER BY AllergyCount ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\"\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student names, which is the 'Student' table.", "To get the full names, we need to concatenate the 'Fname' and 'LName' columns.", "Use the SQL SELECT statement to retrieve the concatenated names as 'FullName'."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName FROM Student;", "hint": "\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the relevant table: The 'Student' table contains the information about students, including their gender.", "Determine the condition: We need to filter the students based on their gender, specifically looking for male students.", "Construct the SQL query: We will select the 'StuID' from the 'Student' table where the 'Sex' column is equal to 'Male'."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\"\n}\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the major information, which is the 'Student' table.", "To find the largest major, we need to count the number of students in each major.", "We will use the COUNT function to count the number of students for each major.", "We will group the results by the 'Major' column to get the count for each major.", "To find the largest major, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.501", "db_id": "allergy_1", "question": "Which advisor has most number of students?", "rationale": ["Identify the relevant table: The 'Student' table contains the 'Advisor' and 'StuID' columns.", "Count the number of students for each advisor: Use COUNT(StuID) to count the number of students associated with each advisor.", "Group the results by advisor: Use GROUP BY Advisor to aggregate the counts for each advisor.", "Order the results to find the advisor with the most students: Use ORDER BY StudentCount DESC to sort the counts in descending order.", "Limit the results to the top advisor: Use LIMIT 1 to get only the advisor with the highest count."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(StuID) AS StudentCount\nFROM Student\nGROUP BY Advisor\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the relevant tables: We need to find students with cat allergies, so we will use the Has_Allergy table.", "Count the number of unique students affected by cat allergies: We will use COUNT(DISTINCT StuID) to ensure we count each student only once.", "Filter the results to only include cat allergies: We will add a WHERE clause to specify that we are only interested in records where the Allergy is 'cat'.", "Construct the SQL query: Combine the SELECT statement with the COUNT function and the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(DISTINCT Has_Allergy.StuID) AS affected_students\nFROM Has_Allergy\nWHERE Has_Allergy.Allergy = 'cat';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\"\n}\n"}
{"sample_id": "train.508", "db_id": "allergy_1", "question": "Which students are unaffected by allergies?", "rationale": ["Identify the main table to query from, which is the Student table.", "To find students unaffected by allergies, we need to exclude those who have any allergies listed in the Has_Allergy table.", "We can achieve this by using a subquery that selects all StuID from the Has_Allergy table.", "The main query will select all columns from the Student table where the StuID is not in the list of StuIDs returned by the subquery."], "gold_sql": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT * FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\"\n}\n"}
{"sample_id": "train.509", "db_id": "allergy_1", "question": "How many female students have milk or egg allergies?", "rationale": ["Identify the relevant tables: Student, Has_Allergy, and Allergy_Type.", "We need to count the number of female students, so we will filter the Student table by Sex = 'Female'.", "We need to find students with specific allergies (Milk or Egg), so we will join the Has_Allergy table with the Allergy_Type table to filter by these allergies.", "The join condition will be based on the StuID in the Student and Has_Allergy tables, and the Allergy in the Has_Allergy and Allergy_Type tables.", "Finally, we will count the distinct StuID from the Student table that meet the criteria of being female and having either a Milk or Egg allergy."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nJOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy \nWHERE Student.Sex = 'Female' \nAND (Allergy_Type.Allergy = 'Milk' OR Allergy_Type.Allergy = 'Egg');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\"\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the relevant tables: Student and Has_Allergy.", "We need to count the number of female students with specific allergies (milk or eggs).", "Use a JOIN to connect the Student table with the Has_Allergy table on StuID.", "Filter the results to include only female students by adding a condition for the Sex column.", "Add a condition to filter allergies to include only 'Milk' or 'Eggs'.", "Use COUNT(DISTINCT Student.StuID) to get the number of unique female students with these allergies."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Student.Sex = 'Female' \nAND Has_Allergy.Allergy IN ('Milk', 'Eggs');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\"\n}\n"}
{"sample_id": "train.513", "db_id": "allergy_1", "question": "Which allergy has most number of students affected?", "rationale": ["We need to find out which allergy has the most number of students affected.", "To do this, we will count the number of students (StuID) for each allergy in the Has_Allergy table.", "We will use the COUNT function to count the number of occurrences of each allergy.", "We will group the results by the Allergy column to get the count for each allergy type.", "To find the allergy with the most students, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to just one record to get the allergy with the highest count."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT Allergy, COUNT(StuID) AS StudentCount\nFROM Has_Allergy\nGROUP BY Allergy\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\"\n}\n"}
{"sample_id": "train.518", "db_id": "allergy_1", "question": "How many students are affected by each allergy type?", "rationale": ["Identify the tables involved: Allergy_Type, Has_Allergy, and Student.", "We need to count the number of students affected by each allergy type, so we will use COUNT() function.", "Join the Allergy_Type table with Has_Allergy on the Allergy column to link allergies to students.", "Then, join the Has_Allergy table with the Student table on the StuID to get student details.", "Group the results by AllergyType to get the count of distinct students for each allergy type."], "gold_sql": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype", "source_tables": ["has_allergy", "allergy_type"], "pred_sql": "SELECT at.AllergyType, COUNT(DISTINCT s.StuID) AS StudentCount\nFROM Allergy_Type at\nJOIN Has_Allergy ha ON at.Allergy = ha.Allergy\nJOIN Student s ON ha.StuID = s.StuID\nGROUP BY at.AllergyType;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\"\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the tables needed: We need to retrieve student information (last names and ages) and their allergies, so we will use the Student and Has_Allergy tables.", "Determine the join condition: The Has_Allergy table has a foreign key relationship with the Student table through StuID, so we will join these tables on StuID.", "Specify the columns to select: We need to select the last names (LName) and ages (Age) of the students.", "Filter the results: We want students who are allergic to both 'milk' and 'cat', so we will use a WHERE clause with the IN operator to filter allergies.", "Group the results: Since we want students with both allergies, we will group by StuID and use HAVING to ensure that the count of distinct allergies is 2."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Student.LName, Student.Age \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat') \nGROUP BY Student.StuID \nHAVING COUNT(DISTINCT Has_Allergy.Allergy) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\"\n}\n"}
{"sample_id": "train.522", "db_id": "allergy_1", "question": "What are the allergies the girl named Lisa has? And what are the types of them? Order the result by allergy names.", "rationale": ["Identify the relevant tables: Student, Has_Allergy, and Allergy_Type.", "We need to find allergies for a student named Lisa, so we will filter the Student table by first name (Fname) and gender (Sex).", "Join the Has_Allergy table to link students with their allergies using StuID.", "Join the Allergy_Type table to get the type of each allergy using the Allergy name.", "Select the Allergy and AllergyType columns from the Allergy_Type table.", "Order the results by the Allergy names."], "gold_sql": "SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  'Lisa' ORDER BY T1.Allergy", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT a.Allergy, a.AllergyType \nFROM Student s \nJOIN Has_Allergy ha ON s.StuID = ha.StuID \nJOIN Allergy_Type a ON ha.Allergy = a.Allergy \nWHERE s.Fname = 'Lisa' AND s.Sex = 'Female' \nORDER BY a.Allergy;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\"\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["We need to find the average age of students with specific types of allergies, which are 'food' and 'animal'.", "To do this, we will join the three tables: Student, Has_Allergy, and Allergy_Type.", "The join between Student and Has_Allergy is done on the StuID column, which is common in both tables.", "Next, we join Has_Allergy with Allergy_Type on the Allergy column to filter by allergy types.", "We will use a WHERE clause to filter the results to only include allergies of type 'food' and 'animal'.", "Finally, we will use the AVG() function to calculate the average age of the filtered students."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT AVG(Student.Age) AS Average_Age\nFROM Student\nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID\nJOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy\nWHERE Allergy_Type.AllergyType IN ('food', 'animal');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\"\n}\n"}
{"sample_id": "train.527", "db_id": "allergy_1", "question": "List the first and last name of the students who do not have any food type allergy.", "rationale": ["Identify the tables involved: Student, Has_Allergy, and Allergy_Type.", "We need to select the first and last names of students, which are in the Student table.", "To find students without food allergies, we need to filter out those who have a food allergy.", "We can use a subquery to find all StuIDs of students who have a food allergy by joining Has_Allergy and Allergy_Type tables.", "The subquery will select StuIDs where the AllergyType is 'food'.", "The main query will select Fname and LName from the Student table where the StuID is not in the list of StuIDs returned by the subquery."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname, LName \nFROM Student \nWHERE StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    JOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy \n    WHERE AllergyType = 'food'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\"\n}\n"}
{"sample_id": "train.529", "db_id": "allergy_1", "question": "Find the number of male (sex is 'M') students who have some food type allery.", "rationale": ["Identify the tables needed: Student, Has_Allergy, and Allergy_Type.", "We need to count the number of male students, so we will filter the Student table by Sex = 'M'.", "We need to find students with food allergies, so we will join the Has_Allergy table with the Allergy_Type table and filter by AllergyType = 'food'.", "Use JOIN to connect the tables based on the foreign key relationships: Has_Allergy.StuID with Student.StuID and Has_Allergy.Allergy with Allergy_Type.Allergy.", "Count the distinct student IDs to avoid counting the same student multiple times if they have multiple food allergies."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nJOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy \nWHERE Student.Sex = 'M' AND Allergy_Type.AllergyType = 'food';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\"\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables involved: Student and Has_Allergy.", "We need to find students with specific allergies, so we will join the Student table with the Has_Allergy table on the StuID column.", "We are interested in the first names and city codes of students, so we will select Student.Fname and Student.city_code.", "The condition specifies that we are looking for students who have allergies to either 'milk' or 'cat', which can be expressed using the IN clause in the WHERE statement.", "Use DISTINCT to ensure that we only get unique combinations of first names and city codes."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT Student.Fname, Student.city_code \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\"\n}\n"}
{"sample_id": "train.533", "db_id": "allergy_1", "question": "Find the number of students who are older than 18 and do not have allergy to either food or animal.", "rationale": ["Identify the main table to query from, which is the 'Student' table.", "We need to count the number of students, so we will use COUNT(*) in the SELECT statement.", "We need to filter students who are older than 18, so we will add a WHERE clause with the condition 's.Age > 18'.", "We need to check for students who do not have allergies to either food or animal. This requires joining the 'Has_Allergy' table to the 'Student' table and then joining the 'Allergy_Type' table to get the allergy types.", "To ensure we include students without any allergies, we will use a LEFT JOIN on the 'Has_Allergy' table and the 'Allergy_Type' table.", "In the WHERE clause, we will check that the allergy type is either NULL (indicating no allergies) or not in the list of 'food' and 'animal'.", "Combine all these conditions to form the final SQL query."], "gold_sql": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' OR T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT COUNT(*) \nFROM Student s \nLEFT JOIN Has_Allergy ha ON s.StuID = ha.StuID \nLEFT JOIN Allergy_Type at ON ha.Allergy = at.Allergy \nWHERE s.Age > 18 \nAND (at.AllergyType IS NULL OR at.AllergyType NOT IN ('food', 'animal'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\"\n}\n"}
{"sample_id": "train.535", "db_id": "allergy_1", "question": "Find the first name and major of the students who are not allegry to soy.", "rationale": ["Identify the required fields: first name (Fname) and major from the Student table.", "Determine the condition: we need students who do not have an allergy to soy.", "To find students without the soy allergy, we can use a subquery that selects StuID from the Has_Allergy table where the Allergy is 'soy'.", "Use the NOT IN clause to filter out those students from the main query that selects from the Student table."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Major \nFROM Student \nWHERE StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'soy'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\"\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["Identify the relevant table: The invoices table contains the billing country and total amount of each invoice.", "Select the required columns: We need to select the billing_country and the average of the total column.", "Group the results: To calculate the average invoice size per country, we will group the results by billing_country.", "Calculate the average: Use the AVG() function to compute the average total for each country.", "Order the results: To get the top countries by average invoice size, we will order the results in descending order based on the average invoice size.", "Limit the results: Finally, we will limit the results to the top 10 countries."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size\nFROM invoices\nGROUP BY billing_country\nORDER BY average_invoice_size DESC\nLIMIT 10;", "hint": "\n"}
{"sample_id": "train.553", "db_id": "store_1", "question": "List every album ordered by album title in ascending order.", "rationale": ["Identify the table that contains album information, which is the 'albums' table.", "Determine the column that contains the album titles, which is 'title'.", "Specify that we want to select the 'title' column from the 'albums' table.", "To meet the requirement of ordering the albums by title in ascending order, use the ORDER BY clause with 'title ASC'."], "gold_sql": "SELECT title FROM albums ORDER BY title;", "source_tables": ["albums"], "pred_sql": "SELECT title FROM albums ORDER BY title ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tracks from the 'tracks' table that have been purchased by customers with a specific first and last name. The placeholders in the WHERE clause represent the customer's first and last names.\"\n}\n"}
{"sample_id": "train.560", "db_id": "store_1", "question": "What are the total amount of money in the invoices billed from Chicago, Illinois?", "rationale": ["Identify the relevant table: invoices, as it contains billing information and total amounts.", "Determine the columns needed: total (for the amount) and billing_city, billing_state (for filtering).", "Formulate the SQL query to sum the total amounts from invoices where the billing city is 'Chicago' and the billing state is 'Illinois'.", "Use the SUM() function to calculate the total amount and apply the WHERE clause to filter the results accordingly."], "gold_sql": "SELECT sum(total) FROM invoices WHERE billing_city  =  'Chicago' AND billing_state  =  'IL';", "source_tables": ["invoices"], "pred_sql": "SELECT SUM(total) AS total_amount FROM invoices WHERE billing_city = 'Chicago' AND billing_state = 'Illinois';", "hint": "\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["Identify the relevant table: The invoices table contains the billing information including the state.", "Determine the required columns: We need the billing_state to group by and a count of invoices for each state.", "Use the COUNT() function to count the number of invoices for each state.", "Group the results by billing_state to get the count for each state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state;", "hint": "\n"}
{"sample_id": "train.565", "db_id": "store_1", "question": "List the state in the US with the most invoices.", "rationale": ["We need to find the state in the US with the most invoices.", "The relevant table for invoices is the 'invoices' table, which contains a column 'billing_state'.", "To count the number of invoices per state, we will use the COUNT() function and group the results by 'billing_state'.", "We will order the results in descending order based on the count of invoices to get the state with the most invoices at the top.", "Finally, we will limit the results to 1 to get only the state with the highest count."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state\nORDER BY invoice_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["Identify the relevant table: The 'invoices' table contains the billing information including the state.", "Determine the required information: We need to count the number of invoices per state.", "Group the results: Use GROUP BY to aggregate the invoice counts by 'billing_state'.", "Count the invoices: Use COUNT(*) to count the number of invoices for each state.", "Order the results: Use ORDER BY to sort the states by the count of invoices in descending order."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state\nORDER BY invoice_count DESC;", "hint": "\n"}
{"sample_id": "train.567", "db_id": "store_1", "question": "List the number of invoices and the invoice total from California.", "rationale": ["We need to count the number of invoices and sum the total of those invoices from customers in California.", "The relevant tables are 'invoices' and 'customers'.", "We will join the 'invoices' table with the 'customers' table on the customer_id field.", "We will filter the results to include only those customers who are located in California using a WHERE clause.", "Finally, we will select the count of invoices and the sum of the total from the invoices."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS number_of_invoices, SUM(total) AS invoice_total\nFROM invoices\nJOIN customers ON invoices.customer_id = customers.id\nWHERE customers.state = 'California';", "hint": "\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the table that contains the information needed: the 'employees' table has the email and phone number.", "Determine the specific columns to select: 'email' and 'phone'.", "Filter the results to find the specific employee by their first and last name: 'Astrid Gruber'.", "Construct the SQL query using the SELECT statement with the appropriate WHERE clause."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: employees and customers.", "We need to find the employee who supported the most customers, so we will join the employees table with the customers table on the support_rep_id.", "We will group the results by employee ID to count the number of customers each employee supports.", "We will order the results by the count of customers in descending order to get the employee with the most customers at the top.", "Finally, we will limit the results to 1 to get only the top employee.", "Select the full name of the employee by concatenating first_name and last_name."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.594", "db_id": "store_1", "question": "What is the full name of the employee who has the most customers?", "rationale": ["Identify the relevant tables: employees and customers.", "We need to find the employee who has the most customers, which means we need to join the employees table with the customers table on the support_rep_id.", "Use GROUP BY to group the results by employee ID to count the number of customers each employee has.", "Use COUNT to count the number of customers for each employee.", "Order the results in descending order based on the count of customers to get the employee with the most customers at the top.", "Limit the results to 1 to get only the employee with the most customers.", "Select the full name of the employee by concatenating first_name and last_name."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.604", "db_id": "store_1", "question": "How many employees who are IT staff are from each city?", "rationale": ["Identify the relevant table: The 'employees' table contains information about employees, including their job titles and cities.", "Determine the criteria: We need to filter employees who are in IT staff positions. This can be done by checking if the 'title' column contains 'IT'.", "Count the number of employees: We will use the COUNT() function to count the number of employees that meet the criteria.", "Group the results: We will group the results by 'city' to get the count of IT staff from each city."], "gold_sql": "SELECT count(*) ,  city FROM employees WHERE title  =  'IT Staff' GROUP BY city", "source_tables": ["employees"], "pred_sql": "SELECT city, COUNT(*) AS number_of_employees\nFROM employees\nWHERE title LIKE '%IT%'\nGROUP BY city;", "hint": "\n"}
{"sample_id": "train.624", "db_id": "store_1", "question": "What is the name of the album that has the track Ball to the Wall?", "rationale": ["Identify the relevant tables: We need to find the album title, which is in the 'albums' table, and we need to link it to the 'tracks' table to find the specific track.", "Determine the relationship: The 'albums' table is related to the 'tracks' table through the 'album_id' foreign key in the 'tracks' table.", "Construct the JOIN clause: We will join the 'albums' table with the 'tracks' table on the condition that 'albums.id' matches 'tracks.album_id'.", "Specify the condition: We need to filter the results to only include tracks with the name 'Ball to the Wall'.", "Select the desired output: We want to select the 'title' from the 'albums' table."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT albums.title \nFROM albums \nJOIN tracks ON albums.id = tracks.album_id \nWHERE tracks.name = 'Ball to the Wall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tracks from the 'tracks' table that have been purchased by customers with a specific first and last name. The placeholders in the WHERE clause represent the customer's first and last names.\"\n}\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the relevant tables: 'tracks', 'genres', and 'media_types'.", "Determine the relationships between these tables: 'tracks' has foreign keys to 'genres' and 'media_types'.", "Select the 'name' column from the 'tracks' table as we need the names of the tracks.", "Use JOIN to combine 'tracks' with 'genres' on the genre_id and with 'media_types' on the media_type_id.", "Add a WHERE clause to filter for tracks that belong to the 'Rock' genre and have the media type 'MPEG'."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN genres ON tracks.genre_id = genres.id \nJOIN media_types ON tracks.media_type_id = media_types.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific genre and media type. The placeholders in the WHERE clause represent the genre's name and the media type's name.\"\n}\n"}
{"sample_id": "train.946", "db_id": "medicine_enzyme_interaction", "question": "What are the names and trade names of the medcines that are FDA approved?", "rationale": ["Identify the relevant table: The 'medicine' table contains the information about medicines.", "Determine the required columns: We need the 'name' and 'Trade_Name' columns from the 'medicine' table.", "Filter the results: We only want medicines that are FDA approved, which is indicated by the 'FDA_approved' column.", "Construct the SQL query: Use a SELECT statement to retrieve the specified columns with a WHERE clause to filter for FDA approved medicines."], "gold_sql": "SELECT name ,  trade_name FROM medicine WHERE FDA_approved  =  'Yes'", "source_tables": ["medicine"], "pred_sql": "SELECT name, Trade_Name FROM medicine WHERE FDA_approved = 'yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\"\n}\n"}
{"sample_id": "train.951", "db_id": "medicine_enzyme_interaction", "question": "What are the ids, names and FDA approval status of medicines in descending order of the number of enzymes that it can interact with.", "rationale": ["Identify the relevant tables: medicine and medicine_enzyme_interaction.", "We need to select the medicine's id, name, and FDA approval status.", "To find the number of enzymes each medicine interacts with, we will join the medicine table with the medicine_enzyme_interaction table on the medicine_id.", "We will group the results by the medicine's id, name, and FDA approval status to aggregate the count of enzyme interactions.", "Finally, we will order the results in descending order based on the count of enzyme interactions."], "gold_sql": "SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC", "source_tables": ["medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT m.id, m.name, m.FDA_approved\nFROM medicine m\nJOIN medicine_enzyme_interaction mei ON m.id = mei.medicine_id\nGROUP BY m.id, m.name, m.FDA_approved\nORDER BY COUNT(mei.enzyme_id) DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\"\n}\n"}
{"sample_id": "train.953", "db_id": "medicine_enzyme_interaction", "question": "What is the id and name of the enzyme with most number of medicines that can interact as 'activator'?", "rationale": ["Identify the relevant tables: 'enzyme' and 'medicine_enzyme_interaction'.", "We need to find the enzyme that has the most medicines interacting with it as 'activator'.", "Join the 'enzyme' table with the 'medicine_enzyme_interaction' table on the enzyme ID.", "Filter the results to only include interactions where the interaction type is 'activator'.", "Group the results by enzyme ID and name to count the number of medicines for each enzyme.", "Order the results by the count of medicines in descending order to get the enzyme with the most interactions at the top.", "Limit the results to 1 to get only the enzyme with the highest count."], "gold_sql": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  'activitor' GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["enzyme", "medicine_enzyme_interaction"], "pred_sql": "SELECT e.id, e.name\nFROM enzyme e\nJOIN medicine_enzyme_interaction mei ON e.id = mei.enzyme_id\nWHERE mei.interaction_type = 'activator'\nGROUP BY e.id, e.name\nORDER BY COUNT(mei.medicine_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\"\n}\n"}
{"sample_id": "train.968", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that can interact as an inhibitor and activitor with enzymes?", "rationale": ["Identify the relevant tables: medicine, enzyme, and medicine_enzyme_interaction.", "We need to select the medicine names and their trade names, so we will select 'name' and 'Trade_Name' from the medicine table.", "To find interactions, we will join the medicine table with the medicine_enzyme_interaction table on the medicine ID.", "Next, we will join the enzyme table to get information about the enzymes involved in the interactions.", "We are specifically interested in interactions that are either 'inhibitor' or 'activator', so we will filter the results using a WHERE clause.", "Finally, we will group the results by medicine ID to ensure we get unique entries for each medicine."], "gold_sql": "SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'inhibitor' INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'activitor'", "source_tables": ["medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT m.name, m.Trade_Name \nFROM medicine m \nJOIN medicine_enzyme_interaction mei ON m.id = mei.medicine_id \nJOIN enzyme e ON mei.enzyme_id = e.id \nWHERE mei.interaction_type IN ('inhibitor', 'activator') \nGROUP BY m.id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\"\n}\n"}
{"sample_id": "train.970", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that cannot interact with the enzyme with the product 'Heme'?", "rationale": ["Identify the columns needed: medicine name and trade name from the 'medicine' table.", "Use the EXCEPT clause to find medicines that do not interact with a specific enzyme product.", "Join the 'medicine' table with 'medicine_enzyme_interaction' and 'enzyme' tables to find interactions.", "Filter the results to only include interactions with the enzyme product 'Heme'.", "Construct the final SQL query to select the required medicine names and trade names, excluding those that interact with 'Heme'."], "gold_sql": "SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  'Protoporphyrinogen IX'", "source_tables": ["enzyme", "medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT name, Trade_Name FROM medicine\nEXCEPT\nSELECT m.name, m.Trade_Name\nFROM medicine m\nJOIN medicine_enzyme_interaction mei ON m.id = mei.medicine_id\nJOIN enzyme e ON mei.enzyme_id = e.id\nWHERE e.Product = 'Heme';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\"\n}\n"}
{"sample_id": "train.1355", "db_id": "college_2", "question": "What is the name of the department with an instructure who has a name like 'Soisalon'?", "rationale": ["Identify the relevant tables: department and instructor.", "Determine the relationship between the tables: the instructor table has a foreign key that references the department table via dept_name.", "Formulate the SQL query to select the department name from the department table where there is a matching instructor name that fits the criteria (LIKE 'Soisalon').", "Use a JOIN to connect the department and instructor tables based on the dept_name column."], "gold_sql": "SELECT dept_name FROM instructor WHERE name LIKE '%Soisalon%'", "source_tables": ["instructor"], "pred_sql": "SELECT department.dept_name \nFROM department \nJOIN instructor ON department.dept_name = instructor.dept_name \nWHERE instructor.name LIKE 'Soisalon';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\"\n}\n"}
{"sample_id": "train.1365", "db_id": "college_2", "question": "What are the titles of courses that are in the Statistics department but not the Psychology department?", "rationale": ["Identify the relevant table: The 'course' table contains the course titles and their associated departments.", "Filter for courses in the Statistics department: Use a WHERE clause to select courses where dept_name is 'Statistics'.", "Exclude courses in the Psychology department: Use a subquery to ensure that the selected courses are not in the Psychology department.", "Construct the final SQL query: Combine the conditions to retrieve the titles of courses that meet both criteria."], "gold_sql": "SELECT title FROM course WHERE dept_name  =  'Statistics' EXCEPT SELECT title FROM course WHERE dept_name  =  'Psychology'", "source_tables": ["course"], "pred_sql": "SELECT title FROM course WHERE dept_name = 'Statistics' AND dept_name NOT IN (SELECT dept_name FROM course WHERE dept_name = 'Psychology');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\"\n}\n"}
{"sample_id": "train.1424", "db_id": "college_2", "question": "Find the title of course whose prerequisite is course Differential Geometry.", "rationale": ["Identify the table that contains course titles, which is the 'course' table.", "Identify the table that contains prerequisites, which is the 'prereq' table.", "To find the course title whose prerequisite is 'Differential Geometry', we need to join the 'course' table with the 'prereq' table on the course_id.", "We need to filter the results to only include those courses that have 'Differential Geometry' as a prerequisite.", "To do this, we can use a subquery to find the course_id of 'Differential Geometry' and use it in the WHERE clause."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  =  'Differential Geometry')", "source_tables": ["course", "prereq"], "pred_sql": "SELECT c.title \nFROM course c \nJOIN prereq p ON c.course_id = p.course_id \nWHERE p.prereq_id = (SELECT course_id FROM course WHERE title = 'Differential Geometry');", "hint": "\n"}
{"sample_id": "train.1426", "db_id": "college_2", "question": "Find the names of students who have taken any course in the fall semester of year 2003.", "rationale": ["Identify the relevant tables: student, takes, and section are needed to find students who have taken courses.", "Join the student table with the takes table on the student ID to link students with their courses.", "Join the section table to filter the courses based on the semester and year.", "Specify the conditions for the semester (Fall) and year (2003) in the WHERE clause to get the desired results."], "gold_sql": "SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  'Fall' AND YEAR  =  2003)", "source_tables": ["student", "takes"], "pred_sql": "SELECT student.name \nFROM student \nJOIN takes ON student.ID = takes.ID \nJOIN section ON takes.course_id = section.course_id AND takes.sec_id = section.sec_id \nWHERE section.semester = 'Fall' AND section.year = '2003';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\"\n}\n"}
{"sample_id": "train.1435", "db_id": "college_2", "question": "What are the names of all instructors who advise students in the math depart sorted by total credits of the student.", "rationale": ["Identify the tables involved: instructor, advisor, and student.", "We need to find instructors who advise students, so we will join the instructor table with the advisor table on the instructor's ID.", "Next, we join the advisor table with the student table on the student's ID to get the students being advised.", "We need to filter the results to only include students from the math department, so we add a WHERE clause for student.dept_name.", "Finally, we want to sort the results by the total credits earned by the students in descending order, so we use ORDER BY student.tot_cred DESC."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id WHERE T3.dept_name  =  'Math' ORDER BY T3.tot_cred", "source_tables": ["instructor", "student", "advisor"], "pred_sql": "SELECT instructor.name \nFROM instructor \nJOIN advisor ON instructor.ID = advisor.i_ID \nJOIN student ON advisor.s_ID = student.ID \nWHERE student.dept_name = 'math' \nORDER BY student.tot_cred DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\"\n}\n"}
{"sample_id": "train.1436", "db_id": "college_2", "question": "What is the course title of the prerequisite of course Mobile Computing?", "rationale": ["Identify the course title of the prerequisite for 'Mobile Computing'.", "First, find the course_id for 'Mobile Computing' from the course table.", "Next, use the prereq table to find the prerequisite course_id associated with 'Mobile Computing'.", "Finally, join the course table again to get the title of the course that corresponds to the prerequisite course_id."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  'Mobile Computing')", "source_tables": ["course", "prereq"], "pred_sql": "SELECT c.title \nFROM course c \nJOIN prereq p ON c.course_id = p.prereq_id \nWHERE p.course_id = (SELECT course_id FROM course WHERE title = 'Mobile Computing');", "hint": "\n"}
{"sample_id": "train.1439", "db_id": "college_2", "question": "What is the name of the instructor who advises the student with the greatest number of total credits?", "rationale": ["Identify the relevant tables: advisor, instructor, and student.", "We need to find the instructor who advises a student with the greatest number of total credits.", "Join the advisor table with the instructor table to get the instructor's name and with the student table to get the total credits.", "Order the results by the total credits in descending order to get the student with the highest credits at the top.", "Use LIMIT 1 to return only the name of the instructor advising the student with the greatest number of total credits."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT 1", "source_tables": ["instructor", "student", "advisor"], "pred_sql": "SELECT instructor.name \nFROM advisor \nJOIN instructor ON advisor.i_ID = instructor.ID \nJOIN student ON advisor.s_ID = student.ID \nORDER BY student.tot_cred DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\"\n}\n"}
{"sample_id": "train.1448", "db_id": "college_2", "question": "Find the number and averaged salary of all instructors who are in the department with the highest budget.", "rationale": ["Identify the department with the highest budget by selecting the 'dept_name' from the 'department' table and ordering by 'budget' in descending order, limiting the result to 1.", "Use the result of the previous step to filter the 'instructor' table, selecting the count of distinct instructor IDs and the average salary of instructors in that department.", "The final SQL query combines these elements to provide the required information: the number of instructors and their average salary in the department with the highest budget."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "pred_sql": "SELECT COUNT(ID) AS instructor_count, AVG(salary) AS average_salary\nFROM instructor\nWHERE dept_name = (SELECT dept_name FROM department ORDER BY budget DESC LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\"\n}\n"}
{"sample_id": "train.1449", "db_id": "college_2", "question": "How many instructors are in the department with the highest budget, and what is their average salary?", "rationale": ["Identify the department with the highest budget by using a subquery that selects the maximum budget from the department table.", "Join the instructor table with the department table on the department name to associate instructors with their respective departments.", "Filter the results to only include instructors from the department that has the highest budget.", "Count the number of instructors in that department using COUNT(i.ID).", "Calculate the average salary of those instructors using AVG(i.salary)."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "pred_sql": "SELECT COUNT(i.ID) AS instructor_count, AVG(i.salary) AS average_salary\nFROM instructor i\nJOIN department d ON i.dept_name = d.dept_name\nWHERE d.budget = (SELECT MAX(budget) FROM department);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\"\n}\n"}
{"sample_id": "train.1452", "db_id": "college_2", "question": "Find the name of students who didn't take any course from Biology department.", "rationale": ["Identify the main requirement: Find students who didn't take any course from the Biology department.", "To achieve this, we need to select student names from the 'student' table.", "We will use a subquery to find all student IDs that have taken courses from the Biology department.", "The subquery will join the 'takes' table with the 'course' table to filter courses by the 'Biology' department.", "The main query will select student names where their IDs are not in the list of IDs returned by the subquery."], "gold_sql": "SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  'Biology')", "source_tables": ["course", "student", "takes"], "pred_sql": "SELECT name FROM student WHERE ID NOT IN (SELECT takes.ID FROM takes JOIN course ON takes.course_id = course.course_id WHERE course.dept_name = 'Biology');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\"\n}\n"}
{"sample_id": "train.1458", "db_id": "college_2", "question": "Find the name and salary of instructors whose salary is below the average salary of the instructors in the Physics department.", "rationale": ["Identify the relevant table: The 'instructor' table contains the information about instructors, including their names and salaries.", "Determine the condition: We need to find instructors whose salary is below the average salary of instructors in the Physics department.", "Calculate the average salary: Use a subquery to calculate the average salary of instructors in the Physics department.", "Combine the conditions: Use a SELECT statement to retrieve the names and salaries of instructors in the Physics department who meet the salary condition."], "gold_sql": "SELECT name ,  salary FROM instructor WHERE salary  <  (SELECT avg(salary) FROM instructor WHERE dept_name  =  'Physics')", "source_tables": ["instructor"], "pred_sql": "SELECT name, salary \nFROM instructor \nWHERE dept_name = 'Physics' \nAND salary < (SELECT AVG(salary) FROM instructor WHERE dept_name = 'Physics');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\"\n}\n"}
{"sample_id": "train.1461", "db_id": "college_2", "question": "What are the names of students who have taken Statistics courses?", "rationale": ["Identify the relevant tables: student, takes, and course.", "We need to find students who have taken courses related to Statistics.", "Join the student table with the takes table on student ID to get the courses they have taken.", "Join the resulting table with the course table on course ID to filter for Statistics courses.", "Use a WHERE clause to filter courses that have 'Statistics' in their title."], "gold_sql": "SELECT T3.name FROM course AS T1 JOIN takes AS T2 ON T1.course_id  =  T2.course_id JOIN student AS T3 ON T2.id  =  T3.id WHERE T1.dept_name  =  'Statistics'", "source_tables": ["course", "student", "takes"], "pred_sql": "SELECT student.name \nFROM student \nJOIN takes ON student.ID = takes.ID \nJOIN course ON takes.course_id = course.course_id \nWHERE course.title LIKE '%Statistics%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\"\n}\n"}
{"sample_id": "train.1464", "db_id": "college_2", "question": "Find the names of all instructors in computer science department", "rationale": ["Identify the table that contains instructor information, which is the 'instructor' table.", "Determine the relevant column for the instructor's name, which is 'name'.", "Identify the condition needed to filter instructors by their department, which is 'dept_name'.", "Specify the department of interest, which is 'computer science'.", "Construct the SQL query to select the names of instructors from the 'instructor' table where the 'dept_name' matches 'computer science'."], "gold_sql": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'", "source_tables": ["instructor"], "pred_sql": "SELECT name FROM instructor WHERE dept_name = 'computer science';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\"\n}\n"}
{"sample_id": "train.1480", "db_id": "college_2", "question": "Find courses that ran in Fall 2009 but not in Spring 2010.", "rationale": ["Identify the courses that were offered in Fall 2009.", "Join the course table with the section table to filter by semester and year.", "Use a subquery to find courses that were offered in Spring 2010.", "Use the NOT IN clause to exclude those courses from the Fall 2009 results."], "gold_sql": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 EXCEPT SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010", "source_tables": ["section"], "pred_sql": "SELECT DISTINCT c.title \nFROM course c \nJOIN section s1 ON c.course_id = s1.course_id \nWHERE s1.semester = 'Fall' AND s1.year = '2009' \nAND c.course_id NOT IN (\n    SELECT s2.course_id \n    FROM section s2 \n    WHERE s2.semester = 'Spring' AND s2.year = '2010'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\"\n}\n"}
{"sample_id": "train.1489", "db_id": "college_2", "question": "What are the names of instructors who earn more than at least one instructor from the Biology department?", "rationale": ["Identify the main requirement: we need the names of instructors who earn more than at least one instructor from the Biology department.", "To find this, we need to compare the salaries of instructors in the main query with those in a subquery.", "The subquery will select the maximum salary from the instructor table where the department name is 'Biology'.", "The main query will select the names of instructors whose salary is greater than the result of the subquery."], "gold_sql": "SELECT name FROM instructor WHERE salary  >  (SELECT min(salary) FROM instructor WHERE dept_name  =  'Biology')", "source_tables": ["instructor"], "pred_sql": "SELECT name FROM instructor WHERE salary > (SELECT MAX(salary) FROM instructor WHERE dept_name = 'Biology');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\"\n}\n"}
{"sample_id": "train.1515", "db_id": "insurance_and_eClaims", "question": "Find the total and average amount paid in claim headers.", "rationale": ["Identify the relevant table: The 'Claim_Headers' table contains the 'Amount_Paid' column which is needed for the calculations.", "Determine the required calculations: We need to calculate both the total and average of the 'Amount_Paid' column.", "Construct the SQL query: Use the SUM() function to get the total amount paid and the AVG() function to get the average amount paid from the 'Claim_Headers' table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\"\n}\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["Identify the relevant table: The 'Claim_Headers' table contains the 'Amount_Paid' column which is needed for the calculations.", "Determine the required calculations: We need to calculate the total amount paid and the average amount paid.", "Construct the SQL query: Use the SUM() function to calculate the total amount and the AVG() function to calculate the average amount from the 'Amount_Paid' column in the 'Claim_Headers' table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\"\n}\n"}
{"sample_id": "train.1517", "db_id": "insurance_and_eClaims", "question": "Find the total amount claimed in the most recently created document.", "rationale": ["Identify the relevant tables: Claim_Headers and Claims_Documents are needed to find the total amount claimed and the most recently created document.", "We need to sum the Amount_Claimed from the Claim_Headers table.", "To find the most recently created document, we will use a subquery to get the maximum Created_Date from the Claims_Documents table.", "Join the Claim_Headers table with the Claims_Documents table on Claim_Header_ID and Claim_ID to link claims with their documents.", "Filter the results to only include claims that correspond to the most recently created document using the subquery in the WHERE clause."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT SUM(ch.Amount_Claimed) AS Total_Amount_Claimed\nFROM Claim_Headers ch\nJOIN Claims_Documents cd ON ch.Claim_Header_ID = cd.Claim_ID\nWHERE cd.Created_Date = (SELECT MAX(Created_Date) FROM Claims_Documents);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\"\n}\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Customers, Claim_Headers, and Policies are needed to get customer details and their claims.", "Join Claim_Headers with Policies to link claims to customers using the Policy_ID.", "Join Policies with Customers to retrieve customer details using Customer_ID.", "Use a subquery to find the maximum amount paid in a single claim from the Claim_Headers table.", "Filter the results to only include the customer(s) who made that maximum claim."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT Customers.Customer_Details \nFROM Claim_Headers \nJOIN Policies ON Claim_Headers.Policy_ID = Policies.Policy_ID \nJOIN Customers ON Policies.Customer_ID = Customers.Customer_ID \nWHERE Claim_Headers.Amount_Paid = (SELECT MAX(Amount_Paid) FROM Claim_Headers);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\"\n}\n"}
{"sample_id": "train.1527", "db_id": "insurance_and_eClaims", "question": "What is the name of the claim processing stage that most of the claims are on?", "rationale": ["We need to find the claim processing stage that most claims are currently in.", "To do this, we will join the Claims_Processing table with the Claims_Processing_Stages table on the Claim_Stage_ID.", "We will group the results by Claim_Status_Name to count how many claims are in each stage.", "Using COUNT(*) will give us the number of claims for each stage.", "We will order the results in descending order based on the count of claims to find the stage with the most claims.", "Finally, we will limit the results to 1 to get only the top stage."], "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"], "pred_sql": "SELECT cps.Claim_Status_Name, COUNT(*) as Claim_Count\nFROM Claims_Processing cp\nJOIN Claims_Processing_Stages cps ON cp.Claim_Stage_ID = cps.Claim_Stage_ID\nGROUP BY cps.Claim_Status_Name\nORDER BY Claim_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\"\n}\n"}
{"sample_id": "train.1535", "db_id": "insurance_and_eClaims", "question": "Find the names of all the customers and staff members.", "rationale": ["Identify the tables needed: Customers and Staff.", "Determine the columns to select: Customer_Details from Customers and Staff_Details from Staff.", "Use a SELECT statement to retrieve the desired columns.", "Since we want to find names from both tables, we can use a cross join (implicit join) by listing both tables in the FROM clause."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "pred_sql": "SELECT Customers.Customer_Details AS Customer_Name, Staff.Staff_Details AS Staff_Name \nFROM Customers, Staff;", "hint": "\n"}
{"sample_id": "train.1545", "db_id": "insurance_and_eClaims", "question": "Which customer is associated with the latest policy?", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find the customer associated with the latest policy, which means we need to look for the policy with the maximum start date.", "Join the Customers table with the Policies table on the Customer_ID to link customers to their policies.", "Use a subquery to find the maximum Start_Date from the Policies table.", "Select the Customer_ID and Customer_Details from the Customers table where the Start_Date matches the maximum Start_Date."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Start_Date = (SELECT MAX(Start_Date) FROM Policies);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\"\n}\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find the customer associated with the most recent policy, which requires joining the Customers table with the Policies table on Customer_ID.", "To find the most recent policy, we will use a subquery to get the maximum Start_Date from the Policies table.", "The main query will select the Customer_ID and Customer_Details from the Customers table where the Start_Date matches the maximum Start_Date from the subquery."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Start_Date = (SELECT MAX(Start_Date) FROM Policies);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\"\n}\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "Determine the columns needed: account_id, account_name, and other_account_details from Accounts.", "Establish the relationship between Accounts and Customers using the customer_id foreign key.", "Filter the results to include only those accounts associated with the customer whose first name is 'Meaghan'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Accounts.account_id, Accounts.account_name, Accounts.other_account_details \nFROM Accounts \nJOIN Customers ON Accounts.customer_id = Customers.customer_id \nWHERE Customers.customer_first_name = 'Meaghan';", "hint": "\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "Determine the columns needed: account_name and other_account_details from Accounts.", "Establish the relationship between Customers and Accounts using the customer_id foreign key.", "Filter the results to only include the customer named Meaghan Keeling by using the WHERE clause with both first and last names."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Accounts.account_name, Accounts.other_account_details \nFROM Customers \nJOIN Accounts ON Customers.customer_id = Accounts.customer_id \nWHERE Customers.customer_first_name = 'Meaghan' AND Customers.customer_last_name = 'Keeling';", "hint": "\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to retrieve the full names of customers, which requires concatenating the first and last names from the Customers table.", "We need to filter the results based on the account name, which is found in the Accounts table.", "Join the Customers table with the Accounts table on the customer_id to link customers with their accounts.", "Use a WHERE clause to filter for accounts with the name '900'.", "Select the concatenated full name as the output."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nJOIN Accounts ON Customers.customer_id = Accounts.customer_id\nWHERE Accounts.account_name = '900';", "hint": "\n"}
{"sample_id": "train.1569", "db_id": "customers_and_invoices", "question": "Show id, first name and last name for all customers and the number of accounts.", "rationale": ["Identify the required fields: customer_id, customer_first_name, customer_last_name from the Customers table, and the count of accounts from the Accounts table.", "To get the number of accounts per customer, a JOIN operation is needed between the Customers table and the Accounts table using the customer_id as the key.", "Since not all customers may have accounts, a LEFT JOIN is appropriate to ensure all customers are included in the results, even those with zero accounts.", "Use the COUNT function to count the number of accounts for each customer, and alias this count as number_of_accounts.", "Group the results by customer_id, customer_first_name, and customer_last_name to ensure the count is calculated correctly for each customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name, COUNT(a.account_id) AS number_of_accounts\nFROM Customers c\nLEFT JOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name;", "hint": "\n"}
{"sample_id": "train.1570", "db_id": "customers_and_invoices", "question": "What are the the full names and ids for all customers, and how many accounts does each have?", "rationale": ["Identify the required fields: customer_id, full name (first and last), and account count.", "To get the full name, concatenate customer_first_name and customer_last_name.", "We need to count the number of accounts for each customer, which requires a join between Customers and Accounts tables.", "Use a LEFT JOIN to ensure all customers are included, even those without accounts.", "Group the results by customer_id and full name to get the count of accounts for each customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name, COUNT(a.account_id) AS account_count\nFROM Customers c\nLEFT JOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name;", "hint": "\n"}
{"sample_id": "train.1580", "db_id": "customers_and_invoices", "question": "Count the number of financial transactions that correspond to each account id.", "rationale": ["Identify the relevant table: Financial_Transactions contains the account_id and transaction_id.", "We need to count the number of transactions for each account, so we will use the COUNT() function.", "To group the results by account_id, we will use the GROUP BY clause.", "The final query will select the account_id and the count of transaction_id, giving us the number of transactions per account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT account_id, COUNT(transaction_id) AS transaction_count\nFROM Financial_Transactions\nGROUP BY account_id;", "hint": "\n"}
{"sample_id": "train.1607", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of invoices for each order.", "rationale": ["We need to retrieve the order ids and the number of invoices for each order.", "To do this, we will select the 'order_id' from the 'Orders' table.", "We will also count the number of invoices associated with each order, which can be done using the COUNT function on 'invoice_number' from the 'Invoices' table.", "To link the 'Orders' and 'Invoices' tables, we will use a LEFT JOIN on the 'order_id' column.", "Finally, we will group the results by 'order_id' to get the count of invoices for each order."], "gold_sql": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id", "source_tables": ["invoices"], "pred_sql": "SELECT Orders.order_id, COUNT(Invoices.invoice_number) AS number_of_invoices\nFROM Orders\nLEFT JOIN Invoices ON Orders.order_id = Invoices.order_id\nGROUP BY Orders.order_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.\"\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["We need to retrieve the order ids and the number of items in each order.", "To do this, we will select the 'order_id' from the 'Orders' table.", "We will also need to count the number of items in each order, which can be done using the COUNT function on 'order_item_id' from the 'Order_Items' table.", "To get the relevant data, we will join the 'Orders' table with the 'Order_Items' table on the 'order_id' field.", "Finally, we will group the results by 'order_id' to get the count of items for each order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT Orders.order_id, COUNT(Order_Items.order_item_id) AS number_of_items\nFROM Orders\nJOIN Order_Items ON Orders.order_id = Order_Items.order_id\nGROUP BY Orders.order_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.\"\n}\n"}
{"sample_id": "train.1622", "db_id": "customers_and_invoices", "question": "What are teh names of the different products, as well as the number of customers who have ordered each product.", "rationale": ["Identify the tables involved: Products, Order_Items, and Orders.", "We need to select the product names from the Products table.", "We need to count the number of customers who have ordered each product, which can be done by counting the occurrences of product_id in the Order_Items table.", "Join the Products table with the Order_Items table on product_id to link products with their orders.", "Join the Order_Items table with the Orders table to ensure we are counting orders correctly.", "Group the results by product name to get the count of customers for each product."], "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"], "pred_sql": "SELECT Products.product_name, COUNT(Order_Items.product_id) AS number_of_customers_ordered\nFROM Products\nJOIN Order_Items ON Products.product_id = Order_Items.product_id\nJOIN Orders ON Order_Items.order_id = Orders.order_id\nGROUP BY Products.product_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.\"\n}\n"}
{"sample_id": "train.2050", "db_id": "party_people", "question": "Which ministers are not a part of the Progress Party?", "rationale": ["Identify the relevant tables: We need to look at the 'member' table to find ministers and the 'party' table to identify the party they belong to.", "Join the 'member' table with the 'party' table on the Party_ID to access the party names associated with each member.", "Filter the results to exclude members of the 'Progress Party' by using a WHERE clause that checks if the Party_name is not equal to 'Progress Party'.", "Select distinct member names to ensure that we do not have duplicate entries in the result."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT DISTINCT m.Member_Name \nFROM member m \nJOIN party p ON m.Party_ID = p.Party_ID \nWHERE p.Party_name != 'Progress Party';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.\"\n}\n"}
{"sample_id": "train.2057", "db_id": "party_people", "question": "Show all party names and the number of members in each party.", "rationale": ["Identify the tables needed: We need data from the 'party' table for party names and the 'member' table for counting members.", "Join the 'party' table with the 'member' table on the Party_ID to associate members with their respective parties.", "Use COUNT() function to count the number of members for each party.", "Group the results by party name to get the count of members for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT party.Party_name, COUNT(member.Member_ID) AS Number_of_Members\nFROM party\nLEFT JOIN member ON party.Party_ID = member.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.\"\n}\n"}
{"sample_id": "train.2072", "db_id": "party_people", "question": "How many events are there for each party?", "rationale": ["We need to count the number of events for each political party.", "The relevant tables are 'party' and 'party_events'.", "We will perform a LEFT JOIN between 'party' and 'party_events' on the Party_ID column to associate each party with its events.", "We will use the COUNT() function to count the number of events for each party.", "Finally, we will group the results by the party name to get the count for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT party.Party_name, COUNT(party_events.Event_ID) AS Event_Count\nFROM party\nLEFT JOIN party_events ON party.Party_ID = party_events.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.\"\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the tables involved: party_events, party, and region.", "We need to count the number of events, so we will use the COUNT() function.", "Join the party_events table with the party table on Party_ID to link events to their respective parties.", "Join the party table with the region table on Region_ID to filter events by region.", "Use a WHERE clause to specify that we are only interested in events in the 'United Kingdom' region and that the event name is 'Annual Meeting'.", "Select the count of these filtered events."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT COUNT(*) AS Annual_Meeting_Count \nFROM party_events pe \nJOIN party p ON pe.Party_ID = p.Party_ID \nJOIN region r ON p.Region_ID = r.Region_ID \nWHERE r.Region_name = 'United Kingdom' AND pe.Event_Name = 'Annual Meeting';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.\"\n}\n"}
{"sample_id": "train.2167", "db_id": "formula_1", "question": "What is the id and family name of the driver who has the longest laptime?", "rationale": ["We need to find the driver with the longest lap time, which is stored in the lapTimes table.", "To get the driver's family name, we will join the drivers table with the lapTimes table on the driverId.", "We will order the results by the lap time in descending order to get the longest lap time at the top.", "Finally, we will limit the results to 1 to get only the driver with the longest lap time."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "pred_sql": "SELECT drivers.driverId, drivers.surname \nFROM drivers \nJOIN lapTimes ON drivers.driverId = lapTimes.driverId \nORDER BY lapTimes.time DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\"\n}\n"}
{"sample_id": "train.2174", "db_id": "formula_1", "question": "How many drivers did not race in 2009?", "rationale": ["We need to find the number of drivers who did not race in the year 2009.", "To do this, we will first identify all drivers who participated in races during 2009 by joining the 'results' table with the 'races' table on 'raceId'.", "Next, we will select the 'driverId' from the results of the races in 2009.", "We will then count all distinct drivers from the 'drivers' table whose 'driverId' is not in the list of drivers who raced in 2009."], "gold_sql": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )", "source_tables": ["results", "races"], "pred_sql": "SELECT COUNT(DISTINCT d.driverId) AS drivers_not_in_2009\nFROM drivers d\nWHERE d.driverId NOT IN (\n    SELECT r.driverId\n    FROM results r\n    JOIN races ra ON r.raceId = ra.raceId\n    WHERE ra.year = 2009\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2179", "db_id": "formula_1", "question": "Find the id and forenames of drivers who participated both the races with name Australian Grand Prix and the races with name Chinese Grand Prix?", "rationale": ["Identify the tables needed: drivers, results, and races.", "We need to find drivers who participated in both the Australian Grand Prix and the Chinese Grand Prix.", "Join the drivers table with the results table to get the race participation.", "Join the results table with the races table to filter by race names.", "Use a subquery to find driver IDs from the results of the Chinese Grand Prix.", "Filter the main query to include only those drivers who are also in the subquery results.", "Select the driverId and forename from the drivers table."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.driverId, d.forename \nFROM drivers d \nJOIN results r1 ON d.driverId = r1.driverId \nJOIN races ra ON r1.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' \nAND d.driverId IN (\n    SELECT r2.driverId \n    FROM results r2 \n    JOIN races rb ON r2.raceId = rb.raceId \n    WHERE rb.name = 'Chinese Grand Prix'\n) \nGROUP BY d.driverId, d.forename;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\"\n}\n"}
{"sample_id": "train.2180", "db_id": "formula_1", "question": "What is the id and first name of all the drivers who participated in the Australian Grand Prix and the Chinese Grand Prix?", "rationale": ["Identify the tables needed: drivers, results, and races.", "We need to select the driverId and forename from the drivers table.", "To find out which drivers participated in the Australian Grand Prix and the Chinese Grand Prix, we need to join the results table with the races table on raceId.", "The races table will be filtered to include only the Australian Grand Prix and the Chinese Grand Prix.", "Finally, we will group the results by driverId and forename to ensure we get unique entries."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT drivers.driverId, drivers.forename \nFROM drivers \nJOIN results ON drivers.driverId = results.driverId \nJOIN races ON results.raceId = races.raceId \nWHERE races.name IN ('Australian Grand Prix', 'Chinese Grand Prix') \nGROUP BY drivers.driverId, drivers.forename;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\"\n}\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the races: Australian Grand Prix and Chinese Grand Prix.", "Select the raceId for the Australian Grand Prix from the races table.", "Select the driverId for drivers who participated in the Australian Grand Prix from the results table.", "Select the raceId for the Chinese Grand Prix from the races table.", "Select the driverId for drivers who participated in the Chinese Grand Prix from the results table.", "Use a NOT IN clause to exclude drivers who participated in the Chinese Grand Prix from the list of drivers who participated in the Australian Grand Prix.", "Join the results table with the drivers table to get the first and last names of the drivers."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.forename, d.surname \nFROM results r \nJOIN drivers d ON r.driverId = d.driverId \nWHERE r.raceId = (SELECT raceId FROM races WHERE name = 'Australian Grand Prix') \nAND d.driverId NOT IN (SELECT driverId FROM results WHERE raceId = (SELECT raceId FROM races WHERE name = 'Chinese Grand Prix'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2190", "db_id": "formula_1", "question": "For each constructor id, how many races are there?", "rationale": ["We need to count the number of races for each constructor id.", "The relevant table for this information is 'constructorResults', which links constructors to races.", "We will select the 'constructorId' and use the COUNT function to count the 'raceId' for each constructor.", "To get the count for each constructor, we will use the GROUP BY clause on 'constructorId'."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(raceId) AS race_count\nFROM constructorResults\nGROUP BY constructorId;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\"\n}\n"}
{"sample_id": "train.2194", "db_id": "formula_1", "question": "What are the names of all races held after 2000 in Spain?", "rationale": ["Identify the relevant tables: 'races' for race information and 'circuits' for circuit location.", "We need to find races held after the year 2000, so we will filter the 'year' column in the 'races' table.", "We also need to filter for races held in Spain, which requires joining the 'circuits' table to access the 'country' column.", "The join condition is based on the 'circuitId' which is common in both 'races' and 'circuits' tables.", "Select the 'name' of the races that meet both conditions."], "gold_sql": "SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = 'Spain' AND T1.year > 2000", "source_tables": ["races", "circuits"], "pred_sql": "SELECT races.name \nFROM races \nJOIN circuits ON races.circuitId = circuits.circuitId \nWHERE races.year > 2000 AND circuits.country = 'Spain';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2217", "db_id": "formula_1", "question": "Find the names of Japanese constructors that have once earned more than 5 points?", "rationale": ["Identify the relevant table: We need to find constructors, so we will use the 'constructors' table.", "Determine the condition: We are looking for Japanese constructors, which means we will filter by the 'nationality' column in the 'constructors' table.", "We need to check the points earned by these constructors, which is found in the 'constructorResults' table. We will join this table with the 'constructors' table using the 'constructorId'.", "We need to filter the results to only include constructors that have earned more than 5 points, so we will add a condition for 'points' in the 'constructorResults' table.", "Finally, we will select the distinct names of the constructors that meet these criteria."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT DISTINCT constructors.name \nFROM constructors \nJOIN constructorResults ON constructors.constructorId = constructorResults.constructorId \nWHERE constructors.nationality = 'Japanese' \nAND constructorResults.points > 5;", "hint": "\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the relevant table: We need to look at the 'constructors' table to get the names of constructors and their nationalities.", "Filter for Japanese constructors: We will add a WHERE clause to filter constructors by nationality = 'Japanese'.", "Aggregate points: We need to check the points earned by each constructor, which is found in the 'constructorResults' table.", "Group by constructorId: We will group the results by constructorId to sum the points for each constructor.", "Filter constructors with more than 5 points: We will use HAVING clause to filter those constructors whose total points exceed 5."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT name FROM constructors WHERE nationality = 'Japanese' AND constructorId IN (SELECT constructorId FROM constructorResults GROUP BY constructorId HAVING SUM(points) > 5);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\"\n}\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races, lapTimes, and circuits are needed to get the average fastest lap speed for a specific race.", "We need to join the races table with the lapTimes table on raceId to access the fastest lap speeds.", "We also need to join the circuits table to filter for the Monaco Grand Prix.", "The WHERE clause will filter the results to only include the Monaco Grand Prix in the year 2008.", "Finally, we will use the AVG() function to calculate the average of the fastest lap speeds."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(lapTimes.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races\nJOIN lapTimes ON races.raceId = lapTimes.raceId\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE circuits.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\"\n}\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: lapTimes, races, and circuits are needed to find the fastest lap speed for the Monaco Grand Prix in 2008.", "We need to find the maximum fastest lap speed, so we will use the MAX() function on the fastestLapSpeed column from the lapTimes table.", "To filter the results for the Monaco Grand Prix, we will join the races table with the circuits table to get the circuit name and ensure it is 'Monaco'.", "We also need to filter the races to only include those from the year 2008.", "The final SQL query will select the maximum fastest lap speed from the lapTimes table, joining it with the races and circuits tables based on their relationships."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(fastestLapSpeed) AS max_fastest_lap_speed \nFROM lapTimes \nJOIN races ON lapTimes.raceId = races.raceId \nJOIN circuits ON races.circuitId = circuits.circuitId \nWHERE circuits.name = 'Monaco' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\"\n}\n"}
{"sample_id": "train.2223", "db_id": "formula_1", "question": "What are the maximum fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the relevant tables: 'races' for race names and years, and 'lapTimes' for fastest lap speeds.", "Join the 'races' table with the 'lapTimes' table on the raceId to associate each lap time with its corresponding race.", "Filter the results to include only races held after the year 2004 using the WHERE clause.", "Group the results by race name to calculate the maximum fastest lap speed for each race using the MAX function.", "Order the final results by year to present them in chronological order."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name AS race_name, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races r\nJOIN lapTimes l ON r.raceId = l.raceId\nWHERE r.year > 2004\nGROUP BY r.name\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\"\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["We need to select the race names and the maximum fastest lap speed for races after the year 2004.", "The relevant tables are 'races' for race names and years, and 'lapTimes' for fastest lap speeds.", "We will join the 'races' table with the 'lapTimes' table on the raceId to correlate the races with their lap times.", "We will filter the results to include only those races that occurred after 2004 using the WHERE clause.", "To find the maximum fastest lap speed for each race, we will use the MAX() function and group the results by race name.", "Finally, we will order the results by year to meet the requirement of the query."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name AS race_name, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races r\nJOIN lapTimes l ON r.raceId = l.raceId\nWHERE r.year > 2004\nGROUP BY r.name\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\"\n}\n"}
{"sample_id": "train.2325", "db_id": "csu_1", "question": "What campuses are located in the county of Los Angeles?", "rationale": ["Identify the relevant table: The 'Campuses' table contains information about campuses, including their location and county.", "Determine the specific condition: We need to filter campuses based on the county, specifically 'Los Angeles'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' column from the 'Campuses' table where the 'County' matches 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\"\n}\n"}
{"sample_id": "train.2347", "db_id": "csu_1", "question": "In what year was the most degrees conferred?", "rationale": ["Identify the table that contains the information about degrees awarded, which is the 'degrees' table.", "To find out in which year the most degrees were conferred, we need to count the number of degrees awarded per year.", "We will use the COUNT function to count the number of degrees for each year.", "We will group the results by year using GROUP BY clause to aggregate the counts for each year.", "To find the year with the maximum degrees conferred, we will order the results in descending order by the count of degrees.", "Finally, we will limit the results to only the top entry using LIMIT 1 to get the year with the most degrees conferred."], "gold_sql": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Year, COUNT(Degrees) AS DegreesConferred \nFROM degrees \nGROUP BY Year \nORDER BY DegreesConferred DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.2348", "db_id": "csu_1", "question": "Which campus has the most degrees conferred in all times?", "rationale": ["Identify the relevant table for degrees conferred, which is the 'degrees' table.", "We need to count the number of degrees awarded for each campus, so we will use the COUNT function on the 'Degrees' column.", "To get the total degrees for each campus, we will group the results by the 'Campus' column.", "To find the campus with the most degrees, we will order the results in descending order based on the count of degrees.", "Finally, we will limit the results to 1 to get the campus with the highest count of degrees."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Campus, COUNT(Degrees) AS TotalDegrees\nFROM degrees\nGROUP BY Campus\nORDER BY TotalDegrees DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.2349", "db_id": "csu_1", "question": "What campus has the most degrees  conferrred over its entire existence?", "rationale": ["Identify the relevant table for degrees awarded, which is the 'degrees' table.", "We need to count the total number of degrees awarded for each campus, so we will use the COUNT() function.", "Group the results by the 'Campus' to aggregate the degree counts for each campus.", "Order the results in descending order to find the campus with the most degrees awarded.", "Limit the results to 1 to get only the campus with the highest count."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Campus, COUNT(Degrees) AS TotalDegrees\nFROM degrees\nGROUP BY Campus\nORDER BY TotalDegrees DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.2351", "db_id": "csu_1", "question": "What campus has the most faculties in 2003?", "rationale": ["Identify the relevant tables: 'Campuses' and 'faculty'.", "We need to find the campus with the most faculty members in the year 2003.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Filter the results to only include records from the year 2003.", "Order the results by the number of faculty members in descending order to get the campus with the most faculty at the top.", "Limit the results to 1 to get only the campus with the highest number of faculty."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT c.Campus, f.Faculty \nFROM Campuses c \nJOIN faculty f ON c.Id = f.Campus \nWHERE f.Year = 2003 \nORDER BY f.Faculty DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.2358", "db_id": "csu_1", "question": "For each Orange county campus, report the number of degrees granted after 2000.", "rationale": ["Identify the relevant tables: 'Campuses' and 'degrees'.", "We need to filter campuses located in 'Orange' county, so we will use the 'County' column from the 'Campuses' table.", "We need to count the number of degrees granted after the year 2000, so we will filter the 'degrees' table for records where 'Year' is greater than 2000.", "We will join the 'Campuses' table with the 'degrees' table on the campus identifier ('Id' in 'Campuses' and 'Campus' in 'degrees').", "We will group the results by campus to get the count of degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT Campuses.Campus, COUNT(degrees.Degrees) AS DegreesGranted\nFROM Campuses\nJOIN degrees ON Campuses.Id = degrees.Campus\nWHERE Campuses.County = 'Orange' AND degrees.Year > '2000'\nGROUP BY Campuses.Campus;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: 'Campuses' for campus information and 'degrees' for degree information.", "We need to count the total number of degrees granted after the year 2000, so we will use the COUNT function on the 'Degrees' column from the 'degrees' table.", "We will join the 'Campuses' table with the 'degrees' table on the campus identifier (Id) to get the campus names along with the degrees awarded.", "We will filter the results to include only those degrees awarded after the year 2000 using the WHERE clause.", "Additionally, we will filter the campuses to include only those located in Orange County.", "Finally, we will group the results by campus to get the total number of degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT c.Campus, COUNT(d.Degrees) AS TotalDegrees\nFROM Campuses c\nJOIN degrees d ON c.Id = d.Campus\nWHERE d.Year > '2000' AND c.County = 'Orange'\nGROUP BY c.Campus;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant tables: Campuses and enrollments.", "We need to filter campuses based on total enrollment and full-time equivalent enrollment for the year 1956.", "Join the Campuses table with the enrollments table using the campus identifier.", "Apply the conditions for total enrollment (> 400) and full-time enrollment (> 200).", "Specify the year as 1956 in the WHERE clause."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT c.Campus \nFROM Campuses c \nJOIN enrollments e ON c.Id = e.Campus \nWHERE e.TotalEnrollment_AY > 400 \nAND e.FTE_AY > 200 \nAND e.Year = '1956';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.2367", "db_id": "csu_1", "question": "What campuses are in Los Angeles county?", "rationale": ["Identify the relevant table: The 'Campuses' table contains information about campuses, including their location and county.", "Determine the specific information needed: The question asks for campuses located in Los Angeles county.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' column from the 'Campuses' table where the 'County' column matches 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\"\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: 'degrees' for the number of degrees conferred and 'Campuses' for the campus name.", "Join the 'degrees' table with the 'Campuses' table on the campus identifier to filter by campus name.", "Use a WHERE clause to specify the campus name as 'San Jose State University' and the year as '2000'.", "Count the number of degrees awarded in the specified year and campus."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT COUNT(Degrees) AS TotalDegrees\nFROM degrees\nJOIN Campuses ON degrees.Campus = Campuses.Id\nWHERE Campuses.Campus = 'San Jose State University' AND degrees.Year = '2000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "We need to filter the faculty data for a specific campus, which is 'San Francisco State University'.", "We also need to filter the data for the year 2004.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to get the campus name.", "Use the SUM function to calculate the total number of faculty members for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT SUM(Faculty) AS TotalFaculty\nFROM faculty\nJOIN Campuses ON faculty.Campus = Campuses.Id\nWHERE Campuses.Campus = 'San Francisco State University' AND faculty.Year = 2004;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\"\n}\n"}
{"sample_id": "train.2378", "db_id": "csu_1", "question": "List the campus that have between 600 and 1000 faculty lines in year 2004.", "rationale": ["Identify the relevant tables: Campuses and faculty.", "Determine the join condition: Campuses.Id should match faculty.Campus.", "Filter the results for the year 2004 using the condition faculty.Year = 2004.", "Apply the condition to filter faculty counts between 600 and 1000 using faculty.Faculty BETWEEN 600 AND 1000."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Campuses.Campus \nFROM Campuses \nJOIN faculty ON Campuses.Id = faculty.Campus \nWHERE faculty.Year = 2004 \nAND faculty.Faculty BETWEEN 600 AND 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\"\n}\n"}
{"sample_id": "train.2379", "db_id": "csu_1", "question": "What are the campuses that had between 600 and 1000 faculty members in 2004?", "rationale": ["Identify the relevant tables: 'Campuses' and 'faculty'.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Filter the results to include only those records from the year 2004.", "Apply a condition to filter faculty members to be between 600 and 1000."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Campuses.Campus \nFROM Campuses \nJOIN faculty ON Campuses.Id = faculty.Campus \nWHERE faculty.Year = 2004 \nAND faculty.Faculty BETWEEN 600 AND 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\"\n}\n"}
{"sample_id": "train.2380", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the most number of degrees in year 2002?", "rationale": ["Identify the year of interest, which is 2002, for the degrees awarded.", "Join the 'faculty' table with the 'degrees' table on the campus identifier to link faculty data with degree data.", "Join the 'Campuses' table to get the campus information associated with the degrees awarded.", "Filter the results to only include records from the year 2002 in the degrees table.", "Group the results by campus to count the number of degrees awarded per campus.", "Order the results by the count of degrees in descending order to find the campus with the most degrees awarded.", "Limit the results to 1 to get only the campus with the most degrees awarded.", "Count the number of faculty lines associated with that campus."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(f.Faculty) AS FacultyCount\nFROM faculty f\nJOIN degrees d ON f.Campus = d.Campus\nJOIN Campuses c ON f.Campus = c.Id\nWHERE d.Year = '2002'\nGROUP BY c.Id\nORDER BY COUNT(d.Degrees) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the year of interest, which is 2001, for degrees awarded.", "Join the 'faculty' table with the 'degrees' table on the campus identifier to correlate faculty members with the degrees awarded.", "Filter the results to only include records from the year 2001.", "Order the results by the number of degrees awarded in ascending order to find the campus with the least degrees awarded.", "Limit the results to 1 to get the campus with the least number of degrees awarded in 2001 and retrieve the corresponding faculty count."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty f \nJOIN degrees d ON f.Campus = d.Campus \nWHERE d.Year = '2001' \nORDER BY d.Degrees ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "Determine the necessary columns: we need to sum the 'Undergraduate' column to get the total number of undergraduates.", "Join the 'discipline_enrollments' table with the 'Campuses' table to filter by the specific campus name 'San Jose State'.", "Use a WHERE clause to specify the campus name to ensure we are only counting undergraduates from San Jose State."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT SUM(Undergraduate) AS TotalUndergraduates \nFROM discipline_enrollments \nJOIN Campuses ON discipline_enrollments.Campus = Campuses.Id \nWHERE Campuses.Campus = 'San Jose State';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\"\n}\n"}
{"sample_id": "train.3131", "db_id": "assets_maintenance", "question": "Which engineer has visited the most times? Show the engineer id, first name and last name.", "rationale": ["Identify the relevant tables: Engineer_Visits and Maintenance_Engineers.", "We need to count the number of visits for each engineer, so we will use COUNT(*) to aggregate the visits.", "Join the Engineer_Visits table with the Maintenance_Engineers table on the engineer_id to get the first and last names of the engineers.", "Group the results by engineer_id, first_name, and last_name to get the count of visits for each engineer.", "Order the results by visit_count in descending order to find the engineer with the most visits.", "Limit the results to 1 to get only the engineer with the highest visit count."], "gold_sql": "SELECT T1.engineer_id ,  T1.first_name ,  T1.last_name FROM Maintenance_Engineers AS T1 JOIN Engineer_Visits AS T2 GROUP BY T1.engineer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["maintenance_engineers", "engineer_visits"], "pred_sql": "SELECT engineer_id, first_name, last_name, COUNT(*) as visit_count\nFROM Engineer_Visits\nJOIN Maintenance_Engineers ON Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id\nGROUP BY engineer_id, first_name, last_name\nORDER BY visit_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3139", "db_id": "assets_maintenance", "question": "How many fault status codes are recorded in the fault log parts table?", "rationale": ["The question asks for the number of unique fault status codes recorded in the Fault_Log_Parts table.", "To find the unique fault status codes, we need to use the COUNT function along with DISTINCT to count only unique values.", "The relevant table for this query is Fault_Log_Parts, which contains the fault_status column.", "The SQL query will select the count of distinct fault_status from the Fault_Log_Parts table."], "gold_sql": "SELECT DISTINCT fault_status FROM Fault_Log_Parts", "source_tables": ["fault_log_parts"], "pred_sql": "SELECT COUNT(DISTINCT fault_status) AS unique_fault_status_count FROM Fault_Log_Parts;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of fault short names along with their corresponding skill descriptions required to fix those faults. The data is sourced from the 'Part_Faults' table, which contains information about faults related to parts, and is joined with the 'Skills_Required_To_Fix' table to identify the necessary skills, and the 'Skills' table to get detailed descriptions of those skills.\"\n}\n"}
{"sample_id": "train.3143", "db_id": "assets_maintenance", "question": "Which part fault requires the most number of skills to fix? List part id and name.", "rationale": ["Identify the relevant tables: Part_Faults, Skills_Required_To_Fix, Skills, and Parts.", "Join Part_Faults with Skills_Required_To_Fix to get the skills required for each part fault.", "Join the result with Skills to get the skill descriptions.", "Join with Parts to get the part names associated with each part fault.", "Group the results by part_id and part_name to count the number of skills required for each part fault.", "Order the results by the count of skills in descending order to find the part fault that requires the most skills.", "Limit the results to 1 to get only the top part fault."], "gold_sql": "SELECT T1.part_id ,  T1.part_name FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id  =  T2.part_id JOIN Skills_Required_To_Fix AS T3 ON T2.part_fault_id  =  T3.part_fault_id GROUP BY T1.part_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["part_faults", "parts", "skills_required_to_fix"], "pred_sql": "SELECT pf.part_id, p.part_name\nFROM Part_Faults pf\nJOIN Skills_Required_To_Fix srf ON pf.part_fault_id = srf.part_fault_id\nJOIN Skills s ON s.skill_id = srf.skill_id\nJOIN Parts p ON pf.part_id = p.part_id\nGROUP BY pf.part_id, p.part_name\nORDER BY COUNT(s.skill_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of fault short names along with their corresponding skill descriptions required to fix those faults. The data is sourced from the 'Part_Faults' table, which contains information about faults related to parts, and is joined with the 'Skills_Required_To_Fix' table to identify the necessary skills, and the 'Skills' table to get detailed descriptions of those skills.\"\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and PROFESSOR.", "We need to count the number of distinct professors teaching a specific class, so we will use COUNT(DISTINCT p.EMP_NUM).", "Join the CLASS table with the PROFESSOR table on the common key PROF_NUM.", "Filter the results to only include the class with the code 'ACCT-211'.", "Construct the SQL query using the SELECT statement to count the professors."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) AS ProfessorCount\nFROM CLASS c\nJOIN PROFESSOR p ON c.PROF_NUM = p.EMP_NUM\nWHERE c.CLASS_CODE = 'ACCT-211';", "hint": "\n"}
{"sample_id": "train.3180", "db_id": "college_1", "question": "What are the first names and birthdates of the professors in charge of ACCT-211?", "rationale": ["Identify the information needed: first names and birthdates of professors for the course ACCT-211.", "Determine the relevant tables: PROFESSOR for professor details, EMPLOYEE for personal details, and CLASS to link professors to classes.", "Join the PROFESSOR table with the EMPLOYEE table to get the first names and birthdates of professors.", "Join the CLASS table to filter professors based on the course code 'ACCT-211'.", "Construct the SQL SELECT statement to retrieve the desired fields from the joined tables."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, EMPLOYEE.EMP_DOB \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\"\n}\n"}
{"sample_id": "train.3189", "db_id": "college_1", "question": "How many different locations does the school with code BUS has?", "rationale": ["Identify the table that contains the location information, which is the DEPARTMENT table.", "Determine the relevant column for locations, which is DEPT_ADDRESS.", "We need to count the distinct addresses to find out how many different locations there are.", "Filter the results to only include departments that belong to the school with the code 'BUS'.", "Construct the SQL query to select the count of distinct DEPT_ADDRESS from the DEPARTMENT table where SCHOOL_CODE is 'BUS'."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT COUNT(DISTINCT DEPT_ADDRESS) AS different_locations\nFROM DEPARTMENT\nWHERE SCHOOL_CODE = 'BUS';", "hint": "\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the table that contains the school locations, which is the DEPARTMENT table.", "The DEPARTMENT table has a column DEPT_ADDRESS that stores the physical addresses of the departments.", "To find the locations associated with a specific school code, we need to filter the DEPARTMENT table by the SCHOOL_CODE column.", "We use the DISTINCT keyword to ensure that we only get unique addresses for the specified school code.", "The final SQL query selects the distinct department addresses where the SCHOOL_CODE is 'BUS'."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\"\n}\n"}
{"sample_id": "train.3206", "db_id": "college_1", "question": "How many classes are held in each department?", "rationale": ["Identify the tables needed: DEPARTMENT, COURSE, and CLASS.", "Join the DEPARTMENT table with the COURSE table on DEPT_CODE to link departments to their courses.", "Join the resulting table with the CLASS table on CRS_CODE to link courses to their classes.", "Count the number of classes (CLASS_CODE) for each department (DEPT_NAME).", "Group the results by department name to get the count of classes per department."], "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"], "pred_sql": "SELECT D.DEPT_NAME, COUNT(C.CLASS_CODE) AS CLASS_COUNT\nFROM DEPARTMENT D\nJOIN COURSE CRS ON D.DEPT_CODE = CRS.DEPT_CODE\nJOIN CLASS C ON CRS.CRS_CODE = C.CRS_CODE\nGROUP BY D.DEPT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\"\n}\n"}
{"sample_id": "train.3209", "db_id": "college_1", "question": "What is the number of professors for different school?", "rationale": ["Identify the relevant tables: PROFESSOR and DEPARTMENT are needed to get the number of professors per school.", "The PROFESSOR table contains the EMP_NUM (professor identifier) and DEPT_CODE (department code).", "The DEPARTMENT table contains the DEPT_CODE and SCHOOL_CODE (school code).", "To find the number of professors per school, we need to join the PROFESSOR and DEPARTMENT tables on DEPT_CODE.", "After joining, we can group the results by SCHOOL_CODE and count the number of professors (using COUNT(PROF_NUM)).", "The final SQL query will select the SCHOOL_CODE and the count of professors, grouped by SCHOOL_CODE."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "pred_sql": "SELECT SCHOOL_CODE, COUNT(PROF_NUM) AS NUMBER_OF_PROFESSORS\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY SCHOOL_CODE;", "hint": "\n"}
{"sample_id": "train.3210", "db_id": "college_1", "question": "How many different professors are there for the different schools?", "rationale": ["Identify the tables needed: PROFESSOR and DEPARTMENT are essential to find the number of professors per school.", "Use JOIN to connect PROFESSOR with DEPARTMENT based on DEPT_CODE to ensure we are counting professors associated with different departments.", "Count the distinct EMP_NUM from the PROFESSOR table to get the number of different professors.", "The final query will select the count of distinct professors from the joined tables."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "pred_sql": "SELECT COUNT(DISTINCT PROFESSOR.EMP_NUM) AS different_professors\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nJOIN CLASS ON DEPARTMENT.DEPT_CODE = CLASS.CRS_CODE;", "hint": "\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["We need to find the number of students for each department, which involves counting students grouped by their department.", "The relevant tables are DEPARTMENT and STUDENT, as we need to get department names and the count of students in each department.", "We will use a LEFT JOIN to connect the DEPARTMENT table with the STUDENT table on the DEPT_CODE, ensuring we include departments even if they have no students.", "We will use the COUNT function to count the number of students (STU_NUM) for each department.", "Finally, we will group the results by DEPARTMENT.DEPT_NAME to get the count for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(STUDENT.STU_NUM) AS NUM_STUDENTS\nFROM DEPARTMENT\nLEFT JOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "\n"}
{"sample_id": "train.3218", "db_id": "college_1", "question": "How many students are in each department?", "rationale": ["We need to find the number of students in each department.", "To do this, we will join the STUDENT table with the DEPARTMENT table using the DEPT_CODE foreign key.", "We will select the DEPT_NAME from the DEPARTMENT table and count the number of unique students (STU_NUM) from the STUDENT table.", "We will group the results by DEPT_NAME to get the count of students for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(STUDENT.STU_NUM) AS STUDENT_COUNT\nFROM STUDENT\nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\"\n}\n"}
{"sample_id": "train.3220", "db_id": "college_1", "question": "How many hours do the students spend studying in each department?", "rationale": ["Identify the relevant tables: DEPARTMENT, COURSE, CLASS, ENROLL, and STUDENT.", "Join the DEPARTMENT table with the COURSE table using DEPT_CODE to get the courses offered by each department.", "Join the COURSE table with the CLASS table using CRS_CODE to link courses to their respective classes.", "Join the CLASS table with the ENROLL table using CLASS_CODE to find out which students are enrolled in each class.", "Join the ENROLL table with the STUDENT table using STU_NUM to access student information.", "Group the results by department name to aggregate the total credit hours for each department.", "Use SUM to calculate the total credit hours for the courses in each department.", "Order the results by the total credit hours in descending order to see which departments have the most study hours."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT D.DEPT_NAME, SUM(C.CRS_CREDIT) AS TOTAL_CREDIT_HOURS\nFROM DEPARTMENT D\nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE\nJOIN CLASS CL ON C.CRS_CODE = CL.CRS_CODE\nJOIN ENROLL E ON CL.CLASS_CODE = E.CLASS_CODE\nJOIN STUDENT S ON E.STU_NUM = S.STU_NUM\nGROUP BY D.DEPT_NAME\nORDER BY TOTAL_CREDIT_HOURS DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\"\n}\n"}
{"sample_id": "train.3222", "db_id": "college_1", "question": "What is the highest, lowest, and average student GPA for every department?", "rationale": ["Identify the required information: highest, lowest, and average GPA for students, grouped by department.", "Determine the relevant tables: DEPARTMENT and STUDENT are needed to access department names and student GPAs.", "Use JOIN to connect DEPARTMENT and STUDENT on the DEPT_CODE field, which is common to both tables.", "Select the department name and calculate the maximum, minimum, and average of the STU_GPA from the STUDENT table.", "Group the results by DEPARTMENT.DEPT_NAME to get the statistics for each department."], "gold_sql": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, \n       MAX(STUDENT.STU_GPA) AS Highest_GPA, \n       MIN(STUDENT.STU_GPA) AS Lowest_GPA, \n       AVG(STUDENT.STU_GPA) AS Average_GPA \nFROM DEPARTMENT \nJOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE \nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "\n"}
{"sample_id": "train.3234", "db_id": "college_1", "question": "How many courses does the department of Computer Information Systmes offer?", "rationale": ["Identify the relevant tables: COURSE and DEPARTMENT.", "We need to count the number of courses offered by a specific department, which is 'Computer Information Systems'.", "Join the COURSE table with the DEPARTMENT table on the DEPT_CODE to filter courses by department.", "Use a WHERE clause to specify the department name as 'Computer Information Systems'.", "Use the COUNT function to count the number of courses (CRS_CODE) in the result set."], "gold_sql": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "department"], "pred_sql": "SELECT COUNT(C.CRS_CODE) AS CourseCount\nFROM COURSE C\nJOIN DEPARTMENT D ON C.DEPT_CODE = D.DEPT_CODE\nWHERE D.DEPT_NAME = 'Computer Information Systems';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\"\n}\n"}
{"sample_id": "train.3238", "db_id": "college_1", "question": "What are the total number of credits offered by each department?", "rationale": ["Identify the tables needed: DEPARTMENT, COURSE, and CLASS.", "Determine the relationships: DEPARTMENT is linked to COURSE via DEPT_CODE, and COURSE is linked to CLASS via CRS_CODE.", "Select the department name from DEPARTMENT and the sum of credits from COURSE.", "Use SUM to calculate the total credits offered by each department.", "Group the results by department name to aggregate the total credits per department.", "Order the results by the total credits in descending order to see which department offers the most credits."], "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"], "pred_sql": "SELECT D.DEPT_NAME, SUM(C.CRS_CREDIT) AS TOTAL_CREDITS\nFROM DEPARTMENT D\nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE\nJOIN CLASS CL ON C.CRS_CODE = CL.CRS_CODE\nGROUP BY D.DEPT_NAME\nORDER BY TOTAL_CREDITS DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\"\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the tables involved: STUDENT, ENROLL, and CLASS.", "We need to find the first names of students, so we will select STUDENT.STU_FNAME.", "Students are enrolled in classes, so we will join the ENROLL table with the STUDENT table on STU_NUM.", "Next, we need to join the CLASS table to filter by the specific course code 'ACCT-211'.", "The WHERE clause will specify that we are only interested in classes with the CRS_CODE 'ACCT-211'."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\"\n}\n"}
{"sample_id": "train.3253", "db_id": "college_1", "question": "What is the name of the department that has the largest number of students enrolled?", "rationale": ["Identify the relevant tables: DEPARTMENT and STUDENT.", "We need to count the number of students in each department, so we will group by the DEPT_CODE in the STUDENT table.", "Use COUNT(STU_NUM) to count the number of students in each department.", "Order the results in descending order to find the department with the largest number of students.", "Limit the results to 1 to get only the department with the highest count.", "Select the DEPT_NAME from the DEPARTMENT table where the DEPT_CODE matches the one with the highest student count."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT DEPT_NAME\nFROM DEPARTMENT\nWHERE DEPT_CODE IN (\n    SELECT STUDENT.DEPT_CODE\n    FROM STUDENT\n    GROUP BY STUDENT.DEPT_CODE\n    ORDER BY COUNT(STU_NUM) DESC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\"\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["Identify the relevant tables: DEPARTMENT and STUDENT are needed to find the department with the most students enrolled.", "Count the number of students in each department by grouping the STUDENT table by DEPT_CODE.", "Order the results by the count of students in descending order to find the department with the most students.", "Limit the results to 1 to get only the top department.", "Select the DEPT_NAME from the DEPARTMENT table where the DEPT_CODE matches the one with the most students."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT DEPT_NAME\nFROM DEPARTMENT\nWHERE DEPT_CODE IN (\n    SELECT STUDENT.DEPT_CODE\n    FROM STUDENT\n    GROUP BY STUDENT.DEPT_CODE\n    ORDER BY COUNT(STU_NUM) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\"\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about class locations, including the CLASS_ROOM column.", "Determine the required information: We need the course codes (CRS_CODE) for classes held in room KLR209.", "Construct the SQL query: Use a SELECT statement to retrieve distinct CRS_CODE values from the CLASS table where CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CRS_CODE FROM CLASS WHERE CLASS_ROOM = 'KLR209';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\"\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed to find students and their grades.", "We need to select the first names of students, which is in the STUDENT table under the column STU_FNAME.", "To find students who received a grade of 'C', we will join the STUDENT table with the ENROLL table on the student number (STU_NUM).", "The WHERE clause will filter the results to only include those students who have an ENROLL_GRADE of 'C'."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\"\n}\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["Identify the relevant tables: EMPLOYEE and CLASS.", "We need the first names of professors, which are in the EMPLOYEE table under the column EMP_FNAME.", "To find professors who do not teach a class, we need to check which professors are not present in the CLASS table.", "The CLASS table has a column PROF_NUM that links to the EMP_NUM in the EMPLOYEE table, indicating which professors are teaching classes.", "We can use a subquery to select all PROF_NUM from the CLASS table and then filter out those from the EMPLOYEE table.", "The final SQL query selects the EMP_FNAME from the EMPLOYEE table where the EMP_NUM is not in the list of PROF_NUM from the CLASS table."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME FROM EMPLOYEE WHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\"\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the relevant tables: EMPLOYEE and PROFESSOR.", "We need to find professors who are not teaching any classes, so we will look for professors in the PROFESSOR table.", "We will use a subquery to find all professors who are teaching classes by checking the CLASS table.", "The main query will select the first names of employees from the EMPLOYEE table where the employee number is in the PROFESSOR table but not in the CLASS table."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME FROM EMPLOYEE WHERE EMP_NUM IN (SELECT PROF_NUM FROM PROFESSOR) AND EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\"\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors, including their highest degree obtained.", "Determine the criteria: We need to count professors who have either a Ph.D. or a Masters degree.", "Construct the SQL query: Use the COUNT function to count the number of professors that meet the criteria, filtering with a WHERE clause that checks if the PROF_HIGH_DEGREE is either 'Ph.D.' or 'Masters'."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) AS NumberOfProfessors\nFROM PROFESSOR\nWHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\"\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the tables needed: STUDENT, CLASS, COURSE, and DEPARTMENT.", "Join the STUDENT table with the CLASS table to find which classes each student is enrolled in.", "Join the CLASS table with the COURSE table to get the department information for each class.", "Join the COURSE table with the DEPARTMENT table to filter by department names.", "Use a WHERE clause to specify the departments: 'Accounting' and 'Computer Info. Systems'.", "Group the results by student first name and use HAVING to ensure that only students enrolled in both departments are included."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME \nFROM STUDENT S \nJOIN CLASS C ON S.STU_NUM = (SELECT E.STU_NUM FROM ENROLL E WHERE E.CLASS_CODE = C.CLASS_CODE) \nJOIN COURSE CR ON C.CRS_CODE = CR.CRS_CODE \nJOIN DEPARTMENT D ON CR.DEPT_CODE = D.DEPT_CODE \nWHERE D.DEPT_NAME IN ('Accounting', 'Computer Info. Systems') \nGROUP BY S.STU_FNAME \nHAVING COUNT(DISTINCT D.DEPT_NAME) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\"\n}\n"}
{"sample_id": "train.3300", "db_id": "college_1", "question": "What is the name of the department with the student that has the lowest GPA?", "rationale": ["Identify the relevant tables: STUDENT and DEPARTMENT.", "We need to find the department name associated with the student who has the lowest GPA.", "Join the STUDENT table with the DEPARTMENT table on the DEPT_CODE to access department names.", "Use a subquery to find the minimum GPA from the STUDENT table.", "Filter the results to only include the department name of the student with the lowest GPA."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME \nFROM STUDENT \nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE STUDENT.STU_GPA = (SELECT MIN(STU_GPA) FROM STUDENT);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\"\n}\n"}
{"sample_id": "train.3314", "db_id": "college_1", "question": "What are the first names, office locations of all lecturers who have taught some course?", "rationale": ["Identify the required fields: first names of lecturers (from EMPLOYEE) and their office locations (from PROFESSOR).", "Determine the relevant tables: EMPLOYEE for first names and PROFESSOR for office locations.", "Establish the relationship between the tables: EMPLOYEE and PROFESSOR are linked by the EMP_NUM field.", "Construct the SQL SELECT statement to retrieve the first names and office locations by joining the EMPLOYEE and PROFESSOR tables."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num", "source_tables": ["course", "employee", "professor", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\"\n}\n"}
{"sample_id": "train.3315", "db_id": "college_1", "question": "Find the first names and offices of all instructors who have taught some course and the course description and the department name.", "rationale": ["Identify the required fields: first names of instructors, their office locations, course descriptions, and department names.", "The first names and office locations are found in the EMPLOYEE and PROFESSOR tables, respectively.", "The course descriptions are in the COURSE table, and the department names are in the DEPARTMENT table.", "To get the required information, we need to join these tables based on their relationships:", "1. Join EMPLOYEE and PROFESSOR on EMP_NUM to get the first names and office locations of professors.", "2. Join PROFESSOR and DEPARTMENT on DEPT_CODE to get the department names.", "3. Join PROFESSOR and COURSE on DEPT_CODE to get the course descriptions.", "4. Join COURSE and CLASS on CRS_CODE to ensure we are only considering courses that have been taught."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code", "source_tables": ["course", "department", "professor", "class", "employee"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE, COURSE.CRS_DESCRIPTION, DEPARTMENT.DEPT_NAME\nFROM EMPLOYEE\nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nJOIN COURSE ON PROFESSOR.DEPT_CODE = COURSE.DEPT_CODE\nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\"\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: DEPARTMENT, COURSE, and CLASS are needed to find the department name associated with a class description.", "Join the DEPARTMENT table with the COURSE table on DEPT_CODE to link departments to their courses.", "Join the COURSE table with the CLASS table on CRS_CODE to link courses to their respective classes.", "Use a WHERE clause to filter courses whose description contains the word 'Statistics'.", "Select the distinct department names from the DEPARTMENT table that meet the criteria."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT DISTINCT D.DEPT_NAME \nFROM DEPARTMENT D \nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE \nJOIN CLASS CL ON C.CRS_CODE = CL.CRS_CODE \nWHERE C.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\"\n}\n"}
{"sample_id": "train.3417", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To create the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter the employees whose first name does not contain the letter 'M'.", "Use the NOT LIKE operator with the pattern '%M%' to exclude those names.", "Select the relevant columns from the 'employees' table."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (concatenation of first and last names), hire date, salary, and department id.", "The full name can be created by concatenating the FIRST_NAME and LAST_NAME fields from the employees table.", "The data is sourced from the 'employees' table, which contains the necessary fields.", "We need to filter employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator in the WHERE clause."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the columns needed: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by DEPARTMENT_ID.", "Construct the SQL SELECT statement with the identified columns, filtering condition, and ordering."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The question pertains to job titles and salaries, so we will focus on the 'jobs' table.", "Determine the condition: We need to find jobs with salaries over 9000, which refers to the 'MAX_SALARY' column in the 'jobs' table.", "Construct the SQL query: We will select the 'JOB_TITLE' from the 'jobs' table where the 'MAX_SALARY' is greater than 9000."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE FROM jobs WHERE MAX_SALARY > 9000;", "hint": "\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The question asks for job titles and salary ranges, which are found in the 'jobs' table.", "Determine the columns needed: We need 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY' from the 'jobs' table.", "Formulate the SQL SELECT statement: Start with SELECT followed by the required columns.", "Add the FROM clause to specify the 'jobs' table.", "Add a WHERE clause to filter the results based on the condition that 'MAX_SALARY' is between 12000 and 18000."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY \nFROM jobs \nWHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["We need to retrieve the employee IDs and the final dates of employment for each employee.", "The relevant tables are 'employees' and 'job_history' since we need employee IDs and their job history.", "We will join the 'employees' table with the 'job_history' table on the EMPLOYEE_ID column to get the necessary information.", "To find the final date of employment for each employee, we will use a subquery to get the maximum END_DATE from the job_history table for each employee."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT e.EMPLOYEE_ID, jh.END_DATE \nFROM employees e \nJOIN job_history jh ON e.EMPLOYEE_ID = jh.EMPLOYEE_ID \nWHERE jh.END_DATE = (SELECT MAX(END_DATE) \n                     FROM job_history \n                     WHERE EMPLOYEE_ID = e.EMPLOYEE_ID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3451", "db_id": "hr_1", "question": "Find the ids of the departments where any manager is managing 4 or more employees.", "rationale": ["We need to find departments where any manager is managing 4 or more employees.", "To do this, we will join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID'.", "Next, we will group the results by 'DEPARTMENT_ID' and 'MANAGER_ID' to count the number of employees in each department managed by each manager.", "Finally, we will use the HAVING clause to filter the groups where the count of employees is 4 or more."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_ID, d.MANAGER_ID\nHAVING COUNT(e.EMPLOYEE_ID) >= 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3457", "db_id": "hr_1", "question": "display job ID for those jobs that were done by two or more for more than 300 days.", "rationale": ["Identify the relevant tables: job_history for job records and employees for employee details.", "We need to find jobs that were held for more than 300 days, so we will calculate the difference between START_DATE and END_DATE in the job_history table.", "We will group the results by JOB_ID to count how many employees held each job.", "We will use the HAVING clause to filter for jobs that have been held by two or more employees.", "Finally, we will select the JOB_ID of those jobs that meet the criteria."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "pred_sql": "SELECT j.JOB_ID\nFROM job_history j\nJOIN employees e ON j.EMPLOYEE_ID = e.EMPLOYEE_ID\nWHERE (j.END_DATE - j.START_DATE) > 300\nGROUP BY j.JOB_ID\nHAVING COUNT(e.EMPLOYEE_ID) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3458", "db_id": "hr_1", "question": "What are the job ids for jobs done more than once for a period of more than 300 days?", "rationale": ["We need to find job IDs for jobs that have been done more than once by employees.", "To do this, we will use the job_history table, which records the job history of employees.", "We will join the job_history table with itself to find instances where the same employee has the same job ID.", "The join condition will be on EMPLOYEE_ID and JOB_ID to ensure we are comparing the same job for the same employee.", "We will also need to ensure that the second job instance starts after the first one, which is done by checking START_DATE.", "Next, we need to check that the duration between the two job instances is more than 300 days, which can be calculated by subtracting the START_DATE of the first instance from the END_DATE of the second instance.", "Finally, we will group the results by JOB_ID and use HAVING to filter for those job IDs that appear more than once."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "pred_sql": "SELECT j1.JOB_ID\nFROM job_history j1\nJOIN job_history j2 ON j1.EMPLOYEE_ID = j2.EMPLOYEE_ID AND j1.JOB_ID = j2.JOB_ID\nWHERE j1.START_DATE < j2.START_DATE\nAND (j2.END_DATE - j1.START_DATE) > 300\nGROUP BY j1.JOB_ID\nHAVING COUNT(*) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3463", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["Identify the tables needed: We need the 'departments' table for department names and the 'employees' table to count the number of employees in each department.", "Join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' to link departments with their employees.", "Use a LEFT JOIN to ensure that departments with no employees are still included in the results with a count of zero.", "Select the 'DEPARTMENT_NAME' from the 'departments' table and count the 'EMPLOYEE_ID' from the 'employees' table to get the number of employees in each department.", "Group the results by 'DEPARTMENT_NAME' to aggregate the employee counts for each department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3470", "db_id": "hr_1", "question": "Provide the full names of employees earning more than the employee with id 163.", "rationale": ["Identify the requirement: We need to find the full names of employees earning more than the employee with ID 163.", "Determine the relevant tables: The 'employees' table contains the necessary information about employee names and salaries.", "Use a subquery to find the salary of the employee with ID 163: This will allow us to compare other employees' salaries against this value.", "Construct the main query: Select the first and last names of employees whose salary is greater than the salary obtained from the subquery."], "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = 163 )", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME \nFROM employees e \nWHERE e.SALARY > (SELECT e2.SALARY FROM employees e2 WHERE e2.EMPLOYEE_ID = '163');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3471", "db_id": "hr_1", "question": "return the smallest salary for every departments.", "rationale": ["We need to return the smallest salary for every department.", "To achieve this, we will select the department name and the minimum salary from the employees.", "We will join the 'departments' table with the 'employees' table on the DEPARTMENT_ID to link employees to their respective departments.", "We will use the MIN() function to find the smallest salary for each department.", "Finally, we will group the results by department name to ensure we get the minimum salary for each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_NAME, MIN(e.SALARY) AS MIN_SALARY\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3472", "db_id": "hr_1", "question": "What is the minimum salary in each department?", "rationale": ["We need to find the minimum salary in each department.", "To do this, we will select the department name and the minimum salary from the employees.", "We will join the 'departments' table with the 'employees' table on the DEPARTMENT_ID column to link employees to their respective departments.", "We will use the MIN() function to calculate the minimum salary for each department.", "Finally, we will group the results by department name to get the minimum salary for each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_NAME, MIN(e.SALARY) AS MIN_SALARY\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the tables involved: employees, departments, locations, and countries.", "We need to select all information regarding employees who are managers, which means we need to find employees whose EMPLOYEE_ID appears as a MANAGER_ID in the employees table.", "Join the employees table with the departments table to get department information, then join with locations to get location details, and finally join with countries to get country names.", "Use a subquery to filter employees who are managers by checking if their EMPLOYEE_ID exists in the MANAGER_ID column of the employees table."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT e.*, d.DEPARTMENT_NAME, l.CITY, c.COUNTRY_NAME \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE e.EMPLOYEE_ID IN (SELECT DISTINCT MANAGER_ID FROM employees WHERE MANAGER_ID IS NOT NULL);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find distinct department IDs where a manager oversees 4 or more employees.", "To do this, we will first identify managers who have 4 or more employees reporting to them. This can be done by grouping the employees by their MANAGER_ID and counting the number of employees for each manager.", "We will use a subquery to get the MANAGER_IDs that have 4 or more employees.", "Next, we will join the departments table with the employees table on the DEPARTMENT_ID to link departments with their respective employees.", "Finally, we will select the distinct DEPARTMENT_IDs from the departments where the MANAGER_ID is in the list of managers identified in the subquery."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DISTINCT d.DEPARTMENT_ID\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nWHERE d.MANAGER_ID IN (\n    SELECT MANAGER_ID\n    FROM employees\n    GROUP BY MANAGER_ID\n    HAVING COUNT(EMPLOYEE_ID) >= 4\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3497", "db_id": "hr_1", "question": "Find the ids of the employees who does not work in those departments where some employees works whose manager id within the range 100 and 200.", "rationale": ["Identify the employees whose IDs we want to find, which are those not working in certain departments.", "We need to find departments where employees have a manager ID in the range of 100 to 200.", "To do this, we will create a subquery that selects distinct DEPARTMENT_IDs from the employees table where the MANAGER_ID is between 100 and 200.", "The main query will then select EMPLOYEE_IDs from the employees table where their DEPARTMENT_ID is not in the list of DEPARTMENT_IDs returned by the subquery."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "pred_sql": "SELECT EMPLOYEE_ID FROM employees WHERE DEPARTMENT_ID NOT IN (SELECT DISTINCT DEPARTMENT_ID FROM employees WHERE MANAGER_ID BETWEEN '100' AND '200');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the requirement: We need the full names and hire dates of employees who work in the same department as an employee named Clara, excluding Clara herself.", "To get the full names, we will concatenate the first and last names of the employees using '||' operator.", "We need to filter employees based on the department of Clara. This requires a subquery to find Clara's department ID.", "The subquery will select the DEPARTMENT_ID from the employees table where the FIRST_NAME is 'Clara'.", "The main query will select the FULL_NAME and HIRE_DATE from the employees table where the DEPARTMENT_ID matches Clara's department and the FIRST_NAME is not 'Clara'."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE \nFROM employees e \nWHERE e.DEPARTMENT_ID = (SELECT e2.DEPARTMENT_ID \n                         FROM employees e2 \n                         WHERE e2.FIRST_NAME = 'Clara') \nAND e.FIRST_NAME != 'Clara';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3506", "db_id": "hr_1", "question": "What are the ids, full names, and salaries for employees making more than average and who work in a department with employees who have the letter J in their first name?", "rationale": ["Identify the required fields: employee IDs, full names (first and last), and salaries.", "To get the full name, concatenate the first and last names using '||'.", "Filter employees whose salary is greater than the average salary. This requires a subquery to calculate the average salary from the employees table.", "Additionally, filter employees based on their department. We need to find departments that have employees with 'J' in their first name, which requires another subquery.", "The subquery for departments selects distinct department IDs from the employees table where the first name contains 'J'.", "Combine these conditions in the main query to get the desired results."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%J%')", "source_tables": ["employees"], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY > (SELECT AVG(SALARY) FROM employees) \nAND e.DEPARTMENT_ID IN (SELECT DISTINCT d.DEPARTMENT_ID \n                         FROM employees \n                         WHERE FIRST_NAME LIKE '%J%');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the main requirement: We need to display the employee number (EMPLOYEE_ID) and job id (JOB_ID) for employees whose salary is less than any salary of those employees whose job title is MK_MAN.", "To find the salaries of employees with the job title MK_MAN, we will use a subquery that selects the minimum salary from the employees table where the job title matches MK_MAN.", "The main query will select EMPLOYEE_ID and JOB_ID from the employees table where the salary is less than the result of the subquery.", "The subquery will be structured as: (SELECT MIN(SALARY) FROM employees JOIN jobs ON employees.JOB_ID = jobs.JOB_ID WHERE JOB_TITLE = 'MK_MAN') to ensure we are comparing against the correct salaries."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID FROM employees WHERE SALARY < (SELECT MIN(SALARY) FROM employees JOIN jobs ON employees.JOB_ID = jobs.JOB_ID WHERE JOB_TITLE = 'MK_MAN')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3510", "db_id": "hr_1", "question": "What are the employee ids, full names, and job ids for employees who make more than the highest earning employee with title PU_MAN?", "rationale": ["Identify the required fields: employee ids, full names, and job ids.", "To get the full names, concatenate the first and last names of employees.", "Filter employees based on their salary being greater than the highest salary of employees with the job title 'PU_MAN'.", "Use a subquery to find the maximum salary of employees with the job title 'PU_MAN'.", "Join the employees table with the jobs table to access job titles for filtering."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.JOB_ID \nFROM employees e \nWHERE e.SALARY > (SELECT MAX(e2.SALARY) \n                  FROM employees e2 \n                  JOIN jobs j ON e2.JOB_ID = j.JOB_ID \n                  WHERE j.JOB_TITLE = 'PU_MAN');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To do this, we will use the 'employees' table to get employee details and the 'departments' table to get department IDs.", "We will join the 'employees' table with the 'departments' table on the DEPARTMENT_ID column to associate employees with their respective departments.", "Next, we will group the results by DEPARTMENT_ID to calculate the total salary for each department using the SUM function on the SALARY column.", "We will also count the number of employees in each department using the COUNT function on EMPLOYEE_ID.", "Finally, we will filter the results using the HAVING clause to include only those departments that have more than 2 employees."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, SUM(e.SALARY) AS TOTAL_SALARY\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_ID\nHAVING COUNT(e.EMPLOYEE_ID) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To get the full name, we can concatenate the first name and last name using '||' operator.", "We will select the department ID and the concatenated full name along with the salary from the 'employees' table.", "To find the highest salary in each department, we can use a subquery that selects the maximum salary from the 'employees' table where the department ID matches the current employee's department ID."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                  FROM employees \n                  WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3516", "db_id": "hr_1", "question": "What are the department ids, full names, and salaries for employees who make the most in their departments?", "rationale": ["Identify the required fields: department ids, full names, and salaries of employees.", "To get the full names, concatenate the first and last names of employees.", "We need to filter employees to only those who have the highest salary in their respective departments.", "Use a subquery to find the maximum salary for each department and compare it with the salary of the employees in the main query."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                  FROM employees \n                  WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the relevant tables: employees, departments, and locations.", "We need to select the full names of employees, which can be constructed by concatenating FIRST_NAME and LAST_NAME.", "We also need to retrieve the CITY from the locations table.", "To get the full names, we will use the SQL concatenation operator '||'.", "We will join the employees table with the departments table on DEPARTMENT_ID to link employees to their departments.", "Next, we will join the departments table with the locations table on LOCATION_ID to get the city information.", "Finally, we will filter the results to include only those employees whose FIRST_NAME contains the letter 'Z' using the LIKE operator."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, CITY \nFROM employees \nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID \nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID \nWHERE FIRST_NAME LIKE '%Z%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "Join the employees table with the departments table on DEPARTMENT_ID to get department information for each employee.", "Join the departments table with the locations table on LOCATION_ID to get location information for each department.", "Join the locations table with the countries table on COUNTRY_ID to get country information for each location.", "Select the first and last names of the employee, concatenated to form the full name, and the country name.", "Filter the results to only include the employee with the specified EMPLOYEE_ID."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, c.COUNTRY_NAME \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE e.EMPLOYEE_ID = ?;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["Identify the tables needed: We need the 'departments' table for department names and the 'employees' table to count the number of employees in each department.", "Join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' to link employees to their respective departments.", "Use a LEFT JOIN to ensure that departments with no employees are still included in the results with a count of zero.", "Select the 'DEPARTMENT_NAME' from the 'departments' table and count the 'EMPLOYEE_ID' from the 'employees' table to get the number of employees in each department.", "Group the results by 'DEPARTMENT_NAME' to aggregate the employee counts for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["Identify the tables needed: We need the 'departments' table for department names and the 'employees' table to count the number of employees in each department.", "Join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' to associate employees with their respective departments.", "Use a LEFT JOIN to ensure that departments with no employees are still included in the results with a count of zero.", "Group the results by 'DEPARTMENT_NAME' to aggregate the employee counts for each department.", "Select the department name and the count of employees, labeling the count as 'EMPLOYEE_COUNT'."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS EMPLOYEE_COUNT\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\"\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the required information: full names and salaries of employees.", "Full names can be constructed by concatenating first and last names from the 'employees' table.", "Salaries are directly available from the 'employees' table.", "To filter employees based on the city, we need to join the 'employees' table with the 'departments' table to get the department information, and then join with the 'locations' table to access the city.", "The join conditions are: employees to departments on DEPARTMENT_ID, and departments to locations on LOCATION_ID.", "Finally, apply a WHERE clause to filter results for the city of London."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\"\n}\n"}
{"sample_id": "train.3641", "db_id": "baseball_1", "question": "In 2014, what are the id and rank of the team that has the largest average number of attendance?", "rationale": ["Identify the relevant table: The 'team' table contains information about teams, including their attendance and rank.", "Specify the year: We are interested in the year 2014, so we will filter the results to only include records from that year.", "Order by attendance: To find the team with the largest average attendance, we will order the results by the 'attendance' column in descending order.", "Limit the results: Since we only want the team with the largest attendance, we will limit the results to 1.", "Select the required columns: We need to select the 'team_id' and 'rank' columns from the filtered and ordered results."], "gold_sql": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  2014 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, rank FROM team WHERE year = 2014 ORDER BY attendance DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3647", "db_id": "baseball_1", "question": "Which 3 players won the most player awards? List their full name and id.", "rationale": ["Identify the relevant tables: We need to find player awards, so we will use the 'player_award' table to get the awards won by players.", "Join the 'player' table to get the full names of the players associated with their IDs.", "Group the results by player ID to count the number of awards each player has won.", "Order the results in descending order based on the count of awards to find the top players.", "Limit the results to the top 3 players who have won the most awards."], "gold_sql": "SELECT T1.name_first ,  T1.name_last ,  T1.player_id FROM player AS T1 JOIN player_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT 3;", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.player_id, p.name_first, p.name_last\nFROM player_award pa\nJOIN player p ON pa.player_id = p.player_id\nGROUP BY p.player_id\nORDER BY COUNT(pa.award_id) DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3649", "db_id": "baseball_1", "question": "List three countries which are the origins of the least players.", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their country of birth.", "Count the number of players from each country: Use COUNT(player_id) to count the number of players grouped by 'birth_country'.", "Group the results by country: Use GROUP BY birth_country to aggregate the counts for each country.", "Order the results to find the least represented countries: Use ORDER BY player_count ASC to sort the countries by the number of players in ascending order.", "Limit the results to the top three countries: Use LIMIT 3 to restrict the output to the three countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count \nFROM player \nGROUP BY birth_country \nORDER BY player_count ASC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their birth countries.", "Select the 'birth_country' column and count the number of players from each country using COUNT(player_id).", "Group the results by 'birth_country' to aggregate the player counts for each country.", "Order the results in ascending order based on the player count to find the countries with the least players.", "Limit the results to the top 3 countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.3651", "db_id": "baseball_1", "question": "Find all the players' first name and last name who have empty death record.", "rationale": ["Identify the relevant table: The 'player' table contains the first and last names of players along with their death records.", "Determine the condition for empty death records: A player has an empty death record if the 'death_year', 'death_month', and 'death_day' fields are all NULL.", "Construct the SQL query: Use a SELECT statement to retrieve 'name_first' and 'name_last' from the 'player' table where the death records are empty."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE death_year = '';", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE death_year IS NULL AND death_month IS NULL AND death_day IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["We need to find the highest salary for each team, which requires us to aggregate salary data by team.", "The salary table contains the salary records, and the team table contains the team names and IDs.", "To get the maximum salary for each team, we will use the MAX() function on the salary column.", "We will join the salary table with the team table on the team_id to get the team names along with their IDs.", "Finally, we will group the results by team ID and name to ensure we get the maximum salary for each team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nGROUP BY team.team_id, team.name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3662", "db_id": "baseball_1", "question": "Which players won awards in both 1960 and 1961? Return their first names and last names.", "rationale": ["Identify the relevant tables: player_award for awards and player for player names.", "Join the player_award table to itself to find players who won awards in both years (1960 and 1961).", "Join the player table to get the first and last names of these players.", "Filter the results to include only those who won awards in both specified years."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.name_first, p.name_last\nFROM player_award pa1\nJOIN player_award pa2 ON pa1.player_id = pa2.player_id\nJOIN player p ON pa1.player_id = p.player_id\nWHERE pa1.year = 1960 AND pa2.year = 1961;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) of the team Boston Red Stockings when they won in postseason.", "The postseason table contains the wins of the winning team, and the team table contains the team names.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings'", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) for the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include records where the team name is 'Boston Red Stockings'.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings'", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3669", "db_id": "baseball_1", "question": "What are the name and id of the team with the most victories in 2008 postseason?", "rationale": ["Identify the relevant tables: We need to find the team with the most victories in the postseason for the year 2008, which involves the 'team' and 'postseason' tables.", "Join the tables: We will join the 'team' table with the 'postseason' table on the winning team identifier (team_id_winner).", "Filter by year: We will filter the results to only include records from the year 2008.", "Order by wins: We will order the results by the number of wins in descending order to get the team with the most victories at the top.", "Limit the results: Since we only want the team with the most victories, we will limit the results to 1."], "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"], "pred_sql": "SELECT team.name, team.team_id \nFROM team \nJOIN postseason ON team.team_id = postseason.team_id_winner \nWHERE postseason.year = 2008 \nORDER BY postseason.wins DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3673", "db_id": "baseball_1", "question": "What is the total number of postseason games that team Boston Red Stockings participated in?", "rationale": ["Identify the relevant table for postseason games, which is 'batting_postseason'.", "Determine the column that represents the number of games played in postseason, which is 'g'.", "To find the total number of postseason games for the team 'Boston Red Stockings', we need to filter the records based on the team name.", "Use a subquery to get the 'team_id' for 'Boston Red Stockings' from the 'team' table.", "Sum the 'g' column from the 'batting_postseason' table where the 'team_id' matches the result of the subquery."], "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"], "pred_sql": "SELECT SUM(g) AS total_postseason_games \nFROM batting_postseason \nWHERE team_id IN (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3678", "db_id": "baseball_1", "question": "What is the total salary expenses of team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant table for salary information, which is the 'salary' table.", "We need to calculate the total salary expenses, so we will use the SUM function on the 'salary' column.", "We need to filter the records for the year 2010, so we will add a WHERE clause for 'year = 2010'.", "To filter by the team 'Boston Red Stockings', we need to find the corresponding 'team_id'. This requires a subquery to select the 'team_id' from the 'team' table where the 'name' is 'Boston Red Stockings'.", "Combine all these elements into a single SQL query that sums the salaries for the specified year and team."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT SUM(salary) AS total_salary_expenses \nFROM salary \nWHERE year = 2010 AND team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3679", "db_id": "baseball_1", "question": "How many players were in the team Boston Red Stockings in 2000?", "rationale": ["Identify the relevant tables: salary, team, and player.", "We need to count the distinct players associated with the team 'Boston Red Stockings' in the year 2000.", "Join the salary table with the team table on team_id to filter by team name.", "Join the salary table with the player table on player_id to get player details.", "Use a WHERE clause to specify the year as 2000 and the team name as 'Boston Red Stockings'.", "Count the distinct player IDs to get the number of players."], "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"], "pred_sql": "SELECT COUNT(DISTINCT player.player_id) AS player_count\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nJOIN player ON salary.player_id = player.player_id\nWHERE salary.year = 2000 AND team.name = 'Boston Red Stockings';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant tables: We need the 'salary' table to get salary information and the 'player' table to get player names.", "Join the 'salary' table with the 'player' table on 'player_id' to access player names along with their salaries.", "Filter the results to only include records from the year 2001 using a WHERE clause.", "Order the results by salary in descending order to get the highest salaries at the top.", "Limit the results to the top 3 entries to get the three highest salaries."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player.name_first, player.name_last, salary.salary \nFROM salary \nJOIN player ON salary.player_id = player.player_id \nWHERE salary.year = 2001 \nORDER BY salary.salary DESC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3684", "db_id": "baseball_1", "question": "List all the salary values players received in 2010 and 2001.", "rationale": ["Identify the relevant tables: salary and player.", "We need to retrieve salary values for the years 2010 and 2001.", "Join the salary table with the player table to get player names along with their salaries.", "Use a WHERE clause to filter the results for the specified years (2010 and 2001).", "Select the player ID, first name, last name, and salary in the final output."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT player.player_id, player.name_first, player.name_last, salary.salary \nFROM salary \nJOIN player ON salary.player_id = player.player_id \nWHERE salary.year IN ('2010', '2001');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "The 'hall_of_fame' table contains the 'yearid' column which indicates the year of induction.", "We can count the number of players inducted for each year using COUNT(*) and group the results by 'yearid'.", "To find the year with the least inductees, we will order the results by the count in ascending order.", "Finally, we will limit the results to 1 to get the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) AS num_inducted FROM hall_of_fame GROUP BY yearid ORDER BY num_inducted ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "The relevant table for this information is 'hall_of_fame', which contains the 'yearid' and 'player_id'.", "To find the number of inductees per year, we can use the COUNT function on 'player_id' and group the results by 'yearid'.", "We will then order the results in ascending order based on the count of inductees to find the year with the least inductees.", "Finally, we will limit the results to 1 to get only the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(player_id) AS num_inductees \nFROM hall_of_fame \nGROUP BY yearid \nORDER BY num_inductees ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: 'home_game' for games played and 'park' for park details.", "We need to sum the total games played in a specific park and year, so we will use the SUM function on the 'games' column from the 'home_game' table.", "Join the 'home_game' table with the 'park' table on the 'park_id' to access the park name.", "Filter the results to only include records where the park name is 'Columbia Park' and the year is 1907."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(home_game.games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.park_name = 'Columbia Park' AND home_game.year = 1907;", "hint": "\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: 'home_game' for game statistics and 'park' for park details.", "We need to count the number of games, so we will use the SUM function on the 'games' column from the 'home_game' table.", "To filter the results for 'Columbia Park', we will join the 'home_game' table with the 'park' table on the 'park_id'.", "We will also filter the results for the year 1907 using a WHERE clause.", "The final SQL query will select the total number of games from the joined tables with the specified conditions."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.park_name = 'Columbia Park' AND home_game.year = 1907;", "hint": "\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant table: The 'home_game' table contains information about games played, including the year and city.", "Determine the columns needed: We need to sum the 'games' column to get the total number of games played.", "Apply the conditions: We need to filter the results for the year 2000 and the city of Atlanta.", "Construct the SQL query: Use the SUM function to aggregate the total games played in Atlanta for the specified year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nWHERE city = 'Atlanta' AND year = 2000;", "hint": "\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: 'home_game' for game statistics and 'park' for location details.", "We need to find the total number of games played in Atlanta in the year 2000.", "Join the 'home_game' table with the 'park' table on the park_id to access the city information.", "Filter the results to include only those games that took place in Atlanta and in the year 2000.", "Use the SUM function to calculate the total number of games from the filtered results."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.city = 'Atlanta' AND home_game.year = 2000;", "hint": "\n"}
{"sample_id": "train.3697", "db_id": "baseball_1", "question": "List players' first name and last name who received salary from team Washington Nationals in both 2005 and 2007.", "rationale": ["Identify the relevant tables: We need the 'salary' table to find salary records and the 'player' table to get player names.", "Join the 'salary' table with the 'player' table on 'player_id' to access player names along with their salary records.", "Filter the records to include only those from the 'Washington Nationals' team for the years 2005 and 2007.", "Use a subquery to get the 'team_id' for 'Washington Nationals'.", "Group the results by 'player_id' to ensure we can count the number of distinct years for which each player received a salary.", "Use the HAVING clause to ensure that only players who have salary records for both years (2005 and 2007) are included in the final result."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT p.name_first, p.name_last \nFROM salary s1 \nJOIN player p ON s1.player_id = p.player_id \nWHERE s1.team_id = (SELECT team_id FROM team WHERE name = 'Washington Nationals') \nAND s1.year IN (2005, 2007) \nGROUP BY p.player_id \nHAVING COUNT(DISTINCT s1.year) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3699", "db_id": "baseball_1", "question": "How many home games did the team Boston Red Stockings play from 1990 to 2000 in total?", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games played by teams.", "Determine the columns needed: We need to sum the 'games' column to get the total number of home games.", "Filter by team: We need to find the 'team_id' for 'Boston Red Stockings' from the 'team' table.", "Filter by year: We need to restrict the results to the years between 1990 and 2000.", "Construct the SQL query: Use a subquery to find the 'team_id' and sum the 'games' for the specified years."], "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT SUM(games) AS total_home_games\nFROM home_game\nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')\nAND year BETWEEN 1990 AND 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games played by teams, including the year and the number of games.", "Specify the year: We need to filter the records for the year 1980.", "Select the team and games: We want to retrieve the 'team_id' and the number of 'games' played at home.", "Order the results: To find the team with the least number of home games, we will order the results by the 'games' column in ascending order.", "Limit the results: Since we only need the team with the least number of home games, we will limit the results to 1."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, games FROM home_game WHERE year = 1980 ORDER BY games ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3710", "db_id": "baseball_1", "question": "Which park did the most people attend in 2008?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'park' for park names.", "We need to find the park with the highest attendance in the year 2008.", "Join the 'home_game' table with the 'park' table on 'park_id' to get park names along with attendance.", "Filter the results to only include records from the year 2008.", "Order the results by attendance in descending order to get the park with the highest attendance at the top.", "Limit the results to 1 to get only the park with the most attendance."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT park.park_name, home_game.attendance\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE home_game.year = 2008\nORDER BY home_game.attendance DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to count the number of employees in each department, which involves joining the Department table with the Physician table.", "Use a LEFT JOIN to include all departments even if they have no physicians.", "Group the results by department name to count the number of employees in each department.", "Use COUNT(Physician.EmployeeID) to count the number of physicians in each department.", "Order the results by the count of employees in descending order to find the department with the largest number of employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Physician.EmployeeID) AS EmployeeCount\nFROM Department\nLEFT JOIN Physician ON Department.Head = Physician.EmployeeID\nGROUP BY Department.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["To find the department with the most employees, we need to count the number of physicians affiliated with each department.", "We will join the Department table with the Affiliated_With table on the DepartmentID to get the list of physicians in each department.", "We will use the COUNT function to count the number of physicians for each department.", "We will group the results by the department name to get the count for each department.", "To find the department with the most employees, we will order the results by the count in descending order and limit the results to 1."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Affiliated_With.Physician) AS EmployeeCount\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["We need to find the name and position of the head of the department with the least number of employees.", "The head of each department is identified in the Department table by the 'Head' column, which corresponds to the 'EmployeeID' in the Physician table.", "To find the department with the least number of employees, we can use the Affiliated_With table to count the number of physicians affiliated with each department.", "We will group the results by department and order them by the count of physicians in ascending order, limiting the result to the first one to get the department with the least employees.", "Finally, we will join the Physician and Department tables to get the name and position of the head of that department."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Physician \nJOIN Department ON Physician.EmployeeID = Department.Head \nWHERE Department.DepartmentID = \n  (SELECT Affiliated_With.Department \n   FROM Affiliated_With \n   GROUP BY Affiliated_With.Department \n   ORDER BY COUNT(Affiliated_With.Physician) ASC \n   LIMIT 1);", "hint": "\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["We need to find the names of patients who made an appointment.", "The relevant tables are 'Appointment' and 'Patient'.", "The 'Appointment' table contains a reference to the patient through the 'Patient' column, which corresponds to the 'SSN' in the 'Patient' table.", "We will perform a JOIN between 'Appointment' and 'Patient' on the condition that 'Appointment.Patient' matches 'Patient.SSN'.", "To ensure we get unique names, we will use DISTINCT in our SELECT statement."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT Patient.Name\nFROM Appointment\nJOIN Patient ON Appointment.Patient = Patient.SSN;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\"\n}\n"}
{"sample_id": "train.3905", "db_id": "hospital_1", "question": "List the names of patients who have made appointments.", "rationale": ["We need to list the names of patients who have made appointments.", "The relevant tables are 'Patient' and 'Appointment'.", "We will join these two tables on the common column 'Patient.SSN' in the Patient table and 'Appointment.Patient' in the Appointment table.", "We want to select distinct names to avoid duplicates, so we will use SELECT DISTINCT on Patient.Name."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT Patient.Name\nFROM Patient\nJOIN Appointment ON Patient.SSN = Appointment.Patient;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\"\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["Identify the tables needed: Physician, Affiliated_With, and Department.", "We need to join these tables to get the names of physicians and their affiliated departments.", "The Physician table contains the names of the physicians.", "The Affiliated_With table links physicians to their departments and indicates primary affiliations.", "The Department table contains the names of the departments.", "We will perform an INNER JOIN between Physician and Affiliated_With on EmployeeID and Physician, respectively.", "Then, we will perform another INNER JOIN between Affiliated_With and Department on DepartmentID and Department, respectively.", "Finally, we will filter the results to include only those records where the affiliation is marked as primary."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name AS PhysicianName, Department.Name AS DepartmentName\nFROM Physician\nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician\nJOIN Department ON Affiliated_With.Department = Department.DepartmentID\nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\"\n}\n"}
{"sample_id": "train.3915", "db_id": "hospital_1", "question": "What are the name and primarily affiliated department name of each physician?", "rationale": ["Identify the relevant tables: Physician, Affiliated_With, and Department are needed to get the physician's name and their affiliated department name.", "Use JOIN to combine the Physician table with the Affiliated_With table on the EmployeeID and Physician columns to link physicians with their departments.", "Next, join the Department table on the DepartmentID to get the department names associated with each physician.", "Filter the results to only include those affiliations that are marked as primary by checking the PrimaryAffiliation column."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name, Department.Name \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nJOIN Department ON Affiliated_With.Department = Department.DepartmentID \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\"\n}\n"}
{"sample_id": "train.3929", "db_id": "hospital_1", "question": "Return the name of each physician and the number of patients he or she treats.", "rationale": ["We need to return the names of physicians and the number of patients they treat.", "To find the number of patients treated by each physician, we can use the 'Physician' and 'Patient' tables, along with the 'Prescribes' table which links physicians to patients through prescriptions.", "We will join the 'Physician' table with the 'Prescribes' table on the 'Physician.EmployeeID' and 'Prescribes.Physician' columns.", "Next, we will join the 'Prescribes' table with the 'Patient' table on the 'Prescribes.Patient' and 'Patient.SSN' columns to get the patient information.", "We will use the COUNT function to count the number of patients for each physician and group the results by physician name using GROUP BY."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name, COUNT(Patient.SSN) AS NumberOfPatients\nFROM Physician\nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician\nJOIN Patient ON Prescribes.Patient = Patient.SSN\nGROUP BY Physician.Name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\"\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["We need to find physicians who are in charge of more than one patient.", "The relevant tables are Physician and Prescribes, as Prescribes links physicians to patients.", "We will join the Physician table with the Prescribes table on the EmployeeID and Physician fields respectively.", "Next, we will group the results by the physician's name to count the number of distinct patients each physician is associated with.", "Finally, we will use the HAVING clause to filter the results to only include physicians who have prescribed to more than one distinct patient."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician\nJOIN Patient ON Prescribes.Patient = Patient.SSN\nGROUP BY Physician.Name\nHAVING COUNT(DISTINCT Patient.SSN) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\"\n}\n"}
{"sample_id": "train.3931", "db_id": "hospital_1", "question": "Which physicians are in charge of more than one patient? Give me their names.", "rationale": ["We need to find physicians who are in charge of more than one patient, which implies we need to look at the relationship between physicians and patients.", "The relevant table for this relationship is the 'Prescribes' table, which links physicians to patients through prescriptions.", "We will join the 'Physician' table with the 'Prescribes' table on the 'Physician.EmployeeID' and 'Prescribes.Physician'.", "Next, we will group the results by the physician's EmployeeID to count the number of distinct patients each physician is associated with.", "Finally, we will use the HAVING clause to filter out those physicians who have prescribed to more than one distinct patient, and select their names."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician\nGROUP BY Physician.EmployeeID\nHAVING COUNT(DISTINCT Prescribes.Patient) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\"\n}\n"}
{"sample_id": "train.3934", "db_id": "hospital_1", "question": "Find the number of rooms for different block code?", "rationale": ["Identify the relevant table: The Room table contains information about rooms and their block codes.", "Determine the required information: We need to count the number of rooms for each block code.", "Use the COUNT() function to count the rooms and GROUP BY BlockCode to get the count for each unique block code."], "gold_sql": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode", "source_tables": ["block", "room"], "pred_sql": "SELECT BlockCode, COUNT(RoomNumber) AS NumberOfRooms\nFROM Room\nGROUP BY BlockCode;", "hint": "\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["We need to find the number of medications prescribed for each brand.", "To do this, we will use the 'Prescribes' table to count the number of times each medication has been prescribed.", "We will join the 'Prescribes' table with the 'Medication' table on the medication code to get the brand information.", "We will group the results by the 'Brand' column from the 'Medication' table to get the count for each brand.", "Finally, we will select the brand and the count of prescriptions for that brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT Medication.Brand, COUNT(Prescribes.Medication) AS NumberOfPrescriptions\nFROM Prescribes\nJOIN Medication ON Prescribes.Medication = Medication.Code\nGROUP BY Medication.Brand;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\"\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: Prescribes and Physician.", "We need to find the physician who prescribed the highest dose, so we will focus on the Dose column in the Prescribes table.", "Join the Prescribes table with the Physician table to get the physician's name associated with each prescription.", "Order the results by the Dose in descending order to get the highest dose at the top.", "Limit the results to 1 to get only the physician with the highest dose."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT Physician.Name\nFROM Prescribes\nJOIN Physician ON Prescribes.Physician = Physician.EmployeeID\nORDER BY Prescribes.Dose DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\"\n}\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["We need to list the employee IDs of physicians along with their primary affiliation departments' IDs.", "The relevant tables are 'Physician' and 'Affiliated_With'.", "We will select the 'EmployeeID' from the 'Physician' table and the 'Department' from the 'Affiliated_With' table.", "To get the correct affiliations, we need to join the 'Physician' table with the 'Affiliated_With' table on the 'EmployeeID' and 'Physician' columns respectively.", "We also need to filter the results to only include primary affiliations, which is indicated by the 'PrimaryAffiliation' column in the 'Affiliated_With' table."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\"\n}\n"}
{"sample_id": "train.3961", "db_id": "hospital_1", "question": "What are each physician's employee id and department id primarily affiliated.", "rationale": ["Identify the required columns: EmployeeID from Physician and Department from Affiliated_With.", "Understand the relationship between Physician and Affiliated_With tables through the Physician identifier.", "Use a JOIN operation to combine the Physician and Affiliated_With tables based on the Physician identifier.", "Filter the results to include only those records where the PrimaryAffiliation is marked as 'Yes', indicating the primary department affiliation."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\"\n}\n"}
{"sample_id": "train.3970", "db_id": "hospital_1", "question": "Find the three most expensive procedures.", "rationale": ["Identify the table that contains the procedures and their costs, which is the Procedures table.", "To find the most expensive procedures, we need to select the Name and Cost columns from the Procedures table.", "We will order the results by the Cost column in descending order to get the highest costs first.", "Finally, we limit the results to the top three entries to get the three most expensive procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\"\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["Identify the table that contains the procedures and their costs, which is the Procedures table.", "To find the most costly procedures, we need to select the Name and Cost columns from the Procedures table.", "We will order the results by the Cost column in descending order to get the highest costs first.", "Finally, we limit the results to the top three entries to get the three most costly procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\"\n}\n"}
{"sample_id": "train.3973", "db_id": "hospital_1", "question": "Which physicians are trained in procedures that are more expensive than 5000?", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find physicians who are trained in procedures with a cost greater than 5000.", "Join the Physician table with the Trained_In table on the EmployeeID and Physician fields.", "Join the resulting table with the Procedures table on the Treatment and Code fields.", "Filter the results using a WHERE clause to only include procedures with a cost greater than 5000."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician\nJOIN Procedures ON Trained_In.Treatment = Procedures.Code\nWHERE Procedures.Cost > 5000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\"\n}\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "Join the Physician table with the Trained_In table on the EmployeeID and Physician columns to get the physicians and their trained procedures.", "Join the Procedures table to get the cost of each procedure that the physicians are trained in.", "Use a subquery to find the maximum cost of procedures from the Procedures table.", "Filter the results to only include physicians trained in the procedure with the maximum cost."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician\nJOIN Procedures ON Trained_In.Treatment = Procedures.Code\nWHERE Procedures.Cost = (SELECT MAX(Cost) FROM Procedures);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\"\n}\n"}
{"sample_id": "train.3985", "db_id": "hospital_1", "question": "What procedures cost less than 5000 and have John Wen as a trained physician?", "rationale": ["Identify the relevant tables: Procedures, Trained_In, and Physician.", "We need to find procedures that cost less than 5000, so we will filter the Procedures table based on the Cost column.", "We need to check if John Wen is a trained physician for these procedures, which requires joining the Trained_In table with the Physician table.", "The join condition will be based on the procedure code and the physician's employee ID.", "Finally, we will select the names of the procedures that meet both conditions."], "gold_sql": "SELECT name FROM procedures WHERE cost  <  5000 INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT Procedures.Name \nFROM Procedures \nJOIN Trained_In ON Procedures.Code = Trained_In.Treatment \nJOIN Physician ON Trained_In.Physician = Physician.EmployeeID \nWHERE Procedures.Cost < 5000 AND Physician.Name = 'John Wen';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\"\n}\n"}
{"sample_id": "train.4321", "db_id": "tracking_grants_for_research", "question": "What are the different grant amounts for documents sent before '1986-08-26 20:49:27' and after the grant ended on '1989-03-16 18:27:16'?", "rationale": ["Identify the relevant tables: Grants and Documents are needed to access grant amounts and document sent dates.", "Join the Grants table with the Documents table on the grant_id to link documents to their respective grants.", "Filter the results to include only those documents sent before '1986-08-26 20:49:27'.", "Also, filter to ensure that the grants have ended before '1989-03-16 18:27:16'.", "Select distinct grant amounts to avoid duplicates in the results."], "gold_sql": "SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  '1986-08-26 20:49:27' INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  '1989-03-16 18:27:16'", "source_tables": ["grants", "documents"], "pred_sql": "SELECT DISTINCT Grants.grant_amount \nFROM Grants \nJOIN Documents ON Grants.grant_id = Documents.grant_id \nWHERE Documents.sent_date < '1986-08-26 20:49:27' \nAND Grants.grant_end_date < '1989-03-16 18:27:16';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\"\n}\n"}
{"sample_id": "train.4322", "db_id": "tracking_grants_for_research", "question": "List the project details of the project both producing patent and paper as outcomes.", "rationale": ["Identify the main table to query from, which is the 'Projects' table for project details.", "Determine the relationships between tables: 'Projects' is linked to 'Project_Outcomes' through 'project_id', and 'Project_Outcomes' is linked to 'Research_Outcomes' through 'outcome_code'.", "Use JOIN clauses to connect 'Projects' with 'Project_Outcomes' and 'Research_Outcomes'.", "Filter the results to include only those projects that have outcomes described as 'patent' or 'paper' using a WHERE clause with IN operator."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT p.project_details \nFROM Projects p \nJOIN Project_Outcomes po ON p.project_id = po.project_id \nJOIN Research_Outcomes ro ON po.outcome_code = ro.outcome_code \nWHERE ro.outcome_description IN ('patent', 'paper');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: Grants, Organisations, and Organisation_Types.", "Determine the relationship between these tables: Grants are linked to Organisations via organisation_id, and Organisations are linked to Organisation_Types via organisation_type.", "We need to calculate the total grant amount, so we will use the SUM function on the grant_amount column from the Grants table.", "To filter the results, we will join the Organisation_Types table and apply a WHERE clause to select only those organisations described as 'research'.", "Construct the SQL query using the identified tables, relationships, and conditions."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT SUM(Grants.grant_amount) AS total_grant_amount\nFROM Grants\nJOIN Organisations ON Grants.organisation_id = Organisations.organisation_id\nJOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type\nWHERE Organisation_Types.organisation_type_description = 'research';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter based on the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.\"\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the role code for the 'Leader' role from the Staff_Roles table.", "Find the project_id(s) from the Project_Staff table where the role_code matches the Leader role.", "Group the results by project_id and count the number of staff members for each project.", "Order the projects by the count of staff members in descending order and limit the results to the top project (the one with the most staff).", "Select the date_from and date_to for the staff members working on the project identified in the previous step."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to \nFROM Project_Staff \nWHERE project_id = (\n    SELECT project_id \n    FROM Project_Staff \n    WHERE role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Leader') \n    GROUP BY project_id \n    ORDER BY COUNT(staff_id) DESC \n    LIMIT 1\n)", "hint": "\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields.", "Group the results by organisation_id and organisation_type to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_type, o.organisation_id\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id, o.organisation_type\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the relevant tables: Documents, Grants, Organisations, and Organisation_Types.", "Determine the relationships between these tables: Documents are linked to Grants via grant_id, Grants are linked to Organisations via organisation_id, and Organisations are linked to Organisation_Types via organisation_type.", "Select the 'sent_date' from the Documents table as the main output.", "Use JOIN clauses to connect the tables based on their foreign key relationships.", "Add a WHERE clause to filter grants with a grant_amount greater than 5000."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT Documents.sent_date \nFROM Documents \nJOIN Grants ON Documents.grant_id = Grants.grant_id \nJOIN Organisations ON Grants.organisation_id = Organisations.organisation_id \nJOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type \nWHERE Grants.grant_amount > 5000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\"\n}\n"}
{"sample_id": "train.4338", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects which did not hire any staff for a researcher role.", "rationale": ["We need to list project details from the 'Projects' table.", "We will use a LEFT JOIN to connect the 'Projects' table with the 'Project_Staff' table on the project_id.", "We will filter the join to only include staff members with a role code that corresponds to the 'Researcher' role.", "To find projects that did not hire any staff for a researcher role, we will check for NULL values in the staff_id from the 'Project_Staff' table after the join."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT p.project_details \nFROM Projects p \nLEFT JOIN Project_Staff ps ON p.project_id = ps.project_id AND ps.role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Researcher') \nWHERE ps.staff_id IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.4339", "db_id": "tracking_grants_for_research", "question": "What are the details for all projects that did not hire any staff in a research role?", "rationale": ["Identify the relevant tables: Projects and Project_Staff.", "We need to find projects that did not hire any staff in a research role, so we will use a LEFT JOIN between Projects and Project_Staff.", "The join condition will include a filter for staff roles that are related to research, which can be identified by checking the Staff_Roles table for role descriptions that include 'research'.", "To find projects without any associated research staff, we will check for NULL values in the staff_id column of the Project_Staff table after the join.", "Select the project_id and project_details from the Projects table for the final output."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT p.project_id, p.project_details \nFROM Projects p \nLEFT JOIN Project_Staff ps ON p.project_id = ps.project_id AND ps.role_code IN (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%research%') \nWHERE ps.staff_id IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.4342", "db_id": "tracking_grants_for_research", "question": "When do all the researcher role staff start to work, and when do they stop working?", "rationale": ["Identify the relevant table: Project_Staff contains information about staff members, including their roles and dates of involvement.", "Determine the criteria for filtering: We need to find staff members with roles related to researchers. This can be done by checking the role_code against the Staff_Roles table where the role_description contains 'researcher'.", "Select the required columns: We need to retrieve the start date (date_from) and end date (date_to) of the staff members' involvement.", "Construct the SQL query: Use a SELECT statement to get date_from and date_to from Project_Staff, applying a WHERE clause to filter by role_code that matches the researcher roles."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to \nFROM Project_Staff \nWHERE role_code IN (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%researcher%');", "hint": "\n"}
{"sample_id": "train.4350", "db_id": "tracking_grants_for_research", "question": "How many staff does each project has? List the project id and the number in an ascending order.", "rationale": ["Identify the relevant table: The question asks about staff associated with projects, so we will use the Project_Staff table.", "Count the number of staff members for each project: We will use the COUNT() function to count the staff_id for each project_id.", "Group the results by project_id: We will use GROUP BY to aggregate the counts for each project.", "Order the results in ascending order: We will use ORDER BY to sort the results by project_id in ascending order."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT project_id, COUNT(staff_id) AS staff_count\nFROM Project_Staff\nGROUP BY project_id\nORDER BY project_id ASC;", "hint": "\n"}
{"sample_id": "train.4351", "db_id": "tracking_grants_for_research", "question": "For each project id, how many staff does it have? List them in increasing order.", "rationale": ["Identify the relevant table: The question pertains to the number of staff associated with each project, so we will use the Project_Staff table.", "Count the staff members: We need to count the number of staff members for each project, which can be done using the COUNT() function.", "Group by project_id: To get the count of staff for each project, we will group the results by project_id.", "Order the results: The final output should be in increasing order of project_id, so we will use ORDER BY project_id ASC."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT project_id, COUNT(staff_id) AS staff_count\nFROM Project_Staff\nGROUP BY project_id\nORDER BY project_id ASC;", "hint": "\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes are needed to get project details and their associated outcomes.", "Join the Projects table with the Project_Outcomes table on the project_id to link projects with their outcomes.", "Group the results by project_id and project_details to aggregate the outcomes for each project.", "Count the number of outcomes for each project using COUNT(po.outcome_code).", "Order the results in descending order to get the project with the most outcomes at the top.", "Limit the results to 1 to get only the project with the highest number of outcomes."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT p.project_id, p.project_details\nFROM Projects p\nJOIN Project_Outcomes po ON p.project_id = po.project_id\nGROUP BY p.project_id, p.project_details\nORDER BY COUNT(po.outcome_code) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.4359", "db_id": "tracking_grants_for_research", "question": "What are the details of the project with no outcomes?", "rationale": ["Identify the main table to query: Projects.", "Determine the condition to find projects with no outcomes: Projects that do not have a corresponding entry in the Project_Outcomes table.", "Use a subquery to select project_ids from Project_Outcomes and filter them out from the Projects table.", "Construct the SQL query to select all columns from Projects where the project_id is not in the list of project_ids from Project_Outcomes."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT * FROM Projects WHERE project_id NOT IN (SELECT project_id FROM Project_Outcomes);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "We need to find the organisation that hired the most research staff, so we will join the Organisations table with the Research_Staff table on the organisation_id.", "We will group the results by organisation_id, organisation_type, and organisation_details to count the number of research staff for each organisation.", "We will use the COUNT function to count the number of staff members for each organisation.", "To find the organisation with the most staff, we will order the results in descending order based on the count of staff members.", "Finally, we will limit the results to 1 to get only the organisation with the highest count."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id, o.organisation_type, o.organisation_details\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff for staff involvement in projects and Staff_Roles for role descriptions.", "We need to find the role involved with the most number of projects for each staff member.", "Use a subquery to count the number of projects each role is involved in and order them to find the top role.", "Join the Project_Staff table with the Staff_Roles table to get the role descriptions.", "Select the staff_id and the corresponding role description for the role involved in the most projects."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT ps.staff_id, sr.role_description\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nWHERE ps.project_id IN (\n    SELECT project_id\n    FROM Project_Staff\n    GROUP BY project_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "hint": "\n"}
{"sample_id": "train.4364", "db_id": "tracking_grants_for_research", "question": "Which document type is described with the prefix 'Initial'?", "rationale": ["Identify the relevant table: Document_Types contains the document type descriptions.", "Determine the condition: We need to find document types with descriptions that start with 'Initial'.", "Use the SQL LIKE operator to filter descriptions that start with 'Initial'.", "Construct the SQL SELECT statement to retrieve the document_type_code and document_description from Document_Types where the description matches the condition."], "gold_sql": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'", "source_tables": ["document_types"], "pred_sql": "SELECT document_type_code, document_description FROM Document_Types WHERE document_description LIKE 'Initial%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the start dates of grants from the 'Grants' table that are associated with documents of a specific type. It uses joins to connect the 'Grants', 'Documents', and 'Document_Types' tables based on their foreign key relationships. The placeholder in the WHERE clause represents the description of the document type, allowing users to specify which document type they are interested in. The INTERSECT operation ensures that only the start dates of grants that meet the criteria in both queries are returned.\"\n}\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["Identify the relevant tables: Documents and Grants are needed to link documents to their respective grants.", "Count the number of documents for each grant by using COUNT() function on document_id.", "Group the results by grant_id to get the count of documents per grant.", "To find the document with the most occurrences, order the results by the document count in descending order.", "Limit the results to get the grant with the most documents."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT d.grant_id, COUNT(d.document_id) AS document_count, d.document_id \nFROM Documents d \nJOIN Grants g ON d.grant_id = g.grant_id \nGROUP BY d.grant_id \nORDER BY document_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\"\n}\n"}
{"sample_id": "train.4374", "db_id": "tracking_grants_for_research", "question": "How many Patent outcomes are generated from all the projects?", "rationale": ["Identify the relevant tables: Project_Outcomes and Research_Outcomes are needed to find the patent outcomes related to projects.", "Determine the relationship: Project_Outcomes has a foreign key relationship with Research_Outcomes through the outcome_code.", "Filter the results: We need to count only those outcomes that are described as 'Patent'.", "Construct the SQL query: Use COUNT(*) to count the number of patent outcomes, joining the two tables and applying the appropriate WHERE clause."], "gold_sql": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  'Patent'", "source_tables": ["project_outcomes"], "pred_sql": "SELECT COUNT(*) AS patent_outcome_count\nFROM Project_Outcomes\nJOIN Research_Outcomes ON Project_Outcomes.outcome_code = Research_Outcomes.outcome_code\nWHERE Research_Outcomes.outcome_description LIKE '%Patent%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.4376", "db_id": "tracking_grants_for_research", "question": "How many project staff worked as leaders or started working before '1989-04-24 23:51:54'?", "rationale": ["Identify the relevant table: Project_Staff contains information about staff members associated with projects.", "Determine the criteria for counting staff: We need to count staff who worked as leaders or started working before a specific date.", "Identify the role codes for leaders: Use the Staff_Roles table to find role codes where the role description includes 'leader'.", "Filter the Project_Staff table: Use a subquery to filter Project_Staff based on the role codes obtained from the Staff_Roles table and the date condition.", "Count the number of records that meet the criteria."], "gold_sql": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'", "source_tables": ["project_staff"], "pred_sql": "SELECT COUNT(*) \nFROM Project_Staff \nWHERE role_code IN (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%leader%') \nAND date_from < '1989-04-24 23:51:54';", "hint": "\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes.", "Determine the relationship between these tables: Projects is linked to Project_Outcomes via project_id, and Project_Outcomes is linked to Research_Outcomes via outcome_code.", "Formulate the SQL query to select the outcome_description from Research_Outcomes.", "Add a WHERE clause to filter the results based on the project detail 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT Research_Outcomes.outcome_description \nFROM Projects \nJOIN Project_Outcomes ON Projects.project_id = Project_Outcomes.project_id \nJOIN Research_Outcomes ON Project_Outcomes.outcome_code = Research_Outcomes.outcome_code \nWHERE Projects.project_details = 'sint';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes are needed to get the project details and their associated outcomes.", "Join the Projects table with Project_Outcomes on project_id to link projects with their outcomes.", "Join the resulting table with Research_Outcomes on outcome_code to get the descriptions of the outcomes.", "Filter the results where the project_details in the Projects table matches 'sint'.", "Select the outcome_description from the Research_Outcomes table as the final output."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT Research_Outcomes.outcome_description \nFROM Projects \nJOIN Project_Outcomes ON Projects.project_id = Project_Outcomes.project_id \nJOIN Research_Outcomes ON Project_Outcomes.outcome_code = Research_Outcomes.outcome_code \nWHERE Projects.project_details = 'sint';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.4385", "db_id": "tracking_grants_for_research", "question": "What are the details for the projects which were launched by the organization with the most projects?", "rationale": ["Identify the requirement: We need to find details of projects launched by the organization with the most projects.", "Determine the relevant tables: The 'Projects' table contains the project details and the 'organisation_id' to identify the organization.", "Use a subquery to find the organization with the most projects: We can group the 'Projects' table by 'organisation_id' and count the number of projects for each organization, ordering by the count in descending order and limiting the result to 1.", "Use the result of the subquery to filter the main query: The main query will select all columns from the 'Projects' table where the 'organisation_id' matches the one returned by the subquery."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT * FROM Projects WHERE organisation_id = (SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY COUNT(project_id) DESC LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.4391", "db_id": "tracking_grants_for_research", "question": "For each project id, how many tasks are there?", "rationale": ["Identify the relevant table: The question asks about tasks associated with projects, so we will use the 'Tasks' table.", "Count the number of tasks for each project: We need to group the results by 'project_id' and count the 'task_id' for each group.", "Construct the SQL query: We will select 'project_id' and the count of 'task_id' as 'task_count', and group the results by 'project_id'."], "gold_sql": "SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id", "source_tables": ["tasks", "projects"], "pred_sql": "SELECT project_id, COUNT(task_id) AS task_count\nFROM Tasks\nGROUP BY project_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\"\n}\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["Identify the relevant table for staff roles, which is 'Staff_Roles'.", "Select the columns 'role_code' and 'role_description' from the 'Staff_Roles' table to get the information about staff roles."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, role_description FROM Staff_Roles;", "hint": "\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["Identify the table that contains staff roles, which is 'Project_Staff'.", "To find the most common role, we need to count the occurrences of each role code in the 'Project_Staff' table.", "Use the COUNT() function to count the number of staff members for each role code.", "Group the results by 'role_code' to aggregate the counts for each role.", "Order the results in descending order based on the count to get the most common role at the top.", "Limit the results to 1 to get only the most common role."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count \nFROM Project_Staff \nGROUP BY role_code \nORDER BY role_count DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to count the number of products, so we will use the COUNT() function.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to filter by category.", "Add a WHERE clause to filter for products in the 'Spices' category.", "Add another condition in the WHERE clause to filter for products with a typical selling price greater than 1000."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT COUNT(*) AS product_count \nFROM Products \nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code \nWHERE Ref_Product_Categories.product_category_description = 'Spices' \nAND Products.typical_selling_price > 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to retrieve the product category descriptions, so we will select from Ref_Product_Categories.", "Join the Products table with Ref_Product_Categories on the product_category_code to link products to their categories.", "Filter the products based on their descriptions containing the letter 't' using the LIKE operator.", "Use DISTINCT to ensure that we only get unique category descriptions."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description \nFROM Products p \nJOIN Ref_Product_Categories rpc ON p.product_category_code = rpc.product_category_code \nWHERE p.product_description LIKE '%t%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query filters the results based on the product's name and the type of characteristic, using placeholders for both values.\"\n}\n"}
{"sample_id": "train.5576", "db_id": "products_gen_characteristics", "question": "Count the products that have the color description \"white\" or have the characteristic name \"hot\".", "rationale": ["Identify the tables involved: Products, Ref_Colors, Product_Characteristics, and Characteristics.", "Determine the relationships between these tables using foreign keys: Products links to Ref_Colors via color_code, and to Product_Characteristics via product_id. Product_Characteristics links to Characteristics via characteristic_id.", "Use LEFT JOINs to include all products, even if they don't have a matching color or characteristic.", "In the WHERE clause, filter for products that either have the color description 'white' or the characteristic name 'hot'.", "Count the distinct product IDs to avoid counting the same product multiple times if it meets both criteria."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT p.product_id) AS product_count\nFROM Products p\nLEFT JOIN Ref_Colors c ON p.color_code = c.color_code\nLEFT JOIN Product_Characteristics pc ON p.product_id = pc.product_id\nLEFT JOIN Characteristics ch ON pc.characteristic_id = ch.characteristic_id\nWHERE c.color_description = 'white' OR ch.characteristic_name = 'hot';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using joins based on their relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\"\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: We need to find the unit of measure for 'Herb' products, which involves the Products and Ref_Product_Categories tables.", "Join the Products table with Ref_Product_Categories to access the unit_of_measure column.", "Use the Product_Characteristics and Characteristics tables to ensure we are filtering by the correct product name ('Herb').", "Construct the SQL query to select the unit_of_measure for products with the name 'Herb'."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT pc.unit_of_measure \nFROM Ref_Product_Categories rpc \nJOIN Products p ON rpc.product_category_code = p.product_category_code \nJOIN Product_Characteristics pc ON p.product_id = pc.product_id \nJOIN Characteristics c ON pc.characteristic_id = c.characteristic_id \nWHERE p.product_name = 'Herb';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the columns needed: unit_of_measure from Ref_Product_Categories and product_category_code from Products.", "Establish the relationship between the tables using the foreign key: Products.product_category_code = Ref_Product_Categories.product_category_code.", "Filter the results to only include the product named 'chervil'.", "Construct the SQL SELECT statement to retrieve the desired columns."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT pc.product_category_code, p.product_name, p.unit_of_measure \nFROM Products p \nJOIN Ref_Product_Categories pc ON p.product_category_code = pc.product_category_code \nWHERE p.product_name = 'chervil';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5589", "db_id": "products_gen_characteristics", "question": "What are the names of products that are not 'white' in color and are not measured by the unit 'Handful'?", "rationale": ["Identify the relevant tables: Products, Ref_Colors, Product_Characteristics, Characteristics, and Ref_Product_Categories.", "Join the Products table with Ref_Colors to filter out products that are white in color.", "Join the Products table with Product_Characteristics to access the characteristics of each product.", "Join the Product_Characteristics table with Characteristics to ensure we can filter based on characteristic names if needed.", "Join the Products table with Ref_Product_Categories to filter out products measured by the unit 'Handful'.", "Construct the WHERE clause to exclude products that are 'white' and those measured by 'Handful'.", "Select the product names from the resulting dataset."], "gold_sql": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  'white' AND t2.unit_of_measure != 'Handful'", "source_tables": ["products", "ref_colors", "ref_product_categories"], "pred_sql": "SELECT Products.product_name \nFROM Products \nJOIN Ref_Colors ON Products.color_code = Ref_Colors.color_code \nJOIN Product_Characteristics ON Products.product_id = Product_Characteristics.product_id \nJOIN Characteristics ON Product_Characteristics.characteristic_id = Characteristics.characteristic_id \nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code \nWHERE Ref_Colors.color_description != 'white' \nAND Ref_Product_Categories.unit_of_measure != 'Handful';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using joins based on their relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\"\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["We need to find the color description used by the least number of products.", "To do this, we will join the 'Ref_Colors' table with the 'Products' table on the 'color_code' column.", "We will group the results by 'color_code' to count how many products are associated with each color.", "We will order the results in ascending order based on the count of products, so that the color with the least products comes first.", "Finally, we will limit the results to just one entry to get the color description used by the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT c.color_description\nFROM Ref_Colors c\nJOIN Products p ON c.color_code = p.color_code\nGROUP BY c.color_code\nORDER BY COUNT(p.product_id) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using joins based on their relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\"\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To do this, we will join the 'Characteristics' table with the 'Product_Characteristics' table to link characteristics to products.", "Next, we will join the 'Products' table to get the product information associated with each characteristic.", "We will group the results by the characteristic name to count how many distinct products each characteristic is associated with.", "Finally, we will use the HAVING clause to filter the results to only include characteristics that are linked to two or more distinct products."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT c.characteristic_name\nFROM Characteristics c\nJOIN Product_Characteristics pc ON c.characteristic_id = pc.characteristic_id\nJOIN Products p ON pc.product_id = p.product_id\nGROUP BY c.characteristic_name\nHAVING COUNT(DISTINCT p.product_id) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query filters the results based on the product's name and the type of characteristic, using placeholders for both values.\"\n}\n"}
{"sample_id": "train.5669", "db_id": "dorm_1", "question": "What are the names of the all-female dorms?", "rationale": ["Identify the table that contains information about dormitories, which is the 'Dorm' table.", "Determine the relevant column that specifies the gender designation for the dormitory, which is the 'gender' column.", "Formulate a SQL query to select the 'dorm_name' from the 'Dorm' table where the 'gender' is 'F' for all-female dorms."], "gold_sql": "SELECT dorm_name FROM dorm WHERE gender  =  'F'", "source_tables": ["dorm"], "pred_sql": "SELECT dorm_name FROM Dorm WHERE gender = 'F';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\"\n}\n"}
{"sample_id": "train.5688", "db_id": "dorm_1", "question": "Find the average and total capacity of dorms for the students with gender X.", "rationale": ["Identify the tables involved: Dorm, Lives_in, and Student.", "We need to calculate the average and total capacity of dorms, so we will use the AVG() and SUM() functions on the 'student_capacity' column from the Dorm table.", "To find the relevant dorms, we need to join the Dorm table with the Lives_in table on 'dormid', and then join the Lives_in table with the Student table on 'stuid'.", "We need to filter the results based on the gender of the students, which is specified in the WHERE clause as 'Student.Sex = 'X'.", "Finally, we select the average and total capacity from the resulting joined tables."], "gold_sql": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  'X'", "source_tables": ["dorm"], "pred_sql": "SELECT AVG(Dorm.student_capacity) AS average_capacity, SUM(Dorm.student_capacity) AS total_capacity\nFROM Dorm\nJOIN Lives_in ON Dorm.dormid = Lives_in.dormid\nJOIN Student ON Lives_in.stuid = Student.StuID\nWHERE Student.Sex = 'X';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\"\n}\n"}
{"sample_id": "train.5699", "db_id": "dorm_1", "question": "What are the names and types of the dorms that have a capacity greater than 300 or less than 100?", "rationale": ["Identify the relevant table: The Dorm table contains information about dormitories, including their names and capacities.", "Determine the columns needed: We need the dorm_name and student_capacity columns from the Dorm table.", "Establish the condition: We want dorms with a capacity greater than 300 or less than 100.", "Construct the SQL query: Use a SELECT statement to retrieve the required columns from the Dorm table, applying the specified conditions in the WHERE clause."], "gold_sql": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100", "source_tables": ["dorm"], "pred_sql": "SELECT dorm_name, student_capacity \nFROM Dorm \nWHERE student_capacity > 300 OR student_capacity < 100;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\"\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables needed: We need to count students, so we will use the 'Student' and 'Lives_in' tables, and we also need to filter by dormitory gender, so we will include the 'Dorm' table.", "Join the tables: We will join 'Student' with 'Lives_in' on the student ID (StuID) and 'Lives_in' with 'Dorm' on the dormitory ID (dormid).", "Filter for male dorms: We will add a WHERE clause to filter the results to only include dorms where the gender is 'male'.", "Count the total number of students: We will use COUNT(*) to get the total number of students who meet the criteria."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(*) AS total_students\nFROM Student s\nJOIN Lives_in l ON s.StuID = l.stuid\nJOIN Dorm d ON l.dormid = d.dormid\nWHERE d.gender = 'male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\"\n}\n"}
{"sample_id": "train.5755", "db_id": "dorm_1", "question": "What is the most common amenity in the dorms?", "rationale": ["To find the most common amenity in the dorms, we need to count the occurrences of each amenity.", "The 'Has_amenity' table links dormitories to their amenities, so we will use this table to get the amenity data.", "We will join the 'Has_amenity' table with the 'Dorm' table to ensure we are counting amenities associated with existing dorms.", "We will group the results by the amenity ID to count how many times each amenity appears.", "Finally, we will order the results in descending order based on the count of amenities and limit the result to 1 to get the most common amenity."], "gold_sql": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_amenity", "dorm_amenity"], "pred_sql": "SELECT ha.amenid, COUNT(*) as amenity_count\nFROM Has_amenity ha\nJOIN Dorm d ON ha.dormid = d.dormid\nGROUP BY ha.amenid\nORDER BY amenity_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\"\n}\n"}
{"sample_id": "train.5757", "db_id": "dorm_1", "question": "What are the first names of all students who live in the dorm with the most amenities?", "rationale": ["Identify the tables needed: 'Student' for student names and 'Lives_in' for dormitory information.", "Join the 'Student' table with the 'Lives_in' table on the student ID to get the first names of students along with their dormitory IDs.", "Use a subquery to find the dormitory ID that has the most amenities by counting the number of amenities in the 'Has_amenity' table, grouping by dormitory ID, and ordering by the count in descending order.", "Limit the subquery to return only the dormitory with the highest count of amenities.", "Filter the main query to only include students who live in the dormitory identified by the subquery."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT S.Fname \nFROM Student S \nJOIN Lives_in L ON S.StuID = L.stuid \nWHERE L.dormid = (\n    SELECT H.dormid \n    FROM Has_amenity H \n    GROUP BY H.dormid \n    ORDER BY COUNT(H.amenid) DESC \n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\"\n}\n"}
{"sample_id": "train.5776", "db_id": "customer_complaints", "question": "Find the emails of customers who has filed a complaints of the product with the most complaints.", "rationale": ["Identify the need to find emails of customers who filed complaints.", "Understand that we need to join the Customers table with the Complaints table to access customer emails related to complaints.", "Determine that we need to find the product with the most complaints by grouping the Complaints table by product_id and counting the number of complaints for each product.", "Use a subquery to find the product_id that has the maximum count of complaints.", "Finally, select the email addresses of customers who filed complaints for that specific product."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address\nFROM Customers c\nJOIN Complaints co ON c.customer_id = co.customer_id\nWHERE co.product_id = (\n    SELECT product_id\n    FROM Complaints\n    GROUP BY product_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\"\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the main goal: Retrieve the email addresses of customers who have filed complaints about the product with the greatest number of complaints.", "Understand the relationships between tables: Customers are linked to Complaints through customer_id, and Complaints are linked to Products through product_id.", "To find the product with the greatest number of complaints, a subquery is needed that counts complaints grouped by product_id and orders them in descending order, limiting the result to the top product.", "Join the Customers table with the Complaints table to get the email addresses of customers who filed complaints about the identified product."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address\nFROM Customers c\nJOIN Complaints comp ON c.customer_id = comp.customer_id\nWHERE comp.product_id = (\n    SELECT product_id\n    FROM Complaints\n    GROUP BY product_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.5779", "db_id": "customer_complaints", "question": "Return the names of products that have had complaints filed by the customer who has filed the fewest complaints.", "rationale": ["Identify the need to find product names associated with complaints.", "Understand that we need to join the Products table with the Complaints table based on the product_id.", "Recognize that we need to filter the complaints to only those made by the customer who has filed the fewest complaints.", "To find the customer with the fewest complaints, we can use a subquery that groups complaints by customer_id and orders them by the count of complaints in ascending order, limiting the result to 1.", "Combine the results of the main query and the subquery to get the desired product names."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT p.product_name \nFROM Products p \nJOIN Complaints c ON p.product_id = c.product_id \nWHERE c.customer_id = (\n    SELECT customer_id \n    FROM Complaints \n    GROUP BY customer_id \n    ORDER BY COUNT(complaint_id) ASC \n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\"\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the relevant tables: Staff, Complaints, and Products.", "We need to find the last name of the staff member handling complaints related to products.", "Join the Staff table with the Complaints table on staff_id to link staff members to their complaints.", "Join the Complaints table with the Products table on product_id to link complaints to the products.", "Order the results by product price in ascending order to find the product with the lowest price.", "Limit the results to 1 to get only the last name of the staff member handling the complaint for the lowest priced product."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT Staff.last_name \nFROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nJOIN Products ON Complaints.product_id = Products.product_id \nORDER BY Products.product_price ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.5800", "db_id": "customer_complaints", "question": "How many customers are there in the customer type with the most customers?", "rationale": ["Identify the relevant table: Customers table contains customer information including customer type.", "Count the number of customers for each customer type: Use COUNT(customer_id) to count customers grouped by customer_type_code.", "Group the results by customer type: Use GROUP BY customer_type_code to aggregate the counts for each type.", "Order the results to find the type with the most customers: Use ORDER BY customer_count DESC to sort the counts in descending order.", "Limit the results to only the top result: Use LIMIT 1 to get only the customer type with the highest count."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT customer_type_code, COUNT(customer_id) AS customer_count\nFROM Customers\nGROUP BY customer_type_code\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\"\n}\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the main goal: to find the first names of the top 5 staff members who have handled the greatest number of complaints.", "To achieve this, we need to count the number of complaints handled by each staff member. This can be done by grouping the Complaints table by staff_id and counting the complaint_id.", "Next, we will order the results in descending order based on the count of complaints to get the staff who handled the most complaints at the top.", "We will limit the results to the top 5 staff members using the LIMIT clause.", "Finally, we will select the first names of these top 5 staff members from the Staff table using a subquery that retrieves the staff_ids of the top 5 staff members."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Complaints GROUP BY staff_id ORDER BY COUNT(complaint_id) DESC LIMIT 5)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.5812", "db_id": "customer_complaints", "question": "Which state has the most customers?", "rationale": ["Identify the relevant table: The question asks about customers, so we will use the Customers table.", "Determine the required information: We need to count the number of customers in each state.", "Group the results: We will group the results by the 'state' column to get the count of customers per state.", "Order the results: We will order the results in descending order based on the count of customers to find the state with the most customers.", "Limit the results: We will limit the results to 1 to get only the state with the highest count."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT state, COUNT(customer_id) AS customer_count\nFROM Customers\nGROUP BY state\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.5813", "db_id": "customer_complaints", "question": "Give the state that has the most customers.", "rationale": ["Identify the table that contains customer information, which is the 'Customers' table.", "To find the state with the most customers, we need to count the number of customers in each state.", "Use the COUNT function to count the number of customer IDs grouped by state.", "Group the results by the 'state' column to aggregate the counts for each state.", "Order the results in descending order based on the count of customers to get the state with the most customers at the top.", "Limit the results to 1 to get only the state with the highest count."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT state, COUNT(customer_id) AS customer_count\nFROM Customers\nGROUP BY state\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.5865", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions whose share count is bigger than 100 and whose type code is \"PUR\"?", "rationale": ["Identify the tables involved: Lots, Transactions, and Transactions_Lots.", "Determine the relationship between these tables: Lots are linked to Transactions through Transactions_Lots.", "Specify the required fields: We need the 'lot_details' from the Lots table.", "Apply the conditions: We need to filter transactions where share_count is greater than 100 and the transaction type code is 'PUR'.", "Construct the SQL query using JOINs to connect the tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  100 AND T3.transaction_type_code  =  'PUR'", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT Lots.lot_details \nFROM Lots \nJOIN Transactions_Lots ON Lots.lot_id = Transactions_Lots.lot_id \nJOIN Transactions ON Transactions_Lots.transaction_id = Transactions.transaction_id \nWHERE Transactions.share_count > 100 \nAND Transactions.transaction_type_code = 'PUR';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions where the number of shares involved in the transaction is less than a specified amount. The placeholders in the WHERE clause represent the numeric value for the share count.\"\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["Identify the tables involved: We need the Transactions table for transaction amounts and the Ref_Transaction_Types table for transaction types.", "Determine the columns needed: We need the transaction type description from Ref_Transaction_Types and the amount of transaction from Transactions.", "Join the tables: We will join Transactions and Ref_Transaction_Types on the transaction_type_code to link transaction amounts with their respective types.", "Calculate the average: We will use the AVG() function to calculate the average transaction amount for each transaction type.", "Group the results: We will group the results by transaction type description to get the average for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "\n"}
{"sample_id": "train.5873", "db_id": "tracking_share_transactions", "question": "Show the number of transactions with transaction type code \"SALE\" for different investors if it is larger than 0.", "rationale": ["Identify the relevant tables: Investors and Transactions.", "We need to count the number of transactions for each investor, specifically those with a transaction type code of 'SALE'.", "Join the Investors table with the Transactions table on the investor_id to link investors with their transactions.", "Use the COUNT function to count the number of transactions for each investor where the transaction type code is 'SALE'.", "Group the results by investor_id to get the count for each investor.", "Use the HAVING clause to filter out investors with a transaction count of 0."], "gold_sql": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  'SALE' GROUP BY investor_id", "source_tables": ["transactions"], "pred_sql": "SELECT Investors.investor_id, COUNT(Transactions.transaction_id) AS transaction_count\nFROM Investors\nJOIN Transactions ON Investors.investor_id = Transactions.investor_id\nWHERE Transactions.transaction_type_code = 'SALE'\nGROUP BY Investors.investor_id\nHAVING transaction_count > 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions where the number of shares involved in the transaction is less than a specified amount. The placeholders in the WHERE clause represent the numeric value for the share count.\"\n}\n"}
{"sample_id": "train.5876", "db_id": "tracking_share_transactions", "question": "Show the transaction type code that occurs the most frequently.", "rationale": ["Identify the relevant table: The Transactions table contains the transaction_type_code that we need to analyze.", "Group the data: We need to group the results by transaction_type_code to count the occurrences of each type.", "Count occurrences: Use COUNT(*) to count how many times each transaction_type_code appears.", "Order the results: We will order the results in descending order based on the count to get the most frequent transaction type at the top.", "Limit the results: Since we only want the most frequent transaction type, we will limit the results to 1."], "gold_sql": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["transactions"], "pred_sql": "SELECT transaction_type_code\nFROM Transactions\nGROUP BY transaction_type_code\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5884", "db_id": "tracking_share_transactions", "question": "What are the details of the lots which are not used in any transactions?", "rationale": ["Identify the Lots table to retrieve details of lots.", "Determine that we need to find lots that are not associated with any transactions.", "Use a subquery to select lot_ids from the Transactions_Lots table, which links transactions to lots.", "Use the NOT IN clause to filter out those lot_ids from the Lots table, ensuring we only get lots that are not used in any transactions."], "gold_sql": "SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id", "source_tables": ["lots", "transactions_lots"], "pred_sql": "SELECT * FROM Lots WHERE lot_id NOT IN (SELECT lot_id FROM Transactions_Lots);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions where the number of shares involved in the transaction is less than a specified amount. The placeholders in the WHERE clause represent the numeric value for the share count.\"\n}\n"}
{"sample_id": "train.5893", "db_id": "cre_Theme_park", "question": "Show details of all visitors.", "rationale": ["The user wants to see details of all visitors, which means we need to select all columns from the Visitors table.", "The SQL query will be a simple SELECT statement that retrieves all records from the Visitors table."], "gold_sql": "SELECT Tourist_Details FROM VISITORS", "source_tables": ["visitors"], "pred_sql": "SELECT * FROM Visitors;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\"\n}\n"}
{"sample_id": "train.5901", "db_id": "cre_Theme_park", "question": "What is the detail of the location UK Gallery?", "rationale": ["Identify the table that contains location details, which is the 'Locations' table.", "Determine the specific column that holds the name of the location, which is 'Location_Name'.", "Formulate a SQL query to select all columns from the 'Locations' table where the 'Location_Name' matches 'UK Gallery'."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "pred_sql": "SELECT * FROM Locations WHERE Location_Name = 'UK Gallery';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5902", "db_id": "cre_Theme_park", "question": "Return the detail of the location named \"UK Gallery\".", "rationale": ["Identify the table that contains location details, which is the 'Locations' table.", "Determine the specific column that holds the name of the location, which is 'Location_Name'.", "Formulate a SQL query to select all columns from the 'Locations' table where the 'Location_Name' matches 'UK Gallery'."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "pred_sql": "SELECT * FROM Locations WHERE Location_Name = 'UK Gallery';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5914", "db_id": "cre_Theme_park", "question": "Give me the star rating descriptions of the hotels that cost more than 10000.", "rationale": ["Identify the relevant tables: Hotels and Ref_Hotel_Star_Ratings.", "Determine the columns needed: star_rating_description from Ref_Hotel_Star_Ratings and price_range from Hotels.", "Establish the relationship between the tables using the foreign key: Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code.", "Filter the results based on the price range condition: Hotels.price_range > 10000."], "gold_sql": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  10000", "source_tables": ["ref_hotel_star_ratings", "hotels"], "pred_sql": "SELECT Ref_Hotel_Star_Ratings.star_rating_description \nFROM Hotels \nJOIN Ref_Hotel_Star_Ratings ON Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code \nWHERE Hotels.price_range = 'More than 10000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["Identify the relevant tables: Museums and Tourist_Attractions.", "Determine the columns needed: Museum_ID and Museum_Details from Museums, and Opening_Hours from Tourist_Attractions.", "Establish the relationship between the tables: Museums are linked to Tourist_Attractions through the Museum_ID and Tourist_Attraction_ID.", "Construct the SQL SELECT statement to retrieve the desired columns from the joined tables."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT Museums.Museum_ID, Museums.Museum_Details, Tourist_Attractions.Opening_Hours \nFROM Museums \nJOIN Tourist_Attractions ON Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Royal_Family.", "Determine the relationship between the tables: Tourist_Attractions.Tourist_Attraction_ID is linked to Royal_Family.Royal_Family_ID.", "Select the required fields: Name, Description, and How_to_Get_There from Tourist_Attractions.", "Construct the SQL query using a JOIN to combine the two tables based on the identified relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name, Tourist_Attractions.Description, Tourist_Attractions.How_to_Get_There \nFROM Tourist_Attractions \nJOIN Royal_Family ON Tourist_Attractions.Tourist_Attraction_ID = Royal_Family.Royal_Family_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5924", "db_id": "cre_Theme_park", "question": "Find the details of the shops that can be reached by walk.", "rationale": ["Identify the relevant table for shops, which is the 'Shops' table.", "Determine the relationship between shops and tourist attractions, which is through the 'Tourist_Attraction_ID'.", "Use a JOIN to connect the 'Shops' table with the 'Tourist_Attractions' table based on the matching IDs.", "Filter the results to include only those attractions where the 'How_to_Get_There' field indicates that they can be reached by walking, using a LIKE clause."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "pred_sql": "SELECT Shops.Shop_ID, Shops.Shop_Details \nFROM Shops \nJOIN Tourist_Attractions ON Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Tourist_Attractions.How_to_Get_There LIKE '%walk%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5927", "db_id": "cre_Theme_park", "question": "What are the details of the markets that can be accessed by walk or bus?", "rationale": ["Identify the relevant table for street markets, which is 'Street_Markets'.", "Determine the need to join with 'Tourist_Attractions' to access the 'How_to_Get_There' details.", "Use a JOIN clause to connect 'Street_Markets' with 'Tourist_Attractions' on the common identifier 'Market_ID' and 'Tourist_Attraction_ID'.", "Filter the results using a WHERE clause to find markets that can be accessed by either walking or by bus, using the LIKE operator to match the relevant phrases."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "pred_sql": "SELECT Street_Markets.Market_ID, Street_Markets.Market_Details \nFROM Street_Markets \nJOIN Tourist_Attractions ON Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Tourist_Attractions.How_to_Get_There LIKE '%walk%' OR Tourist_Attractions.How_to_Get_There LIKE '%bus%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5928", "db_id": "cre_Theme_park", "question": "Find the details of all the markets that are accessible by walk or bus.", "rationale": ["Identify the relevant table for street markets, which is 'Street_Markets'.", "Determine the need to join with 'Tourist_Attractions' to access the 'How_to_Get_There' details.", "Use a JOIN clause to connect 'Street_Markets' with 'Tourist_Attractions' on the common identifier 'Market_ID' and 'Tourist_Attraction_ID'.", "Filter the results using a WHERE clause to find markets that can be accessed by either walking or by bus, using the LIKE operator to match the relevant phrases."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "pred_sql": "SELECT Street_Markets.Market_ID, Street_Markets.Market_Details \nFROM Street_Markets \nJOIN Tourist_Attractions ON Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Tourist_Attractions.How_to_Get_There LIKE '%walk%' OR Tourist_Attractions.How_to_Get_There LIKE '%bus%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "Determine the relevant column for hotel pricing, which is 'price_range'.", "To find the most expensive hotels, sort the results in descending order based on the 'price_range' column.", "Limit the results to the top three entries to get the three most expensive hotels."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5943", "db_id": "cre_Theme_park", "question": "Show the details and star ratings of the 3 least expensive hotels.", "rationale": ["Identify the relevant tables: Hotels and Ref_Hotel_Star_Ratings.", "We need to select hotel details and their star ratings, so we will select columns from both tables: hotel_id, star_rating_code, price_range, other_hotel_details from Hotels and star_rating_description from Ref_Hotel_Star_Ratings.", "Join the Hotels table with Ref_Hotel_Star_Ratings on the star_rating_code to get the star rating descriptions.", "Order the results by price_range in ascending order to get the least expensive hotels first.", "Limit the results to 3 to get only the 3 least expensive hotels."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT h.hotel_id, h.star_rating_code, h.price_range, h.other_hotel_details, r.star_rating_description\nFROM Hotels h\nJOIN Ref_Hotel_Star_Ratings r ON h.star_rating_code = r.star_rating_code\nORDER BY h.price_range ASC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Visits are needed to find out how tourists get to attractions.", "Join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID to link visits to their respective attractions.", "Select the How_to_Get_There column to find out the transportation methods used by tourists.", "Count the number of visits for each transportation method using COUNT(*) and group the results by How_to_Get_There.", "Order the results in descending order based on the count of visits to find the most popular transportation method.", "Limit the results to 1 to get only the top transportation method."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Visit_Count\nFROM Tourist_Attractions\nJOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID\nGROUP BY How_to_Get_There\nORDER BY Visit_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant tables: We need to look at the Visits table to see how many times each transportation method (How_to_Get_There) has been used to visit tourist attractions.", "Join the Visits table with the Tourist_Attractions table to access the transportation method used for each visit.", "Group the results by the transportation method to count how many times each method has been used.", "Order the results in descending order to find the most frequently used transportation method.", "Limit the results to 1 to get only the top transportation method."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Visit_Count\nFROM Visits\nJOIN Tourist_Attractions ON Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID\nGROUP BY How_to_Get_There\nORDER BY Visit_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5951", "db_id": "cre_Theme_park", "question": "Show different tourist attractions' names, ids, and the corresponding number of visits.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Visits.", "We need to select the names and IDs of tourist attractions, which are in the Tourist_Attractions table.", "We also need to count the number of visits for each attraction, which can be done by counting the Tourist_ID in the Visits table.", "Join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID to link visits to the corresponding attractions.", "Group the results by the Tourist_Attraction_ID and Name to get the count of visits for each attraction."], "gold_sql": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT ta.Name AS Tourist_Attraction_Name, ta.Tourist_Attraction_ID, COUNT(v.Tourist_ID) AS Number_of_Visits\nFROM Tourist_Attractions ta\nJOIN Visits v ON ta.Tourist_Attraction_ID = v.Tourist_Attraction_ID\nGROUP BY ta.Tourist_Attraction_ID, ta.Name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["Identify the relevant tables: Tourist_Attractions for attraction names, Tourist_Attraction_Features for linking attractions to their features, and Features for feature details.", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table on the Tourist_Attraction_ID to get the features associated with each attraction.", "Join the resulting table with the Features table on Feature_ID to access the feature details.", "Filter the results using a WHERE clause to include only those attractions that have 'parking' or 'shopping' as their feature details."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT Tourist_Attractions.Name\nFROM Tourist_Attractions\nJOIN Tourist_Attraction_Features ON Tourist_Attractions.Tourist_Attraction_ID = Tourist_Attraction_Features.Tourist_Attraction_ID\nJOIN Features ON Tourist_Attraction_Features.Feature_ID = Features.Feature_ID\nWHERE Features.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find the names of tourist attractions that have specific features (parking or shopping).", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table on the Tourist_Attraction_ID to link attractions with their features.", "Then, join the Features table to get the feature details associated with each attraction.", "Use a WHERE clause to filter the results to only include attractions that have 'parking' or 'shopping' as their feature details."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT ta.Name \nFROM Tourist_Attractions ta \nJOIN Tourist_Attraction_Features taf ON ta.Tourist_Attraction_ID = taf.Tourist_Attraction_ID \nJOIN Features f ON taf.Feature_ID = f.Feature_ID \nWHERE f.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5964", "db_id": "cre_Theme_park", "question": "Which tourist attractions do the tourists Vincent and Marcelle visit? Tell me the names of the attractions.", "rationale": ["Identify the relevant tables: Tourist_Attractions for attraction names, Visits for linking tourists to attractions, and Visitors for tourist details.", "Join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID to get the attractions visited by tourists.", "Join the resulting table with the Visitors table on Tourist_ID to filter the results based on specific tourists.", "Use a WHERE clause to specify the names of the tourists, Vincent and Marcelle, using their details.", "Select the names of the tourist attractions from the final joined table."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT ta.Name\nFROM Tourist_Attractions ta\nJOIN Visits v ON ta.Tourist_Attraction_ID = v.Tourist_Attraction_ID\nJOIN Visitors vi ON v.Tourist_ID = vi.Tourist_ID\nWHERE vi.Tourist_Details IN ('Vincent', 'Marcelle')\nGROUP BY ta.Name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.6059", "db_id": "customers_and_addresses", "question": "What is the average amount of items ordered in each order?", "rationale": ["To find the average amount of items ordered in each order, we need to focus on the 'Order_Items' table, which contains the 'order_quantity' for each product in an order.", "We can use the AVG() function to calculate the average of the 'order_quantity' column.", "The SQL query will select the average of 'order_quantity' from the 'Order_Items' table."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "pred_sql": "SELECT AVG(order_quantity) AS average_items_ordered\nFROM Order_Items;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.\"\n}\n"}
{"sample_id": "train.6066", "db_id": "customers_and_addresses", "question": "Find the payment method that is used most frequently.", "rationale": ["Identify the relevant table: The question asks about payment methods, which are stored in the Customers table.", "Count the occurrences of each payment method: We need to count how many times each payment method appears in the Customers table.", "Group the results by payment method: This allows us to aggregate the counts for each unique payment method.", "Order the results by frequency: We want to sort the payment methods by their count in descending order to find the most frequently used one.", "Limit the results to the top entry: Since we only want the most frequently used payment method, we will limit the results to 1."], "gold_sql": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT payment_method, COUNT(payment_method) AS frequency\nFROM Customers\nGROUP BY payment_method\nORDER BY frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses are needed to find the city associated with each customer.", "Join the Customers table with Customer_Addresses on customer_id to link customers to their addresses.", "Join the resulting table with Addresses on address_id to access the city information.", "Group the results by city to count the number of customers in each city using COUNT(c.customer_id).", "Order the results in descending order based on the customer count to find the city with the most customers.", "Limit the results to 1 to get only the city with the highest number of customers."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT a.city, COUNT(c.customer_id) AS customer_count\nFROM Customers c\nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id\nJOIN Addresses a ON ca.address_id = a.address_id\nGROUP BY a.city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6098", "db_id": "customers_and_addresses", "question": "Find the contact channel code that was used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "We need to find the contact channel code for a specific customer, so we will join the Customers table with the Customer_Contact_Channels table on the customer_id.", "Filter the results to only include the customer named 'Tillman Ernser'.", "Select the channel_code from the Customer_Contact_Channels table."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT Customer_Contact_Channels.channel_code \nFROM Customers \nJOIN Customer_Contact_Channels ON Customers.customer_id = Customer_Contact_Channels.customer_id \nWHERE Customers.customer_name = 'Tillman Ernser';", "hint": "\n"}
{"sample_id": "train.6099", "db_id": "customers_and_addresses", "question": "What is the \"active to date\" of the latest contact channel used by \"Tillman Ernser\"?", "rationale": ["Identify the relevant tables: We need to look at the Customer_Contact_Channels table for the 'active to date' and the Customers table to find the customer by name.", "Join the Customer_Contact_Channels table with the Customers table on the customer_id to link contact channels to the specific customer.", "Filter the results to only include the customer named 'Tillman Ernser'.", "Order the results by 'active_from_date' in descending order to get the latest contact channel first.", "Limit the results to 1 to get only the latest 'active to date'."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT Customer_Contact_Channels.active_to_date \nFROM Customer_Contact_Channels \nJOIN Customers ON Customer_Contact_Channels.customer_id = Customers.customer_id \nWHERE Customers.customer_name = 'Tillman Ernser' \nORDER BY Customer_Contact_Channels.active_from_date DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the customer ID for 'Tillman Ernser' from the Customers table.", "Use the identified customer ID to find the active contact channels in the Customer_Contact_Channels table.", "Sort the results by 'active_from_date' in descending order to get the latest contact channel.", "Limit the results to 1 to get only the latest contact channel's 'active_to_date'."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT active_to_date \nFROM Customer_Contact_Channels \nWHERE customer_id = (\n    SELECT customer_id \n    FROM Customers \n    WHERE customer_name = 'Tillman Ernser'\n) \nORDER BY active_from_date DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["Identify the relevant table: The question pertains to contact channels, which are stored in the 'Customer_Contact_Channels' table.", "Determine the relevant columns: We need the 'active_from_date' and 'active_to_date' columns to calculate the time span of each contact channel.", "Calculate the time span: The time span can be calculated by subtracting 'active_from_date' from 'active_to_date'. In SQLite, we can use the 'julianday' function to convert these dates into a format that allows for subtraction.", "Calculate the average: We can use the 'AVG' function to find the average of these time spans.", "Filter out inactive channels: We should only consider channels that have an 'active_to_date' that is not null, as this indicates that the channel was active for a certain period."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_time_span\nFROM Customer_Contact_Channels\nWHERE active_to_date IS NOT NULL;", "hint": "\n"}
{"sample_id": "train.6102", "db_id": "customers_and_addresses", "question": "Compute the average active time span of contact channels.", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the data about contact channels and their active periods.", "Determine the columns needed: active_from_date and active_to_date are necessary to calculate the active time span.", "Calculate the time span: Use the julianday function to convert the dates to Julian day numbers and subtract to find the difference in days.", "Compute the average: Use the AVG function to calculate the average of the active time spans.", "Filter out inactive channels: Ensure that only channels with a non-null active_to_date are considered, as these represent channels that have been deactivated."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_active_time_span\nFROM Customer_Contact_Channels\nWHERE active_to_date IS NOT NULL;", "hint": "\n"}
{"sample_id": "train.6104", "db_id": "customers_and_addresses", "question": "Return the channel code and contact number of the customer contact channel whose active duration was the longest.", "rationale": ["Identify the relevant table: The question asks for information from the 'Customer_Contact_Channels' table, specifically the 'channel_code' and 'contact_number'.", "Determine the criteria for selection: We need to find the contact channel with the longest active duration. This can be calculated by subtracting 'active_from_date' from 'active_to_date'.", "Sort the results: To find the longest active duration, we can order the results by the duration in descending order.", "Limit the results: Since we only need the channel with the longest duration, we will limit the results to 1."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT channel_code, contact_number\nFROM Customer_Contact_Channels\nORDER BY (julianday(active_to_date) - julianday(active_from_date)) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.\"\n}\n"}
{"sample_id": "train.6105", "db_id": "customers_and_addresses", "question": "Find the name and active date of the customer that use email as the contact channel.", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "We need to retrieve the customer name and the active date of the contact channel.", "Join the Customers table with the Customer_Contact_Channels table on customer_id to link customers with their contact channels.", "Filter the results to include only those contact channels where the channel_code is 'email'.", "To ensure we only get currently active email channels, we check that active_to_date is NULL."], "gold_sql": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT c.customer_name, cc.active_from_date \nFROM Customers c \nJOIN Customer_Contact_Channels cc ON c.customer_id = cc.customer_id \nWHERE cc.channel_code = 'email' AND cc.active_to_date IS NULL;", "hint": "\n"}
{"sample_id": "train.6127", "db_id": "customers_and_addresses", "question": "Who made the latest order?", "rationale": ["Identify the relevant tables: Customers and Customer_Orders.", "We need to find the customer who made the latest order, so we will join the Customers table with the Customer_Orders table on customer_id.", "To find the latest order, we will use a subquery to get the maximum order_date from the Customer_Orders table.", "Finally, we will select the customer_name from the Customers table where the order_date matches the maximum order_date."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT 1", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT c.customer_name \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nWHERE co.order_date = (SELECT MAX(order_date) FROM Customer_Orders);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.\"\n}\n"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["Identify the tables involved: Products, Order_Items, and Customer_Orders.", "We need to find the product with the largest total order quantity, which means we will sum the order quantities from the Order_Items table.", "Join the Products table with the Order_Items table on product_id to access the order quantities for each product.", "Group the results by product_id to calculate the total order quantity for each product.", "Order the results in descending order based on the total order quantity.", "Limit the results to 1 to get the product with the largest total order quantity."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Products.product_id, Products.product_details\nFROM Products\nJOIN Order_Items ON Products.product_id = Order_Items.product_id\nGROUP BY Products.product_id\nORDER BY SUM(Order_Items.order_quantity) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.\"\n}\n"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The Addresses table contains the information about addresses, including city and state.", "Determine the conditions: We need to find addresses in two specific cities (East Julianaside and Gleasonmouth) and their corresponding states (Texas and Arizona).", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the Addresses table where the city and state match the specified criteria.", "Combine the conditions using OR to ensure that either of the two city-state pairs can be returned."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6134", "db_id": "customers_and_addresses", "question": "What are all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant tables: We need to retrieve addresses, so we will focus on the 'Addresses' table.", "Determine the filtering criteria: The question specifies two cities (East Julianaside and Gleasonmouth) and their respective states (Texas and Arizona).", "Construct the WHERE clause: We need to filter the results to include addresses that match either of the specified cities and states.", "Combine the conditions using OR: Since we want addresses from either city, we will use the OR operator to combine the conditions for both cities and states.", "Select all columns: Since the question asks for all addresses, we will use SELECT * to retrieve all columns from the Addresses table."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["Identify the table that contains the competition information, which is the 'match' table.", "Determine that we need to select the 'Match_ID' from the 'match' table where the competition name matches '1994 FIFA World Cup qualification'.", "Use a subquery to find the competition identifier for '1994 FIFA World Cup qualification' and retrieve the corresponding 'Match_ID'."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "pred_sql": "SELECT Match_ID FROM match WHERE Competition = (SELECT Competition FROM match WHERE Competition = '1994 FIFA World Cup qualification');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\"\n}\n"}
{"sample_id": "train.6275", "db_id": "city_record", "question": "Find the city that hosted the most events.", "rationale": ["To find the city that hosted the most events, we need to count the number of matches hosted by each city.", "We will use the 'hosting_city' table, which contains the 'Host_City' and 'Match_ID' columns.", "We will group the results by 'Host_City' to aggregate the count of matches for each city.", "We will use the COUNT function to count the number of matches for each city.", "To get the city with the most events, we will order the results in descending order based on the count of matches.", "Finally, we will limit the results to 1 to get only the city that hosted the most events."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "pred_sql": "SELECT Host_City, COUNT(Match_ID) AS Event_Count\nFROM hosting_city\nGROUP BY Host_City\nORDER BY Event_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\"\n}\n"}
{"sample_id": "train.6282", "db_id": "city_record", "question": "Which three cities have the largest regional population?", "rationale": ["Identify the table that contains the relevant data: the 'city' table has the 'Regional_Population' column.", "We need to select the 'City' and 'Regional_Population' columns from the 'city' table.", "To find the cities with the largest populations, we will order the results by 'Regional_Population' in descending order.", "To limit the results to only the top three cities, we will use the 'LIMIT' clause with a value of 3."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "pred_sql": "SELECT City, Regional_Population FROM city ORDER BY Regional_Population DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6283", "db_id": "city_record", "question": "What are the three largest cities in terms of regional population?", "rationale": ["Identify the table that contains the relevant data: the 'city' table has the 'City' and 'Regional_Population' columns.", "To find the largest cities by population, we need to sort the results by 'Regional_Population' in descending order.", "We want only the top three results, so we will use the LIMIT clause to restrict the output to 3 rows."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "pred_sql": "SELECT City, Regional_Population FROM city ORDER BY Regional_Population DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables: 'city' for city names and 'temperature' for temperature data.", "We need to find the city with the highest temperature in February, so we will focus on the 'Feb' column in the 'temperature' table.", "Join the 'city' table with the 'temperature' table on 'City_ID' to get the city names along with their February temperatures.", "Order the results by the February temperature in descending order to get the highest temperature at the top.", "Limit the results to 1 to get only the city with the highest temperature."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, t.Feb \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nORDER BY t.Feb DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables.", "Determine the columns needed: We need the city name and the average temperatures for March, July, and October.", "Establish the relationship between tables: The 'temperature' table is linked to the 'city' table via 'City_ID'.", "Formulate the conditions: We want cities where the temperature in March is lower than in July or higher than in October.", "Construct the SQL query: Use a SELECT statement to retrieve the city names and temperatures, applying the necessary JOIN and WHERE clauses."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, t.Mar, t.Jul, t.Oct \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Jul OR t.Mar > t.Oct;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6290", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in July and which have also served as host cities?", "rationale": ["Identify the relevant tables: city, temperature, and hosting_city.", "We need to find cities where the average temperature in March (t.Mar) is lower than in July (t.Jul).", "We also need to ensure that these cities have hosted a match, which is indicated by the hosting_city table.", "Join the city table with the temperature table on City_ID to access temperature data.", "Join the resulting table with the hosting_city table to filter for cities that have hosted matches.", "Use a WHERE clause to filter for cities where the temperature in March is less than in July."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City, c.City_ID \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nJOIN hosting_city h ON c.City_ID = h.Host_City \nWHERE t.Mar < t.Jul;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables to get city names and their temperature data.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Filter the results to find cities where the average temperature in March (t.Mar) is less than the average temperature in December (t.Dec).", "Additionally, we need to ensure that these cities have never served as host cities, which requires checking against the 'hosting_city' table.", "Use a subquery to select all 'Host_City' entries from the 'hosting_city' table and exclude these from our main query using NOT IN."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6295", "db_id": "city_record", "question": "Which cities have higher temperature in Feb than in Jun or have once served as host cities?", "rationale": ["Identify the relevant tables: city, temperature, and hosting_city.", "We need to find cities with higher temperatures in February than in June, which requires joining the city and temperature tables on City_ID.", "Additionally, we need to check if the city has hosted a match, which involves joining the city table with the hosting_city table on Host_City.", "The condition for higher temperature in February than in June is expressed as t.Feb > t.Jun.", "The condition for having hosted a match is expressed as h.Host_City IS NOT NULL.", "We use a LEFT JOIN for hosting_city to ensure we still get cities that meet the temperature condition even if they haven't hosted a match.", "Finally, we select distinct city names that meet either of the conditions using a WHERE clause with an OR operator."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT DISTINCT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nLEFT JOIN hosting_city h ON c.City_ID = h.Host_City \nWHERE (t.Feb > t.Jun) OR (h.Host_City IS NOT NULL);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6324", "db_id": "e_government", "question": "Find the last name of the first ever contact person of the organization with the highest UK Vat number.", "rationale": ["Identify the organization with the highest UK VAT number by using a subquery to select the maximum value from the Organizations table.", "Join the Organizations table with the Organization_Contact_Individuals table to link organizations with their contact individuals.", "Join the Individuals table to get the last names of the individuals who contacted the organization.", "Filter the results to only include the organization with the highest UK VAT number.", "Order the results by the start date of the contact period to find the first contact person.", "Limit the results to 1 to get only the first contact person's last name."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.uk_vat_number  =  (SELECT max(uk_vat_number) FROM organizations) ORDER BY t2.date_contact_to ASC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "pred_sql": "SELECT i.individual_last_name \nFROM Organizations o \nJOIN Organization_Contact_Individuals oci ON o.organization_id = oci.organization_id \nJOIN Individuals i ON oci.individual_id = i.individual_id \nWHERE o.uk_vat_number = (SELECT MAX(uk_vat_number) FROM Organizations) \nORDER BY oci.date_contact_from \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names of individuals who have contacted a specific organization. It retrieves data from the 'Organizations', 'Organization_Contact_Individuals', and 'Individuals' tables, filtering based on the organization's name. The results are ordered by the end date of the contact period, and a limit is applied to the number of results returned.\"\n}\n"}
{"sample_id": "train.6328", "db_id": "e_government", "question": "Find name of the services that has never been used.", "rationale": ["Identify the table that contains the service names, which is the Services table.", "We need to find services that have never been used, which means we need to check against the Party_Services table where service bookings are recorded.", "To find services that have never been used, we can select service names from the Services table where the service_id is not present in the Party_Services table.", "Construct the SQL query using a subquery to filter out the used services from the Services table."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "pred_sql": "SELECT service_name \nFROM Services \nWHERE service_id NOT IN (SELECT service_id FROM Party_Services);", "hint": "\n"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table: The question asks for cities and states, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' for cities and 'state_province_county' for states.", "Use DISTINCT to avoid duplicate entries: Since we want the names of all cities and states, using DISTINCT will ensure that we only get unique combinations.", "Construct the SQL query: Combine the selected columns and the table name into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6331", "db_id": "e_government", "question": "What are the names of all cities and states?", "rationale": ["Identify the relevant table: The question asks for city and state names, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' and 'state_province_county' from the Addresses table.", "Use DISTINCT to avoid duplicate entries: Since cities and states may repeat, we use DISTINCT to get unique combinations.", "Construct the SQL query: Combine the selected columns and table into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the relevant tables: Organization_Contact_Individuals, Individuals, and Organizations.", "We need to retrieve the last names of individuals, so we will select Individuals.individual_last_name.", "To link the individuals to the organizations they contacted, we will join Organization_Contact_Individuals with Individuals on individual_id.", "We also need to join Organizations to ensure we are considering the correct organization contacts, using organization_id.", "The results should be ordered by the end date of the contact period, which is date_contact_to, in descending order to get the most recent contacts first."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "pred_sql": "SELECT Individuals.individual_last_name \nFROM Organization_Contact_Individuals \nJOIN Individuals ON Organization_Contact_Individuals.individual_id = Individuals.individual_id \nJOIN Organizations ON Organization_Contact_Individuals.organization_id = Organizations.organization_id \nORDER BY Organization_Contact_Individuals.date_contact_to DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names of individuals who have contacted a specific organization. It retrieves data from the 'Organizations', 'Organization_Contact_Individuals', and 'Individuals' tables, filtering based on the organization's name. The results are ordered by the end date of the contact period, and a limit is applied to the number of results returned.\"\n}\n"}
{"sample_id": "train.6723", "db_id": "activity_1", "question": "Show the first name, last name, and phone number for all female faculty members.", "rationale": ["Identify the relevant table: Faculty.", "Select the columns needed: Fname, Lname, Phone.", "Filter the results to include only female faculty members by using the WHERE clause with the condition Sex = 'Female'."], "gold_sql": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'", "source_tables": ["faculty"], "pred_sql": "SELECT Fname, Lname, Phone \nFROM Faculty \nWHERE Sex = 'Female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\"\n}\n"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the table that contains faculty information, which is the Faculty table.", "Determine the relevant column for gender, which is 'Sex'.", "Filter the results to include only male faculty members by using the condition 'Sex = 'Male''.", "Select the unique identifier for faculty members, which is 'FacID'.", "Construct the SQL query to retrieve the FacID of all male faculty members."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "pred_sql": "SELECT FacID FROM Faculty WHERE Sex = 'Male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\"\n}\n"}
{"sample_id": "train.6738", "db_id": "activity_1", "question": "Find the building that has the largest number of faculty members.", "rationale": ["Identify the table that contains information about faculty members, which is the Faculty table.", "To find the building with the largest number of faculty members, we need to count the number of faculty members in each building.", "We will use the COUNT() function to count the number of FacID (faculty identifiers) for each building.", "We will group the results by the Building column to get the count for each building.", "To get the building with the largest number of faculty members, we will order the results in descending order based on the count and limit the results to 1."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(FacID) AS FacultyCount\nFROM Faculty\nGROUP BY Building\nORDER BY FacultyCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\"\n}\n"}
{"sample_id": "train.6740", "db_id": "activity_1", "question": "In which buildings are there at least ten professors?", "rationale": ["Identify the relevant table: Faculty, which contains information about faculty members including their building.", "We need to find buildings with at least ten professors, so we will group the results by the 'Building' column.", "Use the COUNT function to count the number of faculty members (FacID) in each building.", "Apply the HAVING clause to filter groups that have a count of at least 10."], "gold_sql": "SELECT building FROM Faculty WHERE rank  =  'Professor' GROUP BY building HAVING count(*)  >=  10", "source_tables": ["faculty"], "pred_sql": "SELECT Building\nFROM Faculty\nGROUP BY Building\nHAVING COUNT(FacID) >= 10;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\"\n}\n"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their rank and gender.", "Filter by rank: We need to focus on faculty members who are assistant professors, so we will filter the results where Rank = 'Assistant Professor'.", "Group by gender: To get the count of male and female assistant professors, we will group the results by the Sex column.", "Count the number of faculty members: We will use the COUNT() function to count the number of faculty members in each gender group."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) as Count \nFROM Faculty \nWHERE Rank = 'Assistant Professor' \nGROUP BY Sex;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\"\n}\n"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the relevant table: The Student table contains information about students, including their names and advisors.", "Determine the specific student: We are looking for a student with the first name 'Linda' and last name 'Smith'.", "Select the Advisor column: We need to retrieve the advisor of this specific student.", "Construct the SQL query: Use a SELECT statement to get the Advisor from the Student table where the first name is 'Linda' and the last name is 'Smith'."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Advisor FROM Student WHERE Fname = 'Linda' AND LName = 'Smith';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\"\n}\n"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["We need to find the IDs of students whose advisors are professors.", "The Student table contains the student information including their advisor's ID.", "The Faculty table contains the faculty information including their IDs.", "We will join the Student table with the Faculty table on the Advisor and FacID columns to find the matching records.", "We select the distinct student IDs from the result to avoid duplicates."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT DISTINCT Student.StuID \nFROM Student \nJOIN Faculty ON Student.Advisor = Faculty.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\"\n}\n"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the tables needed: We need information from the Student table for student names and the Faculty table to find the advisor's name.", "Join the Student table with the Faculty table on the Advisor field, which corresponds to the Faculty's FacID.", "Filter the results to only include students whose advisor's first name is 'Michael' and last name is 'Goodrich'.", "Select the first name and last name of the students from the joined tables."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT S.Fname, S.LName \nFROM Student S \nJOIN Faculty F ON S.Advisor = F.FacID \nWHERE F.Fname = 'Michael' AND F.Lname = 'Goodrich';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\"\n}\n"}
{"sample_id": "train.6759", "db_id": "activity_1", "question": "What are the first and last name of the faculty who has the most students?", "rationale": ["Identify the tables involved: Faculty, Faculty_Participates_in, Participates_in, and Student.", "We need to find the faculty members and the number of students they have.", "Join the Faculty table with Faculty_Participates_in to link faculty to activities.", "Join the Participates_in table to link activities to students.", "Group the results by faculty ID to count the number of students associated with each faculty member.", "Order the results by the count of students in descending order to find the faculty member with the most students.", "Limit the results to 1 to get only the faculty member with the highest count."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Faculty.Fname, Faculty.Lname\nFROM Faculty\nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID\nJOIN Participates_in ON Faculty_Participates_in.actid = Participates_in.actid\nJOIN Student ON Participates_in.stuid = Student.StuID\nGROUP BY Faculty.FacID\nORDER BY COUNT(Student.StuID) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\"\n}\n"}
{"sample_id": "train.6765", "db_id": "activity_1", "question": "What activities do we have?", "rationale": ["The question asks for a list of activities available.", "To get the activities, we need to select the 'activity_name' from the 'Activity' table.", "The 'Activity' table contains the names of all activities, so we will perform a simple SELECT query on this table."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "pred_sql": "SELECT activity_name FROM Activity;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\"\n}\n"}
{"sample_id": "train.6766", "db_id": "activity_1", "question": "List all the activities we have.", "rationale": ["Identify the table that contains the information about activities, which is the 'Activity' table.", "Determine the column that holds the names of the activities, which is 'activity_name'.", "Construct a SQL query to select all activity names from the 'Activity' table."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "pred_sql": "SELECT activity_name FROM Activity;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\"\n}\n"}
{"sample_id": "train.6780", "db_id": "activity_1", "question": "What is the first and last name of the faculty members who participated in at least one activity? For each of them, also show the number of activities they participated in.", "rationale": ["Identify the relevant tables: Faculty and Faculty_Participates_in.", "We need to select the first name (Fname) and last name (Lname) of faculty members.", "We also need to count the number of activities each faculty member participated in, which can be done using COUNT() on the actid from Faculty_Participates_in.", "Join the Faculty table with the Faculty_Participates_in table on the FacID to link faculty members with their activities.", "Group the results by faculty ID, first name, and last name to aggregate the count of activities for each faculty member.", "Use HAVING clause to filter out faculty members who have not participated in any activities (i.e., count should be greater than 0)."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname, Faculty.Lname, COUNT(Faculty_Participates_in.actid) AS activity_count\nFROM Faculty\nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID\nGROUP BY Faculty.FacID, Faculty.Fname, Faculty.Lname\nHAVING COUNT(Faculty_Participates_in.actid) > 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\"\n}\n"}
{"sample_id": "train.6781", "db_id": "activity_1", "question": "Show all the activity names and the number of faculty involved in each activity.", "rationale": ["We need to retrieve the names of activities and count the number of faculty members involved in each activity.", "The relevant table for activity names is the 'Activity' table, which contains the 'activity_name' column.", "To count the number of faculty members involved in each activity, we will use the 'Faculty_Participates_in' table, which links faculty members to activities via the 'actid' column.", "We will perform a LEFT JOIN between the 'Activity' table and the 'Faculty_Participates_in' table on the 'actid' column to ensure we get all activities, even those with no faculty participation.", "We will use the COUNT function to count the number of faculty IDs associated with each activity and group the results by activity name to get the count for each activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "pred_sql": "SELECT Activity.activity_name, COUNT(Faculty_Participates_in.FacID) AS faculty_count\nFROM Activity\nLEFT JOIN Faculty_Participates_in ON Activity.actid = Faculty_Participates_in.actid\nGROUP BY Activity.activity_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\"\n}\n"}
{"sample_id": "train.6782", "db_id": "activity_1", "question": "How many faculty members participate in each activity? Return the activity names and the number of faculty members.", "rationale": ["We need to find out how many faculty members participate in each activity.", "The relevant tables are 'Activity' and 'Faculty_Participates_in'.", "We will join these two tables on the 'actid' column, which is common to both tables.", "We will select the 'activity_name' from the 'Activity' table and count the number of 'FacID' from the 'Faculty_Participates_in' table to get the number of faculty members participating in each activity.", "We will group the results by 'activity_name' to get the count for each activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "pred_sql": "SELECT Activity.activity_name, COUNT(Faculty_Participates_in.FacID) AS faculty_count\nFROM Activity\nLEFT JOIN Faculty_Participates_in ON Activity.actid = Faculty_Participates_in.actid\nGROUP BY Activity.activity_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\"\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: We need to find students who participate in activities, so we will use the 'Participates_in' and 'Student' tables.", "Determine the columns needed: We need the student IDs (stuid) from the 'Participates_in' table and the age from the 'Student' table.", "Join the tables: We will join 'Participates_in' with 'Student' on the student ID to get the necessary information about the students who participate in activities.", "Apply the age filter: We need to filter the results to include only those students who are under 20 years old.", "Select distinct student IDs: Since a student may participate in multiple activities, we will use DISTINCT to ensure each student ID is listed only once."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT DISTINCT p.stuid \nFROM Participates_in p \nJOIN Student s ON p.stuid = s.StuID \nWHERE s.Age < 20;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\"\n}\n"}
{"sample_id": "train.6795", "db_id": "activity_1", "question": "Find the first names of the faculty members who are playing Canoeing or Kayaking.", "rationale": ["Identify the tables involved: Faculty, Faculty_Participates_in, and Activity.", "We need to find the first names of faculty members, so we will select Faculty.Fname.", "To find the relevant activities, we will join the Faculty_Participates_in table with the Faculty table on FacID.", "Next, we will join the Activity table to get the activity names associated with the faculty members.", "We will filter the results to include only those activities that are either 'Canoeing' or 'Kayaking' using the WHERE clause with IN operator."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname \nFROM Faculty \nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID \nJOIN Activity ON Faculty_Participates_in.actid = Activity.actid \nWHERE Activity.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\"\n}\n"}
{"sample_id": "train.6796", "db_id": "activity_1", "question": "Which faculty members are playing either Canoeing or Kayaking? Tell me their first names.", "rationale": ["Identify the relevant tables: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members who participate in specific activities (Canoeing or Kayaking).", "Join the Faculty table with Faculty_Participates_in on FacID to link faculty members to their activities.", "Join the resulting table with the Activity table on actid to access the activity names.", "Use a WHERE clause to filter activities to only include 'Canoeing' or 'Kayaking'.", "Select the first names of the faculty members from the Faculty table."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname \nFROM Faculty \nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID \nJOIN Activity ON Faculty_Participates_in.actid = Activity.actid \nWHERE Activity.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\"\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the main entities involved: Faculty and Activities.", "We need to find faculty members who do not participate in specific activities (Canoeing and Kayaking).", "Use a subquery to find faculty IDs (FacID) that are associated with the activities Canoeing and Kayaking.", "Select the first names (Fname) of faculty members whose IDs are not in the list generated by the subquery."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty F \nWHERE F.FacID NOT IN (\n    SELECT FP.FacID \n    FROM Faculty_Participates_in FP \n    JOIN Activity A ON FP.actid = A.actid \n    WHERE A.activity_name IN ('Canoeing', 'Kayaking')\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\"\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables involved: We need to find student IDs from the Participates_in table and the activity names from the Activity table.", "Determine the relationship: The Participates_in table has a foreign key relationship with the Activity table through the actid column.", "Filter the activities: We need to filter the activities to only include 'Canoeing' and 'Kayaking'.", "Construct the SQL query: Use a JOIN to combine the Participates_in and Activity tables, and select the student IDs where the activity names match the specified activities."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT p.stuid \nFROM Participates_in p \nJOIN Activity a ON p.actid = a.actid \nWHERE a.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\"\n}\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data are needed to find car models and their horsepower.", "Join the model_list table with the car_names table to get the car models and their makes.", "Join the resulting table with the cars_data table to access the horsepower of each car model.", "Use the MIN() function to find the minimum horsepower across all models.", "Group the results by Model to ensure we get the minimum horsepower for each model.", "Order the results by the minimum horsepower in ascending order to get the model with the least horsepower at the top.", "Limit the results to 1 to get only the model with the minimum horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, MIN(Horsepower) AS MinHorsepower \nFROM model_list \nJOIN car_names ON model_list.Model = car_names.Model \nJOIN cars_data ON car_names.MakeId = cars_data.Id \nGROUP BY Model \nORDER BY MinHorsepower ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.97", "db_id": "car_1", "question": "Find the model of the car whose weight is below the average weight.", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data are needed to find car models and their weights.", "Join the model_list table with the car_names table to get the car models along with their makes.", "Join the resulting table with the cars_data table to access the weight of each car model.", "Use a subquery to calculate the average weight of all cars in the cars_data table.", "Filter the results to include only those car models whose weight is below the average weight."], "gold_sql": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT ml.Model \nFROM model_list ml \nJOIN car_names cn ON ml.Model = cn.Model \nJOIN cars_data cd ON cn.MakeId = cd.Id \nWHERE cd.Weight < (SELECT AVG(Weight) FROM cars_data);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: cars_data, car_names, model_list, and car_makers are needed to find the accelerate of the specific car make and model.", "The 'cars_data' table contains the 'Accelerate' column, which we want to retrieve.", "The 'car_names' table links the car make to the car model, so we need to join it with 'cars_data' using the MakeId.", "The 'model_list' table connects the car model to the car maker, so we join it with 'car_names' on the Model column.", "The 'car_makers' table is included to ensure we are referencing the correct car maker, but in this case, we are filtering by the make directly in the WHERE clause.", "Construct the SQL query to select the 'Accelerate' value where the make is 'amc' and the model is 'hornet sportabout (sw)'."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT cars_data.Accelerate \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nJOIN model_list ON car_names.Model = model_list.Model \nJOIN car_makers ON model_list.Maker = car_makers.Id \nWHERE car_names.Make = 'amc' AND model_list.Model = 'hornet sportabout (sw)';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\"\n}\n"}
{"sample_id": "dev.112", "db_id": "car_1", "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?", "rationale": ["Identify the car model we are interested in: 'amc hornet sportabout (sw)'.", "We need to find the acceleration data for this specific car model.", "To do this, we will join the 'car_names' table with the 'model_list' table to get the corresponding maker.", "Next, we will join the 'model_list' table with the 'car_makers' table to link the car maker to its country.", "Finally, we will join with the 'cars_data' table to access the acceleration data for the specific car model.", "The final query will select the 'Accelerate' column from the 'cars_data' table where the make matches 'amc hornet sportabout (sw)'."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT cars_data.Accelerate \nFROM car_names \nJOIN model_list ON car_names.Model = model_list.Model \nJOIN car_makers ON model_list.Maker = car_makers.Id \nJOIN countries ON car_makers.Country = countries.CountryId \nWHERE car_names.Make = 'amc hornet sportabout (sw)';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the relevant tables: car_makers and countries.", "We need to count the number of car makers based in France, so we will use the COUNT function.", "Join the car_makers table with the countries table on the Country field to filter by France.", "Use a WHERE clause to specify that we are only interested in car makers from France."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(*) AS NumberOfCarMakers\nFROM car_makers\nJOIN countries ON car_makers.Country = countries.CountryId\nWHERE countries.Country = 'France';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\"\n}\n"}
{"sample_id": "dev.121", "db_id": "car_1", "question": "What are all the makers and models?", "rationale": ["We need to retrieve all car makers and their respective models.", "The relevant tables for this query are 'car_makers', 'model_list', and 'car_names'.", "We will join 'model_list' with 'car_makers' on the 'Maker' field to get the maker names.", "Next, we will join 'car_names' with 'model_list' on the 'Model' field to get the model names.", "Finally, we will select distinct combinations of makers and models to avoid duplicates."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "pred_sql": "SELECT DISTINCT car_makers.Maker, model_list.Model \nFROM model_list \nJOIN car_makers ON model_list.Maker = car_makers.Id \nJOIN car_names ON car_names.Model = model_list.Model;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the relevant tables: countries, car_makers, and continents.", "Join the countries table with the car_makers table on the country identifier.", "Join the continents table to filter for Europe.", "Group the results by country name to count the number of car manufacturers per country.", "Use the HAVING clause to filter countries that have at least 3 car manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT countries.CountryName\nFROM countries\nJOIN car_makers ON countries.CountryId = car_makers.Country\nJOIN continents ON countries.Continent = continents.ContId\nWHERE continents.Continent = 'Europe'\nGROUP BY countries.CountryName\nHAVING COUNT(car_makers.Id) >= 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\"\n}\n"}
{"sample_id": "dev.130", "db_id": "car_1", "question": "What are the names of all European countries with at least 3 manufacturers?", "rationale": ["Identify the relevant tables: countries, car_makers, and continents.", "We need to filter for European countries, so we will join the continents table to get the continent names.", "Join the car_makers table to count the number of manufacturers associated with each country.", "Group the results by country name to aggregate the count of manufacturers per country.", "Use the HAVING clause to filter countries that have at least 3 manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT countries.CountryName \nFROM countries \nJOIN car_makers ON countries.CountryId = car_makers.Country \nJOIN continents ON countries.Continent = continents.ContId \nWHERE continents.Continent = 'Europe' \nGROUP BY countries.CountryName \nHAVING COUNT(car_makers.Id) >= 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\"\n}\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the relevant tables: 'cars_data' for horsepower and cylinders, 'car_names' for car make, and 'model_list' for car models.", "We need to find the maximum horsepower for car models with 3 cylinders, so we will filter 'cars_data' where Cylinders = 3.", "Join 'cars_data' with 'car_names' on the MakeId to get the make of the car.", "We will also join 'car_names' with 'model_list' to ensure we are considering the correct models, although in this case, we are primarily interested in the make and horsepower.", "Use the MAX() function to get the maximum horsepower and group the results by car make to ensure we get the maximum horsepower for each make."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(cars_data.Horsepower) AS MaxHorsepower, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nJOIN model_list ON car_names.Model = model_list.Model \nWHERE cars_data.Cylinders = 3 \nGROUP BY car_names.Make;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.141", "db_id": "car_1", "question": "Which model has the most version(make) of cars?", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data are needed to find car models and their makes.", "Join the model_list table with the car_names table to associate each model with its respective make.", "Join the resulting table with the cars_data table to ensure we are considering all versions of each model.", "Group the results by Model to count the number of distinct makes for each model.", "Order the results by the count of makes in descending order to find the model with the most versions.", "Limit the results to 1 to get only the top model with the most versions."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "pred_sql": "SELECT Model, COUNT(Make) AS VersionCount\nFROM model_list\nJOIN car_names ON model_list.Model = car_names.Model\nJOIN cars_data ON car_names.MakeId = cars_data.Id\nGROUP BY Model\nORDER BY VersionCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.142", "db_id": "car_1", "question": "What model has the most different versions?", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data are needed to find car models and their versions.", "Join the model_list table with car_names to get the make of each model.", "Join the resulting table with cars_data to count the number of versions for each model.", "Group the results by Model to count the number of different versions for each model.", "Order the results by the count of versions in descending order to find the model with the most versions.", "Limit the results to 1 to get only the model with the highest count."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "pred_sql": "SELECT Model, COUNT(*) as VersionCount\nFROM model_list\nJOIN car_names ON model_list.Model = car_names.Model\nJOIN cars_data ON car_names.MakeId = cars_data.Id\nGROUP BY Model\nORDER BY VersionCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["We need to find car makers with more than 3 models.", "We will use the 'car_makers' table to get the maker's ID and name.", "We will join the 'model_list' table to count the number of models for each maker.", "We will group the results by the maker's ID and name to aggregate the model counts.", "Finally, we will use the HAVING clause to filter out makers with 3 or fewer models."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(ml.ModelId) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.161", "db_id": "car_1", "question": "How many countries has more than 2 car makers ?", "rationale": ["We need to find the number of countries that have more than 2 car makers.", "To do this, we will join the 'countries' table with the 'car_makers' table on the country identifier.", "We will group the results by the country identifier to count the number of car makers for each country.", "Using the COUNT function, we will count the number of car makers for each country.", "Finally, we will use the HAVING clause to filter the results to only include countries with more than 2 car makers."], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(DISTINCT countries.CountryId) AS CountryCount\nFROM countries\nJOIN car_makers ON countries.CountryId = car_makers.Country\nGROUP BY countries.CountryId\nHAVING COUNT(car_makers.Id) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\"\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables: cars_data for car specifications, car_names for car make and model, and model_list for the car model details.", "We need to filter the cars based on the number of cylinders, specifically those with 4 cylinders.", "We want to find the model with the largest horsepower, so we will use the MAX function on the horsepower column.", "We will join the tables on their respective keys to access the necessary columns: cars_data.Id with car_names.MakeId and car_names.Model with model_list.Model.", "We will group the results by model to apply the MAX function correctly and then order the results in descending order to get the highest horsepower at the top.", "Finally, we will limit the results to 1 to get only the model with the largest horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT model_list.Model, MAX(cars_data.Horsepower) AS MaxHorsepower\nFROM cars_data\nJOIN car_names ON cars_data.Id = car_names.MakeId\nJOIN model_list ON car_names.Model = model_list.Model\nWHERE cars_data.Cylinders = 4\nGROUP BY model_list.Model\nORDER BY MaxHorsepower DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\"\n}\n"}
{"sample_id": "dev.171", "db_id": "car_1", "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?", "rationale": ["Identify the relevant tables: car_names, model_list, cars_data, and car_makers are needed to get the car models and their weights while excluding Ford.", "Join the car_names table with model_list to get the maker information.", "Join the model_list with cars_data to access the weight of the cars.", "Join the car_makers table to filter out the models made by 'Ford Motor Company'.", "Use a WHERE clause to filter for models lighter than 3500 pounds and not made by 'Ford Motor Company'."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';", "source_tables": ["car_makers", "model_list", "car_names", "cars_data"], "pred_sql": "SELECT car_names.Model \nFROM car_names \nJOIN model_list ON car_names.Model = model_list.Model \nJOIN cars_data ON car_names.MakeId = cars_data.Id \nJOIN car_makers ON model_list.Maker = car_makers.Id \nWHERE cars_data.Weight < 3500 \nAND car_makers.FullName != 'Ford Motor Company';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.175", "db_id": "car_1", "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .", "rationale": ["Identify the relevant tables: car_makers and model_list.", "We need to find car makers that produce at least 2 models, so we will join car_makers with model_list on the Maker ID.", "Group the results by car maker ID and name to aggregate the number of models each maker produces.", "Use the HAVING clause to filter for car makers that have 2 or more models.", "Additionally, we need to ensure that there are more than 3 distinct car makers in total, which can be checked using a subquery."], "gold_sql": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(ml.ModelId) >= 2\nAND (SELECT COUNT(DISTINCT cm2.Id) FROM car_makers cm2) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\"\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["Identify the relevant tables: car_makers, model_list, car_names, and cars_data.", "Join the car_makers table with model_list to get the models associated with each maker.", "Join the model_list with car_names to link the models to their makes.", "Join car_names with cars_data to count the number of cars produced for each make.", "Group the results by car maker's Id and Maker name to aggregate the counts.", "Use the HAVING clause to filter for car makers that produce at least 2 distinct models and have more than 3 cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nJOIN car_names cn ON ml.Model = cn.Model\nJOIN cars_data cd ON cn.MakeId = cd.Id\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(DISTINCT ml.Model) >= 2 AND COUNT(cd.Id) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\"\n}\n"}
{"sample_id": "dev.526", "db_id": "student_transcripts_tracking", "question": "What are the names and ids of every course with less than 2 sections?", "rationale": ["Identify the relevant tables: Courses and Sections.", "We need to find courses that have less than 2 sections, so we will join the Courses table with the Sections table on the course_id.", "Use a LEFT JOIN to ensure we include courses that may not have any sections at all.", "Group the results by course_id and course_name to aggregate the section counts for each course.", "Use the HAVING clause to filter the grouped results to only include courses with a count of sections less than 2."], "gold_sql": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2", "source_tables": ["courses", "sections"], "pred_sql": "SELECT Courses.course_id, Courses.course_name\nFROM Courses\nLEFT JOIN Sections ON Courses.course_id = Sections.course_id\nGROUP BY Courses.course_id, Courses.course_name\nHAVING COUNT(Sections.section_id) < 2;", "hint": "\n"}
{"sample_id": "dev.534", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Student_Enrolment_Courses are needed to get student details and their enrolment information.", "Join the Students table with Student_Enrolment on student_id to link students with their enrolment records.", "Join the resulting table with Student_Enrolment_Courses on student_enrolment_id to link enrolment records with the courses they are enrolled in.", "Group the results by student_id to aggregate the enrolment records for each student.", "Use the HAVING clause to filter the groups to only those students who are enrolled in exactly 2 distinct degree programs."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Student_Enrolment_Courses sec ON se.student_enrolment_id = sec.student_enrolment_id\nGROUP BY s.student_id\nHAVING COUNT(DISTINCT se.degree_program_id) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\"\n}\n"}
{"sample_id": "dev.535", "db_id": "student_transcripts_tracking", "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs.", "We need to join these tables to get the names of students enrolled in a Bachelor degree program.", "The Students table contains the first, middle, and last names of students.", "The Student_Enrolment table links students to their degree programs.", "The Degree_Programs table contains the degree program names.", "Use a JOIN to connect Students to Student_Enrolment on student_id, and Student_Enrolment to Degree_Programs on degree_program_id.", "Filter the results to include only those degree programs that contain 'Bachelor' in their name."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nWHERE dp.degree_summary_name LIKE '%Bachelor%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\"\n}\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["Identify the relevant tables: Degree_Programs and Student_Enrolment are needed to find the degree programs and their enrollments.", "Join the Degree_Programs table with the Student_Enrolment table on the degree_program_id to associate students with their respective programs.", "Group the results by degree_program_id and degree_summary_name to count the number of students enrolled in each program.", "Use COUNT(se.student_id) to count the number of students for each program.", "Order the results in descending order based on the count of students to find the program with the most enrollments.", "Limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_program_id, dp.degree_summary_name\nFROM Degree_Programs dp\nJOIN Student_Enrolment se ON dp.degree_program_id = se.degree_program_id\nGROUP BY dp.degree_program_id, dp.degree_summary_name\nORDER BY COUNT(se.student_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\"\n}\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment are needed to find student details and their enrollments.", "Join the Students table with the Student_Enrolment table on the student_id to link students with their enrollments.", "Use COUNT() to count the number of enrollments for each student.", "Group the results by student_id to aggregate the enrollment counts per student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Limit the results to 1 to get only the top student."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name, COUNT(se.student_enrolment_id) AS number_of_enrolments\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id\nORDER BY number_of_enrolments DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\"\n}\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["Identify the relevant tables: Courses, Student_Enrolment_Courses, and Student_Enrolment are needed to find the course with the most enrollments.", "Join the Courses table with the Student_Enrolment_Courses table on course_id to link courses with their enrollments.", "Join the Student_Enrolment table to ensure we are counting valid enrollments.", "Group the results by course_id to count the number of enrollments for each course.", "Order the results by the count of enrollments in descending order to get the course with the most enrollments at the top.", "Limit the results to 1 to get only the course with the highest number of enrollments."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT C.course_name\nFROM Courses C\nJOIN Student_Enrolment_Courses SEC ON C.course_id = SEC.course_id\nJOIN Student_Enrolment SE ON SEC.student_enrolment_id = SE.student_enrolment_id\nGROUP BY C.course_id\nORDER BY COUNT(SEC.student_course_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\"\n}\n"}
{"sample_id": "dev.548", "db_id": "student_transcripts_tracking", "question": "What is the name of the course with the most students enrolled?", "rationale": ["Identify the relevant tables: Courses, Student_Enrolment_Courses, and Student_Enrolment are needed to find the course with the most students enrolled.", "Join the Courses table with the Student_Enrolment_Courses table on course_id to link courses with their enrollments.", "Join the resulting table with the Student_Enrolment table on student_enrolment_id to access student enrollment records.", "Group the results by course_id to count the number of students enrolled in each course.", "Order the results by the count of students in descending order to get the course with the most students at the top.", "Limit the results to 1 to get only the course with the highest enrollment."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT C.course_name\nFROM Courses C\nJOIN Student_Enrolment_Courses SEC ON C.course_id = SEC.course_id\nJOIN Student_Enrolment SE ON SEC.student_enrolment_id = SE.student_enrolment_id\nGROUP BY C.course_id\nORDER BY COUNT(SE.student_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\"\n}\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant tables: Students and Addresses for student information and their current address.", "Join the Students table with the Addresses table on the current_address_id to access the state information.", "Filter the results to include only those students whose current address is in North Carolina.", "Use the EXCEPT clause to exclude students who are enrolled in any degree programs by joining the Students table with the Student_Enrolment table and selecting their last names."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "SELECT last_name FROM Students\nJOIN Addresses ON Students.current_address_id = Addresses.address_id\nWHERE Addresses.state_province_county = 'North Carolina'\nEXCEPT\nSELECT Students.last_name FROM Students\nJOIN Student_Enrolment ON Students.student_id = Student_Enrolment.student_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\"\n}\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the table that contains student information, which is the 'Students' table.", "Determine the relevant column for the mobile phone number, which is 'cell_mobile_number'.", "Filter the records based on the student's first name 'Timmothy' and last name 'Ward'.", "Construct the SQL query to select the mobile phone number from the 'Students' table with the specified conditions."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\"\n}\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["Identify the relevant tables: Students and Addresses.", "We need to join the Students table with the Addresses table on the current_address_id to get the address details for each student.", "Group the results by address_id and the address lines to count the number of students at each address.", "Order the results by the count of students in descending order to find the address with the most students.", "Limit the results to 1 to get only the address with the highest count."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT a.address_id, a.line_1, a.line_2, a.line_3\nFROM Addresses a\nJOIN Students s ON a.address_id = s.current_address_id\nGROUP BY a.address_id, a.line_1, a.line_2, a.line_3\nORDER BY COUNT(s.student_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\"\n}\n"}
{"sample_id": "dev.578", "db_id": "student_transcripts_tracking", "question": "What are the different addresses that have students living there?", "rationale": ["We need to find different addresses where students live, which involves joining the 'Addresses' table with the 'Students' table.", "The 'Students' table contains a column 'current_address_id' that references the 'address_id' in the 'Addresses' table.", "To get the unique addresses, we will use SELECT DISTINCT to avoid duplicates in the results.", "The final SQL query will select all columns from the 'Addresses' table where there is a match with the 'current_address_id' in the 'Students' table."], "gold_sql": "SELECT count(DISTINCT current_address_id) FROM Students", "source_tables": ["students"], "pred_sql": "SELECT DISTINCT Addresses.* FROM Addresses JOIN Students ON Addresses.address_id = Students.current_address_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\"\n}\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve information about a section, we need to select all columns from the Sections table.", "We will use a WHERE clause to filter the results to only include the section with the name 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT * FROM Sections WHERE section_name = 'h';", "hint": "\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the relevant table: The question pertains to countries and their government forms, so we will use the 'country' table.", "Determine the condition: We need to count the number of countries where the government form includes the word 'Republic'.", "Construct the SQL query: We will use the COUNT function to count the rows that meet the condition in the 'country' table."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(*) FROM country WHERE GovernmentForm LIKE '%Republic%';", "hint": "\n"}
{"sample_id": "dev.723", "db_id": "world_1", "question": "How many people live in Asia, and what is the largest GNP among them?", "rationale": ["Identify the relevant tables: 'country' for continent and GNP, and 'city' for population.", "We need to sum the population of cities in Asia, so we will use the SUM function on the Population column from the city table.", "We also need to find the maximum GNP among countries in Asia, so we will use the MAX function on the GNP column from the country table.", "To link the city and country tables, we will use a JOIN on the CountryCode from the city table and the Code from the country table.", "We will filter the results to only include countries in Asia by adding a WHERE clause for the continent.", "Finally, we will select both the total population and the largest GNP in the final query."], "gold_sql": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  'Asia'", "source_tables": ["country"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation, MAX(c.GNP) AS LargestGNP\nFROM country AS co\nJOIN city AS c ON co.Code = c.CountryCode\nWHERE co.Continent = 'Asia';", "hint": "\n"}
{"sample_id": "dev.724", "db_id": "world_1", "question": "What is the average life expectancy in African countries that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains the information about countries, including life expectancy and government form.", "Determine the columns needed: We need 'LifeExpectancy' to calculate the average and 'GovernmentForm' to filter for republics.", "Filter for African countries: Use the 'Continent' column to select only countries in Africa.", "Filter for republics: Use the 'GovernmentForm' column to select countries that have 'Republic' in their government form.", "Calculate the average life expectancy: Use the AVG() function to compute the average of the 'LifeExpectancy' column for the filtered results."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT AVG(LifeExpectancy) AS AverageLifeExpectancy\nFROM country\nWHERE Continent = 'Africa' AND GovernmentForm LIKE '%Republic%';", "hint": "\n"}
{"sample_id": "dev.725", "db_id": "world_1", "question": "Give the average life expectancy for countries in Africa which are republics?", "rationale": ["Identify the relevant table: The 'country' table contains the information about countries, including life expectancy and government form.", "Determine the columns needed: We need the 'LifeExpectancy' column to calculate the average and the 'GovernmentForm' column to filter for republics.", "Set the conditions for the query: We want countries that are in the continent of Africa and have a government form that includes 'Republic'.", "Use the AVG() function to calculate the average life expectancy for the filtered results."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT AVG(LifeExpectancy) AS AverageLifeExpectancy \nFROM country \nWHERE Continent = 'Africa' \nAND GovernmentForm LIKE '%Republic%';", "hint": "\n"}
{"sample_id": "dev.731", "db_id": "world_1", "question": "Give the mean GNP and total population of nations which are considered US territory.", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their GNP and population.", "Determine the criteria for US territories: We need to filter countries that are considered US territories. This can be done by checking if the country name contains 'United States' or 'US'.", "Select the required fields: We need to calculate the average GNP and the total population, so we will use the AVG() function for GNP and SUM() function for population.", "Construct the SQL query: Combine the SELECT statement with the appropriate aggregate functions and the WHERE clause to filter the results."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT AVG(GNP) AS Mean_GNP, SUM(Population) AS Total_Population \nFROM country \nWHERE Name LIKE '%United States%' OR Name LIKE '%US%';", "hint": "\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and continent.", "Determine the specific continent of interest: The question specifies Africa.", "Count the distinct forms of government: Use COUNT(DISTINCT GovernmentForm) to find the number of unique government forms in Africa."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(DISTINCT GovernmentForm) AS DifferentFormsOfGovernment \nFROM country \nWHERE Continent = 'Africa';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.754", "db_id": "world_1", "question": "What are the countries where either English or Dutch is the official language ?", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find countries with specific official languages.", "Determine the criteria: We are interested in countries where either English or Dutch is an official language.", "Use JOIN to combine the 'country' and 'countrylanguage' tables on the CountryCode field, which is the common key.", "Filter the results to include only those rows where IsOfficial is 'T' (true) and the Language is either 'English' or 'Dutch'.", "Select the distinct country names to avoid duplicates in the results."], "gold_sql": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'english' and isofficial  =  't' union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'dutch' and isofficial  =  't'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT country.Name \nFROM country \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE countrylanguage.IsOfficial = 'T' \nAND (countrylanguage.Language = 'English' OR countrylanguage.Language = 'Dutch');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find countries with specific official languages.", "Determine the criteria: We are interested in countries where either English or Dutch is an official language.", "Use JOIN to combine the 'country' and 'countrylanguage' tables based on the CountryCode.", "Filter the results to include only those languages that are marked as official (IsOfficial = 'T').", "Use a WHERE clause to specify that the language must be either English or Dutch.", "Select the distinct country names to avoid duplicates in the results."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT country.Name \nFROM country \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE countrylanguage.IsOfficial = 'T' \nAND (countrylanguage.Language = 'English' OR countrylanguage.Language = 'Dutch');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.758", "db_id": "world_1", "question": "Which languages are spoken by only one country in republic governments?", "rationale": ["Identify the relevant tables: We need to look at the 'countrylanguage' table for languages and the 'country' table for government forms.", "Join the 'countrylanguage' table with the 'country' table on the CountryCode to access the government form of each country.", "Filter the results to include only official languages (IsOfficial = 'T') and countries with a republican form of government (GovernmentForm LIKE '%Republic%').", "Group the results by language to count how many countries speak each language.", "Use the HAVING clause to filter the grouped results to include only those languages that are spoken in exactly one country (HAVING COUNT(DISTINCT c.Code) = 1)."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl.Language \nFROM countrylanguage cl \nJOIN country c ON cl.CountryCode = c.Code \nWHERE cl.IsOfficial = 'T' \nAND c.GovernmentForm LIKE '%Republic%' \nGROUP BY cl.Language \nHAVING COUNT(DISTINCT c.Code) = 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.759", "db_id": "world_1", "question": "What languages are only used by a single country with a republic government?", "rationale": ["Identify the relevant tables: We need to look at the 'countrylanguage' table for languages and the 'country' table for government forms.", "Join the 'countrylanguage' table with the 'country' table on the CountryCode to access the government form of each country that speaks a language.", "Filter the results to include only official languages (IsOfficial = 'T') and countries with a government form that includes 'Republic'.", "Group the results by language to count how many countries speak each language.", "Use the HAVING clause to filter the grouped results to only include languages that are spoken in exactly one country (COUNT(DISTINCT c.Code) = 1)."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl.Language \nFROM countrylanguage cl \nJOIN country c ON cl.CountryCode = c.Code \nWHERE cl.IsOfficial = 'T' \nAND c.GovernmentForm LIKE '%Republic%' \nGROUP BY cl.Language \nHAVING COUNT(DISTINCT c.Code) = 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.760", "db_id": "world_1", "question": "Find the city with the largest population that uses English.", "rationale": ["Identify the relevant tables: 'city', 'country', and 'countrylanguage'.", "We need to find cities that use English, so we will join the 'city' table with the 'country' table and then with the 'countrylanguage' table.", "The join condition will be based on the foreign key relationships: city.CountryCode = country.Code and countrylanguage.CountryCode = country.Code.", "Filter the results to include only those rows where the language is 'English'.", "To find the city with the largest population, we will order the results by the 'Population' column in descending order.", "Finally, we will limit the results to 1 to get only the city with the largest population."], "gold_sql": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  'English' ORDER BY T1.Population DESC LIMIT 1", "source_tables": ["city", "countrylanguage"], "pred_sql": "SELECT c.Name, c.Population \nFROM city c \nJOIN country co ON c.CountryCode = co.Code \nJOIN countrylanguage cl ON co.Code = cl.CountryCode \nWHERE cl.Language = 'English' \nORDER BY c.Population DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the requirement: We need to find the total population of countries that do not have English as an official language.", "To achieve this, we will first need to identify the countries where English is an official language. This can be done by querying the 'countrylanguage' table.", "We will filter the 'countrylanguage' table for entries where the Language is 'English' and IsOfficial is 'T' (true).", "Next, we will use the results from the previous step to exclude these countries from our main query.", "In the main query, we will select the SUM of the Population from the 'country' table, ensuring we only include countries that are not in the list of countries that have English as an official language."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation\nFROM country c\nWHERE c.Code NOT IN (\n    SELECT cl.CountryCode\n    FROM countrylanguage cl\n    WHERE cl.Language = 'English' AND cl.IsOfficial = 'T'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.774", "db_id": "world_1", "question": "What are the African countries that have a  population less than any country in Asia?", "rationale": ["Identify the countries in Africa by filtering the 'country' table for 'Continent = 'Africa'.", "Determine the population criteria by finding the minimum population of countries in Asia using a subquery: 'SELECT MIN(Population) FROM country WHERE Continent = 'Asia'.", "Combine these two criteria in the main query to select the names of African countries that have a population less than the minimum population of any Asian country."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Africa'  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  'Asia')", "source_tables": ["country"], "pred_sql": "SELECT Name FROM country WHERE Continent = 'Africa' AND Population < (SELECT MIN(Population) FROM country WHERE Continent = 'Asia');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.777", "db_id": "world_1", "question": "What are the Asian countries which have a population larger than that of any country in Africa?", "rationale": ["Identify the countries in Asia by filtering the 'country' table where the 'Continent' is 'Asia'.", "We need to compare the population of these Asian countries with the population of countries in Africa.", "To find the maximum population in Africa, we can use a subquery that selects the maximum population from the 'country' table where the 'Continent' is 'Africa'.", "The final query selects the names of Asian countries whose population is greater than the maximum population found in the African countries."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Asia'  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  'Africa')", "source_tables": ["country"], "pred_sql": "SELECT c.Name \nFROM country c \nWHERE c.Continent = 'Asia' \nAND c.Population > (SELECT MAX(Population) FROM country WHERE Continent = 'Africa');", "hint": "\n"}
{"sample_id": "dev.778", "db_id": "world_1", "question": "What are the country codes for countries that do not speak English?", "rationale": ["Identify the main requirement: to find country codes for countries that do not speak English.", "Understand that we need to check the 'countrylanguage' table to find countries where English is an official language.", "Use a subquery to select country codes from the 'countrylanguage' table where the language is 'English' and it is marked as official (IsOfficial = 'T').", "Use the NOT IN clause to filter out these country codes from the main query that selects from the 'country' table.", "Select distinct country codes from the 'country' table that are not in the list of country codes that speak English."], "gold_sql": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["countrylanguage"], "pred_sql": "SELECT DISTINCT country.Code \nFROM country \nWHERE country.Code NOT IN (\n    SELECT countrylanguage.CountryCode \n    FROM countrylanguage \n    WHERE countrylanguage.Language = 'English' AND countrylanguage.IsOfficial = 'T'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.786", "db_id": "world_1", "question": "Which unique cities are in Asian countries where Chinese is the official language ?", "rationale": ["Identify the relevant tables: 'city', 'country', and 'countrylanguage'.", "We need to find unique cities, so we will use SELECT DISTINCT on the city names.", "Join the 'city' table with the 'country' table on the CountryCode to get the continent information.", "Join the 'country' table with the 'countrylanguage' table to filter by the official language.", "Filter the results to include only cities in Asia and where Chinese is an official language."], "gold_sql": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  't' and t2.language  =  'chinese' and t1.continent  =  'asia'", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT DISTINCT city.Name \nFROM city \nJOIN country ON city.CountryCode = country.Code \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE country.Continent = 'Asia' \nAND countrylanguage.Language = 'Chinese' \nAND countrylanguage.IsOfficial = 'T';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the columns needed: Name, IndepYear, and SurfaceArea from the country table.", "Determine the condition to find the country with the lowest population: this requires a subquery to find the minimum population.", "Construct the subquery to select the minimum population from the country table: SELECT MIN(Population) FROM country.", "Use the result of the subquery in the main query to filter the country with that minimum population.", "Combine the selected columns and the condition into a complete SQL query."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["Identify the relevant tables: We need to use the 'country' table to get country names and the 'countrylanguage' table to count the languages spoken in each country.", "Join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' fields to associate countries with their languages.", "Group the results by country name to aggregate the language counts for each country.", "Use the COUNT function to count the number of languages spoken in each country.", "Filter the results using the HAVING clause to include only those countries that speak more than 2 languages."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Name, COUNT(cl.Language) AS LanguageCount\nFROM country c\nJOIN countrylanguage cl ON c.Code = cl.CountryCode\nGROUP BY c.Name\nHAVING COUNT(cl.Language) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the relevant table: The question pertains to government forms and population, which are found in the 'country' table.", "Select the columns needed: We need 'GovernmentForm' and the total population, so we will select 'GovernmentForm' and use SUM() on 'Population'.", "Apply the condition: We need to filter for countries with an average life expectancy greater than 72, so we will add a WHERE clause for 'LifeExpectancy > 72'.", "Group the results: Since we want the total population for each government form, we will use GROUP BY on 'GovernmentForm'.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation\nFROM country\nWHERE LifeExpectancy > 72\nGROUP BY GovernmentForm;", "hint": "\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the table to query: The 'city' table contains the relevant information about cities.", "Determine the columns needed: We need the 'Name' of the cities and the 'Population' to filter them.", "Formulate the condition: We want cities with a population between 160000 and 900000.", "Construct the SQL query: Use the SELECT statement to retrieve the city names where the population meets the specified range."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT Name FROM city WHERE Population BETWEEN '160000' AND '900000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.820", "db_id": "world_1", "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find the country codes where Spanish is spoken.", "Determine the criteria: We are interested in the language 'Spanish' and want to find the countries where it is spoken by the largest percentage of the population.", "Join the tables: We will join 'countrylanguage' with 'country' on the 'CountryCode' to get the country details along with the language details.", "Select the country codes: We will select the 'Code' from the 'country' table.", "Order the results: We will order the results by the 'Percentage' column in descending order to get the countries where Spanish is spoken by the largest percentage of people."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "pred_sql": "SELECT country.Code FROM countrylanguage JOIN country ON countrylanguage.CountryCode = country.Code WHERE countrylanguage.Language = 'Spanish' ORDER BY countrylanguage.Percentage DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.821", "db_id": "world_1", "question": "Return the codes of countries for which Spanish is the predominantly spoken language.", "rationale": ["Identify the relevant table: The 'countrylanguage' table contains information about languages spoken in countries.", "Determine the criteria: We need to find countries where Spanish is predominantly spoken, which can be indicated by a percentage greater than 50%.", "Construct the SQL query: We will select the 'CountryCode' from the 'countrylanguage' table where the 'Language' is 'Spanish' and the 'Percentage' is greater than 50%."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "pred_sql": "SELECT cl.CountryCode \nFROM countrylanguage cl \nWHERE cl.Language = 'Spanish' AND cl.Percentage > 50;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\"\n}\n"}
{"sample_id": "dev.920", "db_id": "dog_kennels", "question": "What is the average age of the dogs who have gone through any treatments?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to find the average age of dogs that have undergone treatments, so we will join the Dogs table with the Treatments table on the dog_id.", "Use the AVG() function to calculate the average age of the dogs from the Dogs table after the join."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT AVG(D.age) AS average_age\nFROM Dogs D\nJOIN Treatments T ON D.dog_id = T.dog_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.936", "db_id": "dog_kennels", "question": "Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.", "rationale": ["Identify the relevant tables: Owners, Dogs, and Treatments.", "Join the Owners table with the Dogs table on owner_id to link owners to their dogs.", "Join the resulting table with the Treatments table on dog_id to link dogs to their treatments.", "Group the results by owner_id and last_name to aggregate the treatment counts for each owner.", "Count the number of treatments for each owner using COUNT(Treatments.treatment_id).", "Order the results in descending order to find the owner with the most treatments.", "Limit the results to 1 to get only the top owner."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT Owners.owner_id, Owners.last_name\nFROM Owners\nJOIN Dogs ON Owners.owner_id = Dogs.owner_id\nJOIN Treatments ON Dogs.dog_id = Treatments.dog_id\nGROUP BY Owners.owner_id, Owners.last_name\nORDER BY COUNT(Treatments.treatment_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["We need to find professionals who have administered at least two different types of treatments.", "This requires joining the 'Professionals' table with the 'Treatments' table on the professional_id.", "We will group the results by professional_id to count the distinct treatment types each professional has administered.", "Using the HAVING clause, we can filter the groups to include only those with a count of distinct treatment types greater than or equal to 2.", "Finally, we select the professional_id and cell_number from the filtered results."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT p.professional_id, p.cell_number\nFROM Professionals p\nJOIN Treatments t ON p.professional_id = t.professional_id\nGROUP BY p.professional_id\nHAVING COUNT(DISTINCT t.treatment_type_code) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\"\n}\n"}
{"sample_id": "dev.944", "db_id": "dog_kennels", "question": "What are the first name and last name of the professionals who have done treatment with cost below average?", "rationale": ["Identify the tables needed: Professionals and Treatments.", "We need to join the Professionals table with the Treatments table on the professional_id.", "We need to select the first_name and last_name from the Professionals table.", "We need to filter the results to include only those treatments where the cost is below the average cost of treatments.", "To find the average cost, we will use a subquery that calculates the average from the Treatments table."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT DISTINCT p.first_name, p.last_name \nFROM Professionals p \nJOIN Treatments t ON p.professional_id = t.professional_id \nWHERE t.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\"\n}\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["Identify the required information: owner's first name, last name, and dog's size.", "Determine the relevant tables: Owners, Dogs, and Sizes.", "Establish the relationships between the tables: Owners to Dogs (via owner_id) and Dogs to Sizes (via size_code).", "Use JOIN clauses to combine the tables based on these relationships.", "Select the appropriate columns from the combined tables."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.951", "db_id": "dog_kennels", "question": "What are each owner's first name, last name, and the size of their dog?", "rationale": ["Identify the required information: owner's first name, last name, and dog's size.", "Determine the relevant tables: Owners, Dogs, and Sizes.", "Establish the relationships between the tables: Owners to Dogs (via owner_id) and Dogs to Sizes (via size_code).", "Use JOIN clauses to combine the tables based on these relationships.", "Select the appropriate columns from the combined tables."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "Determine the columns needed: arriving date (date_arrived) and departing date (date_departed) from the Dogs table.", "Establish the relationship between Dogs and Treatments using the dog_id foreign key.", "Construct the SQL query to select the required columns from Dogs, joining with Treatments to filter for dogs that have undergone treatment."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT Dogs.date_arrived, Dogs.date_departed \nFROM Dogs \nJOIN Treatments ON Dogs.dog_id = Treatments.dog_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.961", "db_id": "dog_kennels", "question": "Who owns the youngest dog? Give me his or her last name.", "rationale": ["Identify the relevant tables: Owners and Dogs.", "We need to find the youngest dog, which requires accessing the Dogs table to get the date_of_birth.", "Join the Owners table with the Dogs table on the owner_id to link owners with their dogs.", "Order the results by date_of_birth in descending order to get the youngest dog first.", "Limit the results to 1 to get only the owner of the youngest dog."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.last_name \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nORDER BY Dogs.date_of_birth DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["Identify the tables needed: Breeds, Sizes, and Dogs.", "We need to find distinct combinations of breed types and size types for dogs.", "Join the Dogs table with the Breeds table on breed_code to get breed names.", "Join the Dogs table with the Sizes table on size_code to get size descriptions.", "Select distinct breed names and size descriptions to get unique combinations."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT B.breed_name, S.size_description\nFROM Dogs D\nJOIN Breeds B ON D.breed_code = B.breed_code\nJOIN Sizes S ON D.size_code = S.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\"\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["We need to retrieve the first names of professionals and the descriptions of the treatments they have performed.", "The relevant tables for this query are 'Professionals', 'Treatments', and 'Treatment_Types'.", "We will join these tables based on their foreign key relationships: 'Treatments.professional_id' with 'Professionals.professional_id' and 'Treatments.treatment_type_code' with 'Treatment_Types.treatment_type_code'.", "Using SELECT DISTINCT ensures that we only get unique combinations of professional first names and treatment descriptions."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT DISTINCT Professionals.first_name, Treatment_Types.treatment_type_description\nFROM Professionals\nJOIN Treatments ON Professionals.professional_id = Treatments.professional_id\nJOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\"\n}\n"}
