{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["Identify the table that contains course registrations, which is 'Student_Course_Registrations'.", "Count the number of students registered for each course by using COUNT(student_id) and group the results by course_id.", "Order the results in descending order to find the course with the most registrations.", "Limit the results to 1 to get only the course with the highest number of registered students."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT course_id, COUNT(student_id) AS number_of_students \nFROM Student_Course_Registrations \nGROUP BY course_id \nORDER BY number_of_students DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n    \"1\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n    \"2\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["The question asks for the IDs of students who attended some courses.", "To find this information, we need to look at the 'Student_Course_Attendance' table, which records attendance of students for courses.", "We want to select unique student IDs, so we will use the DISTINCT keyword to avoid duplicates.", "The final SQL query will select the distinct student_id from the Student_Course_Attendance table."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n    \"2\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\"\n}\n"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["The question asks for the IDs of all students who have attended at least one course.", "To find this information, we need to look at the 'Student_Course_Attendance' table, which records attendance for students in courses.", "We will select the 'student_id' from the 'Student_Course_Attendance' table.", "Using DISTINCT ensures that we only get unique student IDs, as a student may have attended multiple courses."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n    \"2\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\"\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["Identify the relevant tables: Candidates, People, and Student_Course_Attendance.", "Join the Candidates table with the People table to link candidates to their personal information.", "Join the resulting table with the Student_Course_Attendance table to find attendance records for candidates.", "Order the results by the date of attendance in descending order to get the most recent attendance first.", "Limit the results to 1 to get only the most recent candidate who accessed the course."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT DISTINCT c.candidate_id \nFROM Candidates c \nJOIN People p ON c.candidate_id = p.person_id \nJOIN Student_Course_Attendance a ON p.person_id = a.student_id \nORDER BY a.date_of_attendance DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n    \"2\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\"\n}\n"}
{"sample_id": "train.77", "db_id": "student_assessment", "question": "What is detail of the student who registered the most number of courses?", "rationale": ["Identify the table that contains student details, which is the 'Students' table.", "Determine the relationship between students and their course registrations, which is found in the 'Student_Course_Registrations' table.", "To find the student who registered for the most courses, we need to count the number of course registrations for each student.", "Group the results by student_id and order them by the count of course registrations in descending order.", "Limit the results to only the top entry to get the student with the most registrations.", "Join this result back to the 'Students' table to retrieve the details of that student."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT s.student_id, s.student_details \nFROM Students s \nJOIN ( \n    SELECT student_id, COUNT(course_id) AS course_count \n    FROM Student_Course_Registrations \n    GROUP BY student_id \n    ORDER BY course_count DESC \n    LIMIT 1 \n) AS most_courses ON s.student_id = most_courses.student_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n    \"2\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\"\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["We need to retrieve the course ID and course names along with the count of registered students for each course.", "To achieve this, we will use a SELECT statement to get the course_id and course_name from the Courses table.", "We will also need to count the number of students registered for each course, which can be done using the COUNT() function on the student_id from the Student_Course_Registrations table.", "To link the Courses and Student_Course_Registrations tables, we will use a LEFT JOIN on the course_id.", "We will group the results by course_id and course_name to ensure we get the count of students for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT Courses.course_id, COUNT(Student_Course_Registrations.student_id) AS student_count, Courses.course_name \nFROM Courses \nLEFT JOIN Student_Course_Registrations ON Courses.course_id = Student_Course_Registrations.course_id \nGROUP BY Courses.course_id, Courses.course_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n    \"2\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\"\n}\n"}
{"sample_id": "train.90", "db_id": "student_assessment", "question": "What are the ids of the students who registered for course 301 most recently?", "rationale": ["Identify the relevant table: 'Student_Course_Registrations' contains the registration information for students and courses.", "Filter the records to only include those where the course_id is '301'.", "Order the results by 'registration_date' in descending order to get the most recent registration first.", "Limit the results to 1 to get only the most recent student registration for course 301."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n    \"2\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["We need to find distinct cities of addresses associated with students.", "To do this, we will join the Addresses table with the People_Addresses table to link addresses to people.", "Next, we will join the resulting table with the Students table to filter for only those people who are students.", "Finally, we will select the distinct cities from the Addresses table."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "pred_sql": "SELECT DISTINCT a.city\nFROM Addresses a\nJOIN People_Addresses pa ON a.address_id = pa.address_id\nJOIN Students s ON pa.person_id = s.student_id;", "hint": "\n"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["We need to find students who registered for courses but did not attend any.", "First, we will select the details from the 'Students' table.", "We will join the 'Student_Course_Registrations' table to get the registered courses for each student.", "Next, we will perform a LEFT JOIN with the 'Student_Course_Attendance' table to check for attendance records.", "In the WHERE clause, we will filter for students where the attendance record is NULL, indicating they did not attend any course."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "pred_sql": "SELECT s.student_id, s.student_details \nFROM Students s \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nLEFT JOIN Student_Course_Attendance sca ON scr.student_id = sca.student_id AND scr.course_id = sca.course_id \nWHERE sca.student_id IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n    \"2\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant tables: We need to look at the 'Student_Course_Registrations' table to find students who registered for courses, and the 'Courses' table to filter for the course named 'Statistics'.", "Join the tables: We will join 'Student_Course_Registrations' with 'Courses' on the course_id to access course names.", "Filter for the specific course: We will add a WHERE clause to filter the results to only include registrations for the course 'Statistics'.", "Select the student_id: We will select the student_id from the 'Student_Course_Registrations' table.", "Order by registration date: Finally, we will order the results by the registration_date to get the students in the order they registered."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT sr.student_id\nFROM Student_Course_Registrations sr\nJOIN Courses c ON sr.course_id = c.course_id\nWHERE c.course_name = 'Statistics'\nORDER BY sr.registration_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n    \"2\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\"\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Determine the specific course of interest, which is 'Statistics'.", "Use a subquery to find the course_id associated with the course name 'Statistics'.", "Select the student_id from 'Student_Course_Registrations' where the course_id matches the one found in the subquery.", "Order the results by the registration_date to get the ids in the order of registration."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n    \"2\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.123", "db_id": "bike_1", "question": "For each zip code, return the average mean temperature of August there.", "rationale": ["Identify the relevant table: The 'weather' table contains the temperature data and zip codes.", "Determine the columns needed: We need 'zip_code' and the average of 'mean_temperature_f'.", "Filter the data for August: Use a WHERE clause to filter the dates to include only those in August.", "Group the results: Use GROUP BY to aggregate the results by 'zip_code' to get the average temperature for each zip code."], "gold_sql": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE '8/%' GROUP BY zip_code", "source_tables": ["weather"], "pred_sql": "SELECT zip_code, AVG(mean_temperature_f) AS average_mean_temperature\nFROM weather\nWHERE date BETWEEN '2023-08-01' AND '2023-08-31'\nGROUP BY zip_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n    \"1\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n    \"2\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\"\n}\n"}
{"sample_id": "train.135", "db_id": "bike_1", "question": "Which bike traveled the most often in zip code 94002?", "rationale": ["Identify the relevant table: The 'trip' table contains information about bike trips, including the bike identifier and the zip code of the user.", "Filter trips by zip code: We need to filter the trips to only include those that started in zip code 94002.", "Count trips per bike: We will group the results by bike_id and count the number of trips for each bike.", "Order by trip count: To find the bike that traveled the most often, we will order the results in descending order based on the trip count.", "Limit the results: Since we only want the bike that traveled the most often, we will limit the results to 1."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id, COUNT(*) AS trip_count\nFROM trip\nWHERE zip_code = '94002'\nGROUP BY bike_id\nORDER BY trip_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n    \"1\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n    \"2\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\"\n}\n"}
{"sample_id": "train.136", "db_id": "bike_1", "question": "What is the id of the bike that traveled the most in 94002?", "rationale": ["Identify the relevant table: The 'trip' table contains the information about bike trips, including the bike_id and duration.", "Filter trips by zip code: We need to focus on trips that started in the zip code '94002'.", "Order the results: To find the bike that traveled the most, we will order the trips by duration in descending order.", "Limit the results: Since we only need the bike that traveled the most, we will limit the results to 1."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id\nFROM trip\nWHERE zip_code = '94002'\nORDER BY duration DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n    \"1\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n    \"2\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\"\n}\n"}
{"sample_id": "train.143", "db_id": "bike_1", "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?", "rationale": ["We need to select the names and ids of stations.", "The relevant tables are 'station' and 'status'.", "We will join the 'station' table with the 'status' table on the station id.", "We need to group the results by station id to calculate the average number of bikes available.", "We will use the HAVING clause to filter for stations with an average of more than 14 bikes available.", "Additionally, we will check if the installation date of the station falls in December using the strftime function to extract the month from the installation_date."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT s.name, s.id \nFROM station s \nJOIN status st ON s.id = st.station_id \nGROUP BY s.id \nHAVING AVG(st.bikes_available) > 14 OR strftime('%m', s.installation_date) = '12';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n    \"1\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.144", "db_id": "bike_1", "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "rationale": ["Identify the relevant tables: 'station' for station details and 'status' for bike availability.", "Join the 'station' table with the 'status' table on the station ID to access bike availability data.", "Group the results by station ID to calculate the average number of bikes available for each station.", "Use the HAVING clause to filter stations that have an average of more than 14 bikes available.", "Additionally, check if the installation date of the station falls in December using a LIKE clause to match the month in the date format."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT s.name, s.id \nFROM station s \nJOIN status st ON s.id = st.station_id \nGROUP BY s.id \nHAVING AVG(st.bikes_available) > 14 \n   OR s.installation_date LIKE '%-12-%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n    \"1\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.145", "db_id": "bike_1", "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?", "rationale": ["Identify the relevant table: The question pertains to cloud cover rates, which are found in the 'weather' table.", "Filter by zip code: We need to focus on records where the zip code is 94107, so we will include a WHERE clause for this.", "Group by cloud cover: To find the most common cloud cover rates, we will group the results by the 'cloud_cover' column.", "Count occurrences: We will count how many times each cloud cover rate appears using COUNT(cloud_cover).", "Order results: To find the most common rates, we will order the results in descending order based on the count of occurrences.", "Limit results: Finally, we will limit the results to the top 3 most common cloud cover rates using LIMIT 3."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "pred_sql": "SELECT cloud_cover, COUNT(cloud_cover) AS cover_count\nFROM weather\nWHERE zip_code = 94107\nGROUP BY cloud_cover\nORDER BY cover_count DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n    \"1\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n    \"2\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\"\n}\n"}
{"sample_id": "train.161", "db_id": "bike_1", "question": "For each trip, return its ending station's installation date.", "rationale": ["We need to return the installation date of the ending station for each trip.", "The relevant tables are 'trip' and 'station'.", "We will join the 'trip' table with the 'station' table on the condition that the 'end_station_id' from the 'trip' table matches the 'id' from the 'station' table.", "We will select the 'installation_date' from the 'station' table as it corresponds to the ending station of each trip."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.installation_date \nFROM trip t \nJOIN station s ON t.end_station_id = s.id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n    \"1\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n    \"2\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\"\n}\n"}
{"sample_id": "train.162", "db_id": "bike_1", "question": "What is the installation date for each ending station on all the trips?", "rationale": ["Identify the relevant tables: 'trip' for trips and 'station' for station details.", "We need the installation date of each ending station, which is found in the 'station' table.", "The 'trip' table contains the 'end_station_id' which links to the 'id' in the 'station' table.", "Use a JOIN operation to combine 'trip' and 'station' on the condition that 'trip.end_station_id' matches 'station.id'.", "Select the 'installation_date' from the 'station' table after the join."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.installation_date \nFROM trip t \nJOIN station s ON t.end_station_id = s.id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n    \"1\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\"\n}\n"}
{"sample_id": "train.163", "db_id": "bike_1", "question": "Which trip started from the station with the largest dock count? Give me the trip id.", "rationale": ["Identify the relevant tables: We need to look at the 'trip' table for trip details and the 'station' table for dock counts.", "Determine the relationship: The 'trip' table has a foreign key 'start_station_id' that relates to the 'id' in the 'station' table.", "Find the station with the largest dock count: We can use a subquery to find the maximum dock count from the 'station' table.", "Join the tables: We will join the 'trip' table with the 'station' table on the station ID to filter trips that started from the station with the maximum dock count.", "Select the trip ID: Finally, we will select the trip ID from the resulting dataset."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "pred_sql": "SELECT trip.id \nFROM trip \nJOIN station ON trip.start_station_id = station.id \nWHERE station.dock_count = (SELECT MAX(dock_count) FROM station);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n    \"1\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n    \"2\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\"\n}\n"}
{"sample_id": "train.165", "db_id": "bike_1", "question": "Count the number of trips that did not end in San Francisco city.", "rationale": ["Identify the requirement to count trips that did not end in San Francisco.", "To achieve this, we need to filter trips based on their end station.", "We will use a subquery to find all station IDs that are located in San Francisco.", "The subquery will select the 'id' from the 'station' table where the 'city' is 'San Francisco'.", "The main query will count all trips where the 'end_station_id' is not in the list of IDs returned by the subquery."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) AS trip_count \nFROM trip \nWHERE end_station_id NOT IN (\n    SELECT id \n    FROM station \n    WHERE city = 'San Francisco'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.166", "db_id": "bike_1", "question": "How many trips did not end in San Francisco?", "rationale": ["Identify the relevant table: The 'trip' table contains information about trips, including the end station name.", "Determine the condition: We need to count trips that did not end in San Francisco, which means we will filter the results where the 'end_station_name' is not equal to 'San Francisco'.", "Use the COUNT function: To get the total number of trips that meet the condition, we will use the COUNT(*) function.", "Construct the SQL query: Combine the SELECT statement with the FROM clause and the WHERE condition to form the complete SQL query."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != 'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) AS trip_count \nFROM trip \nWHERE end_station_name != 'San Francisco';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.167", "db_id": "bike_1", "question": "In zip code 94107, on which day neither Fog nor Rain was not observed?", "rationale": ["Identify the relevant table: The 'weather' table contains the weather reports including events like Fog and Rain.", "Filter by zip code: We need to focus on the records where the zip code is 94107.", "Exclude specific weather events: We want to find days where neither Fog nor Rain was observed, which can be done by checking the 'events' column for the absence of these terms.", "Select distinct dates: We want to retrieve unique dates that meet the criteria, so we will use SELECT DISTINCT."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT date \nFROM weather \nWHERE zip_code = 94107 \nAND events NOT LIKE '%Fog%' \nAND events NOT LIKE '%Rain%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n    \"1\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n    \"2\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\"\n}\n"}
{"sample_id": "train.168", "db_id": "bike_1", "question": "On which day has it neither been foggy nor rained in the zip code of 94107?", "rationale": ["Identify the relevant table: The 'weather' table contains the necessary information about weather conditions.", "Determine the conditions for the query: We need to find days with no fog (events IS NULL) and no rain (precipitation_inches = 0).", "Specify the zip code: We are interested in the weather reports for the zip code 94107.", "Construct the SQL query: Select the date from the weather table where the conditions are met."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT date \nFROM weather \nWHERE zip_code = 94107 \nAND events IS NULL \nAND precipitation_inches = 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n    \"1\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n    \"2\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\"\n}\n"}
{"sample_id": "train.183", "db_id": "bike_1", "question": "List all the cities in a decreasing order of each city's stations' highest latitude.", "rationale": ["We need to list all the cities from the 'station' table.", "To find the highest latitude for each city, we will use the MAX function on the 'lat' column.", "We will group the results by 'city' to ensure we get the highest latitude for each city.", "Finally, we will order the results in decreasing order of the highest latitude using ORDER BY clause."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, MAX(lat) AS highest_latitude\nFROM station\nGROUP BY city\nORDER BY highest_latitude DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.184", "db_id": "bike_1", "question": "For each city, list their names in decreasing order by their highest station latitude.", "rationale": ["We need to select the city and name of the stations from the 'station' table.", "The requirement is to list the names of the stations for each city.", "To fulfill the requirement of ordering by the highest latitude, we will use the 'lat' column from the 'station' table.", "We will order the results in descending order to get the highest latitude first."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, name FROM station ORDER BY lat DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.189", "db_id": "bike_1", "question": "For each station, return its longitude and the average duration of trips that started from the station.", "rationale": ["We need to select the longitude of each station and the average duration of trips that started from that station.", "The 'station' table contains the longitude information, while the 'trip' table contains the duration of trips and the starting station ID.", "To get the average duration of trips for each station, we will join the 'station' table with the 'trip' table on the station ID.", "We will group the results by the station ID to calculate the average duration for each station.", "Finally, we will select the longitude and the calculated average duration in the SQL query."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.long, AVG(t.duration) AS average_duration\nFROM station s\nJOIN trip t ON s.id = t.start_station_id\nGROUP BY s.id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n    \"1\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n    \"2\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\"\n}\n"}
{"sample_id": "train.190", "db_id": "bike_1", "question": "For each start station id, what is its name, longitude and average duration of trips started there?", "rationale": ["We need to retrieve the start station id, name, longitude, and average duration of trips that started at each station.", "The relevant table for station information is the 'station' table, which contains the station id, name, and longitude.", "The 'trip' table contains the duration of trips and the start station id.", "To get the average duration of trips for each start station, we will join the 'station' table with the 'trip' table on the station id and the start station id.", "We will use the AVG() function to calculate the average duration of trips for each station.", "Finally, we will group the results by the station id, name, and longitude to get the average duration for each unique station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.id, s.name, s.long, AVG(t.duration) AS average_duration\nFROM station s\nJOIN trip t ON s.id = t.start_station_id\nGROUP BY s.id, s.name, s.long;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n    \"1\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n    \"2\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\"\n}\n"}
{"sample_id": "train.192", "db_id": "bike_1", "question": "For each end station id, what is its name, latitude, and minimum duration for trips ended there?", "rationale": ["We need to retrieve the end station id, name, latitude, and minimum duration for trips that ended at each station.", "The relevant tables are 'station' for station details and 'trip' for trip details.", "We will join the 'station' table with the 'trip' table on the end station id, which is represented by 'end_station_id' in the 'trip' table.", "We will select the station id, name, and latitude from the 'station' table, and the minimum duration of trips from the 'trip' table.", "To get the minimum duration, we will use the MIN() function and group the results by station id, name, and latitude."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.id, s.name, s.lat, MIN(t.duration) AS min_duration\nFROM station s\nJOIN trip t ON s.id = t.end_station_id\nGROUP BY s.id, s.name, s.lat;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n    \"1\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n    \"2\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\"\n}\n"}
{"sample_id": "train.196", "db_id": "bike_1", "question": "What are all the different zip codes that have a maximum dew point that was always below 70?", "rationale": ["We need to find all unique zip codes where the maximum dew point is always below 70.", "To achieve this, we will select distinct zip codes from the weather table.", "We will group the results by zip_code to aggregate the data for each zip code.", "We will use the HAVING clause to filter the groups where the maximum dew point (max_dew_point_f) is less than 70."], "gold_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT zip_code \nFROM weather \nGROUP BY zip_code \nHAVING MAX(max_dew_point_f) < 70;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n    \"1\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n    \"2\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\"\n}\n"}
{"sample_id": "train.205", "db_id": "bike_1", "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.", "rationale": ["We need to find zip codes where the average mean humidity is below 70 and at least 100 trips took place.", "First, we will group the 'trip' table by 'zip_code' and count the number of trips for each zip code using COUNT(id).", "We will filter these groups using HAVING to ensure that only those with at least 100 trips are included.", "Next, we need to check the average mean humidity for each zip code in the 'weather' table.", "We will create a subquery that groups the 'weather' table by 'zip_code' and calculates the average mean humidity using AVG(mean_humidity).", "We will filter this subquery using HAVING to include only those zip codes where the average mean humidity is below 70.", "Finally, we will use the results of the subquery to filter the main query, ensuring that we only select zip codes that meet both criteria."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code \nFROM trip \nGROUP BY zip_code \nHAVING COUNT(id) >= 100 AND zip_code IN (\n    SELECT zip_code \n    FROM weather \n    GROUP BY zip_code \n    HAVING AVG(mean_humidity) < 70\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n    \"1\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n    \"2\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\"\n}\n"}
{"sample_id": "train.206", "db_id": "bike_1", "question": "What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?", "rationale": ["We need to find zip codes with an average mean humidity below 70 and at least 100 trips.", "First, we will group the 'trip' table by 'zip_code' and count the number of trips for each zip code using COUNT(id).", "Next, we will filter these groups to only include those with at least 100 trips using HAVING COUNT(id) >= 100.", "Simultaneously, we need to check the average mean humidity for each zip code in the 'weather' table.", "We will create a subquery that groups the 'weather' table by 'zip_code' and calculates the average mean humidity using AVG(mean_humidity).", "We will filter this subquery to only include zip codes where the average mean humidity is below 70 using HAVING AVG(mean_humidity) < 70.", "Finally, we will use the results of the subquery to filter the main query, ensuring that we only select zip codes that meet both criteria."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code \nFROM trip \nGROUP BY zip_code \nHAVING COUNT(id) >= 100 AND zip_code IN (\n    SELECT zip_code \n    FROM weather \n    GROUP BY zip_code \n    HAVING AVG(mean_humidity) < 70\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n    \"1\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n    \"2\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\"\n}\n"}
{"sample_id": "train.304", "db_id": "product_catalog", "question": "What are the attribute data types with more than 3 attribute definitions?", "rationale": ["Identify the table that contains the attribute definitions, which is 'Attribute_Definitions'.", "We need to find the attribute data types, so we will select the 'attribute_data_type' column.", "To find the data types with more than 3 definitions, we will group the results by 'attribute_data_type'.", "We will use the HAVING clause to filter groups that have a count of 'attribute_id' greater than 3."], "gold_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  3", "source_tables": ["attribute_definitions"], "pred_sql": "SELECT attribute_data_type\nFROM Attribute_Definitions\nGROUP BY attribute_data_type\nHAVING COUNT(attribute_id) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\"\n}\n"}
{"sample_id": "train.316", "db_id": "product_catalog", "question": "Find the entry names of the catalog with the attribute that have the most entries.", "rationale": ["Identify the relevant tables: Catalog_Contents for entry names and Catalog_Contents_Additional_Attributes for attributes.", "Join Catalog_Contents with Catalog_Contents_Additional_Attributes on catalog_entry_id to link entries with their attributes.", "Group the results by catalog_entry_name to count the number of attributes associated with each entry.", "Order the results by the count of attributes in descending order to find the entry with the most attributes.", "Limit the results to 1 to get only the entry name with the most attributes."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT cc.catalog_entry_name\nFROM Catalog_Contents cc\nJOIN Catalog_Contents_Additional_Attributes cca ON cc.catalog_entry_id = cca.catalog_entry_id\nGROUP BY cc.catalog_entry_name\nORDER BY COUNT(cca.attribute_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n    \"1\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n    \"2\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\"\n}\n"}
{"sample_id": "train.317", "db_id": "product_catalog", "question": "What is the entry name of the most expensive catalog (in USD)?", "rationale": ["Identify the relevant table: Catalog_Contents contains the catalog entries and their prices.", "We need to find the entry name of the most expensive catalog, which means we need to order the entries by price in descending order.", "Use the ORDER BY clause to sort the entries by price_in_dollars in descending order.", "Limit the results to 1 to get only the most expensive entry.", "Select the catalog_entry_name to get the name of the most expensive catalog entry."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents ORDER BY price_in_dollars DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n    \"1\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n    \"2\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\"\n}\n"}
{"sample_id": "train.330", "db_id": "product_catalog", "question": "What are the names of catalog entries with level number 8?", "rationale": ["Identify the relevant table: The question asks for catalog entries, which are found in the 'Catalog_Contents' table.", "Determine the specific column needed: The question specifically asks for the names of the catalog entries, which corresponds to the 'catalog_entry_name' column.", "Apply the filter: The question specifies a level number of 8, so we need to filter the results where 'catalog_level_number' equals '8'.", "Construct the SQL query: Combine the selected column and the filter condition into a complete SQL query."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  '8'", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE catalog_level_number = '8';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n    \"1\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n    \"2\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\"\n}\n"}
{"sample_id": "train.331", "db_id": "product_catalog", "question": "Find the names of the products with length smaller than 3 or height greater than 5.", "rationale": ["Identify the table that contains product information, which is the Catalog_Contents table.", "Determine the relevant columns needed for the query: catalog_entry_name for product names, length for the length condition, and height for the height condition.", "Construct the SQL SELECT statement to retrieve the catalog_entry_name from the Catalog_Contents table.", "Add the WHERE clause to filter products based on the conditions: length smaller than 3 or height greater than 5."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name \nFROM Catalog_Contents \nWHERE length < 3 OR height > 5;", "hint": "\n"}
{"sample_id": "train.332", "db_id": "product_catalog", "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.", "rationale": ["Identify the relevant table: The question asks about catalog contents, which are stored in the 'Catalog_Contents' table.", "Determine the columns needed: We need the 'catalog_entry_name' column from the 'Catalog_Contents' table.", "Apply the conditions: The question specifies that we need entries with a length below 3 or above 5. This translates to a WHERE clause in SQL that filters based on the 'length' column.", "Construct the SQL query: Combine the SELECT statement with the FROM clause and the WHERE conditions to form the complete SQL query."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE length < 3 OR length > 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n    \"1\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n    \"2\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\"\n}\n"}
{"sample_id": "train.338", "db_id": "product_catalog", "question": "On which days more than one revisions were made on catalogs.", "rationale": ["Identify the relevant table: The 'Catalogs' table contains information about catalog revisions, specifically the 'date_of_latest_revision' column.", "Group the results by the 'date_of_latest_revision' to count how many revisions were made on each date.", "Use the COUNT function to count the number of revisions for each date.", "Filter the results using the HAVING clause to only include dates where the count of revisions is greater than one."], "gold_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1", "source_tables": ["catalogs"], "pred_sql": "SELECT date_of_latest_revision, COUNT(*) as revision_count \nFROM Catalogs \nGROUP BY date_of_latest_revision \nHAVING COUNT(*) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n    \"1\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n    \"2\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\"\n}\n"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flight origins and destinations.", "Determine the required information: We need to find the origins of flights that are headed to Honolulu.", "Construct the SQL query: Use SELECT to get distinct origins from the flight table where the destination is 'Honolulu'."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT DISTINCT origin FROM flight WHERE destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n    \"1\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the required columns: We need the 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We are interested in flights that depart from 'LA' and arrive at 'Honolulu'.", "Construct the SQL query: Use a SELECT statement to retrieve the specified columns from the 'flight' table, applying the necessary WHERE clause to filter the results."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n    \"1\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their prices.", "Determine the columns needed: We need the 'price' column to calculate the average price.", "Filter the results: We need to filter the flights to only include those from 'LA' to 'Honolulu'.", "Use the AVG() function: To calculate the average price of the filtered flights, we will use the AVG() function in SQL.", "Construct the SQL query: Combine all the elements into a complete SQL query that selects the average price from the flight table with the specified conditions."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT AVG(price) AS average_price \nFROM flight \nWHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n    \"1\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["Identify the tables needed: We need data from the 'aircraft' table for aircraft names and from the 'flight' table to count the number of flights.", "We will use a LEFT JOIN to combine the 'aircraft' table with the 'flight' table on the aircraft ID (aid) to ensure we get all aircraft even if they have no flights.", "We will use COUNT(f.flno) to count the number of flights associated with each aircraft.", "We need to group the results by aircraft ID and name to get the count for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT a.name, COUNT(f.flno) AS number_of_flights\nFROM aircraft a\nLEFT JOIN flight f ON a.aid = f.aid\nGROUP BY a.aid, a.name;", "hint": "\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables needed: We need information from the 'aircraft' table for aircraft names and the 'flight' table to count the number of flights.", "We will use a LEFT JOIN to connect the 'aircraft' table with the 'flight' table on the aircraft ID (aid) to ensure we include all aircraft, even those with no flights.", "We will use COUNT(f.flno) to count the number of flights for each aircraft.", "We will group the results by the aircraft ID (a.aid) to get the count of flights for each aircraft.", "Finally, we will select the aircraft name and the count of flights in the output."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT a.name, COUNT(f.flno) AS flight_count\nFROM aircraft a\nLEFT JOIN flight f ON a.aid = f.aid\nGROUP BY a.aid;", "hint": "\n"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["Identify the tables involved: employee, certificate, and aircraft.", "We need to find employees who are not certified to fly a specific aircraft (Boeing 737-800).", "Use a LEFT JOIN to connect employee with certificate to find all employees and their certifications.", "Use another LEFT JOIN to connect certificate with aircraft to get the aircraft details.", "Filter the results to include only those employees who do not have a certification for Boeing 737-800.", "The condition for filtering is that the aircraft name should not be 'Boeing 737-800' or the aircraft name should be NULL (indicating no certification)."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.name \nFROM employee e \nLEFT JOIN certificate c ON e.eid = c.eid \nLEFT JOIN aircraft a ON c.aid = a.aid \nWHERE a.name != 'Boeing 737-800' OR a.name IS NULL;", "hint": "\n"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["Identify the relevant tables: We need to get the aircraft names from the 'aircraft' table and the count of certificates from the 'certificate' table.", "Join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid) to associate each aircraft with its certificates.", "Group the results by aircraft ID to count how many certificates each aircraft has.", "Order the results by the count of certificates in ascending order to find the aircraft with the fewest certificates.", "Limit the results to 1 to get only the aircraft with the fewest certificates."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nORDER BY COUNT(c.eid) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.432", "db_id": "flight_1", "question": "What are the names of the aircraft that the least people are certified to fly?", "rationale": ["Identify the relevant tables: We need to find aircraft names and the number of employees certified to fly each aircraft, so we will use the 'aircraft' and 'certificate' tables.", "Join the tables: We will join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid) to link aircraft with their certified employees.", "Group by aircraft: We will group the results by the aircraft ID to count the number of certifications for each aircraft.", "Count certifications: Use COUNT(c.eid) to count the number of employees certified for each aircraft.", "Order by count: We will order the results in ascending order based on the count of certifications to find the aircraft with the least certifications.", "Limit the results: Finally, we will limit the results to 1 to get the aircraft with the least number of certified employees."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nORDER BY COUNT(c.eid) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["Identify the relevant tables: employee, certificate, and aircraft.", "We need to find employees who have certificates to fly aircraft with a distance greater than 5000.", "Join the employee table with the certificate table on employee ID (eid) and then join with the aircraft table on aircraft ID (aid).", "Filter the results to include only those aircraft where the distance is greater than 5000.", "Group the results by employee ID to count the number of certificates each employee has.", "Order the results by the count of certificates in descending order to find the employee with the most certificates.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.salary, e.name \nFROM employee e \nJOIN certificate c ON e.eid = c.eid \nJOIN aircraft a ON c.aid = a.aid \nWHERE a.distance > 5000 \nGROUP BY e.eid \nORDER BY COUNT(c.aid) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The question asks for all the different food allergies, which implies we need to retrieve unique allergy names.", "We will use the 'Allergy_Type' table, which contains the 'Allergy' column that lists the names of the allergies.", "To get all unique allergies, we will use the SELECT DISTINCT statement to avoid duplicates."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Allergy_Type;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.452", "db_id": "allergy_1", "question": "How many animal type allergies exist?", "rationale": ["Identify the relevant table: The Allergy_Type table contains the allergy types.", "Determine the specific allergy type: We are interested in counting the distinct allergy types that fall under 'Animal'.", "Use the COUNT function to count the distinct AllergyType entries that match 'Animal'.", "Construct the SQL query to select the count of distinct AllergyType from the Allergy_Type table where the AllergyType is 'Animal'."], "gold_sql": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  'animal'", "source_tables": ["allergy_type"], "pred_sql": "SELECT COUNT(DISTINCT AllergyType) AS Animal_Allergy_Count\nFROM Allergy_Type\nWHERE AllergyType = 'Animal';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["Identify the tables involved: We need to look at the 'Allergy_Type' and 'Has_Allergy' tables to find the allergy types and their counts.", "Join the tables: We will join 'Has_Allergy' with 'Allergy_Type' on the common column 'Allergy' to get the allergy types associated with each student.", "Group by allergy type: We will group the results by 'AllergyType' to count how many allergies fall under each type.", "Count the allergies: Use COUNT() to count the number of occurrences of each allergy type.", "Order the results: We will order the results in descending order based on the count of allergies to find the most common allergy type.", "Limit the results: Finally, we will limit the results to 1 to get only the allergy type with the highest count."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(Has_Allergy.Allergy) AS AllergyCount\nFROM Has_Allergy\nJOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy\nGROUP BY AllergyType\nORDER BY AllergyCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["We need to find the least common allergy type, which means we need to count how many students have each type of allergy.", "To do this, we will join the 'Has_Allergy' table with the 'Allergy_Type' table on the Allergy column.", "We will group the results by AllergyType to get the count of students for each allergy type.", "Next, we will order the results by the count of students in ascending order to find the least common allergy type.", "Finally, we will limit the results to 1 to get only the least common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(StuID) AS AllergyCount\nFROM Has_Allergy\nJOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy\nGROUP BY AllergyType\nORDER BY AllergyCount ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student names, which is the 'Student' table.", "To get the full names, we need to concatenate the 'Fname' and 'LName' columns.", "Use the SQL SELECT statement to retrieve the concatenated names as 'FullName'."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName FROM Student;", "hint": "\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the table needed: The 'Student' table contains the information about students, including their IDs and gender.", "Determine the condition: We need to filter the students based on their gender, specifically for male students.", "Construct the SQL query: Use a SELECT statement to retrieve the 'StuID' from the 'Student' table where the 'Sex' column equals 'Male'."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the majors, which is the 'Student' table.", "We need to group the results by the 'Major' column to count how many students are in each major.", "Use the COUNT function to count the number of students (StuID) for each major.", "Order the results in descending order based on the count of students to find the largest major.", "Limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(StuID) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major and ordered by the number of students in each major in descending order. The placeholder in the LIMIT clause represents the maximum number of majors to return.\"\n}\n"}
{"sample_id": "train.502", "db_id": "allergy_1", "question": "Give the advisor with the most students.", "rationale": ["Identify the table that contains advisor information, which is the 'Student' table.", "We need to count the number of students for each advisor, so we will use the COUNT() function on the 'StuID' column.", "Group the results by the 'Advisor' column to aggregate the student counts for each advisor.", "Order the results in descending order based on the count of students to find the advisor with the most students.", "Limit the results to 1 to get only the advisor with the highest count."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(StuID) AS StudentCount\nFROM Student\nGROUP BY Advisor\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of academic advisors from the 'Student' table, grouped by the advisor's name. The results are ordered by the number of students assigned to each advisor in descending order, with a limit on the number of advisors returned, specified by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["Identify the relevant tables: We need to count students with specific allergies, so we will use the 'Has_Allergy' table which links students to their allergies.", "Determine the condition: We are interested in students who have 'cat' allergies, so we will filter the results based on this condition.", "Count distinct students: We need to count the unique student IDs (StuID) from the 'Has_Allergy' table where the allergy matches 'cat'.", "Construct the SQL query: Using the COUNT function to get the number of distinct students with the specified allergy."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(DISTINCT Has_Allergy.StuID) AS StudentCount \nFROM Has_Allergy \nWHERE Has_Allergy.Allergy = 'cat';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the relevant tables: We need to look at the 'Has_Allergy' table to find students with specific allergies.", "Determine the specific allergy: The question asks about 'cat allergies', so we will filter for that allergy.", "Count the unique students: We need to count the distinct 'StuID' from the 'Has_Allergy' table where the allergy is 'cat'.", "Construct the SQL query: We will use the COUNT function to get the number of unique students affected by cat allergies."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(DISTINCT Has_Allergy.StuID) AS StudentCount \nFROM Has_Allergy \nWHERE Allergy = 'cat';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["We need to count the number of female students who have specific allergies (milk or eggs).", "To do this, we will join the 'Student' table with the 'Has_Allergy' table on the 'StuID' column, which is the unique identifier for students.", "We will filter the results to include only female students by adding a condition in the WHERE clause: 'Student.Sex = 'Female'.", "Next, we will specify the allergies we are interested in (milk and eggs) using the IN clause: 'Has_Allergy.Allergy IN ('milk', 'eggs')'.", "Finally, we will use COUNT(DISTINCT Student.StuID) to count the unique students that meet these criteria."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Student.Sex = 'Female' \nAND Has_Allergy.Allergy IN ('milk', 'eggs');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.514", "db_id": "allergy_1", "question": "Which allergy is the most common?", "rationale": ["Identify the relevant tables: 'Has_Allergy' contains the allergies associated with students.", "To find the most common allergy, we need to count occurrences of each allergy in the 'Has_Allergy' table.", "Use the COUNT function to count how many students have each allergy.", "Group the results by the 'Allergy' column to aggregate the counts for each allergy.", "Order the results in descending order based on the count to get the most common allergy at the top.", "Limit the results to 1 to retrieve only the most common allergy."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT Allergy, COUNT(*) as AllergyCount \nFROM Has_Allergy \nGROUP BY Allergy \nORDER BY AllergyCount DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["We need to find students who have allergies to both milk and cat.", "To do this, we will join the 'Student' table with the 'Has_Allergy' table twice: once for each allergy.", "The first join (HA1) will filter for students with a milk allergy, and the second join (HA2) will filter for students with a cat allergy.", "We will select the last name (LName) and age (Age) of the students who meet both conditions.", "The final SQL query will include the necessary SELECT, FROM, and JOIN clauses, along with the appropriate WHERE conditions."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.LName, S.Age \nFROM Student S \nJOIN Has_Allergy HA1 ON S.StuID = HA1.StuID \nJOIN Has_Allergy HA2 ON S.StuID = HA2.StuID \nWHERE HA1.Allergy = 'milk' AND HA2.Allergy = 'cat';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the tables needed: We need to retrieve student information (last names and ages) and their allergies, so we will use the 'Student' and 'Has_Allergy' tables.", "Determine the relationship: The 'Has_Allergy' table links students to their allergies via the 'StuID' column, which is a foreign key in 'Has_Allergy'.", "Select the required columns: We need 'LName' and 'Age' from the 'Student' table.", "Filter the results: We need to filter students who have allergies to 'milk' and 'cat'. This can be done using the WHERE clause with the IN operator to specify multiple allergies.", "Group the results: Since we are joining tables and filtering, we should group by 'StuID' to ensure we get unique student records."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Student.LName, Student.Age \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat') \nGROUP BY Student.StuID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.523", "db_id": "allergy_1", "question": "Find the first name and gender of the student who has allergy to milk but not cat.", "rationale": ["Identify the tables needed: We need data from the 'Student' table for first names and gender, and the 'Has_Allergy' table to filter students based on their allergies.", "We need to find students who have an allergy to 'milk'. This requires a subquery that selects 'StuID' from 'Has_Allergy' where 'Allergy' is 'milk'.", "We also need to exclude students who have an allergy to 'cat'. This requires another subquery that selects 'StuID' from 'Has_Allergy' where 'Allergy' is 'cat'.", "Combine the results: Use the 'StuID' from the first subquery to filter the 'Student' table, and use the 'StuID' from the second subquery to exclude those students from the results.", "Select the desired columns: Finally, select 'Fname' and 'Sex' from the 'Student' table for the filtered results."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex \nFROM Student \nWHERE StuID IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'milk'\n) \nAND StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'cat'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.524", "db_id": "allergy_1", "question": "What are the first name and gender of the students who have allergy to milk but can put up with cats?", "rationale": ["Identify the required fields: first name (Fname) and gender (Sex) of students.", "Filter students who have an allergy to milk. This requires a subquery to the Has_Allergy table where Allergy = 'milk'.", "Also, filter out students who have an allergy to cats. This requires another subquery to the Has_Allergy table where Allergy = 'cats'.", "Combine these conditions using the IN and NOT IN clauses to get the desired results."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex \nFROM Student \nWHERE StuID IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'milk'\n) \nAND StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'cats'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the tables needed: We need to get student ages from the 'Student' table and filter based on allergies from the 'Has_Allergy' and 'Allergy_Type' tables.", "Join the tables: We will join 'Student' with 'Has_Allergy' on 'StuID' and then join 'Has_Allergy' with 'Allergy_Type' on 'Allergy' to access the allergy types associated with each student.", "Filter by allergy types: We need to filter the results to include only those students who have allergies categorized as 'food' or 'animal'.", "Calculate the average age: We will use the AVG() function to calculate the average age of the filtered students, ensuring to cast the age to an integer for accurate calculation."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT AVG(CAST(Student.Age AS INTEGER)) AS Average_Age\nFROM Student\nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID\nJOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy\nWHERE Allergy_Type.AllergyType IN ('food', 'animal');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["We need to find students who are not allergic to any type of food.", "To do this, we will select the first name and last name of each student from the Student table.", "We will use a LEFT JOIN between the Student table and the Has_Allergy table to include all students, even those without allergies.", "Next, we will also LEFT JOIN the Allergy_Type table to get the allergy types associated with each allergy.", "In the WHERE clause, we will filter for cases where the AllergyType is NULL, which indicates that the student has no allergies."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT S.Fname || ' ' || S.LName AS FullName \nFROM Student S \nLEFT JOIN Has_Allergy HA ON S.StuID = HA.StuID \nLEFT JOIN Allergy_Type AT ON HA.Allergy = AT.Allergy \nWHERE AT.AllergyType IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["Identify the tables needed: Student, Has_Allergy, and Allergy_Type.", "We need to count the number of male students, so we will filter the Student table by Sex = 'M'.", "We need to find students with allergies, so we will join the Has_Allergy table on StuID.", "We also need to filter for allergies that are of type 'Food', so we will join the Allergy_Type table and filter by AllergyType = 'Food'.", "Finally, we will use COUNT(DISTINCT s.StuID) to get the number of unique male students with food allergies."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT COUNT(DISTINCT s.StuID) \nFROM Student s \nJOIN Has_Allergy ha ON s.StuID = ha.StuID \nJOIN Allergy_Type at ON ha.Allergy = at.Allergy \nWHERE s.Sex = 'M' AND at.AllergyType = 'Food';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables needed: We need data from the 'Student' table for first names and city codes, and from the 'Has_Allergy' table to filter students with specific allergies.", "Determine the relationship: The 'Has_Allergy' table links students to their allergies via the 'StuID' column, which is a foreign key in 'Has_Allergy' referencing 'Student'.", "Select the required columns: We need to select distinct first names (Fname) and city codes (city_code) from the 'Student' table.", "Filter the results: We need to filter the results to include only those students who have allergies to either 'milk' or 'cat'. This is done using the WHERE clause with the IN operator to specify the allergies.", "Construct the SQL query: Combine the SELECT statement, JOIN clause, and WHERE clause to form the complete SQL query."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT Student.Fname, Student.city_code \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["Identify the tables needed: We need data from the 'Student' table for first names and city codes, and the 'Has_Allergy' table to filter students based on their allergies.", "Determine the relationship: The 'Has_Allergy' table links students to their allergies via the 'StuID' column, which is a foreign key in 'Has_Allergy' referencing 'Student'.", "Select the required fields: We need to select distinct first names (Fname) and city codes (city_code) from the 'Student' table.", "Filter the results: We need to filter students who have allergies to either 'milk' or 'cat'. This is done using a WHERE clause that checks if the allergy is in the specified list.", "Join the tables: Use an INNER JOIN to combine 'Student' and 'Has_Allergy' on the 'StuID' column to get the relevant data."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT Student.Fname, Student.city_code \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["We need to find the names of the countries and the average invoice size.", "The relevant table for this information is the 'invoices' table, which contains the 'billing_country' and 'total' columns.", "To calculate the average invoice size for each country, we will use the AVG() function on the 'total' column.", "We will group the results by 'billing_country' to get the average for each country.", "To get the top countries by average invoice size, we will order the results in descending order based on the average invoice size.", "Finally, we will limit the results to the top 10 countries."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size\nFROM invoices\nGROUP BY billing_country\nORDER BY AVG(total) DESC\nLIMIT 10;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["Identify the relevant table: invoices, which contains billing information.", "We need to count the number of invoices for each state, so we will use the COUNT() function.", "We will group the results by billing_state to get the count for each state.", "The final SQL query will select the billing_state and the count of invoices, grouping by billing_state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["We need to find the states with the most invoices, which means we will be counting the number of invoices per state.", "The relevant table for this information is the 'invoices' table, which contains a 'billing_state' column.", "To get the count of invoices per state, we will use the COUNT() function and group the results by 'billing_state'.", "Finally, we will order the results in descending order to show the states with the most invoices at the top."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state\nORDER BY invoice_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.568", "db_id": "store_1", "question": "What is the number of invoices and total money billed in them from CA?", "rationale": ["Identify the relevant table: invoices, which contains information about invoices including total amounts and billing details.", "Determine the required information: the number of invoices and the total amount billed.", "Use COUNT(*) to count the number of invoices and SUM(total) to calculate the total amount billed.", "Filter the results to only include invoices from California (CA) by adding a WHERE clause that specifies billing_state = 'CA'."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS number_of_invoices, SUM(total) AS total_billed FROM invoices WHERE billing_state = 'CA';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the table that contains the required information: The 'employees' table has the email and phone number of employees.", "Determine the specific employee: The question asks for Astrid Gruber, so we need to filter the results based on the first name 'Astrid' and last name 'Gruber'.", "Construct the SQL query: We will select the 'email' and 'phone' columns from the 'employees' table where the first name is 'Astrid' and the last name is 'Gruber'."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the street address of employees from the 'employees' table based on their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the employee being queried.\"\n}\n"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["Identify the relevant table: The 'customers' table contains information about customers, including their state.", "Determine the condition: We need to count customers specifically from California, so we will filter the results where the 'state' column equals 'California'.", "Construct the SQL query: Use the COUNT() function to count the number of customers that meet the condition, and select this count as 'customer_count'."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) AS customer_count FROM customers WHERE state = 'California';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: We need to find employees and customers, so we will use the 'employees' and 'customers' tables.", "Join the tables: We will join the 'employees' table with the 'customers' table on the 'support_rep_id' to link customers to their respective support representatives.", "Group by employee: We will group the results by employee ID to count the number of customers each employee supports.", "Count customers: We will use COUNT(c.id) to count the number of customers for each employee.", "Order the results: We will order the results in descending order based on the count of customers supported.", "Limit the results: We will limit the results to 1 to get the employee who supports the most customers."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees who report to a specific manager from the 'employees' table. The placeholders in the WHERE clause represent the first and last names of the manager.\"\n}\n"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["Identify the relevant tables: invoices and customers.", "Determine the relationship between invoices and customers: invoices have a customer_id that links to the customers table.", "Filter the customers table to find the specific customer 'Luca Mancini' using first_name and last_name.", "Count the number of invoices associated with this customer using COUNT(*) function."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "pred_sql": "SELECT COUNT(*) AS order_count \nFROM invoices \nJOIN customers ON invoices.customer_id = customers.id \nWHERE customers.first_name = 'Luca' AND customers.last_name = 'Mancini';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["Identify the track 'Balls to the Wall' in the tracks table.", "Join the tracks table with the albums table using the album_id foreign key.", "Select the title of the album from the albums table where the track name matches 'Balls to the Wall'."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT albums.title FROM albums JOIN tracks ON albums.id = tracks.album_id WHERE tracks.name = 'Balls to the Wall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\"\n}\n"}
{"sample_id": "train.626", "db_id": "store_1", "question": "What is the name of all tracks in the album named Balls to the Wall?", "rationale": ["Identify the relevant tables: We need to retrieve track names from the 'tracks' table and filter them based on the album title from the 'albums' table.", "Determine the relationship: The 'tracks' table has a foreign key 'album_id' that references the 'id' in the 'albums' table, allowing us to join these two tables.", "Construct the SQL query: We will select the 'name' column from the 'tracks' table and join it with the 'albums' table on the condition that the album title matches 'Balls to the Wall'."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN albums ON tracks.album_id = albums.id \nWHERE albums.title = 'Balls to the Wall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\"\n}\n"}
{"sample_id": "train.630", "db_id": "store_1", "question": "What are the names of all Rock tracks that are stored on MPEG audio files?", "rationale": ["Identify the relevant tables: tracks, media_types, and genres are needed to get track names, media type, and genre respectively.", "Join the tracks table with media_types on media_type_id to filter tracks based on their media type.", "Join the tracks table with genres on genre_id to filter tracks based on their genre.", "Use a WHERE clause to specify that we want tracks that are of the genre 'Rock' and are stored in 'MPEG audio' files."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN media_types ON tracks.media_type_id = media_types.id \nJOIN genres ON tracks.genre_id = genres.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG audio';", "hint": "\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the tables involved: tracks, genres, and media_types.", "We need to select the track names, so we will select 'tracks.name'.", "To filter tracks by genre, we will join the 'tracks' table with the 'genres' table on 'tracks.genre_id = genres.id'.", "To filter tracks by media type, we will join the 'tracks' table with the 'media_types' table on 'tracks.media_type_id = media_types.id'.", "We will add a WHERE clause to filter for the genre 'Rock' and the media type 'MPEG'.", "Combine all these elements to form the final SQL query."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN genres ON tracks.genre_id = genres.id \nJOIN media_types ON tracks.media_type_id = media_types.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG';", "hint": "\n"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["Identify the relevant tables: tracks, invoice_lines, invoices, and customers are needed to find the tracks bought by a specific customer.", "Join the tables: We need to join tracks with invoice_lines to get the track purchases, then join invoice_lines with invoices to link to the customer, and finally join invoices with customers to filter by the customer's name.", "Filter by customer name: Use a WHERE clause to specify that we are looking for purchases made by Dean Peeters, using both first and last name."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN invoice_lines ON tracks.id = invoice_lines.track_id \nJOIN invoices ON invoice_lines.invoice_id = invoices.id \nJOIN customers ON invoices.customer_id = customers.id \nWHERE customers.first_name = 'Dean' AND customers.last_name = 'Peeters';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\"\n}\n"}
{"sample_id": "train.686", "db_id": "customers_card_transactions", "question": "What are the full names of customers who do not have any accounts?", "rationale": ["We need to find customers who do not have any accounts, which means we need to check the relationship between the Customers and Accounts tables.", "To do this, we can use a LEFT JOIN to combine the Customers table with a subquery that counts the number of accounts for each customer.", "The subquery selects the customer_id from the Accounts table and counts the number of account_id entries, grouping by customer_id.", "In the main query, we select the first and last names of customers from the Customers table.", "We then join this with the subquery on customer_id, and filter the results where the account count is NULL, indicating that those customers have no accounts."], "gold_sql": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_first_name, c.customer_last_name \nFROM Customers c \nLEFT JOIN (SELECT customer_id, COUNT(account_id) AS account_count \n            FROM Accounts \n            GROUP BY customer_id) a \nON c.customer_id = a.customer_id \nWHERE a.account_count IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\",\n    \"1\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\"\n}\n"}
{"sample_id": "train.688", "db_id": "customers_card_transactions", "question": "What are the full names of customers who have accounts?", "rationale": ["We need to find the full names of customers who have accounts, which means we need to join the Customers table with the Accounts table.", "The Customers table contains the first and last names of customers, which we can concatenate to form the full name.", "The Accounts table contains the customer_id that links to the Customers table, allowing us to find which customers have accounts.", "We will use a JOIN operation to combine the two tables based on the customer_id, and then select the concatenated full name from the result."], "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\",\n    \"1\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\"\n}\n"}
{"sample_id": "train.704", "db_id": "customers_card_transactions", "question": "Return the full name and phone of the customer who has card number 4560596484842.", "rationale": ["Identify the tables needed: We need information from the 'Customers' table for customer details and the 'Customers_Cards' table for card details.", "Determine the fields to select: We need the full name (first and last name) and the phone number of the customer.", "Join the tables: We will join 'Customers' and 'Customers_Cards' on 'customer_id' to link customers with their cards.", "Filter the results: We will filter the results to only include the customer with the specified card number '4560596484842'.", "Construct the SQL query: Combine all the elements into a valid SQL SELECT statement."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.card_number  =  '4560596484842'", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name, customer_phone \nFROM Customers \nJOIN Customers_Cards ON Customers.customer_id = Customers_Cards.customer_id \nWHERE Customers_Cards.card_number = '4560596484842';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\"\n}\n"}
{"sample_id": "train.717", "db_id": "customers_card_transactions", "question": "What is the customer id, first and last name with least number of accounts.", "rationale": ["We need to find the customer with the least number of accounts.", "To do this, we will join the 'Customers' table with the 'Accounts' table on the 'customer_id'.", "We will use a LEFT JOIN to ensure we include customers even if they have no accounts.", "Next, we will group the results by customer ID, first name, and last name to count the number of accounts for each customer.", "We will use the COUNT function to count the number of accounts associated with each customer.", "Finally, we will order the results by the count of accounts in ascending order and limit the results to 1 to get the customer with the least number of accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name \nFROM Customers c \nLEFT JOIN Accounts a ON c.customer_id = a.customer_id \nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name \nORDER BY COUNT(a.account_id) ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\",\n    \"1\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\"\n}\n"}
{"sample_id": "train.718", "db_id": "customers_card_transactions", "question": "Return the id and full name of the customer who has the fewest accounts.", "rationale": ["We need to find the customer with the fewest accounts.", "To do this, we will first summarize the number of accounts associated with each customer using a subquery that counts the accounts grouped by customer_id.", "Next, we will join this subquery with the Customers table to get the customer details.", "We will select the customer_id and concatenate the first and last name to get the full name of the customer.", "Finally, we will order the results by the account count in ascending order and limit the result to 1 to get the customer with the fewest accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nJOIN (SELECT customer_id, COUNT(*) AS account_count\n      FROM Accounts\n      GROUP BY customer_id) ac ON c.customer_id = ac.customer_id\nORDER BY ac.account_count ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\"\n}\n"}
{"sample_id": "train.721", "db_id": "customers_card_transactions", "question": "What is the card type code with most number of cards?", "rationale": ["Identify the relevant table: Customers_Cards contains the card type codes and card IDs.", "Count the number of cards for each card type code using COUNT(card_id).", "Group the results by card type code to aggregate the counts.", "Order the results in descending order based on the count of cards to find the most frequent card type.", "Limit the results to 1 to get only the card type code with the most number of cards."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "pred_sql": "SELECT card_type_code, COUNT(card_id) AS card_count \nFROM Customers_Cards \nGROUP BY card_type_code \nORDER BY card_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table summarizes the different types of cards issued to customers, displaying the card type codes from the 'Customers_Cards' table. The results are grouped by card type code and ordered by the frequency of each type, allowing the user to specify a limit on the number of types returned.\"\n}\n"}
{"sample_id": "train.735", "db_id": "customers_card_transactions", "question": "Show the number of transaction types.", "rationale": ["The user wants to know the number of transaction types.", "To achieve this, we need to select the 'transaction_type' from the 'Financial_Transactions' table.", "We will use the COUNT function to count the occurrences of each transaction type.", "We will group the results by 'transaction_type' to get the count for each type."], "gold_sql": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, COUNT(*) AS transaction_count \nFROM Financial_Transactions \nGROUP BY transaction_type;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions associated with each account from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account identifier, while the count function aggregates the total number of transactions for each account.\",\n    \"1\": \"The virtual table summarizes the different types of cards issued to customers, displaying the card type codes from the 'Customers_Cards' table. The results are grouped by card type code and ordered by the frequency of each type, allowing the user to specify a limit on the number of types returned.\"\n}\n"}
{"sample_id": "train.743", "db_id": "customers_card_transactions", "question": "What is the transaction type that has processed the greatest total amount in transactions?", "rationale": ["Identify the relevant table: Financial_Transactions contains the transaction details including type and amount.", "We need to group the transactions by their type to calculate the total amount for each type.", "Use the SUM function to calculate the total amount for each transaction type.", "Order the results in descending order to find the transaction type with the greatest total amount.", "Limit the results to 1 to get only the top transaction type."], "gold_sql": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, SUM(transaction_amount) AS total_amount\nFROM Financial_Transactions\nGROUP BY transaction_type\nORDER BY total_amount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions associated with each account from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account identifier, while the count function aggregates the total number of transactions for each account.\"\n}\n"}
{"sample_id": "train.893", "db_id": "insurance_fnol", "question": "What are the customer phone numbers under the policy \"Life Insurance\"?", "rationale": ["Identify the relevant tables: Available_Policies for customer phone numbers and Services for policy names.", "Join the Available_Policies table with Customers_Policies to link customers with their policies.", "Join the Services table to filter for the specific policy type, 'Life Insurance'.", "Select the Customer_Phone from the resulting joined tables where the policy name matches 'Life Insurance'."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "pred_sql": "SELECT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nJOIN Services s ON s.Service_ID = cp.Policy_ID \nWHERE s.Service_name = 'Life Insurance';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\"\n}\n"}
{"sample_id": "train.895", "db_id": "insurance_fnol", "question": "Which policy type has the most records in the database?", "rationale": ["We need to find out which policy type has the most records in the database.", "To do this, we will query the 'Available_Policies' table, focusing on the 'policy_type_code' column.", "We will use the COUNT function to count the occurrences of each policy type.", "We will group the results by 'policy_type_code' to aggregate the counts for each type.", "To find the most common policy type, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one record to get the top policy type."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "pred_sql": "SELECT policy_type_code, COUNT(*) as policy_count \nFROM Available_Policies \nGROUP BY policy_type_code \nORDER BY policy_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\"\n}\n"}
{"sample_id": "train.897", "db_id": "insurance_fnol", "question": "What are all the customer phone numbers under the most popular policy type?", "rationale": ["We need to find all customer phone numbers associated with the most popular policy type.", "To determine the most popular policy type, we can create a subquery that counts the occurrences of each policy type in the Available_Policies table, grouping by the policy_type_code and ordering by the count in descending order, limiting the result to the top one.", "Next, we join this subquery with the Customers_Policies table to link the most popular policy type to the customers who have that policy.", "We also need to join the Available_Policies table to get the Customer_Phone associated with the policy.", "Finally, we select distinct customer phone numbers to avoid duplicates."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nJOIN (\n    SELECT policy_type_code, COUNT(*) as policy_count \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    ORDER BY policy_count DESC \n    LIMIT 1\n) AS most_popular_policy ON ap.policy_type_code = most_popular_policy.policy_type_code \nJOIN Customers c ON cp.Customer_ID = c.Customer_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\"\n}\n"}
{"sample_id": "train.898", "db_id": "insurance_fnol", "question": "Find the phone numbers of customers using the most common policy type among the available policies.", "rationale": ["Identify the tables involved: Customers, Customers_Policies, and Available_Policies.", "We need to find the phone numbers of customers, so we will select 'Customer_Phone' from the Customers table.", "To link customers with their policies, we will join the Customers table with the Customers_Policies table on 'Customer_ID'.", "Next, we will join the Customers_Policies table with the Available_Policies table on 'Policy_ID' to access the policy types.", "To find the most common policy type, we will create a subquery that groups the policies by 'policy_type_code', counts them, and orders them in descending order, limiting the result to the top one.", "Finally, we will filter the main query to only include customers whose policies match the most common policy type found in the subquery."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT c.Customer_Phone \nFROM Customers c \nJOIN Customers_Policies cp ON c.Customer_ID = cp.Customer_ID \nJOIN Available_Policies ap ON cp.Policy_ID = ap.Policy_ID \nWHERE ap.policy_type_code = (\n    SELECT policy_type_code \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\"\n}\n"}
{"sample_id": "train.1060", "db_id": "match_season", "question": "Show the players from college UCLA.", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their college.", "Determine the condition: We need to filter players based on their college, specifically those who attended UCLA.", "Use a subquery: To find the teams associated with UCLA, we can use a subquery on the 'match_season' table to get the 'Team_id' where the 'College' is 'UCLA'.", "Combine the results: The main query will select the 'Player' names from the 'player' table where the 'Team' matches the 'Team_id' from the subquery."], "gold_sql": "SELECT Player FROM match_season WHERE College  =  'UCLA'", "source_tables": ["match_season"], "pred_sql": "SELECT Player FROM player WHERE Team IN (SELECT Team_id FROM match_season WHERE College = 'UCLA');", "hint": "\n"}
{"sample_id": "train.1082", "db_id": "match_season", "question": "Show the season, the player, and the name of the team that players belong to.", "rationale": ["Identify the required columns: Season, Player, and Team Name.", "The Season and Player are from the match_season table.", "The Team Name is from the team table.", "To get the Team Name associated with each player, a JOIN operation is needed between match_season and team tables on the Team identifier.", "Construct the SQL SELECT statement to retrieve the desired columns from the joined tables."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "pred_sql": "SELECT match_season.Season, match_season.Player, team.Name \nFROM match_season \nJOIN team ON match_season.Team = team.Team_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of match seasons, including the season name, player name, and the corresponding team name. The data is retrieved from the 'match_season' table, which is joined with the 'team' table to associate each player with their respective team using the team identifier.\",\n    \"1\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\"\n}\n"}
{"sample_id": "train.1092", "db_id": "match_season", "question": "Show the country names and the corresponding number of players.", "rationale": ["We need to show the country names and the corresponding number of players.", "To get the country names, we will select from the 'country' table.", "We need to count the number of players associated with each country, which requires joining the 'country' table with the 'match_season' table to link players to their countries.", "We also need to join the 'player' table to ensure we are counting the players correctly.", "The join condition will be based on the country identifier in the 'match_season' table and the 'country' table, and the player names in the 'match_season' and 'player' tables.", "Finally, we will group the results by country name to get the count of players for each country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "pred_sql": "SELECT country.Country_name, COUNT(player.Player_ID) AS Number_of_Players\nFROM country\nJOIN match_season ON country.Country_id = match_season.Country\nJOIN player ON match_season.Player = player.Player\nGROUP BY country.Country_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct official native languages of countries represented by players in a specific position during matches. The placeholder in the WHERE clause represents the player's position.\",\n    \"1\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\"\n}\n"}
{"sample_id": "train.1098", "db_id": "match_season", "question": "Show the top 3 most common colleges of players in match seasons.", "rationale": ["We need to find the top 3 most common colleges of players in match seasons.", "To do this, we will query the 'match_season' table, which contains the 'College' column.", "We will use the COUNT function to count the occurrences of each college.", "We will group the results by the 'College' column to aggregate the counts for each college.", "Next, we will order the results in descending order based on the count of players from each college.", "Finally, we will limit the results to the top 3 colleges."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as College_Count \nFROM match_season \nGROUP BY College \nORDER BY College_Count DESC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\",\n    \"1\": \"This virtual table provides a summary of match seasons, including the season name, player name, and the corresponding team name. The data is retrieved from the 'match_season' table, which is joined with the 'team' table to associate each player with their respective team using the team identifier.\"\n}\n"}
{"sample_id": "train.1099", "db_id": "match_season", "question": "What are the three colleges from which the most players are from?", "rationale": ["Identify the relevant table: The 'match_season' table contains the 'College' column and player information.", "Count the number of players from each college: Use COUNT(*) to count the number of players grouped by 'College'.", "Group the results by college: Use GROUP BY College to aggregate the counts for each college.", "Order the results: Use ORDER BY Player_Count DESC to sort the colleges by the number of players in descending order.", "Limit the results to the top three: Use LIMIT 3 to get only the top three colleges with the most players."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as Player_Count\nFROM match_season\nGROUP BY College\nORDER BY Player_Count DESC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.1107", "db_id": "match_season", "question": "Return the names of countries that have players that play the Forward position, as well as players who play the Defender position.", "rationale": ["We need to return the names of countries that have players in specific positions (Forward and Defender).", "To achieve this, we will join the 'country' table with the 'match_season' table using the country identifier (Country_id).", "The join will allow us to associate each player with their respective country during a specific season.", "We will filter the results using a WHERE clause to include only those players whose position is either 'Forward' or 'Defender'.", "Finally, we will select distinct country names to avoid duplicates in the result."], "gold_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "pred_sql": "SELECT DISTINCT c.Country_name\nFROM country c\nJOIN match_season ms ON c.Country_id = ms.Country\nWHERE ms.Position IN ('Forward', 'Defender');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct official native languages of countries represented by players in a specific position during matches. The placeholder in the WHERE clause represents the player's position.\",\n    \"1\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\"\n}\n"}
{"sample_id": "train.1109", "db_id": "match_season", "question": "Return the colleges that have players who play the Midfielder position, as well as players who play the Defender position.", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players, their positions, and the colleges they attended.", "Determine the required positions: We need to filter players who play either 'Midfielder' or 'Defender'.", "Use the SELECT statement to retrieve the 'College' column from the 'match_season' table.", "Apply a WHERE clause to filter the results based on the specified positions.", "Use DISTINCT to ensure that each college is listed only once in the results."], "gold_sql": "SELECT College FROM match_season WHERE POSITION  =  'Midfielder' INTERSECT SELECT College FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "pred_sql": "SELECT DISTINCT College \nFROM match_season \nWHERE Position IN ('Midfielder', 'Defender');", "hint": "\n"}
{"sample_id": "train.1222", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with type code \"Duplex\"?", "rationale": ["Identify the relevant tables: Apartments and Apartment_Bookings are needed to get the apartment type and booking dates.", "Join the Apartments table with the Apartment_Bookings table on the apt_id to link apartments with their bookings.", "Filter the results to only include apartments with the type code 'Duplex'.", "Select the booking start and end dates from the joined tables."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  'Duplex'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartments a \nJOIN Apartment_Bookings ab ON a.apt_id = ab.apt_id \nWHERE a.apt_type_code = 'Duplex';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n    \"1\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\"\n}\n"}
{"sample_id": "train.1224", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with more than 2 bedrooms?", "rationale": ["Identify the relevant tables: Apartments and Apartment_Bookings are needed to get the booking dates and bedroom count.", "Select the booking start and end dates from the Apartment_Bookings table.", "Join the Apartments table with the Apartment_Bookings table on the apt_id to link apartments with their bookings.", "Filter the results to include only those apartments that have more than 2 bedrooms by using a WHERE clause."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartments a \nJOIN Apartment_Bookings ab ON a.apt_id = ab.apt_id \nWHERE a.bedroom_count > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n    \"1\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\"\n}\n"}
{"sample_id": "train.1225", "db_id": "apartment_rentals", "question": "Find the booking start date and end date for the apartments that have more than two bedrooms.", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to link bookings to their respective apartments.", "Filter the results to include only those apartments that have more than two bedrooms by using a WHERE clause with the condition 'a.bedroom_count > 2'.", "Select the booking start date and end date from the results."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartment_Bookings ab \nJOIN Apartments a ON ab.apt_id = a.apt_id \nWHERE a.bedroom_count > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n    \"1\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\"\n}\n"}
{"sample_id": "train.1229", "db_id": "apartment_rentals", "question": "Which apartments have bookings with status code \"Confirmed\"? Return their apartment numbers.", "rationale": ["Identify the relevant tables: Apartments and Apartment_Bookings are needed to find apartment numbers with confirmed bookings.", "Join the Apartments table with the Apartment_Bookings table on the apt_id to link apartments with their bookings.", "Filter the results to include only those bookings where the booking_status_code is 'Confirmed'.", "Select the apt_number from the filtered results to return the desired information."], "gold_sql": "SELECT DISTINCT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  'Confirmed'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT a.apt_number \nFROM Apartments a \nJOIN Apartment_Bookings ab ON a.apt_id = ab.apt_id \nWHERE ab.booking_status_code = 'Confirmed';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n    \"1\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\"\n}\n"}
{"sample_id": "train.1232", "db_id": "apartment_rentals", "question": "Show the guest first names, start dates, and end dates of all the apartment bookings.", "rationale": ["Identify the required fields: guest first names, booking start dates, and booking end dates.", "Determine the relevant tables: Guests for guest information and Apartment_Bookings for booking details.", "Establish the relationship between the tables: Apartment_Bookings is linked to Guests through guest_id.", "Construct the SQL SELECT statement to retrieve the desired fields from the joined tables."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT Guests.guest_first_name, Apartment_Bookings.booking_start_date, Apartment_Bookings.booking_end_date\nFROM Apartment_Bookings\nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\"\n}\n"}
{"sample_id": "train.1234", "db_id": "apartment_rentals", "question": "Show the start dates and end dates of all the apartment bookings made by guests with gender code \"Female\".", "rationale": ["Identify the relevant tables: Apartment_Bookings and Guests.", "Determine the columns needed: booking_start_date and booking_end_date from Apartment_Bookings.", "Establish the relationship between the tables: Apartment_Bookings is linked to Guests via guest_id.", "Filter the results to include only those bookings made by guests with gender code 'Female'.", "Construct the SQL query using SELECT to retrieve the required columns, JOIN to connect the tables, and WHERE to apply the filter."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  'Female'", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT Apartment_Bookings.booking_start_date, Apartment_Bookings.booking_end_date \nFROM Apartment_Bookings \nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id \nWHERE Guests.gender_code = 'Female';", "hint": "\n"}
{"sample_id": "train.1238", "db_id": "apartment_rentals", "question": "Show the facility codes of apartments with more than 4 bedrooms.", "rationale": ["Identify the relevant tables: We need to retrieve facility codes from the Apartment_Facilities table and filter apartments based on the number of bedrooms from the Apartments table.", "Join the Apartment_Facilities table with the Apartments table on the apt_id to link facilities to their respective apartments.", "Apply a filter to select only those apartments that have more than 4 bedrooms using the condition 'a.bedroom_count > 4'.", "Select the distinct facility codes from the joined result to avoid duplicates."], "gold_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "source_tables": ["apartments", "apartment_facilities"], "pred_sql": "SELECT DISTINCT af.facility_code \nFROM Apartment_Facilities af \nJOIN Apartments a ON af.apt_id = a.apt_id \nWHERE a.bedroom_count > 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n    \"1\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\"\n}\n"}
{"sample_id": "train.1256", "db_id": "apartment_rentals", "question": "Show the top 3 apartment type codes sorted by the average number of rooms in descending order.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of rooms.", "Select the columns needed: We need the apartment type code (apt_type_code) and the average number of rooms (AVG(room_count)).", "Group the results by apartment type code: This allows us to calculate the average number of rooms for each type.", "Order the results: We want to sort the results by the average number of rooms in descending order to get the top types.", "Limit the results: We only want the top 3 apartment type codes, so we use the LIMIT clause."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, AVG(room_count) AS average_rooms\nFROM Apartments\nGROUP BY apt_type_code\nORDER BY average_rooms DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n    \"1\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\"\n}\n"}
{"sample_id": "train.1258", "db_id": "apartment_rentals", "question": "Show the apartment type code that has the largest number of total rooms, together with the number of bathrooms and number of bedrooms.", "rationale": ["Identify the relevant table: The Apartments table contains the necessary columns for apartment type code, number of bathrooms, number of bedrooms, and total number of rooms.", "Group the results by apartment type code to aggregate the data: Use GROUP BY apt_type_code to summarize the data for each type of apartment.", "Calculate the maximum number of rooms for each apartment type: Use MAX(room_count) to find the largest number of total rooms for each apartment type.", "Select the number of bathrooms and bedrooms: Include bathroom_count and bedroom_count in the SELECT statement to retrieve these values along with the apartment type code.", "Order the results by the maximum number of rooms in descending order: Use ORDER BY max_rooms DESC to ensure the apartment type with the largest number of rooms appears first.", "Limit the results to only one entry: Use LIMIT 1 to return only the apartment type with the largest number of total rooms."], "gold_sql": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, MAX(room_count) AS max_rooms, bathroom_count, bedroom_count \nFROM Apartments \nGROUP BY apt_type_code \nORDER BY max_rooms DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n    \"1\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\"\n}\n"}
{"sample_id": "train.1261", "db_id": "apartment_rentals", "question": "Which apartment type code appears the most often?", "rationale": ["Identify the relevant table: The Apartments table contains the apt_type_code which we need to analyze.", "Count the occurrences of each apartment type code: We will use COUNT(*) to count how many times each apt_type_code appears.", "Group the results by apt_type_code: This is done using GROUP BY to aggregate the counts for each type code.", "Order the results by the count in descending order: This allows us to see which type code appears the most often at the top of the results.", "Limit the results to the top entry: Using LIMIT 1 ensures we only get the most frequently occurring apartment type code."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, COUNT(*) as type_count \nFROM Apartments \nGROUP BY apt_type_code \nORDER BY type_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n    \"1\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\"\n}\n"}
{"sample_id": "train.1262", "db_id": "apartment_rentals", "question": "Show the most common apartment type code among apartments with more than 1 bathroom.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of bathrooms.", "Filter apartments: We need to filter apartments that have more than 1 bathroom, which is done using the WHERE clause.", "Group by apartment type: To find the most common apartment type, we group the results by the apt_type_code.", "Count occurrences: We use COUNT(*) to count how many apartments exist for each type code.", "Order by count: We order the results in descending order to get the most common type at the top.", "Limit the results: We use LIMIT 1 to get only the most common apartment type code."], "gold_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code\nFROM Apartments\nWHERE bathroom_count > 1\nGROUP BY apt_type_code\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n    \"1\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\"\n}\n"}
{"sample_id": "train.1272", "db_id": "apartment_rentals", "question": "Show the apartment numbers of apartments with unit status availability of both 0 and 1.", "rationale": ["Identify the relevant table for apartment numbers, which is the 'Apartments' table.", "Determine the condition for availability, which is represented in the 'View_Unit_Status' table with the 'available_yn' column.", "Use a subquery to filter apartments based on their availability status, specifically looking for those with both 'Yes' (1) and 'No' (0) availability.", "Select the 'apt_number' from the 'Apartments' table where the 'apt_id' matches the results from the subquery."], "gold_sql": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1", "source_tables": ["view_unit_status", "apartments"], "pred_sql": "SELECT apt_number FROM Apartments WHERE apt_id IN (SELECT apt_id FROM View_Unit_Status WHERE available_yn IN ('Yes', 'No'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n    \"1\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.\"\n}\n"}
{"sample_id": "train.1294", "db_id": "soccer_1", "question": "How many leagues are there in England?", "rationale": ["Identify the relevant table: The question pertains to leagues, so we will use the 'League' table.", "Determine the condition: We need to filter the leagues to only those in England.", "Construct the SQL query: We will use the COUNT function to count the number of leagues that match the condition."], "gold_sql": "SELECT count(*) FROM Country AS T1 JOIN League AS T2 ON T1.id  =  T2.country_id WHERE T1.name  =  'England'", "source_tables": ["country", "league"], "pred_sql": "SELECT COUNT(*) AS league_count FROM League WHERE name = 'England';", "hint": "\n"}
{"sample_id": "train.1303", "db_id": "soccer_1", "question": "List all of the player ids with a height of at least 180cm and an overall rating higher than 85.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to select player ids, so we will select the 'id' column from the Player table.", "We need to filter players based on height and overall rating.", "Join the Player table with Player_Attributes table using the player_api_id as the common key.", "Apply the height filter (at least 180cm) on the Player table.", "Apply the overall rating filter (greater than 85) on the Player_Attributes table."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE overall_rating  >  85", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT p.id\nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.height >= 180 AND pa.overall_rating > 85;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of players from the 'Player' table who have an overall skill rating higher than the average overall rating of all players recorded in the 'Player_Attributes' table. The query uses a subquery to calculate the average overall rating and filters the results accordingly.\",\n    \"1\": \"This virtual table lists the distinct names of players from the 'Player' table who have the highest overall skill rating recorded in the 'Player_Attributes' table. The query joins the 'Player' and 'Player_Attributes' tables based on the player's API identifier and filters the results to only include players whose dribbling attribute matches the maximum overall rating found in the 'Player_Attributes' table.\"\n}\n"}
{"sample_id": "train.1304", "db_id": "soccer_1", "question": "List all of the ids for left-footed players with a height between 180cm and 190cm.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to filter players based on their height, which is in the Player table.", "We also need to filter players based on their preferred foot, which is in the Player_Attributes table.", "The height condition is that it should be between 180cm and 190cm.", "The preferred foot condition is that it should be 'left'.", "We will use a subquery to find the player_api_ids of left-footed players from the Player_Attributes table.", "Finally, we will select the ids of players from the Player table who meet both conditions."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 AND height  <=  190 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE preferred_foot  =  'left'", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT Player.id \nFROM Player \nWHERE Player.height BETWEEN 180 AND 190 \nAND Player.player_api_id IN (\n    SELECT Player_Attributes.player_api_id \n    FROM Player_Attributes \n    WHERE Player_Attributes.preferred_foot = 'left'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of players from the 'Player' table who have the highest overall skill rating recorded in the 'Player_Attributes' table. The query joins the 'Player' and 'Player_Attributes' tables based on the player's API identifier and filters the results to only include players whose dribbling attribute matches the maximum overall rating found in the 'Player_Attributes' table.\"\n}\n"}
{"sample_id": "train.1306", "db_id": "soccer_1", "question": "List the names and birthdays of the top five players in terms of potential.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to retrieve player names and birthdays, so we will select 'player_name' and 'birthday' from the Player table.", "To get the potential ratings, we will join the Player table with the Player_Attributes table using the 'player_api_id' as the key.", "We will order the results by the 'potential' column in descending order to get the top players.", "Finally, we will limit the results to the top five players."], "gold_sql": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT 5", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT player.player_name, player.birthday\nFROM Player AS player\nJOIN Player_Attributes AS attributes ON player.player_api_id = attributes.player_api_id\nORDER BY attributes.potential DESC\nLIMIT 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of players from the 'Player' table who have the highest overall skill rating recorded in the 'Player_Attributes' table. The query joins the 'Player' and 'Player_Attributes' tables based on the player's API identifier and filters the results to only include players whose dribbling attribute matches the maximum overall rating found in the 'Player_Attributes' table.\"\n}\n"}
{"sample_id": "train.1511", "db_id": "insurance_and_eClaims", "question": "Which type of policy is most frequently used? Give me the policy type code.", "rationale": ["To find the most frequently used policy type, we need to count the occurrences of each policy type code in the Policies table.", "We will use the COUNT function to count how many times each Policy_Type_Code appears.", "We will group the results by Policy_Type_Code to aggregate the counts for each type.", "To determine which policy type is the most frequently used, we will order the results in descending order based on the count.", "Finally, we will limit the results to only the top entry to get the most frequently used policy type."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(*) as Frequency\nFROM Policies\nGROUP BY Policy_Type_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\"\n}\n"}
{"sample_id": "train.1513", "db_id": "insurance_and_eClaims", "question": "Find all the policy types that are used by more than 2 customers.", "rationale": ["Identify the relevant table: The 'Policies' table contains the 'Policy_Type_Code' and 'Customer_ID' which are needed to find the policy types used by customers.", "Group the data by 'Customer_ID' to count how many customers are associated with each policy type.", "Use the HAVING clause to filter groups that have more than 2 customers.", "Select the 'Policy_Type_Code' from the 'Policies' table where the 'Customer_ID' meets the criteria established in the subquery.", "Group the final results by 'Policy_Type_Code' to get distinct policy types that meet the condition."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code\nFROM Policies\nWHERE Customer_ID IN (\n    SELECT Customer_ID\n    FROM Policies\n    GROUP BY Customer_ID\n    HAVING COUNT(DISTINCT Customer_ID) > 2\n)\nGROUP BY Policy_Type_Code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\"\n}\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["The question asks for the total and average amount paid in claim headers.", "To get the total amount paid, we can use the SUM() function on the 'Amount_Paid' column from the 'Claim_Headers' table.", "To get the average amount paid, we can use the AVG() function on the same 'Amount_Paid' column.", "We will select both the total and average in a single SQL query using a SELECT statement."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\",\n    \"1\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\",\n    \"2\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\"\n}\n"}
{"sample_id": "train.1518", "db_id": "insurance_and_eClaims", "question": "How much amount in total were claimed in the most recently created document?", "rationale": ["Identify the relevant tables: We need to look at the 'Claim_Headers' table for the amount claimed and the 'Claims_Documents' table to find the most recently created document.", "Determine the relationship: The 'Claim_Headers' table has a 'Claim_Header_ID' that links to the 'Claims_Documents' table through the 'Claim_ID'.", "Find the most recent document: We will use a subquery to select the 'Claim_ID' from 'Claims_Documents' ordered by 'Created_Date' in descending order, limiting the result to 1 to get the most recent document.", "Calculate the total claimed amount: We will sum the 'Amount_Claimed' from 'Claim_Headers' where the 'Claim_Header_ID' matches the 'Claim_ID' from the subquery."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT SUM(Amount_Claimed) AS Total_Claimed_Amount\nFROM Claim_Headers\nWHERE Claim_Header_ID = (\n    SELECT Claim_ID\n    FROM Claims_Documents\n    ORDER BY Created_Date DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\",\n    \"1\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\",\n    \"2\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\"\n}\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Claim_Headers for claims, Policies for linking claims to customers, and Customers for customer details.", "Join the Claim_Headers table with the Policies table on Policy_ID to link claims to their respective policies.", "Join the resulting table with the Customers table on Customer_ID to retrieve customer details associated with each claim.", "Order the results by Amount_Paid in descending order to find the claim with the largest amount paid.", "Limit the results to 1 to get only the customer associated with the largest claim."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details\nFROM Claim_Headers ch\nJOIN Policies p ON ch.Policy_ID = p.Policy_ID\nJOIN Customers c ON p.Customer_ID = c.Customer_ID\nORDER BY ch.Amount_Paid DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\",\n    \"1\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\",\n    \"2\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\"\n}\n"}
{"sample_id": "train.1521", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the minimum amount of payment in one claim?", "rationale": ["Identify the relevant tables: Customers, Claim_Headers, and Policies are needed to get customer details and link claims to customers.", "Join the Claim_Headers table with the Policies table on Policy_ID to connect claims to their respective policies.", "Join the resulting table with the Customers table on Customer_ID to access customer details.", "Use a subquery to find the minimum Amount_Paid from the Claim_Headers table.", "Filter the main query to return customer details where the Amount_Paid matches the minimum amount found in the subquery."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT Customers.Customer_Details \nFROM Claim_Headers \nJOIN Policies ON Claim_Headers.Policy_ID = Policies.Policy_ID \nJOIN Customers ON Policies.Customer_ID = Customers.Customer_ID \nWHERE Claim_Headers.Amount_Paid = (\n    SELECT MIN(Amount_Paid) \n    FROM Claim_Headers\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\",\n    \"1\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\"\n}\n"}
{"sample_id": "train.1531", "db_id": "insurance_and_eClaims", "question": "Find the names of the customers who have an deputy policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Filter the Policies table for those with a Policy_Type_Code of 'deputy'.", "Select the Customer_Details from the Customers table for those who meet the criteria."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Policy_Type_Code = 'deputy';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\",\n    \"1\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\"\n}\n"}
{"sample_id": "train.1533", "db_id": "insurance_and_eClaims", "question": "Find the names of customers who either have an deputy policy or uniformed policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find customers with specific policy types, so we will join the Customers table with the Policies table on Customer_ID.", "The condition for the policies is that the Policy_Type_Code should be either 'deputy' or 'uniformed'.", "We will select distinct customer details to avoid duplicates in the results."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy' OR t1.policy_type_code  =  'Uniform'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT DISTINCT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nWHERE p.Policy_Type_Code IN ('deputy', 'uniformed')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\"\n}\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find the customer associated with the most recently started policy, so we will join the Customers table with the Policies table on Customer_ID.", "To find the most recent policy, we will use a subquery to get the maximum Start_Date from the Policies table.", "The main query will select the Customer_ID and Customer_Details from the Customers table where the Start_Date matches the maximum Start_Date found in the subquery."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Start_Date = (SELECT MAX(Start_Date) FROM Policies);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\",\n    \"1\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\"\n}\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "Determine the columns needed: account_id, account_name, and other_account_details from Accounts.", "Establish the relationship between Accounts and Customers using the customer_id foreign key.", "Filter the results to include only those accounts associated with the customer whose first name is 'Meaghan'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Accounts.account_id, Accounts.account_name, Accounts.other_account_details \nFROM Accounts \nJOIN Customers ON Accounts.customer_id = Customers.customer_id \nWHERE Customers.customer_first_name = 'Meaghan';", "hint": "\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "Determine the columns needed: account_name and other_account_details from Accounts.", "Establish the relationship between Customers and Accounts using the customer_id foreign key.", "Filter the results to only include the customer named Meaghan Keeling by using the WHERE clause with both first and last names."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Accounts.account_name, Accounts.other_account_details \nFROM Customers \nJOIN Accounts ON Customers.customer_id = Accounts.customer_id \nWHERE Customers.customer_first_name = 'Meaghan' AND Customers.customer_last_name = 'Keeling';", "hint": "\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "Determine the columns needed: full names (first and last) from Customers and account name from Accounts.", "Join the Customers table with the Accounts table on the customer_id field to link customers with their accounts.", "Filter the results to include only those accounts with the name '900'.", "Select the concatenated first and last names as the full name."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nJOIN Accounts ON Customers.customer_id = Accounts.customer_id\nWHERE Accounts.account_name = '900';", "hint": "\n"}
{"sample_id": "train.1568", "db_id": "customers_and_invoices", "question": "Return the id and full name of the customer with the most accounts.", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to join these tables on the customer_id to link customers with their accounts.", "We will group the results by customer_id to count the number of accounts each customer has.", "We will order the results by the count of accounts in descending order to find the customer with the most accounts.", "Finally, we will limit the results to 1 to get only the top customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id\nORDER BY COUNT(a.account_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1579", "db_id": "customers_and_invoices", "question": "How many transaction does each account have? Show the number and account id.", "rationale": ["Identify the relevant table: Financial_Transactions contains the transaction data.", "We need to count the number of transactions for each account, which means we will use the COUNT() function.", "We will select the account_id and the count of transaction_id, which gives us the number of transactions per account.", "To group the results by account_id, we will use the GROUP BY clause."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT account_id, COUNT(transaction_id) AS transaction_count\nFROM Financial_Transactions\nGROUP BY account_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\"\n}\n"}
{"sample_id": "train.1589", "db_id": "customers_and_invoices", "question": "Show the account name, id and the number of transactions for each account.", "rationale": ["We need to select the account name and account id from the Accounts table.", "We also need to count the number of transactions for each account, which is stored in the Financial_Transactions table.", "To get the number of transactions per account, we will perform a LEFT JOIN between the Accounts table and the Financial_Transactions table on the account_id.", "We will use the COUNT function to count the transaction_id from the Financial_Transactions table, which gives us the number of transactions for each account.", "Finally, we will group the results by account_id and account_name to ensure we get the count for each unique account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "pred_sql": "SELECT a.account_name, a.account_id, COUNT(ft.transaction_id) AS number_of_transactions\nFROM Accounts a\nLEFT JOIN Financial_Transactions ft ON a.account_id = ft.account_id\nGROUP BY a.account_id, a.account_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\"\n}\n"}
{"sample_id": "train.1599", "db_id": "customers_and_invoices", "question": "Show the invoice number and the number of transactions for each invoice.", "rationale": ["We need to retrieve the invoice number and the number of transactions for each invoice.", "The 'Invoices' table contains the invoice numbers, so we will select 'invoice_number' from this table.", "To count the number of transactions associated with each invoice, we will join the 'Financial_Transactions' table on the 'invoice_number'.", "We will use a LEFT JOIN to ensure we include all invoices even if there are no transactions associated with them.", "We will use the COUNT function to count the number of transaction IDs for each invoice number.", "Finally, we will group the results by 'invoice_number' to get the count for each individual invoice."], "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"], "pred_sql": "SELECT Invoices.invoice_number, COUNT(Financial_Transactions.transaction_id) AS number_of_transactions\nFROM Invoices\nLEFT JOIN Financial_Transactions ON Invoices.invoice_number = Financial_Transactions.invoice_number\nGROUP BY Invoices.invoice_number;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\"\n}\n"}
{"sample_id": "train.1602", "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?", "rationale": ["We need to find the invoice number and invoice date for the invoice with the greatest number of transactions.", "The hint suggests creating a virtual table that summarizes the total number of invoices associated with each order.", "To achieve this, we can use a subquery to group the invoices by order_id and count the number of invoices for each order.", "We will order the results of this subquery in descending order based on the count of invoices and limit the results to 1 to get the order_id with the greatest number of invoices.", "Finally, we will use this order_id to select the corresponding invoice_number and invoice_date from the Invoices table."], "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"], "pred_sql": "SELECT invoice_number, invoice_date FROM Invoices WHERE order_id = (SELECT order_id FROM Invoices GROUP BY order_id ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\"\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["Identify the tables involved: Orders and Order_Items.", "We need to retrieve the order ids from the Orders table and the count of items from the Order_Items table.", "Join the Orders table with the Order_Items table on the order_id to associate each order with its items.", "Use the COUNT function to count the number of items (order_item_id) for each order.", "Group the results by order_id to get the count of items for each specific order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT Orders.order_id, COUNT(Order_Items.order_item_id) AS number_of_items\nFROM Orders\nJOIN Order_Items ON Orders.order_id = Order_Items.order_id\nGROUP BY Orders.order_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\",\n    \"1\": \"This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.\",\n    \"2\": \"This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.\"\n}\n"}
{"sample_id": "train.2049", "db_id": "party_people", "question": "Show all ministers who do not belong to Progress Party.", "rationale": ["Identify the tables involved: We need to retrieve information about ministers and their associated parties, so we will use the 'member' and 'party' tables.", "Determine the relevant columns: We need the names of the ministers, which are in the 'member' table under 'Member_Name'. We also need to filter based on the party name, which is in the 'party' table under 'Party_name'.", "Establish the relationship between tables: The 'member' table has a foreign key 'Party_ID' that links to the 'party' table's 'Party_ID'. We will use a JOIN to connect these tables based on this relationship.", "Formulate the WHERE clause: We need to filter out ministers who belong to the 'Progress Party'. This will be done using a WHERE clause that checks if 'Party_name' is not equal to 'Progress Party'.", "Select distinct names: Since a minister may belong to a party that has multiple members, we will use DISTINCT to ensure that each minister's name appears only once in the results."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT DISTINCT m.Member_Name \nFROM member m \nJOIN party p ON m.Party_ID = p.Party_ID \nWHERE p.Party_name != 'Progress Party';", "hint": "\n"}
{"sample_id": "train.2058", "db_id": "party_people", "question": "How many members are in each party?", "rationale": ["We need to count the number of members in each party.", "To do this, we will select the party name from the 'party' table.", "We will also count the member IDs from the 'member' table to get the number of members in each party.", "We will use a LEFT JOIN to connect the 'party' table with the 'member' table based on the Party_ID.", "Finally, we will group the results by the party name to get the count for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT party.Party_name, COUNT(member.Member_ID) AS Member_Count\nFROM party\nLEFT JOIN member ON party.Party_ID = member.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of party events associated with a specific region and event name. It joins the 'region', 'party', and 'party_events' tables to filter the results based on the specified region name and event name. The placeholders in the WHERE clause represent the region's name and the event's name.\"\n}\n"}
{"sample_id": "train.2071", "db_id": "party_people", "question": "Show party names and the number of events for each party.", "rationale": ["We need to retrieve the names of the parties and the count of events associated with each party.", "To do this, we will select the 'Party_name' from the 'party' table.", "We will also count the 'Event_ID' from the 'party_events' table to get the number of events for each party.", "Since a party may not have any events, we will use a LEFT JOIN between the 'party' and 'party_events' tables on the 'Party_ID'.", "Finally, we will group the results by 'Party_name' to get the count of events for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT party.Party_name, COUNT(party_events.Event_ID) AS Number_of_Events\nFROM party\nLEFT JOIN party_events ON party.Party_ID = party_events.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of party events associated with a specific region and event name. It joins the 'region', 'party', and 'party_events' tables to filter the results based on the specified region name and event name. The placeholders in the WHERE clause represent the region's name and the event's name.\"\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the relevant tables: region, party, and party_events.", "Determine the relationship between the tables: region is linked to party via Region_ID, and party is linked to party_events via Party_ID.", "Filter the results based on the region name 'United Kingdom' and the event name 'Annual Meeting'.", "Use COUNT(*) to count the number of events that match the criteria."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT COUNT(*) AS Annual_Meeting_Count\nFROM region r\nJOIN party p ON r.Region_ID = p.Region_ID\nJOIN party_events pe ON p.Party_ID = pe.Party_ID\nWHERE r.Region_name = 'United Kingdom' AND pe.Event_Name = 'Annual Meeting';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of party events associated with a specific region and event name. It joins the 'region', 'party', and 'party_events' tables to filter the results based on the specified region name and event name. The placeholders in the WHERE clause represent the region's name and the event's name.\"\n}\n"}
{"sample_id": "train.2176", "db_id": "formula_1", "question": "What are the names and years of all races that had a driver with the last name Lewis?", "rationale": ["Identify the tables needed: We need the 'races' table for race names and years, the 'results' table to link races with drivers, and the 'drivers' table to filter by the last name 'Lewis'.", "Join the 'races' table with the 'results' table on 'raceId' to get the results for each race.", "Join the 'results' table with the 'drivers' table on 'driverId' to filter results for drivers with the last name 'Lewis'.", "Select the 'name' and 'year' columns from the 'races' table where the driver's surname matches 'Lewis'."], "gold_sql": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = 'Lewis'", "source_tables": ["results", "drivers", "races"], "pred_sql": "SELECT r.name, r.year \nFROM races r \nJOIN results res ON r.raceId = res.raceId \nJOIN drivers d ON res.driverId = d.driverId \nWHERE d.surname = 'Lewis';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n    \"1\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\"\n}\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["We need to find the first and last names of drivers who participated in the Australian Grand Prix but not in the Chinese Grand Prix.", "First, we will select the drivers from the 'drivers' table and join it with the 'results' table to get the race results for each driver.", "Next, we will join the 'races' table to filter the results specifically for the Australian Grand Prix.", "To ensure we only get drivers who did not participate in the Chinese Grand Prix, we will use a subquery that selects driver IDs from the 'results' table for the Chinese Grand Prix.", "Finally, we will filter the main query to exclude any driver IDs that appear in the subquery, ensuring we only get drivers who participated in the Australian Grand Prix and not in the Chinese Grand Prix."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.forename, d.surname \nFROM drivers d \nJOIN results r1 ON d.driverId = r1.driverId \nJOIN races ra ON r1.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' \nAND d.driverId NOT IN (\n    SELECT d2.driverId \n    FROM drivers d2 \n    JOIN results r2 ON d2.driverId = r2.driverId \n    JOIN races rb ON r2.raceId = rb.raceId \n    WHERE rb.name = 'Chinese Grand Prix'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n    \"1\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\"\n}\n"}
{"sample_id": "train.2183", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who was in position 1 as standing and won?", "rationale": ["We need to find distinct forenames of drivers who were in position 1 in the standings and have won races.", "To achieve this, we will select the 'forename' column from the 'drivers' table.", "We will join the 'drivers' table with the 'driverStandings' table on the 'driverId' column to access the standings information for each driver.", "In the WHERE clause, we will filter for drivers who have a position of 1 and have won at least one race (wins > 0).", "Using DISTINCT ensures that we only get unique forenames in the result."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.wins > 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n    \"1\": \"This virtual table describes the official names of constructors from the 'constructors' table who are from a specific nationality and have scored more points than a specified threshold in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.\",\n    \"2\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\"\n}\n"}
{"sample_id": "train.2185", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["We need to find distinct forenames of drivers who won in position 1 as driver standing and had more than 20 points.", "To achieve this, we will select the 'forename' column from the 'drivers' table.", "We will join the 'drivers' table with the 'driverStandings' table on the 'driverId' column to access the standings information for each driver.", "In the WHERE clause, we will filter the results to include only those drivers who have a position of 1 and more than 20 points in the standings.", "Using DISTINCT ensures that we only get unique forenames in the result."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n    \"1\": \"This virtual table describes the official names of constructors from the 'constructors' table who are from a specific nationality and have scored more points than a specified threshold in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.\",\n    \"2\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\"\n}\n"}
{"sample_id": "train.2186", "db_id": "formula_1", "question": "What are the first names of the different drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["Identify the relevant tables: 'drivers' for driver information and 'driverStandings' for standings data.", "We need to select distinct first names of drivers, so we will use SELECT DISTINCT on the 'forename' column from the 'drivers' table.", "To find the drivers who won in position 1, we will join the 'drivers' table with the 'driverStandings' table on 'driverId'.", "In the WHERE clause, we will filter for drivers who have a position of 1 and have more than 20 points in the standings."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n    \"1\": \"This virtual table describes the official names of constructors from the 'constructors' table who are from a specific nationality and have scored more points than a specified threshold in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.\"\n}\n"}
{"sample_id": "train.2189", "db_id": "formula_1", "question": "What are the numbers of races for each constructor id?", "rationale": ["The question asks for the number of races for each constructor id.", "To find this information, we need to count the number of races associated with each constructor.", "The relevant table for this information is 'constructorResults', which links constructors to races.", "We will use the COUNT() function to count the occurrences of raceId for each constructorId.", "Finally, we will group the results by constructorId to get the count for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(raceId) AS number_of_races\nFROM constructorResults\nGROUP BY constructorId;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the official names of constructors from the 'constructors' table who are from a specific nationality and have scored more points than a specified threshold in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.\",\n    \"1\": \"This virtual table provides a count of the total number of constructor standings grouped by each constructor's identifier from the 'constructorStandings' table. The placeholder in the SELECT clause represents the constructor's ID.\",\n    \"2\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\"\n}\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the relevant table: We need to retrieve information from the 'constructors' table to get the names of constructors.", "Filter by nationality: We are specifically looking for constructors from Japan, so we will add a condition for nationality = 'Japanese'.", "Determine the points condition: We need to find constructors that have earned more than 5 points, which requires checking the 'constructorStandings' table.", "Use a subquery: We will use a subquery to find constructorIds from the 'constructorStandings' table where points are greater than 5.", "Combine conditions: The main query will select names from the 'constructors' table where the nationality is Japanese and the constructorId is in the list of constructorIds from the subquery."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT name FROM constructors WHERE nationality = 'Japanese' AND constructorId IN (SELECT constructorId FROM constructorStandings WHERE points > 5);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the official names of constructors from the 'constructors' table who are from a specific nationality and have scored more points than a specified threshold in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.\",\n    \"1\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\"\n}\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races, lapTimes, and circuits are needed to find the average fastest lap speed for a specific race.", "The races table contains the race information including the year and the circuit ID.", "The lapTimes table contains the fastest lap speed for each race, linked by raceId.", "The circuits table provides the name of the circuit, which is necessary to filter for the Monaco Grand Prix.", "Join the races table with lapTimes on raceId to access the fastest lap speeds for the races.", "Join the races table with circuits on circuitId to filter for the Monaco Grand Prix.", "Use a WHERE clause to specify the circuit name as 'Monaco Grand Prix' and the year as 2008.", "Calculate the average of the fastest lap speeds using the AVG() function."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(lapTimes.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races\nJOIN lapTimes ON races.raceId = lapTimes.raceId\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE circuits.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n    \"1\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\"\n}\n"}
{"sample_id": "train.2221", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["Identify the relevant tables: We need to find the fastest lap speed for a specific race, so we will use the 'results' and 'races' tables.", "Determine the conditions: We are looking for the race named 'Monaco Grand Prix' that took place in the year 2008.", "Join the tables: We will join the 'results' table with the 'races' table on the raceId to access the race name and year.", "Select the maximum fastest lap speed: We will use the MAX function to get the highest fastest lap speed from the results that meet our conditions."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(fastestLapSpeed) AS max_fastest_lap_speed \nFROM results \nJOIN races ON results.raceId = races.raceId \nWHERE races.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n    \"1\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\"\n}\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races, lapTimes, and circuits are needed to find the fastest lap speed for the Monaco Grand Prix in 2008.", "We need to join the races table with the lapTimes table on raceId to access the fastest lap speeds.", "We also need to join the circuits table to filter for the Monaco circuit using the circuit name.", "The WHERE clause will specify that the circuit name is 'Monaco' and the year is 2008.", "Finally, we will use the MAX function to get the maximum fastest lap speed from the filtered results."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(lapTimes.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races\nJOIN lapTimes ON races.raceId = lapTimes.raceId\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE circuits.name = 'Monaco' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n    \"1\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\"\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to get race names and fastest lap speeds.", "We need to filter races that occurred after 2004, so we will use a WHERE clause on the year column in the races table.", "To get the maximum fastest lap speed for each race, we will use the MAX function on the fastestLapSpeed column from the lapTimes table.", "We will group the results by race name to get the maximum speed for each race.", "Finally, we will order the results by year to meet the requirement of the output."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name AS race_name, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN lapTimes l ON r.raceId = l.raceId\nWHERE r.year > 2004\nGROUP BY r.name\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n    \"1\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\"\n}\n"}
{"sample_id": "train.2225", "db_id": "formula_1", "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to get race names and fastest lap speeds.", "Join the races table with results to link races with their results.", "Join the results table with lapTimes to access the fastest lap speeds for each race.", "Filter the results to include only races held after 2004 using the WHERE clause.", "Group the results by race name to calculate the average fastest lap speed for each race.", "Order the final results by year to get the output in the desired order."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name AS race_name, AVG(l.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN lapTimes l ON r.raceId = l.raceId\nWHERE r.year > 2004\nGROUP BY r.name\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n    \"1\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\"\n}\n"}
{"sample_id": "train.2226", "db_id": "formula_1", "question": "What is the average fastest lap speed for races held after 2004, for each race, ordered by year?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to get the race information and fastest lap speeds.", "We need to filter races that occurred after 2004, so we will use a WHERE clause on the year column of the races table.", "To calculate the average fastest lap speed, we will use the AVG() function on the fastestLapSpeed column from the lapTimes table.", "We will join the races table with the results table to link races with their results, and then join with the lapTimes table to access the fastest lap speeds.", "We will group the results by raceId, year, and name to get the average speed for each race.", "Finally, we will order the results by year to meet the requirement of the query."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.year, r.name, AVG(l.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN lapTimes l ON r.raceId = l.raceId\nWHERE r.year > 2004\nGROUP BY r.raceId, r.year, r.name\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n    \"1\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\"\n}\n"}
{"sample_id": "train.2243", "db_id": "machine_repair", "question": "What is the starting year of the oldest technicians?", "rationale": ["Identify the relevant table: The 'technician' table contains the information about technicians including their starting year.", "Determine the required information: We need to find the starting year of the oldest technician.", "Use the MIN() function: To find the oldest starting year, we can use the MIN() function on the 'Starting_Year' column.", "Construct the SQL query: The SQL query will select the minimum starting year from the technician table."], "gold_sql": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT MIN(Starting_Year) AS Oldest_Starting_Year FROM technician;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of technicians who are assigned to repair tasks for machines that have a value point greater than a specified threshold. The placeholders in the WHERE clause represent the minimum value points for filtering the machines.\",\n    \"1\": \"This virtual table provides a list of technician teams from the 'technician' table, grouped by their team identifier. The results are ordered by the number of technicians in each team in descending order, and the placeholder allows for limiting the number of teams returned.\"\n}\n"}
{"sample_id": "train.2248", "db_id": "machine_repair", "question": "What are the teams with the most technicians?", "rationale": ["Identify the relevant table: The 'technician' table contains information about technicians and their associated teams.", "Group by team: To find the number of technicians in each team, we will use the GROUP BY clause on the 'Team' column.", "Count technicians: We will use the COUNT() function to count the number of technicians in each team.", "Order results: To get the teams with the most technicians, we will order the results in descending order based on the count of technicians.", "Select relevant columns: We will select the 'Team' and the count of technicians as 'technician_count'."], "gold_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT Team, COUNT(technician_id) AS technician_count \nFROM technician \nGROUP BY Team \nORDER BY technician_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of technician teams from the 'technician' table, grouped by their team identifier. The results are ordered by the number of technicians in each team in descending order, and the placeholder allows for limiting the number of teams returned.\",\n    \"1\": \"This virtual table lists the names of technicians who are assigned to repair tasks for machines that have a value point greater than a specified threshold. The placeholders in the WHERE clause represent the minimum value points for filtering the machines.\"\n}\n"}
{"sample_id": "train.2258", "db_id": "machine_repair", "question": "What are the names of the technicians  and how many machines are they assigned to repair?", "rationale": ["Identify the relevant tables: technician and repair_assignment.", "We need to get the names of technicians, which is in the technician table.", "We also need to count the number of machines assigned to each technician, which can be done using the repair_assignment table.", "Join the technician table with the repair_assignment table on the technician_id to link technicians with their assigned repairs.", "Use COUNT() to count the number of Machine_IDs for each technician, which represents the number of machines they are assigned to.", "Group the results by technician name to get the count for each technician."], "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name", "source_tables": ["repair_assignment", "technician"], "pred_sql": "SELECT technician.Name, COUNT(repair_assignment.Machine_ID) AS machine_count\nFROM technician\nJOIN repair_assignment ON technician.technician_id = repair_assignment.technician_id\nGROUP BY technician.Name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of technicians who are assigned to repair tasks for machines that have a value point greater than a specified threshold. The placeholders in the WHERE clause represent the minimum value points for filtering the machines.\",\n    \"1\": \"This virtual table provides a list of technician teams from the 'technician' table, grouped by their team identifier. The results are ordered by the number of technicians in each team in descending order, and the placeholder allows for limiting the number of teams returned.\"\n}\n"}
{"sample_id": "train.2328", "db_id": "csu_1", "question": "Find all the campuses opened in 1958.", "rationale": ["Identify the relevant table: The 'Campuses' table contains information about the campuses, including the year they were opened.", "Determine the condition: We need to find campuses that were opened in the year 1958, which corresponds to the 'Year' column in the 'Campuses' table.", "Construct the SQL query: We will select the 'Campus' column from the 'Campuses' table where the 'Year' is equal to '1958'."], "gold_sql": "SELECT campus FROM campuses WHERE YEAR  =  1958", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE Year = '1958';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n    \"1\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n    \"2\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\"\n}\n"}
{"sample_id": "train.2334", "db_id": "csu_1", "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.", "rationale": ["Identify the relevant table: The 'Campuses' table contains the information about campus names and their locations.", "Determine the filtering criteria: We need to find campuses located in either 'Northridge, Los Angeles' or 'San Francisco, San Francisco'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' column from the 'Campuses' table, applying a WHERE clause to filter based on the specified locations."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE (Location = 'Northridge, Los Angeles' OR Location = 'San Francisco, San Francisco');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n    \"1\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n    \"2\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name. The campuses are ordered by the total number of degrees awarded, in descending order, and the result is limited to a specified number of campuses. The placeholder in the LIMIT clause represents the maximum number of campuses to return.\"\n}\n"}
{"sample_id": "train.2350", "db_id": "csu_1", "question": "Which campus has the most faculties in year 2003?", "rationale": ["Identify the relevant tables: 'Campuses' for campus names and 'faculty' for faculty counts.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Filter the results to only include records for the year 2003.", "Order the results by the number of faculty members in descending order to find the campus with the most faculty.", "Limit the results to 1 to get only the campus with the highest number of faculty."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT c.Campus, f.Faculty \nFROM Campuses c \nJOIN faculty f ON c.Id = f.Campus \nWHERE f.Year = 2003 \nORDER BY f.Faculty DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n    \"2\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\"\n}\n"}
{"sample_id": "train.2356", "db_id": "csu_1", "question": "report the total number of degrees granted between 1998 and 2002.", "rationale": ["Identify the relevant table: The 'degrees' table contains information about degrees awarded, including the year they were awarded.", "Determine the required data: We need to count the total number of degrees awarded between the years 1998 and 2002.", "Construct the SQL query: Use the COUNT function to count the number of records in the 'degrees' table where the 'Year' falls within the specified range."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT COUNT(*) AS TotalDegrees\nFROM degrees\nWHERE Year BETWEEN '1998' AND '2002';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n    \"1\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name. The campuses are ordered by the total number of degrees awarded, in descending order, and the result is limited to a specified number of campuses. The placeholder in the LIMIT clause represents the maximum number of campuses to return.\",\n    \"2\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\"\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: 'Campuses' and 'degrees' are needed to get campus names and the number of degrees awarded.", "Join the 'Campuses' table with the 'degrees' table on the campus identifier to link campuses with their awarded degrees.", "Filter the results to include only those degrees awarded after the year 2000 by using a WHERE clause.", "Additionally, filter the campuses to include only those located in Orange County.", "Group the results by campus to get the total number of degrees awarded for each campus.", "Count the number of degrees for each campus using COUNT() function and alias it as TotalDegrees."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT c.Campus, COUNT(d.Degrees) AS TotalDegrees\nFROM Campuses c\nJOIN degrees d ON c.Id = d.Campus\nWHERE d.Year > '2000' AND c.County = 'Orange'\nGROUP BY c.Campus;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n    \"1\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name. The campuses are ordered by the total number of degrees awarded, in descending order, and the result is limited to a specified number of campuses. The placeholder in the LIMIT clause represents the maximum number of campuses to return.\",\n    \"2\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\"\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant tables: 'enrollments' for total and full-time enrollment data, and 'Campuses' for campus names.", "Join the 'enrollments' table with the 'Campuses' table on the campus identifier to get campus names along with enrollment data.", "Filter the results to include only those campuses where total enrollment is greater than 400 and full-time enrollment is greater than 200.", "Specify the year as 1956 to limit the results to that specific academic year."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT Campuses.Campus \nFROM enrollments \nJOIN Campuses ON enrollments.Campus = Campuses.Id \nWHERE enrollments.TotalEnrollment_AY > 400 \nAND enrollments.FTE_AY > 200 \nAND enrollments.Year = '1956';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n    \"2\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\"\n}\n"}
{"sample_id": "train.2363", "db_id": "csu_1", "question": "What campus started in year 1956, has more than 200 full time students, and more than 400 students enrolled?", "rationale": ["Identify the relevant tables: Campuses and enrollments.", "We need to filter campuses based on the year they started, which is in the Campuses table.", "We also need to check for the number of full-time students and total enrollments, which are in the enrollments table.", "Join the Campuses table with the enrollments table on the campus identifier.", "Apply the filters: year = 1956, FTE_AY > 200, and TotalEnrollment_AY > 400."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT c.Campus \nFROM Campuses c \nJOIN enrollments e ON c.Id = e.Campus \nWHERE c.Year = '1956' \nAND e.FTE_AY > '200' \nAND e.TotalEnrollment_AY > '400';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n    \"2\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\"\n}\n"}
{"sample_id": "train.2366", "db_id": "csu_1", "question": "List the campuses in Los Angeles county.", "rationale": ["Identify the relevant table: The 'Campuses' table contains information about campuses, including their location and county.", "Determine the filtering criteria: We need to filter campuses based on the county, specifically 'Los Angeles'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' names from the 'Campuses' table where the 'County' is 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n    \"1\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name. The campuses are ordered by the total number of degrees awarded, in descending order, and the result is limited to a specified number of campuses. The placeholder in the LIMIT clause represents the maximum number of campuses to return.\",\n    \"2\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\"\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: 'degrees' for degrees conferred and 'Campuses' for campus names.", "We need to filter the degrees awarded for 'San Jose State University' in the year 2000.", "Join the 'degrees' table with the 'Campuses' table on the campus identifier to access the campus name.", "Use the SUM function to calculate the total number of degrees conferred for the specified campus and year."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(Degrees) AS TotalDegreesConferred \nFROM degrees \nJOIN Campuses ON degrees.Campus = Campuses.Id \nWHERE Campuses.Campus = 'San Jose State University' AND degrees.Year = '2000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n    \"2\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name. The campuses are ordered by the total number of degrees awarded, in descending order, and the result is limited to a specified number of campuses. The placeholder in the LIMIT clause represents the maximum number of campuses to return.\"\n}\n"}
{"sample_id": "train.2374", "db_id": "csu_1", "question": "What is the number of faculty lines in campus \"Long Beach State University\" in 2002?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to get the campus name along with the faculty data.", "Filter the results to only include the campus 'Long Beach State University' and the year 2002.", "Select the 'Faculty' column to get the number of faculty lines for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2002 AND T2.campus  =  'Long Beach State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Faculty FROM faculty INNER JOIN Campuses ON faculty.Campus = Campuses.Id WHERE Campuses.Campus = 'Long Beach State University' AND faculty.Year = 2002;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n    \"2\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\"\n}\n"}
{"sample_id": "train.2376", "db_id": "csu_1", "question": "How many faculty lines are there in \"San Francisco State University\" in year 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to link faculty data with campus names.", "Filter the results to only include records for 'San Francisco State University' and the year 2004.", "Count the number of faculty lines for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) AS FacultyCount \nFROM faculty f \nJOIN Campuses c ON f.Campus = c.Id \nWHERE c.Campus = 'San Francisco State University' AND f.Year = 2004;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\"\n}\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "We need to count the number of faculty lines, so we will use the COUNT() function.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to filter by campus name.", "Filter the results to only include records for 'San Francisco State University' and the year 2004."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) AS FacultyCount \nFROM faculty f \nJOIN Campuses c ON f.Campus = c.Id \nWHERE c.Campus = 'San Francisco State University' AND f.Year = 2004;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\"\n}\n"}
{"sample_id": "train.2381", "db_id": "csu_1", "question": "How many faculty members did the university that conferred the most degrees in 2002 have?", "rationale": ["Identify the year of interest, which is 2002, as specified in the question.", "Determine the relevant tables: 'faculty' for faculty members and 'degrees' for the number of degrees conferred.", "Join the 'faculty' table with the 'degrees' table on the 'Campus' identifier to correlate faculty data with degree data.", "Filter the results to only include records from the year 2002 using a WHERE clause.", "Order the results based on the number of degrees awarded in descending order to find the campus that conferred the most degrees.", "Limit the results to 1 to get only the campus with the highest number of degrees conferred."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty f \nJOIN degrees d ON f.Campus = d.Campus \nWHERE d.Year = '2002' \nORDER BY d.Campus DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n    \"1\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n    \"2\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\"\n}\n"}
{"sample_id": "train.2382", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the least number of degrees in year 2001?", "rationale": ["Identify the year of interest, which is 2001.", "Determine the campus that conferred the least number of degrees in 2001 by grouping the degrees table by campus and counting the degrees awarded.", "Use a subquery to find the campus with the minimum count of degrees awarded in 2001.", "Join the faculty table with the degrees and campuses tables to get the faculty count for the identified campus.", "Count the number of faculty lines for the campus that conferred the least number of degrees in 2001."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(*) AS FacultyCount \nFROM faculty f \nJOIN degrees d ON f.Campus = d.Campus \nJOIN Campuses c ON f.Campus = c.Id \nWHERE d.Year = '2001' \nAND d.Campus = (SELECT d2.Campus \n                FROM degrees d2 \n                WHERE d2.Year = '2001' \n                GROUP BY d2.Campus \n                ORDER BY COUNT(d2.Degrees) ASC \n                LIMIT 1)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n    \"1\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n    \"2\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\"\n}\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the year of interest, which is 2001, for the degrees awarded.", "Determine the campus that awarded the least number of degrees in 2001 by grouping the degrees table by campus and counting the degrees, ordering them in ascending order, and limiting the result to 1.", "Join the faculty table with the degrees table on the campus identifier to get the faculty count for the campus that awarded the least degrees.", "Filter the results to only include the year 2001 for the degrees awarded.", "Select the faculty count for the campus identified in the previous steps."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty f \nJOIN degrees d ON f.Campus = d.Campus \nWHERE d.Year = '2001' \nORDER BY d.Campus IN (SELECT Campus \n                     FROM degrees \n                     WHERE Year = '2001' \n                     GROUP BY Campus \n                     ORDER BY COUNT(Degrees) ASC \n                     LIMIT 1) \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n    \"1\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n    \"2\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\"\n}\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "We need to sum the 'Undergraduate' column to get the total number of undergraduates.", "To filter the data for San Jose State, we need to find its corresponding 'Id' in the 'Campuses' table.", "Use a subquery to select the 'Id' of San Jose State from the 'Campuses' table.", "Construct the SQL query to sum the 'Undergraduate' enrollments for the specific campus."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT SUM(Undergraduate) AS TotalUndergraduates \nFROM discipline_enrollments \nWHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Jose State')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\"\n}\n"}
{"sample_id": "train.2397", "db_id": "candidate_poll", "question": "Return the poll resource associated with the most candidates.", "rationale": ["Identify the relevant table: The 'candidate' table contains the 'Poll_Source' column which we need to analyze.", "Group the data: We need to group the results by 'Poll_Source' to count how many candidates are associated with each source.", "Count the candidates: Use COUNT(*) to count the number of candidates for each poll source.", "Order the results: We will order the results in descending order based on the count of candidates to find the source with the most candidates.", "Limit the results: We will limit the results to 1 to get only the poll source associated with the most candidates."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source, COUNT(*) AS Candidate_Count\nFROM candidate\nGROUP BY Poll_Source\nORDER BY Candidate_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of poll sources from the 'candidate' table, grouped by the source and ordered by the number of occurrences. The placeholder in the LIMIT clause allows the user to specify the maximum number of poll sources to retrieve.\",\n    \"1\": \"This virtual table provides the gender distribution of candidates based on their support rates. It joins the 'people' and 'candidate' tables on the 'People_ID' field, grouping the results by gender and ordering them by the average unsure rate of the candidates. The placeholder in the LIMIT clause allows for specifying the number of results to return.\"\n}\n"}
{"sample_id": "train.2405", "db_id": "candidate_poll", "question": "Return the poll source corresponding to the candidate who has the oppose rate.", "rationale": ["Identify the relevant table: The 'candidate' table contains the 'Poll_Source' and 'Oppose_rate' columns.", "Determine the condition: We want to find the poll source for candidates who have an oppose rate, which implies we need to check for non-null values in the 'Oppose_rate' column.", "Construct the SQL query: We will select the 'Poll_Source' from the 'candidate' table where 'Oppose_rate' is not null."], "gold_sql": "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source FROM candidate WHERE Oppose_rate IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of poll sources from the 'candidate' table, grouped by the source and ordered by the number of occurrences. The placeholder in the LIMIT clause allows the user to specify the maximum number of poll sources to retrieve.\",\n    \"1\": \"This virtual table provides the gender distribution of candidates based on their support rates. It joins the 'people' and 'candidate' tables on the 'People_ID' field, grouping the results by gender and ordering them by the average unsure rate of the candidates. The placeholder in the LIMIT clause allows for specifying the number of results to return.\"\n}\n"}
{"sample_id": "train.2417", "db_id": "candidate_poll", "question": "For each sex, what is the name and sex of the candidate with the oppose rate for their sex?", "rationale": ["Identify the relevant tables: 'people' and 'candidate'.", "We need to join these tables on the 'People_ID' field to access both candidate and personal information.", "Select the 'Name' and 'Sex' from the 'people' table and the 'Oppose_rate' from the 'candidate' table.", "We want to filter the results based on the sex of the candidates, so we ensure that we include the 'Sex' in our selection.", "Order the results by the 'Oppose_rate' in descending order to get the candidates with the highest oppose rates for each sex."], "gold_sql": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex", "source_tables": ["candidate", "people"], "pred_sql": "SELECT p.Name, p.Sex, c.Oppose_rate \nFROM people p \nJOIN candidate c ON p.People_ID = c.People_ID \nWHERE p.Sex IS NOT NULL \nORDER BY c.Oppose_rate DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the gender distribution of candidates based on their support rates. It joins the 'people' and 'candidate' tables on the 'People_ID' field, grouping the results by gender and ordering them by the average unsure rate of the candidates. The placeholder in the LIMIT clause allows for specifying the number of results to return.\"\n}\n"}
{"sample_id": "train.2434", "db_id": "movie_1", "question": "Find the titles of all movies directed by steven spielberg.", "rationale": ["Identify the relevant table: The 'Movie' table contains the information about movie titles and their directors.", "Determine the condition: We need to filter the results to only include movies directed by 'steven spielberg'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'title' column from the 'Movie' table where the 'director' matches 'steven spielberg'."], "gold_sql": "SELECT title FROM Movie WHERE director = 'Steven Spielberg'", "source_tables": ["movie"], "pred_sql": "SELECT title FROM Movie WHERE director = 'steven spielberg';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n    \"1\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the total number of ratings grouped by each director's name.\"\n}\n"}
{"sample_id": "train.2461", "db_id": "movie_1", "question": "What are the different names of all reviewers whose ratings do not have a date field?", "rationale": ["We need to find the names of reviewers whose ratings do not have a date field.", "This means we are looking for records in the Rating table where the ratingDate is NULL.", "To get the names of the reviewers, we will join the Reviewer table with the Rating table on the rID field.", "We will select distinct names to ensure that we do not have duplicate entries in our results."], "gold_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  'null'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nWHERE Rating.ratingDate IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\",\n    \"1\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n    \"2\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.2476", "db_id": "movie_1", "question": "Find the names of all reviewers who rated Gone with the Wind.", "rationale": ["Identify the tables involved: Reviewer, Rating, and Movie.", "To find the names of reviewers who rated a specific movie, we need to join the Reviewer table with the Rating table on the reviewer ID (rID).", "Next, we join the Rating table with the Movie table on the movie ID (mID) to access the movie title.", "We filter the results to only include ratings for the movie titled 'Gone with the Wind'.", "Finally, we select the names of the reviewers from the resulting joined table."], "gold_sql": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  'Gone with the Wind'", "source_tables": ["rating", "movie", "reviewer"], "pred_sql": "SELECT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nJOIN Movie ON Rating.mID = Movie.mID \nWHERE Movie.title = 'Gone with the Wind';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n    \"1\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\"\n}\n"}
{"sample_id": "train.2483", "db_id": "movie_1", "question": "What are the names of all the reviewers and movie names?", "rationale": ["The user wants to know the names of all reviewers and movie names, which means we need to retrieve data from both the Reviewer and Movie tables.", "To get all combinations of reviewers and movies, we can use a CROSS JOIN between the Reviewer and Movie tables.", "The SELECT statement will specify the columns we want to retrieve: Reviewer.name and Movie.title."], "gold_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "source_tables": ["movie", "reviewer"], "pred_sql": "SELECT Reviewer.name, Movie.title\nFROM Reviewer\nCROSS JOIN Movie;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n    \"1\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\",\n    \"2\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.2495", "db_id": "movie_1", "question": "For each director, how many reviews have they received?", "rationale": ["We need to count the number of reviews for each director.", "To do this, we will join the 'Movie' table with the 'Rating' table on the movie identifier (mID).", "We will use a LEFT JOIN to ensure we include directors even if they have no reviews.", "We will select the director's name and count the number of ratings (reviews) associated with each director.", "Finally, we will group the results by the director's name to get the count for each director."], "gold_sql": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT Movie.director, COUNT(Rating.rID) AS review_count\nFROM Movie\nLEFT JOIN Rating ON Movie.mID = Rating.mID\nGROUP BY Movie.director;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the total number of ratings grouped by each director's name.\",\n    \"1\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n    \"2\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.2500", "db_id": "movie_1", "question": "What are the names and years of the movies that has the top 3 highest rating star?", "rationale": ["Identify the tables involved: Movie and Rating.", "We need the movie titles and years, so we will select 'Movie.title' and 'Movie.year'.", "To find the highest ratings, we need to join the Movie table with the Rating table on the movie identifier (mID).", "We will group the results by 'Movie.mID' to calculate the average rating for each movie.", "Order the results by the average rating in descending order to get the highest ratings first.", "Limit the results to the top 3 movies with the highest average ratings."], "gold_sql": "SELECT T2.title ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID ORDER BY T1.stars DESC LIMIT 3", "source_tables": ["rating", "movie"], "pred_sql": "SELECT Movie.title, Movie.year \nFROM Movie \nJOIN Rating ON Movie.mID = Rating.mID \nGROUP BY Movie.mID \nORDER BY AVG(Rating.stars) DESC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n    \"1\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\",\n    \"2\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\"\n}\n"}
{"sample_id": "train.2502", "db_id": "movie_1", "question": "For each director, return the director's name together with the title of the movie they directed that received the highest rating among all of their movies, and the value of that rating. Ignore movies whose director is NULL.", "rationale": ["We need to select the director's name, the title of the movie, and the highest rating for each director.", "To do this, we will join the Movie table with the Rating table on the movie ID (mID).", "We will filter out any movies where the director is NULL using a WHERE clause.", "We will group the results by director and movie title to aggregate the ratings for each movie directed by each director.", "To find the highest rating for each movie, we will use the MAX function on the stars column from the Rating table.", "Finally, we will use a HAVING clause to ensure we only return the movie with the highest rating for each director."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT m.director, m.title, MAX(r.stars) AS highest_rating\nFROM Movie m\nJOIN Rating r ON m.mID = r.mID\nWHERE m.director IS NOT NULL\nGROUP BY m.director, m.title\nHAVING MAX(r.stars) = (SELECT MAX(stars) FROM Rating r2 WHERE r2.mID = m.mID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the total number of ratings grouped by each director's name.\",\n    \"1\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table provides a list of movie titles along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.2503", "db_id": "movie_1", "question": "For each director, what are the titles and ratings for all the movies they reviewed?", "rationale": ["Identify the tables involved: Movie, Reviewer, and Rating.", "Determine the relationships: Movie and Rating are linked by mID, and Rating and Reviewer are linked by rID.", "Select the required fields: director from Movie, title from Movie, and stars from Rating.", "Join the tables based on their relationships to get the necessary data.", "Order the results by director and title for better readability."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT m.director, m.title, r.stars \nFROM Movie m \nJOIN Rating r ON m.mID = r.mID \nJOIN Reviewer rev ON r.rID = rev.rID \nORDER BY m.director, m.title;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n    \"1\": \"This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the total number of ratings grouped by each director's name.\",\n    \"2\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.2505", "db_id": "movie_1", "question": "For each reviewer id, what is the title and rating for the movie with the smallest rating?", "rationale": ["We need to retrieve the reviewer ID, movie title, and rating for the movie with the smallest rating for each reviewer.", "To do this, we will join the Reviewer, Rating, and Movie tables based on their relationships.", "We will use a subquery to find the minimum rating (stars) for each reviewer by filtering the Rating table based on the reviewer's ID.", "The main query will select the reviewer ID, movie title, and stars where the stars match the minimum rating found in the subquery.", "Finally, we will order the results by reviewer ID to keep the output organized."], "gold_sql": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID", "source_tables": ["rating", "movie"], "pred_sql": "SELECT Reviewer.rID, Movie.title, Rating.stars \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nJOIN Movie ON Rating.mID = Movie.mID \nWHERE Rating.stars = (SELECT MIN(stars) \n                     FROM Rating AS r \n                     WHERE r.rID = Reviewer.rID) \nORDER BY Reviewer.rID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\",\n    \"1\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\"\n}\n"}
{"sample_id": "train.2507", "db_id": "movie_1", "question": "For each director, what is the title and score of their most poorly rated movie?", "rationale": ["We need to find the most poorly rated movie for each director, which means we need to calculate the average rating for each movie.", "To do this, we will join the Movie table with the Rating table on the movie ID (mID).", "We will then group the results by movie ID to calculate the average rating for each movie.", "Next, we will order the results by the average rating in ascending order to find the lowest rated movies.", "Finally, we will limit the results to get only the most poorly rated movie for each director."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT m.title, AVG(r.stars) AS average_rating\nFROM Movie m\nJOIN Rating r ON m.mID = r.mID\nGROUP BY m.mID\nORDER BY average_rating ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the total number of ratings grouped by each director's name.\",\n    \"1\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\"\n}\n"}
{"sample_id": "train.2508", "db_id": "movie_1", "question": "What is the name of the movie that is rated by most of times?", "rationale": ["Identify the goal: We need to find the name of the movie that is rated the most times.", "To achieve this, we will use the Rating table to count the number of ratings for each movie (grouped by mID).", "We will order the results by the count of ratings in descending order to get the movie with the highest count at the top.", "We will limit the results to 1 to get only the top-rated movie.", "Finally, we will select the title of the movie from the Movie table using the mID obtained from the previous step."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title FROM Movie WHERE mID IN (SELECT mID FROM Rating GROUP BY mID ORDER BY COUNT(*) DESC LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n    \"1\": \"This virtual table provides a list of movie titles along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n    \"2\": \"This virtual table provides a list of movie titles along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.2509", "db_id": "movie_1", "question": "What is the name of the movie that has been reviewed the most?", "rationale": ["To find the movie that has been reviewed the most, we need to count the number of reviews for each movie.", "We can achieve this by using the Rating table, grouping by the movie identifier (mID), and counting the number of reviewer IDs (rID) for each movie.", "Next, we will order the results by the count of reviews in descending order to get the movie with the highest number of reviews at the top.", "Finally, we will limit the results to just one movie to get the top reviewed movie.", "We will then use the mID from the Rating table to get the corresponding title from the Movie table."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title FROM Movie WHERE mID IN (SELECT mID FROM Rating GROUP BY mID ORDER BY COUNT(rID) DESC LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n    \"1\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table provides a list of movie titles along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.2517", "db_id": "movie_1", "question": "What are the ids of all moviest hat have not been reviewed by Britanny Harris?", "rationale": ["Identify the movies from the Movie table by selecting their unique identifiers (mID).", "Use a subquery to find all movie IDs (mID) that have been rated by the reviewer named 'Britanny Harris'.", "This subquery first selects the reviewer ID (rID) for 'Britanny Harris' from the Reviewer table.", "Then, it uses this rID to find all corresponding movie IDs (mID) in the Rating table.", "Finally, the main query selects all movie IDs from the Movie table that are not in the list of movie IDs returned by the subquery, effectively filtering out movies reviewed by 'Britanny Harris'."], "gold_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT mID FROM Movie WHERE mID NOT IN (SELECT mID FROM Rating WHERE rID IN (SELECT rID FROM Reviewer WHERE name = 'Britanny Harris'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\",\n    \"1\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n    \"2\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.2518", "db_id": "movie_1", "question": "Find the average rating star for each movie that received at least 2 ratings.", "rationale": ["We need to find the average rating star for each movie that received at least 2 ratings.", "To do this, we will join the 'Movie' table with the 'Rating' table on the movie identifier (mID).", "We will select the movie title and calculate the average of the stars given in the ratings using AVG(Rating.stars).", "We will group the results by the movie identifier (Movie.mID) to ensure we get the average rating for each movie.", "To filter the results to only include movies that have received at least 2 ratings, we will use the HAVING clause with COUNT(Rating.rID) >= 2."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2", "source_tables": ["rating"], "pred_sql": "SELECT Movie.title, AVG(Rating.stars) AS average_rating\nFROM Movie\nJOIN Rating ON Movie.mID = Rating.mID\nGROUP BY Movie.mID\nHAVING COUNT(Rating.rID) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n    \"1\": \"This virtual table provides a list of movie titles along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n    \"2\": \"This virtual table provides a list of movie titles along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.2528", "db_id": "movie_1", "question": "What are the names of reviewers who had rated 3 star and 4 star?", "rationale": ["We need to find the names of reviewers who rated movies with 3 stars and 4 stars.", "To do this, we will join the Reviewer table with the Rating table on the reviewer ID (rID).", "We will select the distinct names of reviewers to avoid duplicates.", "The condition for the ratings will be that the stars must be either '3' or '4'.", "Finally, we will construct the SQL query to reflect these requirements."], "gold_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nWHERE Rating.stars IN ('3', '4');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n    \"1\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\",\n    \"2\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.2530", "db_id": "movie_1", "question": "What are the names of movies that get 3 star and 4 star?", "rationale": ["We need to find the names of movies that received ratings of 3 stars and 4 stars.", "To do this, we will select the 'title' from the 'Movie' table.", "We will join the 'Movie' table with the 'Rating' table on the movie identifier 'mID' to access the ratings for each movie.", "We will filter the results using a WHERE clause to include only those ratings that are either 3 or 4 stars.", "Using DISTINCT ensures that we only get unique movie titles in case a movie has multiple ratings of 3 or 4 stars."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "source_tables": ["rating", "movie"], "pred_sql": "SELECT DISTINCT Movie.title \nFROM Movie \nJOIN Rating ON Movie.mID = Rating.mID \nWHERE Rating.stars IN ('3', '4');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n    \"1\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n    \"2\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\"\n}\n"}
{"sample_id": "train.2576", "db_id": "inn_1", "question": "Find the most popular room in the hotel. The most popular room is the room that had seen the largest number of reservations.", "rationale": ["Identify the tables involved: Rooms and Reservations.", "Determine the relationship between the tables: Reservations.Room is a foreign key that references Rooms.RoomId.", "To find the most popular room, we need to count the number of reservations for each room.", "Use a JOIN to combine data from Rooms and Reservations based on the RoomId.", "Group the results by Rooms.RoomId to aggregate the reservation counts for each room.", "Order the results by the count of reservations in descending order to get the most popular room at the top.", "Limit the results to 1 to get only the most popular room."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservation_count\nFROM Rooms\nJOIN Reservations ON Rooms.RoomId = Reservations.Room\nGROUP BY Rooms.RoomId\nORDER BY reservation_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n    \"2\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\"\n}\n"}
{"sample_id": "train.2577", "db_id": "inn_1", "question": "Which room has the largest number of reservations?", "rationale": ["Identify the tables involved: Rooms and Reservations.", "We need to find the room with the largest number of reservations, which means we need to count the number of reservations for each room.", "Join the Rooms table with the Reservations table on the RoomId to get the relevant data.", "Use COUNT() to count the number of reservations for each room.", "Group the results by the RoomId to aggregate the counts for each room.", "Order the results by the count of reservations in descending order to get the room with the most reservations at the top.", "Limit the results to 1 to get only the room with the largest number of reservations."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservation_count\nFROM Rooms\nJOIN Reservations ON Rooms.RoomId = Reservations.Room\nGROUP BY Rooms.RoomId\nORDER BY reservation_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\",\n    \"2\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\"\n}\n"}
{"sample_id": "train.2578", "db_id": "inn_1", "question": "How many kids stay in the rooms reserved by ROY SWEAZY?", "rationale": ["Identify the relevant tables: Reservations contains the information about guests and their reservations, including the number of kids.", "We need to filter the reservations based on the guest's name, specifically 'ROY SWEAZY'.", "The query should sum the number of kids from the Reservations table for the specified guest.", "The SQL query will select the sum of the 'Kids' column from the Reservations table where the FirstName is 'ROY' and the LastName is 'SWEAZY'."], "gold_sql": "SELECT kids FROM Reservations WHERE FirstName = 'ROY' AND LastName  =  'SWEAZY';", "source_tables": ["reservations"], "pred_sql": "SELECT SUM(Kids) AS TotalKids\nFROM Reservations\nWHERE FirstName = 'ROY' AND LastName = 'SWEAZY';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\",\n    \"1\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n    \"2\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\"\n}\n"}
{"sample_id": "train.2582", "db_id": "inn_1", "question": "Which room has the highest rate? List the room's full name, rate, check in and check out date.", "rationale": ["Identify the relevant tables: Rooms and Reservations.", "We need to find the room with the highest rate, which is stored in the Reservations table under the 'Rate' column.", "To get the room's full name, we will select 'roomName' from the Rooms table.", "We will join the Rooms table with the Reservations table on the RoomId to get the corresponding room details for each reservation.", "We will order the results by the 'Rate' in descending order to get the highest rate at the top.", "Finally, we will limit the results to 1 to get only the room with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT r.roomName, res.Rate, res.CheckIn, res.CheckOut \nFROM Rooms r \nJOIN Reservations res ON r.RoomId = res.Room \nORDER BY res.Rate DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n    \"1\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n    \"2\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.2583", "db_id": "inn_1", "question": "Return the name, rate, check in and check out date for the room with the highest rate.", "rationale": ["Identify the required fields: room name, rate, check-in date, and check-out date.", "The data is spread across two tables: Rooms and Reservations. We need to join these tables on the RoomId.", "Select the room name from the Rooms table and the rate, check-in, and check-out dates from the Reservations table.", "To find the room with the highest rate, we will order the results by the rate in descending order.", "Limit the results to only one entry to get the room with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT r.roomName, res.Rate, res.CheckIn, res.CheckOut \nFROM Rooms r \nJOIN Reservations res ON r.RoomId = res.Room \nORDER BY res.Rate DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n    \"1\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\"\n}\n"}
{"sample_id": "train.2589", "db_id": "inn_1", "question": "Find the total number of king beds available.", "rationale": ["Identify the relevant table: The 'Rooms' table contains information about the types of beds available in each room.", "Determine the specific condition: We are interested in rooms that have 'king' beds.", "Use the SUM function: To find the total number of king beds, we will sum the 'beds' column for rooms that meet the condition.", "Construct the SQL query: The query will select the sum of beds from the Rooms table where the bedType is 'king'."], "gold_sql": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT SUM(beds) AS TotalKingBeds FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n    \"1\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\"\n}\n"}
{"sample_id": "train.2590", "db_id": "inn_1", "question": "List the names and decor of rooms that have a king bed. Sort the list by their price.", "rationale": ["Identify the relevant table: The 'Rooms' table contains the information about room names, decor, and bed types.", "Determine the filtering condition: We need to filter rooms that have a 'king' bed, which is specified in the WHERE clause.", "Select the required columns: We need to retrieve the 'roomName' and 'decor' columns from the 'Rooms' table.", "Sort the results: The results should be sorted by 'basePrice', which is the price per night for the room, in ascending order."], "gold_sql": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName, decor FROM Rooms WHERE bedType = 'king' ORDER BY basePrice;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n    \"2\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by the decoration type. The placeholder in the LIMIT clause allows for specifying the maximum number of decoration types to return.\"\n}\n"}
{"sample_id": "train.2594", "db_id": "inn_1", "question": "What is the decor of room Recluse and defiance?", "rationale": ["Identify the relevant table: The 'Rooms' table contains the information about room decor.", "Determine the specific rooms of interest: The user is asking for the decor of rooms named 'Recluse' and 'defiance'.", "Construct the SQL query to select the 'decor' column from the 'Rooms' table where the 'roomName' matches either 'Recluse' or 'defiance'.", "Use the IN clause to specify multiple room names in the WHERE condition."], "gold_sql": "SELECT decor FROM Rooms WHERE roomName  =  'Recluse and defiance';", "source_tables": ["rooms"], "pred_sql": "SELECT decor FROM Rooms WHERE roomName IN ('Recluse', 'defiance');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by the decoration type. The placeholder in the LIMIT clause allows for specifying the maximum number of decoration types to return.\",\n    \"2\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\"\n}\n"}
{"sample_id": "train.2604", "db_id": "inn_1", "question": "Find the first and last names of people who payed more than the rooms' base prices.", "rationale": ["Identify the tables involved: Reservations and Rooms.", "Determine the columns needed: FirstName and LastName from Reservations, and basePrice from Rooms.", "Establish the relationship between the two tables using the foreign key: Reservations.Room = Rooms.RoomId.", "Formulate the condition to filter results: Rate from Reservations must be greater than basePrice from Rooms.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses to retrieve the desired information."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT r.FirstName, r.LastName\nFROM Reservations r\nJOIN Rooms rm ON r.Room = rm.RoomId\nWHERE r.Rate > rm.basePrice;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n    \"1\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\"\n}\n"}
{"sample_id": "train.2609", "db_id": "inn_1", "question": "How many rooms have a king bed?", "rationale": ["Identify the relevant table: The question pertains to the 'Rooms' table, which contains information about room types and their bed configurations.", "Determine the condition: We need to filter the rooms based on the bed type, specifically looking for rooms that have a 'king' bed.", "Construct the SQL query: Use the COUNT function to count the number of rooms that meet the specified condition."], "gold_sql": "SELECT count(*) FROM Rooms WHERE bedType  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT COUNT(*) FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n    \"1\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\"\n}\n"}
{"sample_id": "train.2612", "db_id": "inn_1", "question": "Find the name of the room with the maximum occupancy.", "rationale": ["Identify the table that contains room information, which is the 'Rooms' table.", "Determine the column that holds the maximum occupancy information, which is 'maxOccupancy'.", "To find the room with the maximum occupancy, we need to select the room name from the 'Rooms' table where the 'maxOccupancy' is equal to the maximum value of 'maxOccupancy' in the same table.", "Use a subquery to find the maximum occupancy value from the 'Rooms' table.", "Construct the final SQL query to select the 'roomName' where 'maxOccupancy' matches the maximum occupancy found."], "gold_sql": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE maxOccupancy = (SELECT MAX(maxOccupancy) FROM Rooms);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n    \"1\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n    \"2\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.2621", "db_id": "inn_1", "question": "What is the average minimum and price of the rooms for each different decor.", "rationale": ["Identify the relevant columns needed for the query: 'decor' from the Rooms table and 'basePrice' for calculating average and minimum prices.", "Use the AVG() function to calculate the average price of rooms and the MIN() function to find the minimum price for each decor type.", "Group the results by the 'decor' column to get the average and minimum prices for each different decor type.", "Construct the SQL query using the SELECT statement to retrieve the desired information from the Rooms table."], "gold_sql": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;", "source_tables": ["rooms"], "pred_sql": "SELECT decor, AVG(basePrice) AS average_price, MIN(basePrice) AS minimum_price \nFROM Rooms \nGROUP BY decor;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by the decoration type. The placeholder in the LIMIT clause allows for specifying the maximum number of decoration types to return.\",\n    \"2\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\"\n}\n"}
{"sample_id": "train.2628", "db_id": "inn_1", "question": "List the name of rooms with king or queen bed.", "rationale": ["Identify the relevant table: The 'Rooms' table contains information about room names and bed types.", "Determine the required columns: We need the 'roomName' column to list the names of the rooms.", "Specify the condition: We want rooms that have either 'king' or 'queen' beds, which can be expressed using the IN clause in SQL.", "Construct the SQL query: Combine the selected columns and the condition to form the complete SQL query."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE bedType IN ('king', 'queen');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n    \"1\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by the decoration type. The placeholder in the LIMIT clause allows for specifying the maximum number of decoration types to return.\"\n}\n"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["We need to find the name of each room and the number of times reservations were made for it.", "To achieve this, we will select the 'roomName' from the 'Rooms' table.", "We will also count the number of reservations associated with each room, which can be done using the COUNT function on the 'Code' column from the 'Reservations' table.", "Since a room may not have any reservations, we will use a LEFT JOIN to include all rooms even if they have zero reservations.", "The join condition will be based on the 'RoomId' from the 'Rooms' table matching the 'Room' from the 'Reservations' table.", "Finally, we will group the results by 'RoomId' and 'roomName' to get the count of reservations for each room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservation_count \nFROM Rooms \nLEFT JOIN Reservations ON Rooms.RoomId = Reservations.Room \nGROUP BY Rooms.RoomId, Rooms.roomName;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\",\n    \"1\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n    \"2\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["Identify the table needed: The question asks for details of trucks, so we will use the 'Trucks' table.", "Select all columns: We need all details of the trucks, so we will use 'SELECT *'.", "Order by license number: The question specifies to order the results by the truck license number, so we will add 'ORDER BY truck_licence_number' to the query."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "pred_sql": "SELECT * FROM Trucks ORDER BY truck_licence_number;", "hint": "\n"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to find customer names, so we will select 'customer_name' from the Customers table.", "To filter customers based on their address, we need to join the Customers table with the Customer_Addresses table using 'customer_id'.", "Next, we join the Customer_Addresses table with the Addresses table using 'address_id' to access the state information.", "Finally, we apply a WHERE clause to filter out customers whose state is 'California'."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT customer_name \nFROM Customers C \nJOIN Customer_Addresses CA ON C.customer_id = CA.customer_id \nJOIN Addresses A ON CA.address_id = A.address_id \nWHERE A.state_province_county != 'California';", "hint": "\n"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["Identify the relevant tables: Delivery_Routes, Delivery_Route_Locations, and Order_Deliveries are needed to find the route with the highest number of deliveries.", "Join the Delivery_Routes table with Delivery_Route_Locations on route_id to link routes to their locations.", "Join the resulting table with Order_Deliveries on location_code to associate deliveries with their respective routes.", "Group the results by route_name to count the number of deliveries for each route.", "Order the results in descending order based on the count of deliveries to find the route with the highest number.", "Limit the results to 1 to get only the top route."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "pred_sql": "SELECT route_name\nFROM Delivery_Routes\nJOIN Delivery_Route_Locations ON Delivery_Routes.route_id = Delivery_Route_Locations.route_id\nJOIN Order_Deliveries ON Delivery_Route_Locations.location_code = Order_Deliveries.location_code\nGROUP BY route_name\nORDER BY COUNT(Order_Deliveries.actual_order_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3175", "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and PROFESSOR.", "We need to count the number of distinct professors teaching a specific class, which is identified by the CLASS_CODE 'ACCT-211'.", "Join the CLASS table with the PROFESSOR table on the PROF_NUM field to link classes with their respective professors.", "Use the COUNT function to count the distinct professors (EMP_NUM) teaching the class.", "Filter the results using a WHERE clause to specify the CLASS_CODE as 'ACCT-211'."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) AS professor_count\nFROM CLASS c\nJOIN PROFESSOR p ON c.PROF_NUM = p.EMP_NUM\nWHERE c.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n    \"1\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department associated with each professor.\",\n    \"2\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and PROFESSOR are needed to find the professors teaching a specific class.", "Use the CLASS table to filter for the class with the code 'ACCT-211'.", "Join the CLASS table with the PROFESSOR table on the professor's identifier (PROF_NUM).", "Count the distinct professors (EMP_NUM) who are teaching the specified class.", "Construct the SQL query to select the count of distinct professors for the class 'ACCT-211'."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT PROFESSOR.EMP_NUM) AS professor_count\nFROM CLASS\nJOIN PROFESSOR ON CLASS.PROF_NUM = PROFESSOR.EMP_NUM\nWHERE CLASS.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n    \"1\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department associated with each professor.\",\n    \"2\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["Identify the relevant tables: CLASS, PROFESSOR, EMPLOYEE, and COURSE.", "We need to retrieve the first names and date of birth of professors, so we will select EMPLOYEE.EMP_FNAME and EMPLOYEE.EMP_DOB.", "Join the CLASS table with the PROFESSOR table on the condition that CLASS.PROF_NUM matches PROFESSOR.EMP_NUM to get the professors for each class.", "Join the PROFESSOR table with the EMPLOYEE table on the condition that PROFESSOR.EMP_NUM matches EMPLOYEE.EMP_NUM to access the first names and date of birth of the professors.", "Join the CLASS table with the COURSE table on the condition that CLASS.CRS_CODE matches COURSE.CRS_CODE to filter by the specific course ACCT-211.", "Add a WHERE clause to filter the results to only include the course with CRS_CODE 'ACCT-211'."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, EMPLOYEE.EMP_DOB \nFROM CLASS \nJOIN PROFESSOR ON CLASS.PROF_NUM = PROFESSOR.EMP_NUM \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nWHERE COURSE.CRS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3188", "db_id": "college_1", "question": "Where is the history department?", "rationale": ["Identify the relevant table: The DEPARTMENT table contains information about departments, including their names and addresses.", "Determine the specific information needed: The user is asking for the location of the history department, which means we need the department name and address.", "Construct the SQL query: We will select the DEPT_NAME and DEPT_ADDRESS from the DEPARTMENT table where the DEPT_NAME matches 'History'.", "Use the LIKE operator to ensure we capture any variations in the department name that may include 'History'."], "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"], "pred_sql": "SELECT DEPT_NAME, DEPT_ADDRESS FROM DEPARTMENT WHERE DEPT_NAME LIKE '%History%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n    \"1\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n    \"2\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\"\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the relevant table: The DEPARTMENT table contains the addresses of departments associated with schools.", "Determine the filtering criteria: We need to filter the results based on the SCHOOL_CODE, which is 'BUS'.", "Select the distinct addresses: We want to retrieve different locations, so we will use DISTINCT to avoid duplicates.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter by SCHOOL_CODE."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.\",\n    \"1\": \"This virtual table provides the count of distinct department addresses from the 'DEPARTMENT' table for a specific school. The placeholder in the WHERE clause represents the school code being queried.\"\n}\n"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["Identify the relevant tables: COURSE, CLASS, and DEPARTMENT are needed to get the total credit hours offered by each department.", "The COURSE table contains the credit hours for each course, while the CLASS table links courses to specific classes.", "The DEPARTMENT table provides the department codes that we need to group the results by.", "Join the COURSE and CLASS tables on the CRS_CODE to link courses to their respective classes.", "Join the resulting table with the DEPARTMENT table on DEPT_CODE to associate courses with their departments.", "Use the SUM function to calculate the total credit hours for each department.", "Group the results by DEPARTMENT.DEPT_CODE to get the total credit hours per department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, SUM(COURSE.CRS_CREDIT) AS TOTAL_CREDIT\nFROM COURSE\nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE\nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n    \"1\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n    \"2\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping the results.\"\n}\n"}
{"sample_id": "train.3202", "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["The question asks for the total credits offered by each department.", "To find this information, we need to look at the 'COURSE' table, which contains the credit hours for each course.", "We will join the 'COURSE' table with the 'CLASS' table using the 'CRS_CODE' to link courses to their respective classes.", "Next, we will join the 'COURSE' table with the 'DEPARTMENT' table using the 'DEPT_CODE' to associate courses with their departments.", "We will use the SUM function to aggregate the total credit hours for each department.", "Finally, we will group the results by 'DEPT_CODE' to get the total credits offered by each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, SUM(COURSE.CRS_CREDIT) AS TOTAL_CREDITS\nFROM COURSE\nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE\nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n    \"1\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping the results.\",\n    \"2\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\"\n}\n"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["We need to find the school with the smallest number of professors.", "To do this, we will join the DEPARTMENT table with the PROFESSOR table on the DEPT_CODE.", "We will group the results by SCHOOL_CODE to count the number of professors in each school.", "We will order the results by the count of professors in ascending order to get the school with the least number of professors at the top.", "Finally, we will limit the results to 1 to get only the school with the smallest number of professors."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "pred_sql": "SELECT SCHOOL_CODE\nFROM DEPARTMENT\nJOIN PROFESSOR ON DEPARTMENT.DEPT_CODE = PROFESSOR.DEPT_CODE\nGROUP BY SCHOOL_CODE\nORDER BY COUNT(PROFESSOR.EMP_NUM) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n    \"1\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department associated with each professor.\",\n    \"2\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.\"\n}\n"}
{"sample_id": "train.3215", "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["Identify the relevant tables: PROFESSOR and DEPARTMENT are needed to find the number of professors with a Ph.D. in each department.", "Join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE to associate professors with their respective departments.", "Filter the results to include only those professors who have a Ph.D. by using a WHERE clause that checks the PROF_HIGH_DEGREE column.", "Group the results by DEPARTMENT.DEPT_CODE to count the number of professors in each department.", "Select the DEPARTMENT.DEPT_CODE and the count of professors as PhD_Professors."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, COUNT(PROFESSOR.EMP_NUM) AS PhD_Professors\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nWHERE PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D.'\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n    \"1\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department associated with each professor.\",\n    \"2\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.\"\n}\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["Identify the relevant table: The STUDENT table contains information about students, including their department codes.", "Determine the required output: We need to count the number of students for each department, which means we will use the COUNT() function.", "Group the results: To get the count of students per department, we will use the GROUP BY clause on the DEPT_CODE column.", "Construct the SQL query: Combine the SELECT statement with the COUNT function and the GROUP BY clause to form the complete SQL query."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPT_CODE, COUNT(STU_NUM) AS student_count\nFROM STUDENT\nGROUP BY DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students grouped by their department codes from the 'student' table. The placeholder in the SELECT statement represents the department code for which the count of students is being aggregated.\",\n    \"1\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department associated with each professor.\",\n    \"2\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\"\n}\n"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["We need to find the total number of hours completed by students in each department.", "The relevant table for student credit hours is the STUDENT table, which contains the column STU_HRS for total credit hours.", "We also need to group these results by department, which is represented in the DEPARTMENT table with the DEPT_CODE column.", "To link the STUDENT table with the DEPARTMENT table, we can use the DEPT_CODE foreign key present in both tables.", "We will use a JOIN operation to combine the STUDENT and DEPARTMENT tables based on the DEPT_CODE.", "Finally, we will use the SUM function to calculate the total credit hours for each department and group the results by DEPARTMENT.DEPT_CODE."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, SUM(STUDENT.STU_HRS) AS TOTAL_HOURS\nFROM STUDENT\nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n    \"1\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n    \"2\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping the results.\"\n}\n"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["Identify the relevant tables: COURSE, CLASS, and DEPARTMENT are needed to find the total credits offered by each department.", "Join the COURSE and CLASS tables on the CRS_CODE to link courses with their respective classes.", "Join the resulting table with the DEPARTMENT table on DEPT_CODE to associate courses with their departments.", "Use SUM to calculate the total credit hours for each department by summing the CRS_CREDIT from the COURSE table.", "Group the results by DEPARTMENT.DEPT_CODE to aggregate the total credits per department.", "Order the results in descending order of total credits to find the department with the most credits.", "Limit the results to 1 to get only the department with the highest total credits."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, SUM(COURSE.CRS_CREDIT) AS TOTAL_CREDITS\nFROM COURSE\nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE\nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE\nORDER BY TOTAL_CREDITS DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n    \"1\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping the results.\",\n    \"2\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\"\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the relevant tables: STUDENT, ENROLL, and CLASS.", "We need to find the first names of students, so we will select STUDENT.STU_FNAME.", "Students are enrolled in classes, so we will join the ENROLL table with the STUDENT table on STU_NUM.", "Next, we need to link the ENROLL table to the CLASS table using CLASS_CODE to filter for the specific class 'ACCT-211'.", "Finally, we will add a WHERE clause to specify that we only want students enrolled in the class 'ACCT-211'."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["Identify the tables needed: STUDENT for student names, ENROLL for enrollment details, and CLASS for class information.", "Join the ENROLL table with STUDENT to get the first names of students enrolled in classes.", "Join the CLASS table to filter for the specific class code 'ACCT-211'.", "Add a condition to filter for students who received a grade of 'C'.", "Construct the SELECT statement to retrieve the first names of the students that meet these criteria."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211' AND ENROLL.ENROLL_GRADE = 'C';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n    \"1\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["We need to find the department with the most students enrolled.", "To do this, we will count the number of students in each department by grouping the 'STUDENT' table by 'DEPT_CODE'.", "We will then order these counts in descending order to find the department with the highest count.", "Finally, we will limit the results to just one department to get the top result.", "To retrieve the name of the department, we will join this result with the 'DEPARTMENT' table using the 'DEPT_CODE' to get the corresponding 'DEPT_NAME'."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT DEPT_NAME\nFROM DEPARTMENT\nWHERE DEPT_CODE = (\n    SELECT DEPT_CODE\n    FROM STUDENT\n    GROUP BY DEPT_CODE\n    ORDER BY COUNT(STU_NUM) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students grouped by their department codes from the 'student' table. The placeholder in the SELECT statement represents the department code for which the count of students is being aggregated.\",\n    \"1\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table that are associated with classes in the 'CLASS' table. It joins the 'ENROLL' table to link students to classes, the 'COURSE' table to connect classes to their respective courses, and finally the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the number of classes in descending order, with a limit on the number of departments returned as specified by a placeholder.\",\n    \"2\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\"\n}\n"}
{"sample_id": "train.3257", "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["Identify the relevant table: The CLASS table contains information about classes, including the room where they are held.", "Determine the required columns: We need the course codes (CRS_CODE) for classes held in room KLR209.", "Construct the SQL query: Use a SELECT statement to retrieve distinct course codes from the CLASS table where the CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE\nFROM CLASS\nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n    \"1\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping the results.\",\n    \"2\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.\"\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about class locations, including the CLASS_ROOM column.", "Determine the required information: We need the course codes (CRS_CODE) for classes held in room KLR209.", "Construct the SQL query: Use a SELECT statement to retrieve distinct CRS_CODE from the CLASS table where CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE \nFROM CLASS \nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n    \"1\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping the results.\",\n    \"2\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.\"\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed since we want student names and their grades.", "We need to join the STUDENT table with the ENROLL table on the student number (STU_NUM) to access the grades associated with each student.", "We are interested in students who received a grade of 'C', so we will filter the results using a WHERE clause on the ENROLL_GRADE column.", "To avoid duplicate names, we will use DISTINCT to ensure each first name is listed only once."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["We need to find the first names of professors who do not teach a class.", "To do this, we will use the EMPLOYEE table to get the first names of professors.", "We will join the PROFESSOR table to link professors with their employee records.", "Next, we will perform a LEFT JOIN with the CLASS table to find any classes taught by the professors.", "By using a LEFT JOIN, we can identify professors who do not have any corresponding entries in the CLASS table.", "Finally, we will filter the results where CLASS.CLASS_CODE is NULL, indicating that the professor does not teach any class."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM EMPLOYEE \nLEFT JOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nLEFT JOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CLASS_CODE IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["We need to find the first names of professors who are not teaching any classes.", "To do this, we will use the EMPLOYEE table to get the first names of professors.", "We will perform a LEFT JOIN between the EMPLOYEE table and the PROFESSOR table to get all professors, including those who may not be teaching any classes.", "Next, we will perform another LEFT JOIN with the CLASS table to see if there are any classes associated with each professor.", "Finally, we will filter the results to include only those professors who do not have any associated classes, which can be identified by checking for NULL values in the CLASS_CODE from the CLASS table."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM EMPLOYEE \nLEFT JOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nLEFT JOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CLASS_CODE IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors, including their highest degree obtained.", "Determine the condition: We need to count professors who have either a Ph.D. or a Masters degree. This can be done using a WHERE clause to filter the results based on the PROF_HIGH_DEGREE column.", "Construct the SQL query: Use the COUNT function to count the number of professors that meet the criteria, and select from the PROFESSOR table with the appropriate WHERE clause."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) AS professor_count \nFROM PROFESSOR \nWHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n    \"1\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n    \"2\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department associated with each professor.\"\n}\n"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, and COURSE.", "We need to find the first name of professors teaching specific courses (CIS-220 and QM-261).", "Join the CLASS table with the EMPLOYEE table to get the professor's first name using the PROF_NUM foreign key.", "Join the CLASS table with the COURSE table to filter by the course codes (CIS-220 and QM-261).", "Use a WHERE clause to specify the course codes we are interested in."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM CLASS \nJOIN EMPLOYEE ON CLASS.PROF_NUM = EMPLOYEE.EMP_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nWHERE COURSE.CRS_CODE IN ('CIS-220', 'QM-261');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["We need to find the first names of students enrolled in classes from specific departments: Accounting and Computer Info. Systems.", "To achieve this, we will join several tables: STUDENT, ENROLL, CLASS, COURSE, and DEPARTMENT.", "The STUDENT table contains the first names of students, while the ENROLL table links students to the classes they are taking.", "The CLASS table provides information about the classes, and the COURSE table gives details about the courses associated with those classes.", "The DEPARTMENT table allows us to filter the courses based on the department names we are interested in.", "We will use a WHERE clause to specify that we only want departments that are either 'Accounting' or 'Computer Info. Systems'.", "Finally, we will use DISTINCT to ensure that we only get unique first names of students."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME IN ('Accounting', 'Computer Info. Systems');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3308", "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["Identify the required information: first names and office locations of professors.", "Determine the relevant tables: PROFESSOR for office details, EMPLOYEE for first names, and DEPARTMENT for department names.", "Join the PROFESSOR table with the EMPLOYEE table to get the first names of professors.", "Join the PROFESSOR table with the DEPARTMENT table to filter for the history department.", "Add a condition to filter professors who have a Ph.D. degree.", "Construct the SQL SELECT statement to retrieve the desired columns from the joined tables."], "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'History' \nAND PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3319", "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["Identify the tables needed: STUDENT for student names and ENROLL for enrollment details including grades.", "We need to find students who received either an 'A' or 'C' grade, so we will filter the ENROLL table based on the ENROLL_GRADE column.", "To get the names of the students, we will select the first and last names from the STUDENT table.", "We will join the STUDENT table with the ENROLL table on the student number (STU_NUM) to link students with their grades.", "Use DISTINCT to ensure that each student's name appears only once in the result, even if they took multiple courses with qualifying grades."], "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME, S.STU_LNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nWHERE E.ENROLL_GRADE IN ('A', 'C');", "hint": "\n"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, PROFESSOR, COURSE, and DEPARTMENT.", "We need to retrieve the first names of professors and their highest degree, so we will select EMPLOYEE.EMP_FNAME and PROFESSOR.PROF_HIGH_DEGREE.", "Join the CLASS table with the PROFESSOR table on the professor's employee number (PROF_NUM).", "Join the PROFESSOR table with the EMPLOYEE table to get the first names of the professors.", "Join the CLASS table with the COURSE table to link classes to their respective courses.", "Join the COURSE table with the DEPARTMENT table to filter by the Computer Information Systems department.", "Use a WHERE clause to specify that we only want professors from the Computer Information Systems department."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_HIGH_DEGREE \nFROM CLASS \nJOIN PROFESSOR ON CLASS.PROF_NUM = PROFESSOR.EMP_NUM \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'Computer Information Systems';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: CLASS, COURSE, and DEPARTMENT.", "We need to find the department name, so we will select DEPARTMENT.DEPT_NAME.", "The class description is in the COURSE table, so we will filter based on COURSE.CRS_DESCRIPTION.", "To link the tables, we will join CLASS and COURSE on CLASS.CRS_CODE = COURSE.CRS_CODE, and then join COURSE and DEPARTMENT on COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE.", "Finally, we will use a WHERE clause to filter the courses that have 'Statistics' in their description using the LIKE operator."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME \nFROM CLASS \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE COURSE.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\",\n    \"1\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\",\n    \"2\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department associated with each professor.\"\n}\n"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["We need to retrieve the types and countries of competitions from the competition table.", "The relevant columns for this query are 'Competition_type' and 'Country' from the competition table.", "Using SELECT DISTINCT ensures that we get unique combinations of competition types and countries.", "The final SQL query selects these distinct values from the competition table."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT Competition_type, Country FROM competition;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n    \"1\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\"\n}\n"}
{"sample_id": "train.3355", "db_id": "sports_competition", "question": "Please show the names and the players of clubs.", "rationale": ["Identify the tables needed: 'club' for club names and 'player' for player names.", "Determine the relationship between the tables: 'player' has a foreign key 'Club_ID' that references 'club'.", "Use a JOIN operation to combine data from both tables based on the 'Club_ID'.", "Select the desired columns: the name of the club and the name of the player."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "pred_sql": "SELECT c.name AS club_name, p.name AS player_name \nFROM club c \nJOIN player p ON c.Club_ID = p.Club_ID;", "hint": "\n"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["Identify the relevant table: The 'player' table contains the information about players and their positions.", "Determine the required calculation: We need to calculate the average number of points scored by players in each position.", "Group the results: Use GROUP BY to group the players by their Position.", "Filter the results: Use HAVING to filter out positions where the average points scored is greater than 20."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player GROUP BY Position HAVING AVG(Points) > 20;", "hint": "\n"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant column for player positions, which is 'Position'.", "Identify the column that contains the points scored by players, which is 'Points'.", "Formulate the condition to filter players with more than 20 points or less than 10 points.", "Construct the SQL query to select the 'Position' of players that meet the specified conditions."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player WHERE Points > 20 OR Points < 10;", "hint": "\n"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about the competitions, including their type and country.", "Filter for tournament competitions: We need to focus on competitions where the type is 'tournament'.", "Group by country: To find out how many tournaments each country participated in, we will group the results by the 'Country' column.", "Count the number of tournaments: We will count the number of occurrences for each country using COUNT(*).", "Order the results: To find the country with the most tournaments, we will order the results in descending order based on the count.", "Limit the results: Since we only want the country with the most tournaments, we will limit the results to 1."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country, COUNT(*) AS Tournament_Count \nFROM competition \nWHERE Competition_type = 'tournament' \nGROUP BY Country \nORDER BY Tournament_Count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n    \"1\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\"\n}\n"}
{"sample_id": "train.3384", "db_id": "sports_competition", "question": "what is the name of the country that participated in the most tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about the competitions, including the type and country.", "Filter for tournament competitions: We need to focus on competitions of type 'tournament'.", "Group by country: To find out how many tournaments each country participated in, we will group the results by the 'Country' column.", "Count the occurrences: We will count the number of tournaments for each country using COUNT(*) in the SELECT statement.", "Order by count: To find the country with the most tournaments, we will order the results in descending order based on the count.", "Limit the results: We will limit the results to 1 to get only the country with the highest count."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country FROM competition WHERE Competition_type = 'tournament' GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\"\n}\n"}
{"sample_id": "train.3388", "db_id": "sports_competition", "question": "What are the countries that have never participated in any friendly-type competitions?", "rationale": ["Identify the countries that have participated in competitions by selecting from the competition table.", "Use a subquery to find all Competition_IDs that are associated with friendly-type competitions.", "Select distinct countries from the competition table where the Competition_ID is not in the list of friendly competitions."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT country FROM competition WHERE Competition_ID NOT IN (SELECT Competition_ID FROM competition WHERE Competition_type = 'friendly')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n    \"1\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\"\n}\n"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["Identify the relevant table: The 'employees' table contains the necessary information about employees' names and salaries.", "Determine the required fields: We need to select the first name (FIRST_NAME), last name (LAST_NAME), and salary (SALARY) of employees.", "Set the condition: We want to filter employees who earn below 6000, which can be done using a WHERE clause.", "Construct the SQL query: Combine the SELECT statement with the WHERE condition to form the complete SQL query."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME, LAST_NAME, SALARY FROM employees WHERE SALARY < 6000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n    \"1\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n    \"2\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\"\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (concatenation of first and last names), hire date, salary, and department id.", "To get the full name, we will concatenate the FIRST_NAME and LAST_NAME fields using '||' operator.", "We need to filter employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator with the pattern '%M%'.", "The query will select from the 'employees' table where the conditions are met."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n    \"1\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\",\n    \"2\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\"\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by DEPARTMENT_ID.", "Construct the SQL SELECT statement using the identified fields and conditions."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n    \"1\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n    \"2\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\"\n}\n"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["Identify the required fields: full name (concatenation of first and last names), hire date, salary, and department ID.", "Use the employees table to access the necessary fields.", "Filter employees whose first name does not contain the letter 'M' using the NOT LIKE operator.", "Order the results by department ID in ascending order."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE, e.SALARY, e.DEPARTMENT_ID\nFROM employees e\nWHERE e.FIRST_NAME NOT LIKE '%M%'\nORDER BY e.DEPARTMENT_ID ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n    \"1\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\"\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The 'jobs' table contains job titles and salary information.", "Determine the condition: We need to find jobs with salaries over 9000, which corresponds to the 'MAX_SALARY' column in the 'jobs' table.", "Construct the SQL query: We will select distinct job titles from the 'jobs' table where the maximum salary is greater than 9000."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT DISTINCT JOB_TITLE FROM jobs WHERE MAX_SALARY > 9000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n    \"1\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n    \"2\": \"This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.\"\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The 'jobs' table contains the job titles and salary information.", "Determine the required columns: We need 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY'.", "Apply the filter condition: We want to find jobs where the 'MAX_SALARY' is between 12000 and 18000.", "Construct the SQL query: Use a SELECT statement to retrieve the specified columns from the 'jobs' table with the appropriate WHERE clause."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY FROM jobs WHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n    \"1\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n    \"2\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\"\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["We need to retrieve the employee IDs and the final dates of employment at their last job.", "The 'job_history' table contains the end dates of jobs for employees, so we will join the 'employees' table with the 'job_history' table on the EMPLOYEE_ID.", "To get the last job end date for each employee, we will use the MAX function on the END_DATE column from the 'job_history' table.", "We will group the results by EMPLOYEE_ID to ensure we get one result per employee."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT e.EMPLOYEE_ID, MAX(jh.END_DATE) AS LAST_JOB_END_DATE\nFROM employees e\nJOIN job_history jh ON e.EMPLOYEE_ID = jh.EMPLOYEE_ID\nGROUP BY e.EMPLOYEE_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the employee's unique identifier, while the MAX function is used to retrieve the latest end date for each employee's job history.\",\n    \"1\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n    \"2\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\"\n}\n"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["We need to display the average salary of employees for each department who gets a commission percentage.", "To calculate the average salary, we will use the AVG() function on the SALARY column from the employees table.", "We need to join the employees table with the departments table to get the department names associated with each employee.", "The WHERE clause will filter employees to include only those who have a non-null commission percentage, indicating they receive a commission.", "Finally, we will group the results by department name to get the average salary for each department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_NAME, AVG(e.SALARY) AS average_salary\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nWHERE e.COMMISSION_PCT IS NOT NULL\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\",\n    \"1\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\",\n    \"2\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["Identify the table needed: The question pertains to employee salaries, so we will use the 'employees' table.", "Determine the required calculation: We need to calculate the average salary, which can be done using the AVG() function in SQL.", "Filter the results: We need to include only those employees who have a non-null commission percentage, which can be done using the WHERE clause with 'COMMISSION_PCT IS NOT NULL'.", "Construct the SQL query: Combine the SELECT statement for the average salary with the FROM clause for the 'employees' table and the WHERE clause for the commission percentage filter."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT AVG(SALARY) AS average_salary\nFROM employees\nWHERE COMMISSION_PCT IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n    \"1\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n    \"2\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\"\n}\n"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["Identify the required columns: COUNTRY_ID from countries and the count of cities from locations.", "To get the number of cities for each country, we need to join the countries table with the locations table on the COUNTRY_ID.", "Use the COUNT() function to count the number of cities for each country.", "Group the results by COUNTRY_ID to ensure we get a count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT countries.COUNTRY_ID, COUNT(locations.CITY) AS number_of_cities\nFROM countries\nJOIN locations ON countries.COUNTRY_ID = locations.COUNTRY_ID\nGROUP BY countries.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["Identify the tables needed: 'countries' for country information and 'locations' for city information.", "Determine the relationship between the tables: 'locations' has a foreign key 'COUNTRY_ID' that links to 'countries'.", "Use a JOIN to combine 'countries' and 'locations' on 'COUNTRY_ID'.", "Count the number of cities (from 'locations') for each country (from 'countries').", "Group the results by 'COUNTRY_ID' to get the count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT c.COUNTRY_ID, COUNT(l.CITY) AS CITY_COUNT\nFROM countries c\nJOIN locations l ON c.COUNTRY_ID = l.COUNTRY_ID\nGROUP BY c.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["Identify the main table to query from, which is the 'jobs' table, to get detailed job information.", "We need to filter jobs based on employees who earn a salary of 12000 or more.", "To do this, we will use a subquery that selects the JOB_IDs from the 'employees' table where the SALARY is greater than or equal to 12000.", "The main query will then select all columns from the 'jobs' table where the JOB_ID is in the list returned by the subquery."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "pred_sql": "SELECT j.* \nFROM jobs j \nWHERE j.JOB_ID IN (\n    SELECT e.JOB_ID \n    FROM employees e \n    WHERE e.SALARY >= 12000\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n    \"1\": \"This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.\",\n    \"2\": \"This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the employee's unique identifier, while the MAX function is used to retrieve the latest end date for each employee's job history.\"\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the main requirement: Retrieve all information about employees who are managers.", "To find employees who are managers, we need to check the 'MANAGER_ID' field in the 'employees' table.", "We will use a subquery to get distinct 'MANAGER_ID's from the 'employees' table.", "We need to join the 'employees' table with the 'departments' table to get the department names.", "We also need to join the 'departments' table with the 'locations' table to get the city and state/province of the department's location.", "Finally, we will select all columns from the 'employees' table along with the department name, city, and state/province."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT e.*, d.DEPARTMENT_NAME, l.CITY, l.STATE_PROVINCE \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE e.EMPLOYEE_ID IN (SELECT DISTINCT MANAGER_ID FROM employees WHERE MANAGER_ID IS NOT NULL);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["We need to find departments where any manager is managing 4 or more employees.", "To do this, we will first identify managers who have 4 or more employees reporting to them. This can be done by grouping the employees by MANAGER_ID and counting the number of EMPLOYEE_IDs for each manager, using the HAVING clause to filter those with a count of 4 or more.", "Next, we will join the departments table with the employees table on DEPARTMENT_ID to get the relevant department information for those managers.", "Finally, we will select the unique DEPARTMENT_IDs from the departments table where the manager is in the list of managers identified in the previous step. We will group the results by DEPARTMENT_ID to ensure uniqueness."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nWHERE e.MANAGER_ID IN (\n    SELECT MANAGER_ID\n    FROM employees\n    GROUP BY MANAGER_ID\n    HAVING COUNT(EMPLOYEE_ID) >= 4\n) \nGROUP BY d.DEPARTMENT_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n    \"1\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n    \"2\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find distinct department IDs where a manager oversees 4 or more employees.", "To achieve this, we will join the 'departments' table with the 'employees' table on the DEPARTMENT_ID.", "We will group the results by DEPARTMENT_ID to count the number of employees in each department.", "Using the COUNT function, we will filter the groups to only include those with 4 or more employees using the HAVING clause."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DISTINCT d.DEPARTMENT_ID\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_ID\nHAVING COUNT(e.EMPLOYEE_ID) >= 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n    \"1\": \"This virtual table provides a count of employees grouped by their respective department names from the 'departments' table. The placeholder in the SELECT statement allows for the retrieval of department names, while the COUNT function aggregates the number of employees in each department.\",\n    \"2\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\"\n}\n"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["Identify the relevant table: The 'employees' table contains the information about employees, including their salaries.", "Determine the salary conditions: We need to find employees with salaries above the minimum salary and below 2500.", "Use a subquery to find the minimum salary: The minimum salary can be obtained from the 'jobs' table using a subquery.", "Construct the SQL query: Combine the conditions to filter employees based on their salaries using the WHERE clause."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "pred_sql": "SELECT * FROM employees WHERE SALARY > (SELECT MIN_SALARY FROM jobs) AND SALARY < 2500;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n    \"1\": \"This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.\",\n    \"2\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\"\n}\n"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["Identify the main requirement: to get the full names and hire dates of employees in the same department as Clara.", "To get the full names, we need to concatenate the first and last names of employees.", "We need to filter employees based on the department of the employee named Clara.", "To find Clara's department, we will use a subquery that selects the DEPARTMENT_ID from the employees table where the FIRST_NAME is 'Clara'.", "The main query will select the full names and hire dates of employees whose DEPARTMENT_ID matches the one found in the subquery."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE \nFROM employees e \nWHERE e.DEPARTMENT_ID = (SELECT e2.DEPARTMENT_ID \n                         FROM employees e2 \n                         WHERE e2.FIRST_NAME = 'Clara')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n    \"1\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\",\n    \"2\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\"\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the main requirement: We need the full names (first and last) and hire dates of employees who work in the same department as an employee named Clara, excluding Clara herself.", "To achieve this, we will need to join the 'employees' table with the 'departments' table to access department information.", "We will use a subquery to find the department ID of the employee named Clara. This subquery will select the department ID from the 'departments' table where the employee's first name is Clara.", "The main query will select the first name, last name, and hire date of employees from the 'employees' table where their department ID matches the one found in the subquery.", "Finally, we will add a condition to exclude Clara from the results by ensuring the first name is not Clara."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, e.HIRE_DATE \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nWHERE d.DEPARTMENT_ID = (SELECT d2.DEPARTMENT_ID \n                         FROM employees e2 \n                         JOIN departments d2 ON e2.DEPARTMENT_ID = d2.DEPARTMENT_ID \n                         WHERE e2.FIRST_NAME = 'Clara') \nAND e.FIRST_NAME != 'Clara';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n    \"1\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\",\n    \"2\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\"\n}\n"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["Identify the main requirement: to display employee number and name for employees in departments with any employee whose name contains 'T'.", "We need to select the EMPLOYEE_ID, FIRST_NAME, and LAST_NAME from the employees table.", "To find the relevant departments, we will use a subquery that selects department IDs from the employees table where either the FIRST_NAME or LAST_NAME contains 'T'.", "The subquery will use the LIKE operator to filter names containing 'T'.", "The main query will filter employees based on the department IDs returned by the subquery."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME \nFROM employees e \nWHERE e.DEPARTMENT_ID IN (\n    SELECT DISTINCT e2.DEPARTMENT_ID \n    FROM employees e2 \n    WHERE e2.FIRST_NAME LIKE '%T%' OR e2.LAST_NAME LIKE '%T%'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n    \"1\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n    \"2\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the columns needed: EMPLOYEE_ID and JOB_ID from the employees table.", "Determine the condition: we need employees whose salary is less than any salary of those with the job title 'MK_MAN'.", "To find the salary of employees with the job title 'MK_MAN', we will use a subquery that selects the minimum salary from the employees table where the job title matches 'MK_MAN'.", "Join the employees table with the jobs table to access the JOB_TITLE column while filtering for 'MK_MAN'.", "Construct the main query to select EMPLOYEE_ID and JOB_ID from the employees table where the salary is less than the result of the subquery."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID \nFROM employees \nWHERE SALARY < (SELECT MIN(SALARY) \n                 FROM employees \n                 JOIN jobs ON employees.JOB_ID = jobs.JOB_ID \n                 WHERE JOB_TITLE = 'MK_MAN');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.\",\n    \"1\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n    \"2\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\"\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To do this, we will join the 'employees' table with the 'departments' table on the DEPARTMENT_ID.", "We will use the SUM function to calculate the total salaries for each department.", "We will group the results by DEPARTMENT_ID to aggregate the salaries per department.", "To filter the departments that have more than 2 employees, we will use the HAVING clause with COUNT function."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, SUM(e.SALARY) AS total_salaries\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_ID\nHAVING COUNT(e.EMPLOYEE_ID) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n    \"1\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\",\n    \"2\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\"\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To achieve this, we will first create a subquery that selects the maximum salary for each department from the 'employees' table, grouping by DEPARTMENT_ID.", "Next, we will join this subquery with the 'employees' table to filter out the employees who have the maximum salary in their respective departments.", "In the final SELECT statement, we will retrieve the DEPARTMENT_ID, concatenate FIRST_NAME and LAST_NAME to create FULL_NAME, and also include the SALARY of these employees."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN (\n    SELECT DEPARTMENT_ID, MAX(SALARY) AS MAX_SALARY \n    FROM employees \n    GROUP BY DEPARTMENT_ID\n) AS max_salaries \nON e.DEPARTMENT_ID = max_salaries.DEPARTMENT_ID AND e.SALARY = max_salaries.MAX_SALARY;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n    \"1\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\",\n    \"2\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\"\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the tables needed: employees, departments, and locations.", "We need to retrieve the full names of employees, which requires concatenating their first and last names.", "The city of the employee's department is also needed, which is found in the locations table.", "To get the full names, we will use the SELECT statement to concatenate FIRST_NAME and LAST_NAME.", "We will join the employees table with the departments table on DEPARTMENT_ID to get department information.", "Next, we will join the departments table with the locations table on LOCATION_ID to get the city information.", "Finally, we will filter the results to include only those employees whose first names contain the letter 'Z' using the WHERE clause with the LIKE operator."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, l.CITY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE e.FIRST_NAME LIKE '%Z%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n    \"1\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\"\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed to retrieve the employee's full name and the country they are working in: 'employees', 'departments', 'locations', and 'countries'.", "Join the 'employees' table with the 'departments' table on 'DEPARTMENT_ID' to get department information for each employee.", "Join the 'departments' table with the 'locations' table on 'LOCATION_ID' to get location information for each department.", "Join the 'locations' table with the 'countries' table on 'COUNTRY_ID' to get the country information for each location.", "Select the first name and last name from the 'employees' table and the country name from the 'countries' table.", "Use a WHERE clause to filter the results for the specific employee ID provided."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, c.COUNTRY_NAME \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE e.EMPLOYEE_ID = ?;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n    \"1\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n    \"2\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\"\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "To achieve this, we will join the 'departments' table with the 'employees' table using the 'DEPARTMENT_ID' as the linking key.", "We will select the 'DEPARTMENT_NAME' from the 'departments' table and use the COUNT function to count the number of employees from the 'employees' table.", "We will use a LEFT JOIN to ensure that departments with no employees are still included in the results, showing a count of zero.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count of employees for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n    \"1\": \"This virtual table provides a count of employees grouped by their respective department names from the 'departments' table. The placeholder in the SELECT statement allows for the retrieval of department names, while the COUNT function aggregates the number of employees in each department.\",\n    \"2\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["We need to retrieve the names of departments and the count of employees in each department.", "To achieve this, we will join the 'departments' table with the 'employees' table using the 'DEPARTMENT_ID' as the linking key.", "We will use a LEFT JOIN to ensure that we include all departments, even those without employees.", "We will select the 'DEPARTMENT_NAME' from the 'departments' table and use the COUNT function to count the number of employees in each department.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count of employees for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS EMPLOYEE_COUNT\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n    \"1\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n    \"2\": \"This virtual table provides a count of employees grouped by their respective department names from the 'departments' table. The placeholder in the SELECT statement allows for the retrieval of department names, while the COUNT function aggregates the number of employees in each department.\"\n}\n"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["Identify the tables needed: employees, departments, and locations.", "We need to join the employees table with the departments table to get department information, and then join with the locations table to filter by city.", "The join condition is based on the DEPARTMENT_ID in employees and departments, and LOCATION_ID in departments and locations.", "We need to select the FIRST_NAME, LAST_NAME, and SALARY from the employees table.", "The WHERE clause will filter the results to only include those employees whose department is located in London."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n    \"1\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\",\n    \"2\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\"\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the tables needed: employees, departments, and locations.", "We need to retrieve the first name and last name of employees, which are in the employees table.", "To get the full name, we will concatenate the first and last names.", "We also need the salary of the employees, which is in the employees table.", "To filter employees based on the city, we need to join the locations table with the departments table, as departments have location IDs.", "Join the employees table with the departments table on DEPARTMENT_ID, and then join the departments table with the locations table on LOCATION_ID.", "Finally, apply a WHERE clause to filter results where the city is 'London'."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n    \"1\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.\",\n    \"2\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\"\n}\n"}
{"sample_id": "train.3532", "db_id": "music_1", "question": "Find the id of the song that lasts the longest.", "rationale": ["Identify the table that contains the song information, which is the 'song' table.", "To find the song that lasts the longest, we need to sort the songs by their duration in descending order.", "We will select the 'f_id' of the song, which is the unique identifier for the file associated with the song.", "Using 'ORDER BY duration DESC' will arrange the songs from longest to shortest duration.", "Finally, we will limit the results to 1 to get only the longest song."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT f_id FROM song ORDER BY duration DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n    \"1\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\"\n}\n"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their duration and the artist's name.", "Determine the requirement: We need to find the names of artists who sang the shortest song, which means we need to find the minimum duration of songs.", "Construct a subquery to find the shortest song duration: Use a subquery to select the minimum duration from the 'song' table.", "Use the result of the subquery to filter the main query: Select the artist names from the 'song' table where the duration matches the minimum duration found in the subquery."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "pred_sql": "SELECT artist_name FROM song WHERE duration = (SELECT MIN(duration) FROM song);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n    \"1\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n    \"2\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\"\n}\n"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["Identify the relevant table: The 'song' table contains the duration of songs.", "Determine the condition: We need to find songs with a duration of 4 minutes, which is represented as '4:00'.", "Construct the SQL query: Use the COUNT function to count the number of records in the 'song' table that meet the duration condition."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "pred_sql": "SELECT COUNT(*) FROM song WHERE duration = '4:00';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n    \"1\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\"\n}\n"}
{"sample_id": "train.3549", "db_id": "music_1", "question": "What is the average rating of songs produced by female artists?", "rationale": ["Identify the tables involved: We need to get the average rating of songs, which involves the 'song' table for ratings and the 'artist' table for gender.", "Determine the relationship: The 'song' table has a foreign key relationship with the 'artist' table through the 'artist_name' column.", "Filter the results: We need to filter the artists to only include female artists, which is done using a WHERE clause on the 'gender' column of the 'artist' table.", "Calculate the average: Use the AVG() function to calculate the average rating from the 'song' table, ensuring to join it with the 'artist' table to apply the gender filter."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "pred_sql": "SELECT AVG(song.rating) AS average_rating\nFROM song\nJOIN artist ON song.artist_name = artist.artist_name\nWHERE artist.gender = 'female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["Identify the table that contains the file formats, which is the 'files' table.", "To find the most used file format, we need to count the occurrences of each format.", "Use the COUNT() function to count the number of files for each format.", "Group the results by the 'formats' column to aggregate the counts for each format.", "Order the results in descending order based on the count of files to get the most used format at the top.", "Limit the results to 1 to get only the most used file format."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(*) as file_count \nFROM files \nGROUP BY formats \nORDER BY file_count DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3556", "db_id": "music_1", "question": "What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?", "rationale": ["Identify the table that contains the file information, which is the 'files' table.", "Determine the columns needed for the query: we need 'f_id' to get the file IDs, and we need to filter based on 'formats' and 'resolution'.", "The condition for 'formats' is that it should contain 'mp4', which can be checked using the LIKE operator.", "The condition for 'resolution' is that it should be less than 1000.", "Combine these conditions in the WHERE clause to filter the results accordingly."], "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"], "pred_sql": "SELECT f_id FROM files WHERE formats LIKE '%mp4%' AND resolution < 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n    \"1\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\"\n}\n"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["Identify the main requirement: We need to find the country of origin of female artists who produced songs in Bangla.", "Start with the 'artist' table to filter for female artists. We will use the 'gender' column for this.", "Next, we need to check which of these female artists have produced songs in Bangla. This requires us to look at the 'song' table.", "We can use a subquery to find the 'artist_name' from the 'song' table where the 'languages' column contains 'Bangla'.", "Finally, we will combine these two pieces of information: the country of the female artists and the condition that they have produced songs in Bangla. We will use an IN clause to filter the artist names accordingly."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT country FROM artist WHERE gender = 'female' AND artist_name IN (SELECT artist_name FROM song WHERE languages LIKE '%Bangla%');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n    \"1\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n    \"2\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\"\n}\n"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["Identify the relevant tables: We need information from the 'artist' table for artist details and the 'song' table for song details.", "We are interested in female artists, so we will filter the 'artist' table by gender.", "We need to find songs that are sung in the Bangla language, so we will filter the 'song' table by the 'languages' column.", "To get the countries of the female artists who have sung in Bangla, we will join the 'artist' and 'song' tables on the 'artist_name' column.", "We will select distinct countries to avoid duplicates in the results."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT DISTINCT artist.country \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE artist.gender = 'female' AND song.languages LIKE '%Bangla%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n    \"1\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["Identify the tables involved: We need information from the 'artist' table for gender and name, and from the 'song' table for resolution.", "We need to find the song with the smallest resolution, which requires a subquery to get the minimum resolution from the 'song' table.", "Join the 'artist' table with the 'song' table on the artist's name to get the corresponding artist's gender and name for the song with the smallest resolution.", "Construct the final SQL query to select the artist's gender and name where the song's resolution matches the minimum resolution found in the subquery."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.gender, artist.artist_name \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.resolution = (SELECT MIN(resolution) FROM song);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n    \"1\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n    \"2\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3567", "db_id": "music_1", "question": "For each file format, return the number of artists who released songs in that format.", "rationale": ["We need to count the number of distinct artists for each file format.", "The relevant tables are 'files' and 'song' since we need to access the file formats and the artists associated with the songs.", "We will join the 'files' table with the 'song' table on the 'f_id' column to link songs to their respective files.", "We will select the 'formats' from the 'files' table and count the distinct 'artist_name' from the 'song' table.", "Finally, we will group the results by 'formats' to get the count of artists for each format."], "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(DISTINCT artist_name) AS artist_count\nFROM files\nJOIN song ON files.f_id = song.f_id\nGROUP BY formats;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3576", "db_id": "music_1", "question": "What are the names and genders of all artists who released songs in the month of March?", "rationale": ["Identify the tables needed: We need data from the 'artist' table for names and genders, and the 'song' table for release dates.", "Determine the relationship between the tables: The 'artist' table can be joined with the 'song' table on the 'artist_name' column.", "Filter the songs released in March: Use the strftime function to extract the month from the 'releasedate' column and check if it equals '03'.", "Select the required columns: We need to select 'artist_name' and 'gender' from the 'artist' table."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.gender \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE strftime('%m', song.releasedate) = '03';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n    \"1\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["The question asks for the languages used most often in songs, which implies we need to count occurrences of each language in the 'song' table.", "We will select the 'languages' column from the 'song' table and count how many times each language appears.", "To get the most common languages, we will group the results by the 'languages' column.", "Finally, we will order the results in descending order based on the count of occurrences to show the most used languages first."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "pred_sql": "SELECT languages, COUNT(*) as language_count \nFROM song \nGROUP BY languages \nORDER BY language_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n    \"1\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\"\n}\n"}
{"sample_id": "train.3590", "db_id": "music_1", "question": "What are the names of all male British artists?", "rationale": ["Identify the relevant table: The 'artist' table contains information about artists, including their names, countries, and genders.", "Determine the conditions: We need to filter artists based on two conditions: they must be from Britain and they must be male.", "Construct the SQL query: Use a SELECT statement to retrieve the 'artist_name' from the 'artist' table where the 'country' is 'Britain' and the 'gender' is 'male'."], "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"], "pred_sql": "SELECT artist_name FROM artist WHERE country = 'Britain' AND gender = 'male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3598", "db_id": "music_1", "question": "What is the average rating and resolution of all bangla songs?", "rationale": ["Identify the relevant table: The 'song' table contains the information about songs, including their ratings and resolutions.", "Determine the specific genre: The question asks for Bangla songs, so we will filter the results based on the genre_is column.", "Calculate the average rating and resolution: We will use the AVG() function to compute the average of the rating and resolution columns for the filtered results.", "Construct the SQL query: Combine the SELECT statement with the AVG() functions and the WHERE clause to filter for Bangla songs."], "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"], "pred_sql": "SELECT AVG(rating) AS average_rating, AVG(resolution) AS average_resolution \nFROM song \nWHERE genre_is = 'Bangla';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n    \"1\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3599", "db_id": "music_1", "question": "What are the maximum and minimum resolution of songs whose duration is 3 minutes?", "rationale": ["Identify the relevant table: The 'song' table contains the resolution and duration of songs.", "Determine the required fields: We need the maximum and minimum resolution of songs.", "Apply the condition: We need to filter songs where the duration is exactly 3 minutes.", "Construct the SQL query: Use the MAX() and MIN() functions to get the required resolutions and filter by duration."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "pred_sql": "SELECT MAX(resolution) AS max_resolution, MIN(resolution) AS min_resolution \nFROM song \nWHERE duration = '3 minutes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n    \"1\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["Identify the relevant columns needed for the query: 'duration', 'resolution', and 'languages'.", "Use the MAX() function to find the maximum duration and resolution for each language.", "Group the results by 'languages' to aggregate the data accordingly.", "Order the results by 'languages' to present them in a structured manner."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "pred_sql": "SELECT languages, MAX(duration) AS max_duration, MAX(resolution) AS max_resolution\nFROM song\nGROUP BY languages\nORDER BY languages;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n    \"1\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\"\n}\n"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["Identify the relevant tables: 'song' and 'genre'.", "We need to find the shortest duration and lowest rating of songs, so we will use the MIN() function on the 'duration' and 'rating' columns from the 'song' table.", "To group the results by genre, we will use the GROUP BY clause on the 'g_name' column from the 'genre' table.", "We need to join the 'song' table with the 'genre' table on the genre column to get the genre names associated with the songs.", "Finally, we will order the results by genre name using the ORDER BY clause."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "pred_sql": "SELECT genre.g_name, MIN(song.duration) AS shortest_duration, MIN(song.rating) AS lowest_rating\nFROM song\nJOIN genre ON song.genre_is = genre.g_name\nGROUP BY genre.g_name\nORDER BY genre.g_name;", "hint": "\n"}
{"sample_id": "train.3607", "db_id": "music_1", "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "rationale": ["We need to find the name and country of origin for all artists who have released at least one song with a resolution above 900.", "To do this, we will join the 'artist' table with the 'song' table on the 'artist_name' column, as this will allow us to access both the artist's information and the songs they have released.", "We will use a SELECT statement to retrieve the distinct artist names and their corresponding countries from the joined tables.", "The WHERE clause will filter the results to include only those songs where the resolution is greater than 900."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"], "pred_sql": "SELECT DISTINCT artist.artist_name, artist.country \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.resolution > 900;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n    \"1\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n    \"2\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3619", "db_id": "music_1", "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their languages and associated artists.", "Filter songs by language: We need to filter the songs to only include those that have 'Bangla' in their 'languages' column.", "Count the number of songs per artist: We will group the results by 'artist_name' and count the number of songs for each artist.", "Order the results: We will order the results in descending order based on the count of songs to get the top artists.", "Limit the results: Finally, we will limit the results to the top 3 artists."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist_name, COUNT(song_name) AS song_count \nFROM song \nWHERE languages LIKE '%Bangla%' \nGROUP BY artist_name \nORDER BY song_count DESC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n    \"1\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n    \"2\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3623", "db_id": "music_1", "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?", "rationale": ["Identify the columns needed: duration, file size, and format of songs.", "Determine the relevant tables: 'song' for song details and 'files' for file details.", "Establish the relationship between the tables: 'song' and 'files' are linked by the 'f_id' column.", "Filter the results to include only songs of the genre 'pop'.", "Order the results by the song title, which corresponds to the 'song_name' column in the 'song' table."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT s.duration, f.file_size, f.formats \nFROM song s \nJOIN files f ON s.f_id = f.f_id \nWHERE s.genre_is = 'pop' \nORDER BY s.song_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "We need to select the duration, file size, and formats, which are in the 'song' and 'files' tables.", "Join the 'song' table with the 'files' table on the foreign key 'f_id' to access file details for each song.", "Filter the results to include only those songs that belong to the 'pop' genre.", "Order the final results by the song title in alphabetical order."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT song.duration, files.file_size, files.formats \nFROM song \nJOIN files ON song.f_id = files.f_id \nWHERE song.genre_is = 'pop' \nORDER BY song.song_name ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["Identify the relevant tables: salary and team.", "We need to calculate the average salary, so we will use the AVG() function on the salary column from the salary table.", "To find the salary of players in a specific team, we need to join the salary table with the team table on the team_id column.", "Filter the results to only include players from the team named 'Boston Red Stockings'.", "Construct the SQL query using the SELECT statement to get the average salary."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "pred_sql": "SELECT AVG(s.salary) AS average_salary\nFROM salary s\nJOIN team t ON s.team_id = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\"\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["We need to find the countries with the least number of players.", "To do this, we will select the 'birth_country' from the 'player' table.", "We will count the number of players from each country using COUNT(player_id).", "We will group the results by 'birth_country' to get the count for each country.", "To find the least populated countries, we will order the results in ascending order based on the count of players.", "Finally, we will limit the results to the top 3 countries using LIMIT 3."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count \nFROM player \nGROUP BY birth_country \nORDER BY player_count ASC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of countries where players were born, grouped by country and ordered by the number of players from each country in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of countries to return.\"\n}\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["We need to find the highest salary for each team, which requires joining the 'salary' table with the 'team' table to get team names and IDs.", "The 'salary' table contains the salary information, and the 'team' table contains the team names and IDs.", "To get the maximum salary for each team, we will use the MAX() function on the salary column.", "We will group the results by team ID and team name to ensure we get the maximum salary for each team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nGROUP BY team.team_id, team.name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\"\n}\n"}
{"sample_id": "train.3658", "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["We need to retrieve the team name, team id, and the maximum salary for each team.", "The relevant tables for this query are 'team' and 'salary'.", "We will join the 'team' table with the 'salary' table on the 'team_id' column, as this is the common identifier between the two tables.", "To get the maximum salary for each team, we will use the MAX() function on the 'salary' column from the 'salary' table.", "We will group the results by 'team.team_id' and 'team.name' to ensure we get one result per team with the maximum salary."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM team\nJOIN salary ON team.team_id = salary.team_id\nGROUP BY team.team_id, team.name;", "hint": "\n"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["Identify the relevant tables: 'team' for team names and IDs, and 'salary' for salary information.", "Join the 'team' table with the 'salary' table on 'team_id' to associate teams with their salaries.", "Group the results by 'team_id' to calculate the average salary for each team.", "Use the AVG() function to compute the average salary for each team.", "Order the results in ascending order based on the average salary to find the lowest.", "Limit the results to 1 to get only the team with the lowest average salary."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id\nFROM team\nJOIN salary ON team.team_id = salary.team_id\nGROUP BY team.team_id\nORDER BY AVG(salary.salary) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["We need to find players who won awards in both 1960 and 1961.", "To do this, we will join the 'player' table with the 'player_award' table twice: once for the year 1960 and once for the year 1961.", "The join condition will be based on the player_id, which is the unique identifier for each player.", "We will select the first name and last name of the players from the 'player' table.", "Finally, we will filter the results to include only those players who have awards in both specified years."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.name_first, p.name_last\nFROM player p\nJOIN player_award pa1 ON p.player_id = pa1.player_id\nJOIN player_award pa2 ON p.player_id = pa2.player_id\nWHERE pa1.year = 1960 AND pa2.year = 1961;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n    \"1\": \"This virtual table describes the first and last names of players from the 'player' table who have a specified year of death. The placeholder in the WHERE clause represents the year of death.\"\n}\n"}
{"sample_id": "train.3663", "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["Identify the relevant table: The 'player' table contains the first name, last name, weight, and height of players.", "Determine the conditions: We need players with a weight greater than 220 or a height shorter than 75.", "Construct the SQL query: Use a SELECT statement to retrieve 'name_first' and 'name_last' from the 'player' table, applying the specified conditions in the WHERE clause."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players from the 'player' table who have a specified year of death. The placeholder in the WHERE clause represents the year of death.\",\n    \"1\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\"\n}\n"}
{"sample_id": "train.3664", "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["Identify the relevant table: The 'player' table contains the first name, last name, weight, and height of players.", "Determine the columns needed: We need 'name_first' and 'name_last' for the player's names.", "Establish the conditions: We want players with a weight greater than 220 or a height less than 75.", "Construct the SQL query: Use a SELECT statement to retrieve the names from the 'player' table where the specified conditions are met."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n    \"1\": \"This virtual table describes the first and last names of players from the 'player' table who have a specified year of death. The placeholder in the WHERE clause represents the year of death.\"\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) of the Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings'", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n    \"1\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n    \"2\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\"\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) for the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n    \"1\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n    \"2\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\"\n}\n"}
{"sample_id": "train.3672", "db_id": "baseball_1", "question": "For each year, return the year and the number of times the team Boston Red Stockings won in the postseasons.", "rationale": ["Identify the relevant table for postseason results, which is the 'postseason' table.", "Determine the condition for counting wins, which is when the 'team_id_winner' matches the team ID for 'Boston Red Stockings'.", "Use a subquery to find the 'team_id' for 'Boston Red Stockings' from the 'team' table.", "Group the results by 'year' to get the count of wins for each year.", "Select the 'year' and the count of wins as the final output."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "pred_sql": "SELECT year, COUNT(*) AS wins\nFROM postseason\nWHERE team_id_winner = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')\nGROUP BY year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n    \"1\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n    \"2\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\"\n}\n"}
{"sample_id": "train.3677", "db_id": "baseball_1", "question": "What is the total salary paid by team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant tables: 'salary' for salary data and 'team' for team identification.", "We need to sum the salaries, so we will use the SUM() function on the 'salary' column.", "To find the total salary for the Boston Red Stockings, we need to join the 'salary' table with the 'team' table on 'team_id'.", "We will filter the results to only include records where the team name is 'Boston Red Stockings' and the year is 2010."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT SUM(salary) AS total_salary\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nWHERE team.name = 'Boston Red Stockings' AND salary.year = 2010;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\",\n    \"1\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n    \"2\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\"\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant table: The 'salary' table contains the salary information for players.", "Filter the data: We need to focus on the year 2001, so we will use a WHERE clause to filter the records for that year.", "Sort the results: To find the highest salaries, we will order the results by the 'salary' column in descending order.", "Limit the results: We only want the top 3 salaries, so we will use the LIMIT clause to restrict the output to 3 records."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3682", "db_id": "baseball_1", "question": "How much salary did the top 3 well-paid players get in 2001?", "rationale": ["Identify the relevant table: The salary table contains the salary information for players.", "Filter by year: We need to focus on the year 2001, so we will add a WHERE clause to filter the records for that year.", "Sort the results: To find the top 3 well-paid players, we will order the results by salary in descending order.", "Limit the results: We will use LIMIT 3 to get only the top 3 players based on their salary."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\"\n}\n"}
{"sample_id": "train.3683", "db_id": "baseball_1", "question": "What were all the salary values of players in 2010 and 2001?", "rationale": ["Identify the relevant table: The salary table contains the salary values for players along with the year of the salary record.", "Determine the years of interest: The user is interested in the salary values for the years 2010 and 2001.", "Construct the SQL query: Use a SELECT statement to retrieve the salary column from the salary table where the year is either 2010 or 2001."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT salary FROM salary WHERE year IN (2010, 2001);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n    \"1\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n    \"2\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\"\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["To find the year with the least number of players inducted into the Hall of Fame, we need to count the number of players for each year.", "We will use the `hall_of_fame` table, which contains the `yearid` (year of induction) and `player_id` (unique identifier for each player).", "We will group the results by `yearid` to aggregate the count of players inducted for each year using the COUNT function.", "Next, we will order the results in ascending order based on the count of inductees to find the year with the least number of inductees.", "Finally, we will limit the results to 1 to get only the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(player_id) AS inductee_count \nFROM hall_of_fame \nGROUP BY yearid \nORDER BY inductee_count ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n    \"1\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n    \"2\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\"\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["To find the year with the least number of players inducted into the Hall of Fame, we need to count the number of players for each year.", "We will use the 'hall_of_fame' table, which contains the 'yearid' for the induction year and 'player_id' for the players inducted.", "We will group the results by 'yearid' to aggregate the count of players for each year.", "Next, we will order the results by the count of players in ascending order to get the year with the least inductees at the top.", "Finally, we will limit the results to 1 to get only the year with the least number of inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY COUNT(player_id) ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n    \"1\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n    \"2\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\"\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: 'home_game' for games played and 'park' for park names.", "Filter the 'home_game' table for the year 1907.", "Join the 'home_game' table with the 'park' table to find the team_id associated with 'Columbia Park'.", "Sum the total number of games played in 'Columbia Park' for the year 1907."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nWHERE year = 1907 AND team_id IN (\n    SELECT team_id\n    FROM park\n    WHERE park_name = 'Columbia Park'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n    \"1\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n    \"2\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\"\n}\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: 'home_game' for home games and 'park' for park details.", "We need to count the number of games played in 'Columbia Park' in the year 1907.", "First, we will find the 'team_id' associated with 'Columbia Park' from the 'park' table.", "Then, we will filter the 'home_game' table for the year 1907 and the 'team_id' obtained from the previous step.", "Finally, we will sum the 'games' column from the filtered 'home_game' records to get the total number of games played."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nWHERE year = 1907 AND team_id IN (\n    SELECT team_id\n    FROM park\n    WHERE park_name = 'Columbia Park'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n    \"1\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n    \"2\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\"\n}\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant table for home games, which is 'home_game'.", "We need to sum the total number of games played in the year 2000, so we will use the SUM function on the 'games' column.", "We need to filter the results for the year 2000, so we will add a WHERE clause for 'year = 2000'.", "To find the teams that played in Atlanta, we will need to join the 'team' table to get the 'team_id' for teams located in Atlanta.", "We will use a subquery to select 'team_id' from the 'team' table where the city is 'Atlanta'.", "Finally, we will filter the 'home_game' records to only include those teams that are in Atlanta."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nWHERE year = 2000 AND team_id IN (\n    SELECT team_id\n    FROM team\n    WHERE city = 'Atlanta'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n    \"1\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n    \"2\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\"\n}\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant table for home games, which is 'home_game'.", "We need to filter the results for the year 2000, so we will use a WHERE clause for the year.", "To find games specifically in Atlanta, we need to join or filter by the team associated with Atlanta. We can do this by using a subquery to get the team_id for Atlanta from the 'team' table.", "We will sum the 'games' column to get the total number of games played in Atlanta in 2000."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nWHERE year = 2000 AND team_id IN (\n    SELECT team_id\n    FROM team\n    WHERE name = 'Atlanta'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n    \"1\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n    \"2\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\"\n}\n"}
{"sample_id": "train.3693", "db_id": "baseball_1", "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?", "rationale": ["Identify the relevant table for home game attendance, which is 'home_game'.", "Determine the columns needed: 'attendance' for total attendance and 'year' to filter the years from 2000 to 2010.", "Use a subquery to find the 'team_id' for 'Boston Red Stockings' from the 'team' table.", "Filter the records in 'home_game' by the 'team_id' and the specified year range (2000 to 2010).", "Use the SUM function to calculate the total attendance for the specified team and years."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT SUM(attendance) AS total_attendance \nFROM home_game \nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings') \nAND year BETWEEN 2000 AND 2010;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n    \"1\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\",\n    \"2\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\"\n}\n"}
{"sample_id": "train.3698", "db_id": "baseball_1", "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?", "rationale": ["Identify the relevant tables: 'player' for player names and 'salary' for salary records.", "Join the 'player' table with the 'salary' table on 'player_id' to get player names along with their salary records.", "Filter the results to include only those records where the team is 'Washington Nationals'.", "Use a subquery to find the 'team_id' for 'Washington Nationals'.", "Filter the salary records to include only the years 2005 and 2007.", "Group the results by 'player_id' to aggregate the data for each player.", "Use HAVING clause to ensure that only players who have salary records for both years (count of distinct years = 2) are included."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT p.name_first, p.name_last \nFROM player p \nJOIN salary s ON p.player_id = s.player_id \nWHERE s.team_id = (SELECT team_id FROM team WHERE name = 'Washington Nationals') \nAND s.year IN (2005, 2007) \nGROUP BY p.player_id \nHAVING COUNT(DISTINCT s.year) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n    \"1\": \"This virtual table describes the first and last names of players from the 'player' table who have a specified year of death. The placeholder in the WHERE clause represents the year of death.\"\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant table: home_game, which contains data about home games played by teams.", "We need to find the team with the least number of home games in the year 1980.", "Use a SELECT statement to retrieve the team_id and the number of games from the home_game table.", "Filter the results to only include records from the year 1980 using a WHERE clause.", "Order the results in ascending order based on the number of games played using ORDER BY games ASC.", "Limit the results to only the first record using LIMIT 1 to get the team with the least number of home games."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, games FROM home_game WHERE year = 1980 ORDER BY games ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n    \"1\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n    \"2\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\"\n}\n"}
{"sample_id": "train.3709", "db_id": "baseball_1", "question": "Which park had most attendances in 2008?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'park' for park names.", "Join the 'home_game' table with the 'park' table on the 'park_id' to get park names along with their attendance.", "Filter the results to only include records from the year 2008.", "Order the results by attendance in descending order to find the park with the highest attendance.", "Limit the results to 1 to get only the park with the most attendance."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT park.park_name, home_game.attendance \nFROM home_game \nJOIN park ON home_game.park_id = park.park_id \nWHERE home_game.year = 2008 \nORDER BY home_game.attendance DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n    \"1\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n    \"2\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\"\n}\n"}
{"sample_id": "train.3857", "db_id": "insurance_policies", "question": "Find the settlement amount of the claim with the largest claim amount. Show both the settlement amount and claim amount.", "rationale": ["Identify the tables involved: Claims and Settlements.", "We need to find the claim with the largest claim amount, so we will focus on the Amount_Claimed from the Claims table.", "We also need the corresponding settlement amount, which is in the Settlements table as Amount_Settled.", "To get the required data, we will perform a JOIN between the Claims and Settlements tables on Claim_ID.", "We will order the results by Amount_Claimed in descending order to get the largest claim amount first.", "Finally, we will limit the results to 1 to get only the top record."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"], "pred_sql": "SELECT c.Amount_Claimed, s.Amount_Settled\nFROM Claims c\nJOIN Settlements s ON c.Claim_ID = s.Claim_ID\nORDER BY c.Amount_Claimed DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n    \"1\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n    \"2\": \"This virtual table provides a summary of the amounts claimed and settled for insurance claims from the 'Claims' table. The results are ordered by the claimed amount in descending order, and the placeholder allows for limiting the number of records returned.\"\n}\n"}
{"sample_id": "train.3862", "db_id": "insurance_policies", "question": "Among all the claims, which settlements have a claimed amount that is no more than the average? List the claim start date.", "rationale": ["Identify the relevant tables: Claims and Settlements are needed to get the claim details and the corresponding settlement amounts.", "Join the Claims table with the Settlements table on Claim_ID to link claims with their settlements.", "Use a subquery to calculate the average claimed amount from the Settlements table.", "Filter the results to include only those settlements where the claimed amount is less than or equal to the average claimed amount.", "Select the Date_Claim_Made from the Claims table to list the claim start date along with the claimed amount."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT c.Date_Claim_Made, s.Amount_Claimed \nFROM Claims c \nJOIN Settlements s ON c.Claim_ID = s.Claim_ID \nWHERE s.Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Settlements)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n    \"1\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n    \"2\": \"This virtual table provides a summary of the amounts claimed and settled for insurance claims from the 'Claims' table. The results are ordered by the claimed amount in descending order, and the placeholder allows for limiting the number of records returned.\"\n}\n"}
{"sample_id": "train.3863", "db_id": "insurance_policies", "question": "Return the claim start date for the claims whose claimed amount is no more than the average", "rationale": ["Identify the relevant table: The 'Claims' table contains the information about claims, including the claimed amount and the date the claim was made.", "Determine the condition: We need to find claims where the claimed amount is no more than the average claimed amount. This requires calculating the average of the 'Amount_Claimed' column in the 'Claims' table.", "Construct the subquery: The subquery will calculate the average claimed amount using AVG(Amount_Claimed) FROM Claims.", "Combine the main query and the subquery: The main query will select the 'Date_Claim_Made' from the 'Claims' table where the 'Amount_Claimed' is less than or equal to the average calculated in the subquery."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Claims);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the amounts claimed and settled for insurance claims from the 'Claims' table. The results are ordered by the claimed amount in descending order, and the placeholder allows for limiting the number of records returned.\",\n    \"1\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n    \"2\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\"\n}\n"}
{"sample_id": "train.3868", "db_id": "insurance_policies", "question": "How many settlements were made on the claim with the most recent claim settlement date? List the number and the claim id.", "rationale": ["Identify the most recent claim settlement date from the Claims table using a subquery that selects the maximum Date_Claim_Settled.", "Join the Claims table with the Settlements table on Claim_ID to link settlements to their respective claims.", "Count the number of settlements for the claim that has the most recent settlement date.", "Group the results by Claim_ID to ensure we get the count for that specific claim."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT COUNT(Settlements.Settlement_ID) AS Settlement_Count, Claims.Claim_ID \nFROM Claims \nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID \nWHERE Claims.Date_Claim_Settled = (SELECT MAX(Date_Claim_Settled) FROM Claims) \nGROUP BY Claims.Claim_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of settlements associated with each insurance claim from the 'Claims' table. The placeholder in the SELECT statement represents the unique identifier for each claim, while the count reflects the number of settlements linked to that claim.\",\n    \"1\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n    \"2\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\"\n}\n"}
{"sample_id": "train.3869", "db_id": "insurance_policies", "question": "Find the claim id and the number of settlements made for the claim with the most recent settlement date.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to count the number of settlements for each claim, so we will use a JOIN between Claims and Settlements on Claim_ID.", "To find the claim with the most recent settlement date, we will use a subquery to get the maximum Date_Claim_Settled from the Settlements table.", "We will filter the results of the JOIN to only include those settlements that match the most recent settlement date.", "Finally, we will group the results by Claim_ID and count the number of settlements for each claim."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT Claims.Claim_ID, COUNT(Settlements.Settlement_ID) AS Number_of_Settlements\nFROM Claims\nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID\nWHERE Settlements.Date_Claim_Settled = (\n    SELECT MAX(Date_Claim_Settled)\n    FROM Settlements\n)\nGROUP BY Claims.Claim_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of settlements associated with each insurance claim from the 'Claims' table. The placeholder in the SELECT statement represents the unique identifier for each claim, while the count reflects the number of settlements linked to that claim.\",\n    \"1\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n    \"2\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\"\n}\n"}
{"sample_id": "train.3878", "db_id": "insurance_policies", "question": "What is the most popular payment method?", "rationale": ["To find the most popular payment method, we need to analyze the 'Payments' table.", "We will group the records by 'Payment_Method_Code' to count how many times each payment method has been used.", "Using the COUNT function, we can determine the frequency of each payment method.", "We will order the results in descending order based on the frequency to get the most popular method at the top.", "Finally, we will limit the results to 1 to get only the most popular payment method."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Frequency\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.\"\n}\n"}
{"sample_id": "train.3879", "db_id": "insurance_policies", "question": "Which payment method is used the most often?", "rationale": ["Identify the table that contains payment methods, which is the 'Payments' table.", "To find the most frequently used payment method, we need to count the occurrences of each 'Payment_Method_Code'.", "We will use the COUNT() function to count the number of times each payment method appears in the 'Payments' table.", "We will group the results by 'Payment_Method_Code' to aggregate the counts for each method.", "To get the most often used payment method, we will order the results by the count in descending order.", "Finally, we will limit the results to 1 to get only the most frequently used payment method."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Frequency\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.\"\n}\n"}
{"sample_id": "train.3880", "db_id": "insurance_policies", "question": "With which kind of payment method were the least number of payments processed?", "rationale": ["We need to find the payment method with the least number of payments processed.", "To do this, we will query the Payments table.", "We will group the results by Payment_Method_Code to count the number of payments for each method.", "We will use the COUNT function to count the number of Payment_IDs for each payment method.", "To find the least used payment method, we will order the results in ascending order based on the count of payments.", "Finally, we will limit the results to 1 to get only the payment method with the least number of payments."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(Payment_ID) AS Payment_Count \nFROM Payments \nGROUP BY Payment_Method_Code \nORDER BY Payment_Count ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.\"\n}\n"}
{"sample_id": "train.3886", "db_id": "insurance_policies", "question": "Which kind of policy type was chosen by the most customers?", "rationale": ["Identify the relevant table: The 'Customer_Policies' table contains the 'Policy_Type_Code' and 'Customer_ID' which are needed to determine the policy types chosen by customers.", "Group by policy type: To find out how many customers chose each policy type, we need to group the results by 'Policy_Type_Code'.", "Count the customers: Use COUNT(Customer_ID) to count the number of customers for each policy type.", "Order the results: We want to order the results in descending order based on the count of customers to find the most popular policy type.", "Limit the results: Since we only want the most chosen policy type, we will limit the results to 1."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(Customer_ID) AS Customer_Count\nFROM Customer_Policies\nGROUP BY Policy_Type_Code\nORDER BY Customer_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies from the 'Customer_Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.\"\n}\n"}
{"sample_id": "train.3893", "db_id": "insurance_policies", "question": "Which customers do not have any policies? Find the details of these customers.", "rationale": ["Identify the Customers table to retrieve customer details.", "Determine the criteria for customers without policies, which means their Customer_ID should not exist in the Customer_Policies table.", "Use a subquery to select Customer_IDs from the Customer_Policies table.", "Use the NOT IN clause to filter out customers who have policies from the Customers table."], "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"], "pred_sql": "SELECT * FROM Customers WHERE Customer_ID NOT IN (SELECT Customer_ID FROM Customer_Policies);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies from the 'Customer_Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.\"\n}\n"}
{"sample_id": "train.3895", "db_id": "insurance_policies", "question": "Which claims had exactly one settlement? For each, tell me the the date the claim was made, the date it was settled and the amount settled.", "rationale": ["We need to find claims that had exactly one settlement.", "To do this, we will join the Claims table with the Settlements table on the Claim_ID.", "We will select the Date_Claim_Made and Date_Claim_Settled from the Claims table, and Amount_Settled from the Settlements table.", "We will group the results by Claim_ID to aggregate the settlements for each claim.", "Finally, we will use the HAVING clause to filter the groups to only those with a count of settlements equal to one."], "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT c.Date_Claim_Made, c.Date_Claim_Settled, s.Amount_Settled \nFROM Claims c \nJOIN Settlements s ON c.Claim_ID = s.Claim_ID \nGROUP BY c.Claim_ID \nHAVING COUNT(s.Settlement_ID) = 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of settlements associated with each insurance claim from the 'Claims' table. The placeholder in the SELECT statement represents the unique identifier for each claim, while the count reflects the number of settlements linked to that claim.\",\n    \"1\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n    \"2\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\"\n}\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to count the number of employees (physicians) in each department.", "Join the Department table with the Physician table on the Head of the department.", "Group the results by department to get the count of physicians in each department.", "Order the results by the count of physicians in descending order to find the department with the most employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT d.Name, COUNT(p.EmployeeID) AS EmployeeCount\nFROM Department d\nLEFT JOIN Physician p ON d.Head = p.EmployeeID\nGROUP BY d.DepartmentID\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["We need to find the department with the most employees, which involves counting the number of physicians in each department.", "The 'Department' table contains department information, and the 'Physician' table contains physician information.", "To find the number of employees in each department, we can join the 'Department' table with the 'Physician' table on the condition that the department head is a physician.", "We will group the results by department ID to count the number of physicians in each department.", "We will order the results by the count of physicians in descending order to get the department with the most employees at the top.", "Finally, we will limit the results to just one department to get the one with the most employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Physician.EmployeeID) AS EmployeeCount\nFROM Department\nJOIN Physician ON Department.Head = Physician.EmployeeID\nGROUP BY Department.DepartmentID\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3901", "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["Identify the department with the least employees by counting the number of physicians affiliated with each department.", "Use a subquery to group the 'Affiliated_With' table by 'DepartmentID' and count the number of physicians in each department.", "Order the results of the subquery in ascending order based on the count of physicians to find the department with the least employees.", "Limit the subquery result to 1 to get the department ID with the least employees.", "Use the department ID obtained from the subquery to select the 'Head' from the 'Department' table."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Head FROM Department WHERE DepartmentID = (SELECT DepartmentID FROM Affiliated_With GROUP BY DepartmentID ORDER BY COUNT(Physician) ASC LIMIT 1)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["Identify the head of each department from the 'Department' table, which includes the 'Head' column that references 'Physician.EmployeeID'.", "Join the 'Department' table with the 'Physician' table to get the names and positions of the department heads.", "Group the results by 'Department.DepartmentID' to count the number of employees in each department.", "Order the results by the count of employees in ascending order to find the department with the least number of employees.", "Limit the results to 1 to get only the head of the department with the least number of employees."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Department \nJOIN Physician ON Department.Head = Physician.EmployeeID \nGROUP BY Department.DepartmentID \nORDER BY COUNT(Physician.EmployeeID) ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3903", "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["Identify the head of each department by joining the 'Department' table with the 'Physician' table on the 'Head' column.", "To find the department with the least employees, we need to count the number of physicians affiliated with each department using the 'Affiliated_With' table.", "Group the results by 'DepartmentID' and order them in ascending order based on the count of physicians to find the department with the least employees.", "Use a subquery to get the 'DepartmentID' of the department with the least employees, and use this in the main query to get the head of that department.", "Select the 'Name' and 'Position' of the physician who is the head of the identified department."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Department \nJOIN Physician ON Department.Head = Physician.EmployeeID \nWHERE Department.DepartmentID = \n    (SELECT DepartmentID \n     FROM Affiliated_With \n     GROUP BY DepartmentID \n     ORDER BY COUNT(Physician) ASC \n     LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["Identify the relevant tables: Patient and Appointment.", "We need to find the names of patients who have made appointments, which means we need to join the Patient table with the Appointment table.", "The common field between these two tables is Patient.SSN and Appointment.Patient.", "Use a SELECT statement to retrieve the names from the Patient table.", "Use DISTINCT to ensure that we only get unique patient names in case a patient has multiple appointments."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT Patient.Name \nFROM Patient \nJOIN Appointment ON Patient.SSN = Appointment.Patient;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n    \"1\": \"This virtual table provides a list of nurses who are on call, filtered by specific block floor and block code statuses. The placeholders in the WHERE clause represent the identifiers for the blocked floor and blocked code statuses.\"\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["Identify the tables needed: Physician, Department, and Affiliated_With.", "We need to get the names of physicians, which are in the Physician table, and the names of departments, which are in the Department table.", "The Affiliated_With table links physicians to their departments and indicates whether the affiliation is primary.", "We will perform a JOIN operation between Physician and Affiliated_With on the EmployeeID and Physician columns respectively.", "Next, we will JOIN the result with the Department table on the DepartmentID to get the department names.", "Finally, we will filter the results to include only those records where the affiliation is marked as primary (i.e., 'Yes')."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name, Department.Name \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nJOIN Department ON Affiliated_With.Department = Department.DepartmentID \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n    \"1\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\"\n}\n"}
{"sample_id": "train.3928", "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["We need to find out how many patients each physician takes care of, which involves counting the patients associated with each physician.", "The relevant tables are 'Physician' and 'Patient'.", "The 'Patient' table has a column 'PCP' that indicates the primary care physician for each patient, which links to the 'EmployeeID' in the 'Physician' table.", "We will perform a LEFT JOIN between 'Physician' and 'Patient' on the condition that 'Physician.EmployeeID' matches 'Patient.PCP'.", "To get the count of patients for each physician, we will use the COUNT() function on 'Patient.SSN'.", "We will group the results by 'Physician.Name' to get the count of patients for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name, COUNT(Patient.SSN) AS NumberOfPatients\nFROM Physician\nLEFT JOIN Patient ON Physician.EmployeeID = Patient.PCP\nGROUP BY Physician.Name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\"\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["Identify the relevant tables: Physician and Patient.", "Determine the relationship: A physician can be a primary care physician (PCP) for multiple patients.", "Join the Physician table with the Patient table on the PCP field.", "Group the results by physician to count the number of patients each physician is in charge of.", "Use the HAVING clause to filter for physicians who are in charge of more than one patient."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT p.Name\nFROM Physician p\nJOIN Patient pt ON p.EmployeeID = pt.PCP\nGROUP BY p.EmployeeID\nHAVING COUNT(pt.SSN) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n    \"1\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n    \"2\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\"\n}\n"}
{"sample_id": "train.3940", "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication are needed to find the names of physicians who prescribe a specific medication.", "Join the Physician table with the Prescribes table on the EmployeeID to get the prescriptions made by each physician.", "Join the Prescribes table with the Medication table on the Medication code to filter the prescriptions by the medication name.", "Use a WHERE clause to filter the results to only include prescriptions for the medication 'Thesisin'.", "Select the distinct names of physicians to avoid duplicates in the results."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT DISTINCT Physician.Name \nFROM Physician \nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician \nJOIN Medication ON Prescribes.Medication = Medication.Code \nWHERE Medication.Name = 'Thesisin';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n    \"1\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\"\n}\n"}
{"sample_id": "train.3941", "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication.", "We need to find the names of physicians who prescribe a specific medication, which is 'Thesisin'.", "Join the Physician table with the Prescribes table on the EmployeeID and Physician columns respectively.", "Join the Prescribes table with the Medication table on the Medication code.", "Filter the results to only include records where the medication name is 'Thesisin'.", "Select the Name column from the Physician table to get the names of the physicians."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT Physician.Name \nFROM Physician \nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician \nJOIN Medication ON Prescribes.Medication = Medication.Code \nWHERE Medication.Name = 'Thesisin';", "hint": "\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["Identify the relevant tables: Medication and Prescribes.", "We need to count the number of medications prescribed for each brand, so we will join the Medication table with the Prescribes table on the medication code.", "Select the brand from the Medication table and count the number of prescriptions from the Prescribes table.", "Group the results by the brand to get the count for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT m.Brand, COUNT(p.Medication) AS NumberOfMedications\nFROM Medication m\nJOIN Prescribes p ON m.Code = p.Medication\nGROUP BY m.Brand;", "hint": "\n"}
{"sample_id": "train.3948", "db_id": "hospital_1", "question": "Find the patient who has the most recent undergoing treatment?", "rationale": ["Identify the relevant tables: Undergoes (for treatment details) and Patient (for patient details).", "We need to find the most recent undergoing treatment, which means we should order the results by the DateUndergoes column in descending order.", "To get the patient's details along with the treatment date, we will join the Undergoes table with the Patient table on the Patient's SSN.", "Finally, we will limit the results to 1 to get only the most recent entry."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT Patient.SSN, Patient.Name, Undergoes.DateUndergoes \nFROM Undergoes \nJOIN Patient ON Undergoes.Patient = Patient.SSN \nORDER BY Undergoes.DateUndergoes DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\"\n}\n"}
{"sample_id": "train.3949", "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["Identify the relevant tables: Patient and Undergoes.", "Join the Patient table with the Undergoes table on the Patient's SSN to get the names of patients undergoing treatments.", "Order the results by the DateUndergoes in descending order to get the most recent treatment first.", "Limit the results to 1 to get only the most recent patient undergoing treatment."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT Patient.Name\nFROM Patient\nJOIN Undergoes ON Patient.SSN = Undergoes.Patient\nORDER BY Undergoes.DateUndergoes DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\"\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: Prescribes for prescriptions and Physician for physician details.", "We need to find the physician who prescribed the highest dose, so we will use the MAX function on the Dose column in the Prescribes table.", "To get the physician's name, we will join the Prescribes table with the Physician table on the Physician identifier (EmployeeID).", "The final query will select the name of the physician where the dose is equal to the maximum dose found in the subquery."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT Physician.Name\nFROM Prescribes\nJOIN Physician ON Prescribes.Physician = Physician.EmployeeID\nWHERE Prescribes.Dose = (SELECT MAX(Dose) FROM Prescribes);", "hint": "\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["We need to list the employee IDs of physicians along with their primary affiliation department IDs.", "To achieve this, we will select the 'EmployeeID' from the 'Physician' table and the 'Department' from the 'Affiliated_With' table.", "We will join the 'Physician' table with the 'Affiliated_With' table on the condition that the 'EmployeeID' in 'Physician' matches the 'Physician' in 'Affiliated_With'.", "To filter for only primary affiliations, we will add a WHERE clause that checks if 'PrimaryAffiliation' is equal to 'Yes'."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n    \"1\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\"\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["Identify the table that contains procedure information, which is the Procedures table.", "Determine the relevant columns needed for the query: Name and Cost of the procedures.", "To find the most costly procedures, sort the results by the Cost column in descending order.", "Limit the results to the top three entries to get the three most costly procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "\n"}
{"sample_id": "train.3972", "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find physicians who are trained in specific procedures, so we will join the Physician table with the Trained_In table on the Physician's EmployeeID.", "Next, we join the Trained_In table with the Procedures table on the Treatment code to access the cost of the procedures.", "We need to filter the results to only include procedures that cost more than 5000, so we will add a WHERE clause for Procedures.Cost > 5000.", "Finally, we select the distinct names of the physicians to avoid duplicates."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT DISTINCT Physician.Name\nFROM Physician\nJOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician\nJOIN Procedures ON Trained_In.Treatment = Procedures.Code\nWHERE Procedures.Cost > 5000;", "hint": "\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find the physician who was trained in the most expensive procedure, so we will join the Physician table with the Trained_In table on the physician's identifier.", "Next, we will join the Trained_In table with the Procedures table on the treatment code to access the cost of the procedures.", "To find the most expensive procedure, we will use a subquery to select the maximum cost from the Procedures table.", "Finally, we will filter the results to only include the physician(s) associated with the most expensive procedure and select their names."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT p.Name\nFROM Physician p\nJOIN Trained_In t ON p.EmployeeID = t.Physician\nJOIN Procedures pr ON t.Treatment = pr.Code\nWHERE pr.Cost = (SELECT MAX(Cost) FROM Procedures);", "hint": "\n"}
{"sample_id": "train.3980", "db_id": "hospital_1", "question": "Find all procedures which cost more than 1000 or which physician John Wen was trained in.", "rationale": ["Identify the relevant tables: Procedures and Trained_In, and Physician.", "We need to find procedures that either cost more than 1000 or are associated with the physician named John Wen.", "Use a LEFT JOIN to connect Procedures with Trained_In on the procedure code and then with Physician on the physician's EmployeeID.", "The WHERE clause will filter for procedures with a cost greater than 1000 or those associated with John Wen.", "Select the distinct names of the procedures to avoid duplicates."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT DISTINCT Procedures.Name \nFROM Procedures \nLEFT JOIN Trained_In ON Procedures.Code = Trained_In.Treatment \nLEFT JOIN Physician ON Trained_In.Physician = Physician.EmployeeID \nWHERE Procedures.Cost > 1000 OR Physician.Name = 'John Wen';", "hint": "\n"}
{"sample_id": "train.3993", "db_id": "hospital_1", "question": "How many patients are not using Procrastin-X as medication?", "rationale": ["Identify the main goal: Count the number of patients not using 'Procrastin-X' as medication.", "To achieve this, we need to count all patients and exclude those who have been prescribed 'Procrastin-X'.", "The 'Patient' table contains all patients, and the 'Prescribes' table links patients to medications.", "We will use a subquery to find all patients who have been prescribed 'Procrastin-X'.", "The main query will count all patients whose SSN is not in the list of patients from the subquery."], "gold_sql": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )", "source_tables": ["patient", "prescribes", "medication"], "pred_sql": "SELECT COUNT(*) AS PatientCount \nFROM Patient \nWHERE SSN NOT IN (\n    SELECT Patient \n    FROM Prescribes \n    WHERE Medication = 'Procrastin-X'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\"\n}\n"}
{"sample_id": "train.4256", "db_id": "club_1", "question": "What are the first names of all the students?", "rationale": ["Identify the table that contains the information needed: the 'Student' table.", "Determine which column contains the first names of the students: the 'Fname' column.", "Construct the SQL query to select the 'Fname' column from the 'Student' table."], "gold_sql": "SELECT DISTINCT fname FROM student", "source_tables": ["student"], "pred_sql": "SELECT Fname FROM Student;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.4271", "db_id": "club_1", "question": "Give me the first name and last name for all the female members of the club \"Bootup Baltimore\".", "rationale": ["Identify the tables needed: Student, Member_of_club, and Club.", "We need to select the first name (Fname) and last name (LName) of students who are female members of a specific club.", "Join the Student table with the Member_of_club table on StuID to get the members' details.", "Join the Member_of_club table with the Club table on ClubID to filter by the club name.", "Add a WHERE clause to filter for female students and the specific club name 'Bootup Baltimore'."], "gold_sql": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  'Bootup Baltimore' AND t3.sex  =  'F'", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Student.Fname, Student.LName \nFROM Student \nJOIN Member_of_club ON Student.StuID = Member_of_club.StuID \nJOIN Club ON Member_of_club.ClubID = Club.ClubID \nWHERE Student.Sex = 'Female' AND Club.ClubName = 'Bootup Baltimore';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.4277", "db_id": "club_1", "question": "Find the club which has the largest number of members majoring in \"600\".", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "We need to count the number of members in each club who are majoring in '600'.", "Join the Club table with the Member_of_club table on ClubID to link clubs with their members.", "Join the resulting table with the Student table on StuID to access the major of each student.", "Filter the results to include only those students whose Major is '600'.", "Group the results by ClubID to count the number of members per club.", "Order the results by the count of members in descending order to find the club with the most members.", "Limit the results to 1 to get only the club with the largest number of members."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  '600' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Club.ClubName, COUNT(Member_of_club.StuID) AS MemberCount\nFROM Club\nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID\nJOIN Student ON Member_of_club.StuID = Student.StuID\nWHERE Student.Major = '600'\nGROUP BY Club.ClubID\nORDER BY MemberCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.4278", "db_id": "club_1", "question": "Find the name of the club that has the most female students.", "rationale": ["We need to find the name of the club with the most female students.", "To do this, we will join the 'Club', 'Member_of_club', and 'Student' tables.", "We will filter the students by their gender, specifically looking for 'Female'.", "Next, we will group the results by the club ID to count the number of female students in each club.", "We will order the results in descending order based on the count of female students.", "Finally, we will limit the results to only the top entry, which will give us the club with the most female students."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Club.ClubName\nFROM Club\nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID\nJOIN Student ON Member_of_club.StuID = Student.StuID\nWHERE Student.Sex = 'Female'\nGROUP BY Club.ClubID\nORDER BY COUNT(Student.StuID) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.4312", "db_id": "club_1", "question": "List the clubs that have at least a member with advisor \"1121\".", "rationale": ["We need to list clubs that have at least one member with a specific advisor.", "To achieve this, we will join the 'Club' table with the 'Member_of_club' table to link clubs with their members.", "Next, we will join the 'Student' table to access the advisor information of the members.", "We will filter the results using a WHERE clause to only include students whose advisor is '1121'.", "Finally, we will select distinct club names to avoid duplicates in the results."], "gold_sql": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  1121", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT DISTINCT Club.ClubName \nFROM Club \nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID \nJOIN Student ON Member_of_club.StuID = Student.StuID \nWHERE Student.Advisor = '1121';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: Grants and Organisations are needed to get the total grant amount and the type of organisations.", "Join the Grants table with the Organisations table on the organisation_id to link grants to their respective organisations.", "Filter the results to include only those organisations that are described as 'research'. This requires a subquery to get the organisation_type associated with the description 'research' from the Organisation_Types table.", "Use the SUM function to calculate the total grant amount for the filtered organisations."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT SUM(grant_amount) AS total_grant_amount\nFROM Grants\nJOIN Organisations ON Grants.organisation_id = Organisations.organisation_id\nWHERE Organisations.organisation_type = (SELECT organisation_type FROM Organisation_Types WHERE organisation_type_description = 'research');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n    \"1\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n    \"2\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\"\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the requirement to find the start and end dates of staff working on a project with the most staff members and specifically in a leader role.", "Use the 'Project_Staff' table to get the 'date_from' and 'date_to' for staff members.", "Join the 'Staff_Roles' table to filter for staff members with the role of 'Leader'.", "To find the project with the most staff, use a subquery that counts the number of staff per project and orders them in descending order, limiting the result to the top project.", "Combine the results to get the required dates for the staff in the leader role on the project with the most staff."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT ps.date_from, ps.date_to\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nWHERE sr.role_description = 'Leader'\nAND ps.project_id = (\n    SELECT project_id\n    FROM Project_Staff\n    GROUP BY project_id\n    ORDER BY COUNT(staff_id) DESC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n    \"1\": \"This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.\",\n    \"2\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\"\n}\n"}
{"sample_id": "train.4328", "db_id": "tracking_grants_for_research", "question": "Find the organisation ids and details of the organisations which are involved in", "rationale": ["The user wants to find the organisation ids and details of the organisations involved.", "We need to select the 'organisation_id' and 'organisation_details' from the 'Organisations' table.", "There are no specific filters or conditions mentioned in the user's query, so we will retrieve all records from the 'Organisations' table."], "gold_sql": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  6000", "source_tables": ["grants", "organisations"], "pred_sql": "SELECT organisation_id, organisation_details FROM Organisations;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the details of organisations from the 'Organisations' table that are associated with a specific type of organisation. It joins the 'Organisations' table with the 'Organisation_Types' table to filter organisations based on their type description. The placeholder in the WHERE clause represents the description of the organisation type, and the results are ordered by the organisation details.\",\n    \"1\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n    \"2\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\"\n}\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff are needed to get the organisation type and id along with the count of research staff.", "Join the Organisations table with the Research_Staff table on the organisation_id to link each research staff member to their respective organisation.", "Group the results by organisation_id and organisation_type to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most research staff.", "Limit the results to 1 to get only the organisation with the highest count of research staff."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_type, Organisations.organisation_id\nFROM Organisations\nJOIN Research_Staff ON Organisations.organisation_id = Research_Staff.employer_organisation_id\nGROUP BY Organisations.organisation_id, Organisations.organisation_type\nORDER BY COUNT(Research_Staff.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n    \"1\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n    \"2\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\"\n}\n"}
{"sample_id": "train.4331", "db_id": "tracking_grants_for_research", "question": "What is the type and id of the organization that has the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields.", "Group the results by organisation_id and organisation_type to count the number of research staff per organisation.", "Order the results in descending order based on the count of research staff to find the organisation with the most staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_type, Organisations.organisation_id\nFROM Organisations\nJOIN Research_Staff ON Organisations.organisation_id = Research_Staff.employer_organisation_id\nGROUP BY Organisations.organisation_id, Organisations.organisation_type\nORDER BY COUNT(Research_Staff.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n    \"1\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\"\n}\n"}
{"sample_id": "train.4333", "db_id": "tracking_grants_for_research", "question": "What is the type of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations, Research_Staff, and Organisation_Types.", "Join the Organisations table with the Research_Staff table on the organisation_id to link research staff to their respective organisations.", "Join the Organisation_Types table to get the description of the organisation types.", "Group the results by organisation type to count the number of research staff in each type.", "Order the results in descending order based on the count of research staff to find the type with the most staff.", "Limit the results to 1 to get only the top organisation type."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT ot.organisation_type_description\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nJOIN Organisation_Types ot ON o.organisation_type = ot.organisation_type\nGROUP BY o.organisation_type\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n    \"1\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\"\n}\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the relevant tables: Documents, Grants, Organisations, and Organisation_Types.", "Determine the columns needed: We need the 'sent_date' from the Documents table and the 'grant_amount' from the Grants table.", "Establish the relationships: Documents are linked to Grants via 'grant_id', Grants are linked to Organisations via 'organisation_id', and Organisations are linked to Organisation_Types via 'organisation_type'.", "Construct the SQL query to select the 'sent_date' from the Documents table, joining the necessary tables to filter by grant amount greater than 5000."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT D.sent_date \nFROM Documents D \nJOIN Grants G ON D.grant_id = G.grant_id \nJOIN Organisations O ON G.organisation_id = O.organisation_id \nJOIN Organisation_Types OT ON O.organisation_type = OT.organisation_type \nWHERE G.grant_amount > 5000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n    \"1\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n    \"2\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\"\n}\n"}
{"sample_id": "train.4335", "db_id": "tracking_grants_for_research", "question": "What are the send dates for all documents that have a grant amount of more than 5000 and are involved in research?", "rationale": ["Identify the relevant tables: Documents and Grants.", "Determine the relationship between the tables: Documents has a foreign key grant_id that links to Grants.", "Select the 'sent_date' from the Documents table.", "Filter the results based on the grant amount from the Grants table, specifically looking for amounts greater than 5000."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT Documents.sent_date \nFROM Documents \nJOIN Grants ON Documents.grant_id = Grants.grant_id \nWHERE Grants.grant_amount > 5000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n    \"1\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\"\n}\n"}
{"sample_id": "train.4343", "db_id": "tracking_grants_for_research", "question": "When did researchers start and stop working?", "rationale": ["Identify the relevant table: Project_Staff contains information about staff members' involvement in projects, including their start and end dates.", "Determine the necessary columns: We need the start date (date_from) and end date (date_to) of the researchers' involvement.", "Filter by role: We need to filter the results to include only those staff members whose role is 'researcher'. This requires a subquery to find the role_code associated with the role description 'researcher'.", "Construct the SQL query: Combine the selected columns and the filtering criteria into a complete SQL query."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to \nFROM Project_Staff \nWHERE role_code IN (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%researcher%')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n    \"1\": \"This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.\"\n}\n"}
{"sample_id": "train.4349", "db_id": "tracking_grants_for_research", "question": "What are the details for the project whose research has been published?", "rationale": ["Identify the main table to query: Projects, as we need project details.", "Determine the condition for selecting projects: we need projects whose research has been published, which can be inferred from the Project_Outcomes table.", "Use a subquery to find project_ids from the Project_Outcomes table, indicating that research has been published.", "Combine the main query with the subquery to filter Projects based on the project_ids obtained from the Project_Outcomes table."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE '%Published%'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT * FROM Projects WHERE project_id IN (SELECT project_id FROM Project_Outcomes)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n    \"1\": \"This virtual table provides a count of tasks associated with each project along with the project details from the 'Projects' table. The count is grouped by the unique project identifier, allowing users to see how many tasks are linked to each project.\",\n    \"2\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\"\n}\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes.", "Join the Projects table with the Project_Outcomes table on the project_id.", "Group the results by project_id and project_details to aggregate the outcomes for each project.", "Count the number of outcomes for each project using COUNT(po.outcome_code).", "Order the results in descending order based on the count of outcomes to find the project with the most outcomes.", "Limit the results to 1 to get only the project with the highest number of outcomes."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT p.project_id, p.project_details\nFROM Projects p\nJOIN Project_Outcomes po ON p.project_id = po.project_id\nGROUP BY p.project_id, p.project_details\nORDER BY COUNT(po.outcome_code) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n    \"2\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated outcomes in the 'Project_Outcomes' table. The placeholder in the WHERE clause indicates that we are filtering projects based on their unique identifiers, ensuring we only retrieve those without outcomes.\"\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Organisations and Research_Staff are needed to find the organisation that hired research staff.", "Join the Organisations table with the Research_Staff table on the organisation_id to link research staff to their respective organisations.", "Group the results by organisation_id, organisation_type, and organisation_details to aggregate the count of research staff per organisation.", "Use COUNT(rs.staff_id) to count the number of research staff for each organisation.", "Order the results in descending order based on the count of research staff to find the organisation with the most hires.", "Limit the results to 1 to get only the organisation that hired the most research staff."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id, o.organisation_type, o.organisation_details\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n    \"1\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n    \"2\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\"\n}\n"}
{"sample_id": "train.4361", "db_id": "tracking_grants_for_research", "question": "What are the ids, types, and details of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff are needed to get the organization details and the count of research staff.", "Join the Organisations table with the Research_Staff table on the organisation_id to link organizations with their respective research staff.", "Group the results by organisation_id, organisation_type, and organisation_details to aggregate the count of research staff per organization.", "Use COUNT(rs.staff_id) to count the number of research staff for each organization.", "Order the results in descending order based on the count of research staff to get the organization with the most staff at the top.", "Limit the results to 1 to get only the organization with the highest count of research staff."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id, o.organisation_type, o.organisation_details\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n    \"1\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\"\n}\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff for staff involvement in projects and Staff_Roles for role descriptions.", "Join the Project_Staff table with the Staff_Roles table on the role_code to get the role descriptions.", "Group the results by role_code to count the number of projects associated with each role.", "Use COUNT() to count the number of projects for each role.", "Order the results in descending order based on the project count to find the role with the most projects.", "Limit the results to 1 to get the role involved with the most number of projects."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT sr.role_description, COUNT(ps.project_id) AS project_count\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nGROUP BY ps.role_code\nORDER BY project_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n    \"1\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n    \"2\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\"\n}\n"}
{"sample_id": "train.4367", "db_id": "tracking_grants_for_research", "question": "For grants that have descriptions of Regular and Initial Applications, what are their start dates?", "rationale": ["Identify the relevant tables: Grants, Documents, and Document_Types are needed to retrieve grant start dates based on document descriptions.", "Join the Grants table with the Documents table on the grant_id to link grants with their corresponding documents.", "Join the Documents table with the Document_Types table on document_type_code to filter documents by their descriptions.", "Use a WHERE clause to filter the results for document descriptions that match 'Regular Applications' and 'Initial Applications'.", "Select the grant_start_date from the Grants table as the final output."], "gold_sql": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Regular' INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Initial Application'", "source_tables": ["grants", "document_types", "documents"], "pred_sql": "SELECT Grants.grant_start_date \nFROM Grants \nJOIN Documents ON Grants.grant_id = Documents.grant_id \nJOIN Document_Types ON Documents.document_type_code = Document_Types.document_type_code \nWHERE Document_Types.document_description IN ('Regular Applications', 'Initial Applications');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n    \"1\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n    \"2\": \"This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.\"\n}\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["We need to count the number of documents for each grant id.", "We will use the COUNT() function to count the documents grouped by grant_id.", "We will select the grant_id and the count of documents as document_count.", "To find the grant with the most documents, we will order the results by document_count in descending order.", "Finally, we will limit the results to 1 to get the grant with the most documents."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT d.grant_id, COUNT(d.document_id) AS document_count, d.document_id\nFROM Documents d\nGROUP BY d.grant_id\nORDER BY document_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\"\n}\n"}
{"sample_id": "train.4372", "db_id": "tracking_grants_for_research", "question": "What are all the details of the organisations described as 'Sponsor'? Sort the result in an ascending order.", "rationale": ["Identify the relevant tables: We need to retrieve details from the 'Organisations' table and filter based on the 'Organisation_Types' table.", "Join the 'Organisations' table with the 'Organisation_Types' table using the foreign key 'organisation_type'.", "Filter the results to include only those organisations that have the type description 'Sponsor'.", "Sort the results in ascending order based on the 'organisation_details' column from the 'Organisations' table.", "Construct the SQL query to select all columns from the 'Organisations' table, applying the join and the filters as described."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "pred_sql": "SELECT Organisations.* \nFROM Organisations \nJOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type \nWHERE Organisation_Types.organisation_type_description = 'Sponsor' \nORDER BY Organisations.organisation_details ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n    \"1\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n    \"2\": \"This virtual table provides the details of organisations from the 'Organisations' table that are associated with a specific type of organisation. It joins the 'Organisations' table with the 'Organisation_Types' table to filter organisations based on their type description. The placeholder in the WHERE clause represents the description of the organisation type, and the results are ordered by the organisation details.\"\n}\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes are needed to get project details and their outcomes.", "Determine the relationship: Projects table has a project_id that links to Project_Outcomes table.", "Formulate the query: We need to select outcome_details from Project_Outcomes where the project_details in Projects matches 'sint'.", "Construct the SQL query using JOIN to connect Projects and Project_Outcomes on project_id."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT po.outcome_details \nFROM Projects p \nJOIN Project_Outcomes po ON p.project_id = po.project_id \nWHERE p.project_details = 'sint';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n    \"1\": \"This virtual table provides a count of tasks associated with each project along with the project details from the 'Projects' table. The count is grouped by the unique project identifier, allowing users to see how many tasks are linked to each project.\",\n    \"2\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes are needed to get the project details and their corresponding outcomes.", "Join the Projects table with the Project_Outcomes table on the project_id to link project details with their outcomes.", "Filter the results to only include projects where the project_details match 'sint'.", "Select the outcome_details from the Project_Outcomes table as the final output."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT po.outcome_details \nFROM Projects p \nJOIN Project_Outcomes po ON p.project_id = po.project_id \nWHERE p.project_details = 'sint';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n    \"1\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table provides a count of tasks associated with each project along with the project details from the 'Projects' table. The count is grouped by the unique project identifier, allowing users to see how many tasks are linked to each project.\"\n}\n"}
{"sample_id": "train.4383", "db_id": "tracking_grants_for_research", "question": "What is the id of the organization with the maximum number of outcomes and how many outcomes are there?", "rationale": ["Identify the relevant tables: Organisations, Projects, and Project_Outcomes are needed to find the organization with the maximum number of outcomes.", "Join the Organisations table with the Projects table on organisation_id to link organizations to their projects.", "Join the resulting table with the Project_Outcomes table on project_id to link projects to their outcomes.", "Group the results by organisation_id to count the number of outcomes for each organization.", "Use COUNT() to count the outcomes associated with each organization.", "Order the results by the count of outcomes in descending order to get the organization with the maximum outcomes at the top.", "Limit the results to 1 to get only the organization with the maximum number of outcomes."], "gold_sql": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT o.organisation_id, COUNT(po.outcome_code) AS outcome_count\nFROM Organisations o\nJOIN Projects p ON o.organisation_id = p.organisation_id\nJOIN Project_Outcomes po ON p.project_id = po.project_id\nGROUP BY o.organisation_id\nORDER BY outcome_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\"\n}\n"}
{"sample_id": "train.4384", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects launched by the organisation", "rationale": ["Identify the relevant table: The 'Projects' table contains the project details we need.", "Determine the required columns: We need the 'project_details' column from the 'Projects' table.", "Formulate the SQL query: A simple SELECT statement is sufficient to retrieve the project details from the 'Projects' table."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT project_details FROM Projects;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n    \"1\": \"This virtual table provides a count of tasks associated with each project along with the project details from the 'Projects' table. The count is grouped by the unique project identifier, allowing users to see how many tasks are linked to each project.\",\n    \"2\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["Identify the relevant tables: Project_Staff and Staff_Roles are needed to get the staff roles.", "Join the Project_Staff table with the Staff_Roles table on the role_code to get the role descriptions.", "Filter the results to include only those staff members who are currently involved in projects by checking their date_from and date_to fields."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT sr.role_description \nFROM Project_Staff ps \nJOIN Staff_Roles sr ON ps.role_code = sr.role_code \nWHERE ps.date_from <= DATE('now') AND (ps.date_to IS NULL OR ps.date_to >= DATE('now'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n    \"1\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n    \"2\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\"\n}\n"}
{"sample_id": "train.4394", "db_id": "tracking_grants_for_research", "question": "What are the descriptions of all the project outcomes?", "rationale": ["The user wants to retrieve descriptions of all project outcomes.", "The relevant table for project outcomes is 'Project_Outcomes', which contains the columns 'outcome_code' and 'outcome_details'.", "To get the descriptions, we need to select 'outcome_code' and 'outcome_details' from the 'Project_Outcomes' table.", "The SQL query will be a simple SELECT statement that retrieves these columns from the specified table."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code", "source_tables": ["project_outcomes", "research_outcomes"], "pred_sql": "SELECT outcome_code, outcome_details FROM Project_Outcomes;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated outcomes in the 'Project_Outcomes' table. The placeholder in the WHERE clause indicates that we are filtering projects based on their unique identifiers, ensuring we only retrieve those without outcomes.\",\n    \"2\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\"\n}\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["To find the most common role for the staff, we need to count the occurrences of each role code in the Project_Staff table.", "We will use the COUNT function to count the number of staff members associated with each role code.", "We will group the results by role_code to aggregate the counts for each role.", "To determine the most common role, we will order the results in descending order based on the count of staff members.", "Finally, we will limit the results to 1 to get only the most common role."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count \nFROM Project_Staff \nGROUP BY role_code \nORDER BY role_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n    \"1\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n    \"2\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\"\n}\n"}
{"sample_id": "train.4410", "db_id": "network_2", "question": "Who is the oldest person whose job is student?", "rationale": ["Identify the job title we are interested in, which is 'student'.", "We need to find the maximum age of individuals who have the job title 'student'.", "Use a subquery to select the maximum age from the 'Person' table where the job is 'student'.", "Finally, select the name of the person from the 'Person' table whose age matches the maximum age found in the previous step."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "pred_sql": "SELECT name FROM Person WHERE age = (SELECT MAX(age) FROM Person WHERE job = 'student');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n    \"1\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\"\n}\n"}
{"sample_id": "train.4439", "db_id": "network_2", "question": "What is the name and age of every male? Order the results by age.", "rationale": ["Identify the relevant table: The 'Person' table contains the necessary information about individuals, including their name, age, and gender.", "Filter the results: We need to select only those individuals who are male, which requires a WHERE clause to filter by gender.", "Select the required columns: We need to retrieve the 'name' and 'age' columns from the 'Person' table.", "Order the results: The results should be ordered by age, which can be achieved using the ORDER BY clause."], "gold_sql": "SELECT name FROM Person WHERE gender  =  'male' ORDER BY age", "source_tables": ["person"], "pred_sql": "SELECT name, age FROM Person WHERE gender = 'male' ORDER BY age;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n    \"1\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\"\n}\n"}
{"sample_id": "train.4441", "db_id": "network_2", "question": "What are the names and ages of every person who is a friend of both Dan and Alice?", "rationale": ["Identify the main entities involved: we need names and ages of persons who are friends of both Dan and Alice.", "To find friends of Dan and Alice, we will use the PersonFriend table, which links persons to their friends.", "We need to join the Person table to get the names and ages of the friends.", "We will perform two joins on the PersonFriend table: one for Dan and one for Alice, filtering the results to find common friends.", "The final query will select the name and age of the persons who are friends with both Dan and Alice."], "gold_sql": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, P.age \nFROM Person P \nJOIN PersonFriend PF1 ON P.name = PF1.friend \nJOIN PersonFriend PF2 ON P.name = PF2.friend \nWHERE PF1.name = 'Dan' AND PF2.name = 'Alice';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n    \"1\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n    \"2\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\"\n}\n"}
{"sample_id": "train.4444", "db_id": "network_2", "question": "Find the name of the person who has friends with age above 40 and under age 30?", "rationale": ["Identify the main table to query from, which is the 'Person' table to get the names of individuals.", "Use the 'PersonFriend' table to find friends of individuals, as we need to filter based on their ages.", "Join the 'Person' table with the 'PersonFriend' table on the condition that the name in 'Person' matches the friend in 'PersonFriend'.", "Apply the WHERE clause to filter friends based on the age criteria: age greater than 40 or age less than 30.", "Select distinct names to avoid duplicates in the result."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT p.name \nFROM Person p \nJOIN PersonFriend pf ON p.name = pf.friend \nWHERE p.age > 40 OR p.age < 30;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n    \"1\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\",\n    \"2\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\"\n}\n"}
{"sample_id": "train.4445", "db_id": "network_2", "question": "What are the names of every person who has a friend over 40 and under 30?", "rationale": ["We need to find the names of every person who has a friend over 40 and under 30.", "To do this, we will join the 'Person' table with the 'PersonFriend' table to get the friends of each person.", "We will then join again with the 'Person' table to access the age of the friends.", "We will filter the results to include only those friends whose age is greater than 40 or less than 30.", "Finally, we will select distinct names to avoid duplicates."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT p1.name \nFROM Person p1 \nJOIN PersonFriend pf ON p1.name = pf.name \nJOIN Person p2 ON pf.friend = p2.name \nWHERE (p2.age > 40 OR p2.age < 30);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n    \"1\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n    \"2\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\"\n}\n"}
{"sample_id": "train.4449", "db_id": "network_2", "question": "What are the names of the people who have no friends who are students?", "rationale": ["We need to find names of people who have no friends that are students.", "To do this, we will use a LEFT JOIN to connect the Person table with the PersonFriend table on the name of the person.", "Next, we will perform another LEFT JOIN with the Person table to check if any of the friends (from PersonFriend) have the job title 'student'.", "We will filter the results to include only those where the friend's name (from the second join) is NULL, indicating that there are no friends who are students."], "gold_sql": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  'student'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name \nFROM Person P \nLEFT JOIN PersonFriend PF ON P.name = PF.name \nLEFT JOIN Person S ON PF.friend = S.name AND S.job = 'student' \nWHERE S.name IS NULL;", "hint": "\n"}
{"sample_id": "train.4454", "db_id": "network_2", "question": "Find the name of persons who are friends with Bob.", "rationale": ["Identify the table that contains friendship information, which is the PersonFriend table.", "We need to find friends of a specific person, in this case, 'Bob'.", "The query should select the 'friend' column from the PersonFriend table where the 'name' column matches 'Bob'."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Bob';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n    \"1\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\"\n}\n"}
{"sample_id": "train.4455", "db_id": "network_2", "question": "What are the names of all of Bob's friends?", "rationale": ["Identify the relevant table: PersonFriend contains the friendships.", "Determine the specific person of interest: Bob.", "Construct the SQL query to select the 'friend' column from the PersonFriend table where the 'name' column matches 'Bob'."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Bob';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\"\n}\n"}
{"sample_id": "train.4456", "db_id": "network_2", "question": "Find the names of females who are friends with Zach", "rationale": ["Identify the target gender: females.", "Determine the relationship: friends of Zach.", "Join the Person table with the PersonFriend table to find friends.", "Filter the results to include only females who are friends with Zach."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Zach' AND T1.gender  =  'female'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name \nFROM Person P \nJOIN PersonFriend PF ON P.name = PF.friend \nWHERE P.gender = 'female' AND PF.name = 'Zach';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n    \"1\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\"\n}\n"}
{"sample_id": "train.4465", "db_id": "network_2", "question": "What are the different names of friends who are younger than the average age for a friend?", "rationale": ["Identify the friends of a person from the PersonFriend table.", "Calculate the average age of friends by selecting their names from the PersonFriend table and then using the AVG function on their ages from the Person table.", "Filter the friends whose ages are less than the calculated average age.", "Use DISTINCT to ensure that the names of friends are unique in the final result."], "gold_sql": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT friend\nFROM PersonFriend\nWHERE friend IN (\n    SELECT name\n    FROM Person\n    WHERE age < (\n        SELECT AVG(age)\n        FROM Person\n        WHERE name IN (\n            SELECT friend\n            FROM PersonFriend\n        )\n    )\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n    \"1\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n    \"2\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\"\n}\n"}
{"sample_id": "train.4466", "db_id": "network_2", "question": "Who has friends that are older than the average age? Print their friends and their ages as well", "rationale": ["Identify the relevant tables: Person and PersonFriend.", "Determine the relationship between the tables: PersonFriend contains friends of individuals listed in Person.", "Calculate the average age from the Person table using a subquery.", "Filter the friends from PersonFriend who are older than the average age calculated.", "Select the friend's name and their age from the joined tables."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT pf.friend, p.age \nFROM PersonFriend pf \nJOIN Person p ON pf.friend = p.name \nWHERE p.age > (SELECT AVG(age) FROM Person);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n    \"1\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n    \"2\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\"\n}\n"}
{"sample_id": "train.4467", "db_id": "network_2", "question": "Whare the names, friends, and ages of all people who are older than the average age of a person?", "rationale": ["Identify the required fields: names, friends, and ages of people.", "We need to join the 'Person' table with the 'PersonFriend' table to get the friends of each person.", "The condition specifies that we want people older than the average age.", "To find the average age, we can use a subquery that calculates the average from the 'Person' table.", "The final SQL query will select the name and age from the 'Person' table and the friend from the 'PersonFriend' table, applying the necessary join and where conditions."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name, pf.friend, p.age \nFROM Person p \nJOIN PersonFriend pf ON p.name = pf.name \nWHERE p.age > (SELECT AVG(age) FROM Person);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\",\n    \"1\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n    \"2\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\"\n}\n"}
{"sample_id": "train.4473", "db_id": "network_2", "question": "What are the names of all people who are friends with Alice for the shortest amount of time?", "rationale": ["Identify the table that contains friendship information, which is 'PersonFriend'.", "We need to find friends of 'Alice', so we will filter the 'name' column in the 'PersonFriend' table to be 'Alice'.", "To find the friends with the shortest amount of time, we will order the results by the 'year' column in ascending order.", "Finally, we will select the 'friend' column and limit the results to 1 to get the friend with the shortest friendship duration."], "gold_sql": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Alice' ORDER BY year ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n    \"1\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\"\n}\n"}
{"sample_id": "train.4475", "db_id": "network_2", "question": "What are the names, ages, and jobs of all people who are friends with Alice for the longest amount of time?", "rationale": ["Identify the relevant tables: We need to gather information from the 'Person' table for names, ages, and jobs, and from the 'PersonFriend' table to find friends of Alice.", "Join the 'Person' table with the 'PersonFriend' table on the condition that the friend's name in 'PersonFriend' matches the name in 'Person'.", "Filter the results to only include friends of Alice by using a WHERE clause that specifies PF.name = 'Alice'.", "To find the friends with the longest friendship, we need to order the results by the year the friendship was established in ascending order (earliest first).", "Select the required columns: We need to select the name, age, and job of the friends who meet the criteria."], "gold_sql": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, P.age, P.job\nFROM Person P\nJOIN PersonFriend PF ON P.name = PF.friend\nWHERE PF.name = 'Alice'\nORDER BY PF.year ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n    \"1\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n    \"2\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\"\n}\n"}
{"sample_id": "train.4478", "db_id": "network_2", "question": "Which person whose friends have the oldest average age?", "rationale": ["We need to find the person whose friends have the oldest average age.", "To do this, we will join the 'Person' table with the 'PersonFriend' table to get the friends of each person.", "Next, we will join again with the 'Person' table to get the ages of those friends.", "We will group the results by the person's name to calculate the average age of their friends.", "Finally, we will order the results by the average age in descending order and limit the results to the top one person."], "gold_sql": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT 1", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name\nFROM Person p\nJOIN PersonFriend pf ON p.name = pf.name\nJOIN Person f ON pf.friend = f.name\nGROUP BY p.name\nORDER BY AVG(CAST(f.age AS INTEGER)) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\",\n    \"1\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n    \"2\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\"\n}\n"}
{"sample_id": "train.4480", "db_id": "network_2", "question": "What is the total number of people who has no friend living in the city of Austin.", "rationale": ["We need to count the total number of people who have no friends living in Austin.", "First, we identify the friends who live in Austin by selecting names from the Person table where the city is 'Austin'.", "Next, we find all names from the PersonFriend table where the friend is in the list of friends living in Austin.", "Finally, we count the number of people in the Person table whose names are not in the list of friends identified in the previous step."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT COUNT(*) FROM Person WHERE name NOT IN (SELECT name FROM PersonFriend WHERE friend IN (SELECT name FROM Person WHERE city = 'Austin'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\"\n}\n"}
{"sample_id": "train.4503", "db_id": "document_management", "question": "Find the types of documents with more than 4 documents.", "rationale": ["We need to find the types of documents that have more than 4 documents associated with them.", "To do this, we will join the 'Documents' table with the 'Document_Structures' table using the 'document_structure_code'.", "We will group the results by 'document_structure_code' to count the number of documents for each structure.", "We will use the COUNT function to count the number of documents and alias it as 'document_count'.", "Finally, we will use the HAVING clause to filter the groups where the count of documents is greater than 4."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT ds.document_structure_description, COUNT(d.document_code) AS document_count\nFROM Documents d\nJOIN Document_Structures ds ON d.document_structure_code = ds.document_structure_code\nGROUP BY ds.document_structure_code\nHAVING COUNT(d.document_code) > 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average access count of documents grouped by their document structure code. The placeholder in the LIMIT clause allows the user to specify the maximum number of groups to return, based on the ascending order of their count.\",\n    \"1\": \"This virtual table provides a list of document structure descriptions from the 'Document_Structures' table, which are associated with documents in the 'Documents' table. The results are grouped by the document structure code and ordered by the number of documents associated with each structure, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.4504", "db_id": "document_management", "question": "What are the codes of types of documents of which there are for or more?", "rationale": ["Identify the relevant table: The question pertains to document types, which are found in the 'Documents' table.", "Determine the required information: We need the 'document_type_code' for documents that have four or more occurrences.", "Group the results: Use GROUP BY to group the results by 'document_type_code'.", "Count the occurrences: Use COUNT(document_code) to count how many documents correspond to each document type.", "Filter the results: Use HAVING to filter the groups to only include those with a count of 4 or more."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code\nFROM Documents\nGROUP BY document_type_code\nHAVING COUNT(document_code) >= 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of document structure descriptions from the 'Document_Structures' table, which are associated with documents in the 'Documents' table. The results are grouped by the document structure code and ordered by the number of documents associated with each structure, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.4505", "db_id": "document_management", "question": "Find the total access count of all documents in the most popular document type.", "rationale": ["Identify the requirement to find the total access count of documents.", "Determine that we need to group documents by their document type to find the most popular one based on access count.", "Use a subquery to select the document type code that has the highest total access count.", "In the main query, sum the access counts of documents that match the most popular document type code."], "gold_sql": "SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT SUM(access_count) AS total_access_count\nFROM Documents\nWHERE document_type_code = (\n    SELECT document_type_code\n    FROM Documents\n    GROUP BY document_type_code\n    ORDER BY SUM(access_count) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average access count of documents grouped by their document structure code. The placeholder in the LIMIT clause allows the user to specify the maximum number of groups to return, based on the ascending order of their count.\"\n}\n"}
{"sample_id": "train.4525", "db_id": "document_management", "question": "Find names of the document without any images.", "rationale": ["We need to find documents that do not have any associated images.", "To do this, we will use a LEFT JOIN between the Documents table and the Document_Sections table to get all sections of each document.", "Next, we will perform another LEFT JOIN with the Document_Sections_Images table to find any images associated with those sections.", "By using LEFT JOINs, we can still include documents that have no sections or sections that have no images.", "Finally, we will filter the results where the image_id from Document_Sections_Images is NULL, indicating that there are no images associated with those sections."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "pred_sql": "SELECT d.document_name \nFROM Documents d \nLEFT JOIN Document_Sections ds ON d.document_code = ds.document_code \nLEFT JOIN Document_Sections_Images dsi ON ds.section_id = dsi.section_id \nWHERE dsi.image_id IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of document structure descriptions from the 'Document_Structures' table, which are associated with documents in the 'Documents' table. The results are grouped by the document structure code and ordered by the number of documents associated with each structure, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.4532", "db_id": "document_management", "question": "Count the number of users that are logged in.", "rationale": ["Identify the table that contains user information, which is the 'Users' table.", "To count the number of users, we will use the COUNT() function.", "Since the question asks for the number of users that are logged in, we assume that all users in the 'Users' table are considered logged in for this query.", "The SQL query will select the count of all entries in the 'Users' table."], "gold_sql": "SELECT count(*) FROM users WHERE user_login  =  1", "source_tables": ["users"], "pred_sql": "SELECT COUNT(*) AS logged_in_users FROM Users;", "hint": "\n"}
{"sample_id": "train.4733", "db_id": "department_store", "question": "Return the distinct name of customers whose order status is Pending, in the order of customer id.", "rationale": ["We need to return distinct names of customers.", "The relevant table for customer information is the 'Customers' table, which contains customer names and IDs.", "The 'Customer_Orders' table contains order information, including the order status and customer ID.", "To find customers with a specific order status ('Pending'), we will join the 'Customers' table with the 'Customer_Orders' table on the customer ID.", "We will filter the results to include only those orders where the order status code is 'Pending'.", "Finally, we will order the results by customer ID to meet the requirement of ordering the output."], "gold_sql": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending' ORDER BY T2.customer_id", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT c.customer_name \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nWHERE co.order_status_code = 'Pending' \nORDER BY c.customer_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The date is determined by finding the earliest order date associated with a particular order status, represented by a placeholder.\"\n}\n"}
{"sample_id": "train.4736", "db_id": "department_store", "question": "What are the names and addressed of customers who have both New and Pending orders?", "rationale": ["Identify the relevant tables: Customers, Customer_Orders, and Customer_Addresses.", "Join the Customers table with Customer_Orders to filter customers based on their order status.", "Join the Customer_Addresses table to get the addresses of the customers.", "Use a WHERE clause to filter for orders with status 'New' and 'Pending'.", "Group the results by customer_id to ensure we are counting unique customers.", "Use HAVING to ensure that only customers with both order statuses are included in the final result."], "gold_sql": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'New' INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending'", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT c.customer_name, ca.address_id \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nWHERE co.order_status_code IN ('New', 'Pending') \nGROUP BY c.customer_id \nHAVING COUNT(DISTINCT co.order_status_code) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The date is determined by finding the earliest order date associated with a particular order status, represented by a placeholder.\"\n}\n"}
{"sample_id": "train.4749", "db_id": "department_store", "question": "Find the id and name of the staff who has been assigned for the shortest period.", "rationale": ["Identify the relevant tables: We need to find staff members and their assignment periods, so we will use the Staff and Staff_Department_Assignments tables.", "Determine the columns needed: We need the staff_id and staff_name from the Staff table, and we need to calculate the duration of their assignments from the Staff_Department_Assignments table.", "Calculate the assignment duration: We can calculate the duration of each assignment by subtracting date_assigned_from from date_assigned_to using the julianday function to get the difference in days.", "Sort the results: We will sort the results by the calculated duration in ascending order to find the shortest assignment period.", "Limit the results: We will limit the results to 1 to get only the staff member with the shortest assignment period."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name FROM Staff_Department_Assignments\nWHERE date_assigned_to IS NOT NULL\nORDER BY (julianday(date_assigned_to) - julianday(date_assigned_from)) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n    \"1\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n    \"2\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\"\n}\n"}
{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["Identify the relevant tables: We need to find staff members and their assignment durations, so we will use the Staff and Staff_Department_Assignments tables.", "Join the Staff table with the Staff_Department_Assignments table on staff_id to get the staff names along with their assignment details.", "Calculate the duration of each assignment by subtracting date_assigned_from from date_assigned_to.", "Order the results by the calculated duration in ascending order to find the staff member with the least amount of time assigned.", "Limit the results to 1 to get only the staff member with the least assignment duration."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name FROM Staff_Department_Assignments AS sda\nJOIN Staff AS st ON sda.staff_id = st.staff_id\nORDER BY (date_assigned_to - date_assigned_from) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n    \"1\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n    \"2\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\"\n}\n"}
{"sample_id": "train.4753", "db_id": "department_store", "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.", "rationale": ["Identify the main table to query: Customer_Orders, which contains customer orders and their statuses.", "We need to find distinct customer IDs, so we will use SELECT DISTINCT on the customer_id column.", "We need to filter orders that were placed after some orders that were cancelled. This requires a subquery to find the earliest order date of cancelled orders.", "The subquery selects the minimum order date from Customer_Orders where the order_status_code is 'Cancelled'.", "The main query selects customer IDs from Customer_Orders where the order_date is greater than the result of the subquery."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "pred_sql": "SELECT DISTINCT co.customer_id\nFROM Customer_Orders co\nWHERE co.order_date > (\n    SELECT MIN(co2.order_date)\n    FROM Customer_Orders co2\n    WHERE co2.order_status_code = 'Cancelled'\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The date is determined by finding the earliest order date associated with a particular order status, represented by a placeholder.\"\n}\n"}
{"sample_id": "train.4755", "db_id": "department_store", "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?", "rationale": ["Identify the staff members who have a department assignment.", "Use the Staff_Department_Assignments table to find the staff_id and the date_assigned_to.", "We need to find the maximum date_assigned_to for staff members with the job title of 'Clerical'.", "Join the Staff_Department_Assignments table with the Staff table to filter by job title code 'Clerical'.", "Select staff_id from Staff_Department_Assignments where their date_assigned_to is earlier than the maximum date_assigned_to of Clerical staff."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "pred_sql": "SELECT staff_id FROM Staff_Department_Assignments AS sda\nWHERE date_assigned_to < (\n    SELECT MAX(date_assigned_to)\n    FROM Staff_Department_Assignments AS sda2\n    JOIN Staff AS st ON sda2.staff_id = st.staff_id\n    WHERE st.job_title_code = 'Clerical'\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n    \"1\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n    \"2\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\"\n}\n"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to retrieve customer names and IDs, which are in the Customers table.", "To find customers with 'TN' in their address, we need to join the Customers table with the Customer_Addresses table to link customers to their addresses.", "Next, we join the Customer_Addresses table with the Addresses table to access the address details.", "We will use a WHERE clause to filter addresses that contain 'TN' in the address_details column.", "Finally, we select the customer_name and customer_id from the Customers table."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "pred_sql": "SELECT Customers.customer_name, Customers.customer_id \nFROM Customers \nJOIN Customer_Addresses ON Customers.customer_id = Customer_Addresses.customer_id \nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id \nWHERE Addresses.address_details LIKE '%TN%';", "hint": "\n"}
{"sample_id": "train.4760", "db_id": "department_store", "question": "What are the names and genders of staff who were assigned in 2016?", "rationale": ["Identify the relevant tables: 'Staff' for staff details and 'Staff_Department_Assignments' for assignment dates.", "We need to select the staff names and genders, which are in the 'Staff' table.", "To find staff assigned in 2016, we need to filter the 'Staff_Department_Assignments' table based on the 'date_assigned_from' column.", "The date range for 2016 is from '2016-01-01' to '2017-01-01'.", "Join the 'Staff' table with 'Staff_Department_Assignments' on 'staff_id' to get the necessary details.", "Construct the SQL query to select the required fields and apply the date filter."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT Staff.staff_name, Staff.staff_gender \nFROM Staff \nJOIN Staff_Department_Assignments ON Staff.staff_id = Staff_Department_Assignments.staff_id \nWHERE Staff_Department_Assignments.date_assigned_from >= '2016-01-01' \nAND Staff_Department_Assignments.date_assigned_from < '2017-01-01';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n    \"1\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\",\n    \"2\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\"\n}\n"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["Identify the relevant table: The 'Staff' table contains the names of staff members, and the 'Staff_Department_Assignments' table contains the assignments of staff members to departments along with their job titles.", "Determine the criteria for multiple job assignments: We need to find staff members who have been assigned to more than one distinct job title. This can be achieved by grouping the assignments by 'staff_id' and counting the distinct 'job_title_code'.", "Use a subquery to filter staff members: The subquery will select 'staff_id' from 'Staff_Department_Assignments' where the count of distinct 'job_title_code' is greater than 1, indicating multiple job assignments.", "Join the results with the 'Staff' table: Finally, we will select the 'staff_name' from the 'Staff' table where the 'staff_id' is in the list of staff IDs returned by the subquery."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Staff_Department_Assignments GROUP BY staff_id HAVING COUNT(DISTINCT job_title_code) > 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n    \"1\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n    \"2\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\"\n}\n"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["Identify the relevant table: Customers, which contains customer_id, customer_name, customer_address, and payment_method_code.", "Filter customers based on their address containing 'WY'. This can be done using the LIKE operator with a wildcard: '%WY%'.", "Exclude customers who use a credit card for payment. This is done by checking that payment_method_code is not equal to 'CREDIT_CARD'.", "Combine these conditions in the WHERE clause of the SQL query to retrieve the desired customer ids and names."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name \nFROM Customers \nWHERE customer_address LIKE '%WY%' \nAND payment_method_code != 'CREDIT_CARD';", "hint": "\n"}
{"sample_id": "train.4793", "db_id": "department_store", "question": "Find the average price of all product clothes.", "rationale": ["Identify the table that contains product information, which is the 'Products' table.", "Determine the relevant column for price, which is 'product_price'.", "To find the average price, use the AVG() function.", "Filter the products to only include those that are classified as 'clothes' using the 'product_type_code' column."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "pred_sql": "SELECT AVG(product_price) AS average_price\nFROM Products\nWHERE product_type_code = 'clothes';", "hint": "\n"}
{"sample_id": "train.4795", "db_id": "department_store", "question": "Find the name of the most expensive hardware product.", "rationale": ["Identify the relevant table: Products.", "Determine the column needed: product_name for the name of the product and product_price for the price.", "Filter the products to only include those of type 'hardware' using product_type_code.", "Sort the results by product_price in descending order to get the most expensive product first.", "Limit the results to 1 to get only the most expensive hardware product."], "gold_sql": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1", "source_tables": ["products"], "pred_sql": "SELECT product_name FROM Products WHERE product_type_code = 'hardware' ORDER BY product_price DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["Identify the relevant tables: We need to look at the 'product' and 'store_product' tables to find products and their maximum page sizes.", "Join the 'store_product' table with the 'product' table on the product ID to access the maximum page size for each product.", "Group the results by 'max_page_size' to aggregate the products that share the same page size.", "Use the HAVING clause to filter the groups, ensuring we only include those with more than 3 products listed."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size\nFROM store_product sp\nJOIN product p ON sp.Product_ID = p.product_id\nGROUP BY max_page_size\nHAVING COUNT(sp.Product_ID) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n    \"1\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\"\n}\n"}
{"sample_id": "train.4903", "db_id": "store_product", "question": "What is the maximum page size for everything that has more than 3 products listed?", "rationale": ["Identify the requirement: We need to find the maximum page size for products that are listed in stores with more than 3 products.", "To achieve this, we will first need to identify the stores that have more than 3 products. This can be done using a subquery that groups the 'store_product' table by 'Store_ID' and counts the number of products for each store, filtering with HAVING COUNT(Product_ID) > 3.", "Next, we will use the result of this subquery to filter the 'product' table to get the maximum page size for the products that belong to those stores.", "Finally, we will use the MAX function to get the maximum page size from the filtered products."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT MAX(max_page_size) FROM product WHERE product_id IN (SELECT Product_ID FROM store_product GROUP BY Store_ID HAVING COUNT(Product_ID) > 3);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n    \"1\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\"\n}\n"}
{"sample_id": "train.4913", "db_id": "store_product", "question": "What is the total number of residents for the districts with the 3 largest areas?", "rationale": ["Identify the relevant table: The 'district' table contains the population and area information needed for the query.", "Determine the requirement: We need to find the total number of residents in the districts with the 3 largest areas.", "Use a subquery to find the District_IDs of the top 3 districts by area: This is done by ordering the districts by 'City_Area' in descending order and limiting the results to 3.", "Sum the 'City_Population' for the districts identified in the subquery: This will give us the total number of residents for those districts."], "gold_sql": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3", "source_tables": ["district"], "pred_sql": "SELECT SUM(City_Population) AS Total_Residents\nFROM district\nWHERE District_ID IN (\n    SELECT District_ID\n    FROM district\n    ORDER BY City_Area DESC\n    LIMIT 3\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of stores grouped by the city where their respective districts are headquartered. The placeholders in the query represent the relationships between stores and districts, allowing for aggregation of store counts based on the city names.\",\n    \"1\": \"This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in each city, with a limit on the number of cities returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["Identify the relevant tables: store, store_district, and district are needed to find stores in a specific district.", "Join the store table with the store_district table on Store_ID to link stores to their respective districts.", "Join the resulting table with the district table on District_ID to access district names.", "Filter the results to only include stores located in 'Khanewal District' by using a WHERE clause."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT store.Store_Name \nFROM store \nJOIN store_district ON store.Store_ID = store_district.Store_ID \nJOIN district ON store_district.District_ID = district.District_ID \nWHERE district.District_name = 'Khanewal';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in each city, with a limit on the number of cities returned as specified by the placeholder.\",\n    \"1\": \"This virtual table provides a count of stores grouped by the city where their respective districts are headquartered. The placeholders in the query represent the relationships between stores and districts, allowing for aggregation of store counts based on the city names.\"\n}\n"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["Identify the relevant tables: store, store_district, and district are needed to find the number of stores in each city.", "Join the store table with store_district to associate stores with their respective districts.", "Join the resulting table with the district table to access the Headquartered_City for each district.", "Group the results by Headquartered_City to count the number of stores in each city.", "Order the results by the count of stores in descending order to find the city with the most stores.", "Limit the results to 1 to get only the city with the highest number of stores."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT d.Headquartered_City, COUNT(s.Store_ID) AS Number_of_Stores\nFROM store s\nJOIN store_district sd ON s.Store_ID = sd.Store_ID\nJOIN district d ON sd.District_ID = d.District_ID\nGROUP BY d.Headquartered_City\nORDER BY Number_of_Stores DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in each city, with a limit on the number of cities returned as specified by the placeholder.\",\n    \"1\": \"This virtual table provides a count of stores grouped by the city where their respective districts are headquartered. The placeholders in the query represent the relationships between stores and districts, allowing for aggregation of store counts based on the city names.\"\n}\n"}
{"sample_id": "train.4930", "db_id": "store_product", "question": "Find products with max page size as \"A4\" and pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for max page size and pages per minute color.", "Determine the conditions: We need to filter products where max_page_size is 'A4' and pages_per_minute_color is less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table, applying the WHERE clause to filter based on the identified conditions."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' AND pages_per_minute_color < 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n    \"1\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\"\n}\n"}
{"sample_id": "train.4932", "db_id": "store_product", "question": "Find products with max page size as \"A4\" or pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to find products with a maximum page size of 'A4' or a pages per minute color speed less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table where either condition is met, using the OR operator to combine the conditions."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n    \"1\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\"\n}\n"}
{"sample_id": "train.4935", "db_id": "store_product", "question": "What are all of the products whose name includes the substring \"Scanner\"?", "rationale": ["Identify the table that contains product information, which is the 'product' table.", "Determine the column that contains the product names or descriptions, which is the 'product' column.", "Use the SQL LIKE operator to search for products that include the substring 'Scanner'.", "The '%' wildcard is used before and after 'Scanner' to match any characters before or after the substring.", "Construct the SQL query to select all columns from the 'product' table where the product name contains 'Scanner'."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE product LIKE '%Scanner%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n    \"1\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\"\n}\n"}
{"sample_id": "train.4937", "db_id": "store_product", "question": "What is the most common maximum page size?", "rationale": ["The question asks for the most common maximum page size, which implies we need to count occurrences of each maximum page size in the product table.", "To find the most common maximum page size, we will use the COUNT function to count how many times each max_page_size appears.", "We will group the results by max_page_size to aggregate the counts for each unique size.", "To get the most common size, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one entry to get the most common maximum page size."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1", "source_tables": ["product"], "pred_sql": "SELECT max_page_size, COUNT(*) as count\nFROM product\nGROUP BY max_page_size\nORDER BY count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n    \"1\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\"\n}\n"}
{"sample_id": "train.4938", "db_id": "store_product", "question": "Find the name of the products that are not using the most frequently-used max page size.", "rationale": ["Identify the products from the 'product' table.", "Determine the most frequently-used max page size by grouping the products based on 'max_page_size' and counting the occurrences.", "Order the results by the count in descending order to find the most common max page size.", "Use a subquery to get the most frequently-used max page size.", "Select the product names where the max_page_size is not equal to the most frequently-used max page size."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "pred_sql": "SELECT product.product \nFROM product \nWHERE product.max_page_size != (SELECT max_page_size \n                                  FROM product \n                                  GROUP BY max_page_size \n                                  ORDER BY COUNT(*) DESC \n                                  LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n    \"1\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\"\n}\n"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["We need to calculate the average enrollment of students for each college.", "To do this, we will use the AVG() function on the 'enr' column from the 'College' table.", "We will also select the 'cName' column to group the results by college name.", "The GROUP BY clause will be used to ensure that we get the average enrollment for each college individually."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "pred_sql": "SELECT AVG(enr) AS average_enrollment, cName FROM College GROUP BY cName;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\"\n}\n"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["Identify the relevant tables: The question pertains to players and their training hours, which suggests we need to look at the Player table.", "Determine the required calculation: The question asks for the average training hours, so we will use the AVG() function.", "Assume a column for training hours exists: Since the schema provided does not explicitly mention training hours, we will assume there is a column named 'training_hours' in the Player table for the sake of this query.", "Construct the SQL query: We will select the average of the training_hours column from the Player table."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_training_hours FROM Player", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n    \"1\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4956", "db_id": "soccer_2", "question": "Find the name and training hours of players whose hours are below 1500.", "rationale": ["Identify the relevant table: The 'Player' table contains the names of players and their training hours.", "Determine the condition: We need to find players whose training hours are below 1500.", "Construct the SQL query: Select the 'pName' and 'hours' columns from the 'Player' table where the 'hours' are less than 1500."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "pred_sql": "SELECT pName, hours FROM Player WHERE hours < 1500;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who attended high schools with an enrollment number less than a specified value. The placeholder in the WHERE clause represents the enrollment number of students.\",\n    \"2\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4961", "db_id": "soccer_2", "question": "What are the different types of player positions?", "rationale": ["The question asks for the different types of player positions.", "To find the different types of player positions, we need to look at the 'Tryout' table where player positions are recorded.", "Using the SELECT DISTINCT statement allows us to retrieve unique values from the 'pPos' column in the 'Tryout' table, ensuring that we only get each position listed once."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT pPos FROM Tryout;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n    \"2\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\"\n}\n"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["Identify the relevant table: The 'Tryout' table contains the decision made regarding each player's tryout.", "Determine the specific decision to count: We are interested in counting the number of players who were accepted after the tryout.", "Construct the SQL query: Use the COUNT function to count the number of rows in the 'Tryout' table where the decision is 'accepted'."], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) AS accepted_students\nFROM Tryout\nWHERE decision = 'accepted';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"2\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["Identify the relevant table: The 'Player' table contains information about players, but it does not have a column for training hours. Therefore, we need to assume that training hours are either part of the 'Player' table or need to be calculated based on the tryouts.", "Determine the aggregation functions needed: We need to find the maximum, average, and minimum training hours, which requires the use of the MAX(), AVG(), and MIN() functions in SQL.", "Construct the SQL query: Since the 'Player' table does not have a 'training_hours' column, we cannot directly query it. However, if we assume that training hours are associated with the players in some way, we would typically join the 'Player' table with another table that contains training hours. In this case, we will just select from the 'Player' table as a placeholder."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT MAX(training_hours) AS max_training_hours, AVG(training_hours) AS avg_training_hours, MIN(training_hours) AS min_training_hours FROM Player;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n    \"1\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4967", "db_id": "soccer_2", "question": "What is the average, maximum, and minimum for the number of hours spent training?", "rationale": ["Identify the relevant tables: The question pertains to training hours, which suggests a table related to training or tryouts.", "Determine the necessary calculations: The question asks for average, maximum, and minimum values, which can be calculated using SQL aggregate functions AVG(), MAX(), and MIN().", "Assume there is a 'Training' table that records training hours for players, as the original schema does not include this information.", "Use a WHERE clause to filter the results based on the decision made regarding the player's tryout, assuming we are interested in players who were accepted."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_hours, MAX(training_hours) AS max_hours, MIN(training_hours) AS min_hours \nFROM Training \nWHERE decision = 'accepted';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n    \"1\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4970", "db_id": "soccer_2", "question": "What are the names of players whose training hours is between 500 and 1500?", "rationale": ["Identify the relevant table: The 'Player' table contains player names and their training hours.", "Determine the condition: We need to filter players based on their training hours being between 500 and 1500.", "Construct the SQL query: Use a SELECT statement to retrieve player names from the 'Player' table where the training hours fall within the specified range."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE training_hours BETWEEN 500 AND 1500;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n    \"2\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\"\n}\n"}
{"sample_id": "train.4971", "db_id": "soccer_2", "question": "What are the names of players who train between 500 and 1500 hours?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find players based on their training hours, which is not directly available in the schema. However, we can infer that the decision made in the Tryout table might relate to their training hours.", "The hint suggests that we can filter players based on their decisions in the Tryout table.", "We will select player names from the Player table where their IDs are in the Tryout table with a specific decision (e.g., 'accepted').", "Since the question specifies a range of training hours (500 to 1500), we will assume that this is represented by the position (pPos) in the Tryout table, and we will filter based on that range.", "Combine the conditions to form the final SQL query."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE decision = 'accepted') AND pID IN (SELECT pID FROM Tryout WHERE pPos BETWEEN 500 AND 1500);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n    \"2\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4975", "db_id": "soccer_2", "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?", "rationale": ["Identify the relevant table: The 'College' table contains the necessary information about college names and enrollment numbers.", "Determine the conditions: We need colleges with an enrollment number greater than 10000 and located in Louisiana.", "Construct the SQL query: Use a SELECT statement to retrieve 'cName' and 'enr' from the 'College' table, applying the specified conditions in the WHERE clause."], "gold_sql": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = 'LA'", "source_tables": ["college"], "pred_sql": "SELECT cName, enr FROM College WHERE enr > 10000 AND state = 'Louisiana';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who attended high schools with an enrollment number less than a specified value. The placeholder in the WHERE clause represents the enrollment number of students.\",\n    \"2\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4981", "db_id": "soccer_2", "question": "What are the name of the players who received a card in descending order of the hours of training?", "rationale": ["Identify the relevant table: The 'Player' table contains the names of the players and their eligibility year.", "Determine the required output: We need the names of players who received a card, which corresponds to the 'yCard' column in the 'Player' table.", "Sort the results: The names should be ordered in descending order based on the 'yCard' column, which indicates the year of the player's card or eligibility."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player ORDER BY yCard DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\"\n}\n"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["To find the most popular position among players in the tryout, we need to count how many players are trying out for each position.", "We will use the 'Tryout' table, which contains the 'pPos' column representing the position players are trying out for.", "We will group the results by 'pPos' to aggregate the counts for each position.", "We will count the number of players for each position using COUNT(*).", "To determine the most popular position, we will order the results in descending order based on the count of players for each position.", "Finally, we will limit the results to 1 to get only the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"2\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\"\n}\n"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["To determine the most popular position at tryouts, we need to count how many players tried out for each position.", "We will use the 'Tryout' table, which contains the 'pPos' column representing the position players are trying out for.", "We will group the results by 'pPos' to aggregate the counts for each position.", "We will count the occurrences of each position using COUNT(pPos) and alias it as 'position_count'.", "To find the most popular position, we will order the results in descending order based on 'position_count'.", "Finally, we will limit the results to 1 to get the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(pPos) AS position_count\nFROM Tryout\nGROUP BY pPos\nORDER BY position_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n    \"2\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["Identify the relevant table: The 'Tryout' table contains information about players, their positions, and decisions made regarding their tryouts.", "Determine the required information: We need to find the minimum hours of students playing in different positions.", "Use the MIN() function to calculate the minimum hours for each position.", "Group the results by position using GROUP BY clause to get the minimum hours for each unique position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(hours) AS min_hours\nFROM Tryout\nGROUP BY pPos;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\"\n}\n"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["Identify the relevant tables: We need to find information about players and their practice times, which suggests a table related to practice.", "Determine the required fields: We need the position (pPos) and the minimum practice time for each position.", "Group the results: Since we want the minimum practice time for each position, we will use the GROUP BY clause on pPos.", "Use the MIN function: To find the minimum practice time for each position, we will use the MIN aggregate function."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(practice_time) AS min_practice_time\nFROM Practice\nGROUP BY pPos;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\"\n}\n"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["Identify the tables involved: Player and Tryout.", "We need to select the names of players, which corresponds to the 'pName' column in the Player table.", "We also need to include the position they practiced for, which corresponds to the 'pPos' column in the Tryout table.", "To find players who received a 'yes' decision at tryouts, we will filter the results using the 'decision' column in the Tryout table.", "We will join the Player and Tryout tables on the 'pID' column, which is the unique identifier for players."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT Player.pName, Tryout.pPos \nFROM Player \nJOIN Tryout ON Player.pID = Tryout.pID \nWHERE Tryout.decision = 'yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n    \"2\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find the names of students (players) who successfully tried out for the position of striker.", "This requires a JOIN between the Player table and the Tryout table on the pID column.", "We filter the results where the position (pPos) is 'striker' and the decision is 'successful'.", "Select the pName from the Player table as the final output."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT Player.pName \nFROM Player \nJOIN Tryout ON Player.pID = Tryout.pID \nWHERE Tryout.pPos = 'striker' AND Tryout.decision = 'successful';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n    \"2\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["Identify the relevant tables: Player and Tryout.", "Determine the condition: we are interested in players who got rejected in their tryouts.", "Join the Player and Tryout tables on the pID to get the necessary information about players and their tryout decisions.", "Filter the results to include only those players whose decision was 'rejected'.", "Select the average of the hours spent practicing from the filtered results."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT AVG(hours) AS average_hours\nFROM (SELECT pID, HS, hours\n      FROM Player\n      JOIN Tryout ON Player.pID = Tryout.pID\n      WHERE Tryout.decision = 'rejected') AS rejected_players;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n    \"1\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.5018", "db_id": "soccer_2", "question": "Which college has any student who is a goalie and succeeded in the tryout.", "rationale": ["Identify the relevant tables: College, Player, and Tryout.", "We need to find colleges that have students who are goalies and succeeded in their tryouts.", "This requires joining the College table with the Tryout table on the college name, and the Tryout table with the Player table on the player ID.", "Filter the results where the position (pPos) is 'goalie' and the decision is 'succeeded'.", "Select distinct college names to avoid duplicates."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT c.cName \nFROM College c \nJOIN Tryout t ON c.cName = t.cName \nJOIN Player p ON t.pID = p.pID \nWHERE t.pPos = 'goalie' AND t.decision = 'succeeded';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"2\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\"\n}\n"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["Identify the relevant tables: College and Tryout are needed to get the state and enrollment of colleges where players have been accepted in tryouts.", "We need to join the College table with the Tryout table on the common column cName to link colleges with their respective tryouts.", "The condition for filtering is that we only want colleges where the decision in the Tryout table is 'accepted'.", "Select the state and enrollment number (enr) from the College table for the filtered results."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT College.state, College.enr \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.decision = 'accepted';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"1\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"2\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\"\n}\n"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["Identify the tables involved: College and Tryout.", "We need to find the total enrollment of colleges where students were accepted during tryouts, so we will join the College table with the Tryout table on the college name (cName).", "We will filter the results to only include rows where the decision in the Tryout table is 'accepted'.", "We need to sum the enrollment numbers from the College table, which requires converting the enrollment number from text to integer.", "Finally, we will group the results by the state of the colleges to get the total enrollment per state."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT SUM(CAST(College.enr AS INTEGER)) AS total_enrollment, College.state \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.decision = 'accepted' \nGROUP BY College.state;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"1\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"2\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\"\n}\n"}
{"sample_id": "train.5026", "db_id": "soccer_2", "question": "Find the names of schools that have some students playing in goalie and mid positions.", "rationale": ["We need to find the names of schools (colleges) that have students playing in specific positions: goalie and mid.", "To achieve this, we will use the College table to get the names of colleges.", "We will join the College table with the Tryout table on the college name (cName) to filter the colleges based on the positions of the players.", "In the WHERE clause, we will specify that we are interested in players whose positions (pPos) are either 'goalie' or 'mid'.", "Using DISTINCT will ensure that we only get unique college names in the result."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT c.cName \nFROM College c \nJOIN Tryout t ON c.cName = t.cName \nWHERE t.pPos IN ('goalie', 'mid')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n    \"2\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.5028", "db_id": "soccer_2", "question": "Find the names of states that have some college students playing in goalie and mid positions.", "rationale": ["We need to find distinct states where colleges have students playing in specific positions (goalie and mid).", "To do this, we will join the College, Tryout, and Player tables based on their relationships: College.cName with Tryout.cName and Tryout.pID with Player.pID.", "We will select the distinct states from the College table.", "The condition for the join will be that the position (pPos) in the Tryout table must be either 'goalie' or 'mid'."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT College.state\nFROM College\nJOIN Tryout ON College.cName = Tryout.cName\nJOIN Player ON Tryout.pID = Player.pID\nWHERE Tryout.pPos IN ('goalie', 'mid')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"1\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"2\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\"\n}\n"}
{"sample_id": "train.5029", "db_id": "soccer_2", "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?", "rationale": ["We need to find distinct states where colleges have students playing in specific positions (goalie and mid-field).", "To do this, we will join the College, Tryout, and Player tables based on their relationships.", "The College table provides the state information, while the Tryout table gives us the positions players are trying out for.", "We will filter the results using a WHERE clause to include only those players who are trying out for either 'goalie' or 'mid-field'.", "Finally, we will select distinct states to avoid duplicates in our results."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT College.state\nFROM College\nJOIN Tryout ON College.cName = Tryout.cName\nJOIN Player ON Tryout.pID = Player.pID\nWHERE Tryout.pPos IN ('goalie', 'mid-field')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"1\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"2\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\"\n}\n"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant tables: We need to look at the 'Tryout' table to find players in specific positions.", "Determine the positions of interest: The positions we are interested in are 'goalie' and 'mid'.", "Count distinct colleges: We want to count how many unique colleges (cName) have players trying out for either of these positions.", "Construct the SQL query: We will use a SELECT statement to count distinct college names from the Tryout table where the position is either 'goalie' or 'mid'."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(DISTINCT cName) AS school_count\nFROM Tryout\nWHERE pPos IN ('goalie', 'mid')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"2\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\"\n}\n"}
{"sample_id": "train.5037", "db_id": "soccer_2", "question": "What is the count of states with college students playing in the mid position but not as goalies?", "rationale": ["Identify the tables involved: College, Player, and Tryout.", "We need to count distinct states, so we will use COUNT(DISTINCT College.state).", "We need to join the College table with the Tryout table on the college name (cName) and the Tryout table with the Player table on the player ID (pID).", "The WHERE clause needs to filter for players trying out for the 'mid' position and exclude those with a decision of 'goalie'.", "Construct the SQL query using the identified elements."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')", "source_tables": ["tryout", "college"], "pred_sql": "SELECT COUNT(DISTINCT College.state) \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nJOIN Player ON Tryout.pID = Player.pID \nWHERE Tryout.pPos = 'mid' AND Tryout.decision IS NOT 'goalie';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"1\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\"\n}\n"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["Identify the requirement to find states with colleges that have enrollments less than some other college.", "To achieve this, we need to compare the enrollment numbers of colleges in different states.", "We can use a subquery to find the maximum enrollment number from the College table.", "The main query will select distinct states from the College table where the enrollment number is less than the maximum enrollment number found in the subquery."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE enr < (SELECT MAX(enr) FROM College)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\",\n    \"1\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"2\": \"This virtual table describes the names and high schools of players from the 'Player' table who attended high schools with an enrollment number less than a specified value. The placeholder in the WHERE clause represents the enrollment number of students.\"\n}\n"}
{"sample_id": "train.5102", "db_id": "cre_Drama_Workshop_Groups", "question": "Show the minimum, average, maximum order quantity of all invoices.", "rationale": ["Identify the relevant table: The 'Invoice_Items' table contains the 'Order_Quantity' column which we need to analyze.", "Determine the required calculations: We need to calculate the minimum, average, and maximum of the 'Order_Quantity'.", "Construct the SQL query: Use the aggregate functions MIN(), AVG(), and MAX() on the 'Order_Quantity' column from the 'Invoice_Items' table."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "pred_sql": "SELECT MIN(Order_Quantity) AS Min_Quantity, AVG(Order_Quantity) AS Avg_Quantity, MAX(Order_Quantity) AS Max_Quantity \nFROM Invoice_Items;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n    \"1\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\"\n}\n"}
{"sample_id": "train.5118", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the payment method code used by the most orders?", "rationale": ["Identify the relevant table: Invoices contains the payment_method_code and Order_ID.", "Group the results by payment_method_code to count how many orders are associated with each payment method.", "Order the results in descending order based on the count of Order_ID to find the most used payment method.", "Limit the results to 1 to get only the top payment method code."], "gold_sql": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices"], "pred_sql": "SELECT payment_method_code\nFROM Invoices\nGROUP BY payment_method_code\nORDER BY COUNT(Order_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5127", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the descriptions of the service types that cost more than 100.", "rationale": ["Identify the relevant table: The question asks for service types, which are found in the Services table.", "Determine the required column: We need the descriptions of the service types, so we will select the 'Service_Type_Description' column.", "Filter the results: The question specifies that we only want service types that cost more than 100, which implies we need to filter based on the 'Product_Price' column.", "Construct the SQL query: Combine the SELECT statement with the FROM clause and the WHERE condition to form the complete SQL query."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT Service_Type_Description \nFROM Services \nWHERE Product_Price > 100;", "hint": "\n"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["Identify the relevant tables: We need to find workshop groups and services, so we will use the Drama_Workshop_Groups and Services tables.", "Determine the relationship: The Services table has a foreign key Workshop_Group_ID that links to the Drama_Workshop_Groups table.", "Filter the services: We need to filter the services to only those with the product name 'film'.", "Select the distinct workshop group names: We want the names of the workshop groups, so we will select Store_Name from the Drama_Workshop_Groups table and ensure we get distinct values."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "pred_sql": "SELECT DISTINCT d.Store_Name\nFROM Drama_Workshop_Groups d\nJOIN Services s ON d.Workshop_Group_ID = s.Workshop_Group_ID\nWHERE s.Product_Name = 'film';", "hint": "\n"}
{"sample_id": "train.5142", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the order details of the products with price higher than 2000?", "rationale": ["We need to retrieve order details of products with a price higher than 2000.", "The relevant tables for this query are Invoice_Items, Invoices, Order_Items, and Products.", "We will join these tables to get the necessary details:", "1. Start with Invoice_Items to get the invoice details.", "2. Join Invoices to link the invoice items to their respective invoices.", "3. Join Order_Items to connect the invoice items to the orders they belong to.", "4. Finally, join Products to filter products based on their price.", "The WHERE clause will filter products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_ID, Product_ID, Order_Quantity, Other_Item_Details \nFROM Invoice_Items \nJOIN Invoices ON Invoice_Items.Invoice_ID = Invoices.Invoice_ID \nJOIN Order_Items ON Invoice_Items.Order_Item_ID = Order_Items.Order_Item_ID \nJOIN Products ON Order_Items.Product_ID = Products.Product_ID \nWHERE Products.Product_Price > 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n    \"1\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\"\n}\n"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["Identify the relevant tables: We need to retrieve order details, which are stored in the 'Order_Items' table, and we also need product information, which is in the 'Products' table.", "Determine the columns to select: We want to select order item details such as Order_Item_ID, Order_ID, Product_ID, Order_Quantity, and the Product_Price.", "Establish the relationship between tables: We will join 'Order_Items' with 'Products' on the Product_ID to get the product price for each order item.", "Apply the filter condition: We need to filter the results to include only those products with a price greater than 2000. This will be done in the WHERE clause."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT oi.Order_Item_ID, oi.Order_ID, oi.Product_ID, oi.Order_Quantity, p.Product_Price \nFROM Order_Items oi \nJOIN Products p ON oi.Product_ID = p.Product_ID \nWHERE p.Product_Price > 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n    \"1\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\"\n}\n"}
{"sample_id": "train.5160", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the most frequent status of bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most frequent status of bookings, which means we need to count occurrences of each status code.", "Use the COUNT function: We will count the number of bookings for each status code using COUNT(*) and group the results by 'Status_Code'.", "Order the results: To find the most frequent status, we will order the results in descending order based on the count of bookings.", "Limit the results: Since we only want the most frequent status, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Frequency\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most common status code, which implies counting occurrences of each status code.", "Use the COUNT function: We will count the number of bookings for each status code.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each unique status code.", "Order the results: To find the most common status code, we will order the results in descending order based on the count.", "Limit the results: Since we only need the most common status code, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Count\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["Identify the relevant tables: We need information from the Drama_Workshop_Groups and Bookings tables.", "Determine the relationship: The Drama_Workshop_Groups table is linked to the Bookings table through the Workshop_Group_ID.", "Select the required fields: We need the Store_Name from the Drama_Workshop_Groups table.", "Apply the filter: We need to filter the bookings to only those with a status code of 'stop'.", "Use DISTINCT to ensure we only get unique workshop group names."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "pred_sql": "SELECT DISTINCT dg.Store_Name\nFROM Drama_Workshop_Groups dg\nJOIN Bookings b ON dg.Workshop_Group_ID = b.Workshop_Group_ID\nWHERE b.Status_Code = 'stop';", "hint": "\n"}
{"sample_id": "train.5171", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the description of the service type that offers not only the photo product but also the film product.", "rationale": ["Identify the relevant tables: Ref_Service_Types for service descriptions, Services for linking services to products, and Order_Items for product details.", "Join Ref_Service_Types with Services on Service_Type_Code to get the service descriptions associated with each service.", "Join Services with Order_Items to link services to the products they offer.", "Use a subquery to filter products to only those that are 'photo' and 'film'.", "Group the results by Service_Type_Description to aggregate services that offer both products.", "Use HAVING to ensure that only service types offering both products are included, which means counting distinct Product_IDs should equal 2."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT DISTINCT rst.Service_Type_Description\nFROM Ref_Service_Types rst\nJOIN Services s ON rst.Service_Type_Code = s.Service_Type_Code\nJOIN Order_Items oi ON s.Product_ID = oi.Product_ID\nWHERE oi.Product_ID IN (\n    SELECT Product_ID\n    FROM Products\n    WHERE Product_Name IN ('photo', 'film')\n)\nGROUP BY rst.Service_Type_Description\nHAVING COUNT(DISTINCT oi.Product_ID) = 2;", "hint": "\n"}
{"sample_id": "train.5459", "db_id": "voter_2", "question": "Find the average age of female students.", "rationale": ["Identify the table needed: The 'Student' table contains the age and gender information.", "Determine the condition: We need to filter for female students, which is done using the condition 'Sex = 'Female'.", "Calculate the average: Use the AVG() function to calculate the average age of the filtered students.", "Construct the SQL query: Combine the SELECT statement with the AVG function and the WHERE clause to filter for female students."], "gold_sql": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  'F'", "source_tables": ["student"], "pred_sql": "SELECT AVG(Age) AS Average_Age FROM Student WHERE Sex = 'Female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\",\n    \"1\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n    \"2\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5466", "db_id": "voter_2", "question": "What are the distinct president votes on 08/30/2015?", "rationale": ["Identify the relevant table: The question pertains to votes, specifically for the president, which is recorded in the 'Voting_record' table.", "Determine the specific column needed: We need the distinct values from the 'President_Vote' column.", "Filter the records based on the date: The question specifies a date (08/30/2015), which corresponds to the 'Registration_Date' column in the 'Voting_record' table.", "Construct the SQL query: Use SELECT DISTINCT to get unique president votes from the 'Voting_record' table where the 'Registration_Date' matches the specified date."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote \nFROM Voting_record \nWHERE Registration_Date = '2015-08-30';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"1\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"2\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["Identify the relevant table: The 'Voting_record' table contains the voting information, including the presidential votes.", "Determine the required data: We need to retrieve distinct presidential votes.", "Specify the condition: We need to filter the records based on the registration date, which is '08/30/2015'.", "Format the date correctly for SQLite: Convert '08/30/2015' to '2015-08-30'.", "Construct the SQL query: Use SELECT DISTINCT to get unique presidential votes from the Voting_record table where the registration date matches."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote \nFROM Voting_record \nWHERE Registration_Date = '2015-08-30';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"1\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"2\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5476", "db_id": "voter_2", "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "We need to find distinct ages of students, so we will select the 'Age' column from the 'Student' table.", "We need to join the 'Student' table with the 'Voting_record' table on the 'StuID' column to access voting records for students.", "We are specifically interested in students who have voted for the secretary candidate, so we will check if 'Secretary_Vote' is not null.", "We also need to filter the results based on the election cycle, which is specified as 'fall'.", "Construct the SQL query using SELECT DISTINCT to get unique ages, joining the two tables, and applying the necessary filters."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Age \nFROM Student S \nJOIN Voting_record V ON S.StuID = V.StuID \nWHERE V.Secretary_Vote IS NOT NULL \nAND V.Election_Cycle = 'fall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"1\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n    \"2\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["Identify the relevant tables: We need to get information from the 'Student' table for advisors and the 'Voting_record' table for voting details.", "Determine the relationship: The 'StuID' in both tables will be used to join them together.", "Specify the condition: We are interested in students who have voted for a treasurer, which means we need to check if 'Treasurer_Vote' is not null.", "Filter by election cycle: We need to specify that we are looking for votes in the spring election cycle.", "Select distinct advisors: Since multiple students may have the same advisor, we will use DISTINCT to get a unique list of advisors."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Advisor FROM Student INNER JOIN Voting_record ON Student.StuID = Voting_record.StuID WHERE Voting_record.Treasurer_Vote IS NOT NULL AND Voting_record.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"1\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"2\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5486", "db_id": "voter_2", "question": "How many male (sex is M) students have class senator votes in the fall election cycle?", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "Determine the relevant columns: 'Sex' from 'Student' and 'Election_Cycle' from 'Voting_record'.", "Filter for male students (Sex = 'M') and the specific election cycle (fall).", "Count the number of records that meet these criteria using COUNT(*) function."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT COUNT(*) \nFROM Student s \nJOIN Voting_record v ON s.StuID = v.StuID \nWHERE s.Sex = 'M' \nAND v.Election_Cycle = 'fall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of students from the 'Student' table who are registered to vote in a specific election cycle and belong to a particular gender. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.\",\n    \"1\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"2\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "Determine the columns needed: average age from 'Student' and the secretary vote from 'Voting_record'.", "Establish the relationship between the tables using the foreign key: 'Voting_record.Secretary_Vote' corresponds to 'Student.StuID'.", "Apply the filters: city code must be 'NYC' and the election cycle must be 'spring'.", "Construct the SQL query to calculate the average age of students who meet the criteria."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(Age) AS Average_Age\nFROM Student\nJOIN Voting_record ON Student.StuID = Voting_record.Secretary_Vote\nWHERE Student.city_code = 'NYC' AND Voting_record.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n    \"1\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"2\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\"\n}\n"}
{"sample_id": "train.5492", "db_id": "voter_2", "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "Determine the condition for female students: 'Sex' = 'F'.", "Identify the voting record for the secretary candidate: 'Secretary_Vote'.", "Specify the election cycle as 'spring'.", "Join the 'Student' table with the 'Voting_record' table on the 'StuID' and 'Secretary_Vote' columns.", "Calculate the average age of the filtered results using AVG(Age)."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(Age) AS Average_Age\nFROM Student\nJOIN Voting_record ON Student.StuID = Voting_record.Secretary_Vote\nWHERE Student.Sex = 'F' AND Voting_record.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n    \"1\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"2\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\"\n}\n"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["Identify the relevant tables: We need to retrieve data from the Student table and the Voting_record table.", "Determine the columns needed: We need the distinct first names (Fname) of students, so we will select S.Fname.", "Establish the relationship between tables: We will join the Student table (S) with the Voting_record table (V) on the StuID column, which is common to both tables.", "Set the conditions for the query: We want students who have voted for the vice president, which means we need to check that the Vice_President_Vote column in the Voting_record table is not null.", "Additionally, we need to filter out students whose city code is 'PIT', so we will add a condition to exclude those records.", "Finally, we will use DISTINCT to ensure that we only get unique first names."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Fname \nFROM Student S \nJOIN Voting_record V ON S.StuID = V.StuID \nWHERE V.Vice_President_Vote IS NOT NULL \nAND S.city_code != 'PIT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5495", "db_id": "voter_2", "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?", "rationale": ["We need to find distinct first names of students who voted for the vice president.", "To do this, we will join the Student table with the Voting_record table on the StuID column, which is the unique identifier for students in both tables.", "We will filter the results to include only those records where the Vice_President_Vote is not null, indicating that the student has cast a vote for the vice president.", "Additionally, we will filter out students who reside in a city with the city code 'PIT' by adding a condition that city_code should not equal 'PIT'.", "Finally, we will select the distinct first names (Fname) from the resulting dataset."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Fname FROM Student JOIN Voting_record ON Student.StuID = Voting_record.StuID WHERE Vice_President_Vote IS NOT NULL AND city_code != 'PIT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"1\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5496", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is not 2192.", "rationale": ["Identify the relevant tables: Student and Voting_record.", "We need to find distinct last names (LName) of students, so we will select LName from the Student table.", "We need to join the Student table with the Voting_record table on the StuID column to access voting information.", "We need to filter the results to include only those students who have cast a vote for president (President_Vote IS NOT NULL).", "Additionally, we need to ensure that the advisor of the student is not '2192' (Advisor != '2192').", "Finally, we will use DISTINCT to ensure that we only get unique last names."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student JOIN Voting_record ON Student.StuID = Voting_record.StuID WHERE President_Vote IS NOT NULL AND Advisor != '2192';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"1\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5499", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes and have 8741 as the advisor?", "rationale": ["Identify the requirement to find distinct last names of students who voted for president and have a specific advisor.", "The relevant table for student information is 'Student', which contains the last names and advisor information.", "The 'Voting_record' table contains the voting information, specifically the 'President_Vote' column to check if a student voted for president.", "To find students who voted for president, we can use a subquery to select 'StuID' from 'Voting_record' where 'President_Vote' is not null.", "We then need to filter the 'Student' table to get distinct last names where the 'StuID' is in the result of the subquery and the 'Advisor' is '8741'.", "Combine these conditions into a single SQL query using SELECT DISTINCT to get the unique last names."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student WHERE StuID IN (SELECT StuID FROM Voting_record WHERE President_Vote IS NOT NULL) AND Advisor = '8741';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"1\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and sex.", "Filter the data: We need to focus on female students, so we will add a WHERE clause to filter by Sex = 'F'.", "Group the results: To find the most common major, we will group the results by the Major column.", "Count the occurrences: We will use COUNT(*) to count the number of students in each major.", "Order the results: We will order the results in descending order based on the count of students in each major.", "Limit the results: Since we only want the most common major, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as MajorCount \nFROM Student \nWHERE Sex = 'F' \nGROUP BY Major \nORDER BY MajorCount DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major field of study. The results are ordered by the number of students in each major in descending order, with a limit on the number of majors returned as specified by the placeholder.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are registered to vote in a specific election cycle and belong to a particular gender. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and gender.", "Filter for female students: We need to focus on female students, so we will add a WHERE clause to filter by 'Sex = 'Female' '.", "Group by major: To find out how many female students are in each major, we will use GROUP BY on the 'Major' column.", "Count the number of students in each major: We will use COUNT(*) to count the number of female students in each major.", "Order the results: We want the major with the most female students, so we will order the results in descending order by the count of students.", "Limit the results: Since we only want the major with the most female students, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major\nFROM Student\nWHERE Sex = 'Female'\nGROUP BY Major\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major field of study. The results are ordered by the number of students in each major in descending order, with a limit on the number of majors returned as specified by the placeholder.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are registered to vote in a specific election cycle and belong to a particular gender. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.\",\n    \"2\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\"\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories are needed to filter by product category and selling price.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to access the category descriptions.", "Filter the results to include only those products that belong to the 'Spices' category and have a typical selling price greater than 1000.", "Count the number of products that meet these criteria."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT COUNT(*) \nFROM Products \nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code \nWHERE Ref_Product_Categories.product_category_description = 'Spices' \nAND Products.typical_selling_price > 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"1\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\"\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the relevant tables: We need to get product category descriptions, so we will use the 'Ref_Product_Categories' table.", "Join the 'Products' table to link products with their categories using the 'product_category_code'.", "Filter the products based on their descriptions containing the letter 't' using the LIKE operator.", "Select distinct product category descriptions to avoid duplicates."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description \nFROM Ref_Product_Categories rpc \nJOIN Products p ON rpc.product_category_code = p.product_category_code \nWHERE p.product_description LIKE '%t%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"1\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\",\n    \"2\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\"\n}\n"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["Identify the tables involved: Products, Product_Characteristics, and Characteristics.", "We need to count distinct characteristic names, so we will use COUNT(DISTINCT ...) in the SELECT clause.", "Join the Products table with Product_Characteristics on product_id to link products with their characteristics.", "Join the Product_Characteristics table with Characteristics on characteristic_id to access characteristic names.", "Filter the results to only include the product with the name 'cumin' using a WHERE clause."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT c.characteristic_name) AS distinct_characteristic_count\nFROM Products p\nJOIN Product_Characteristics pc ON p.product_id = pc.product_id\nJOIN Characteristics c ON pc.characteristic_id = c.characteristic_id\nWHERE p.product_name = 'cumin';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"1\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n    \"2\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\"\n}\n"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["Identify the tables involved: Products, Ref_Colors, Product_Characteristics, and Characteristics.", "Determine the relationships between these tables using foreign keys: Products to Ref_Colors via color_code, Products to Product_Characteristics via product_id, and Product_Characteristics to Characteristics via characteristic_id.", "Use a LEFT JOIN to include all products, even if they do not have a matching color or characteristic.", "Filter the results in the WHERE clause to include products that are either described as 'white' in the Ref_Colors table or have a characteristic named 'hot' in the Characteristics table.", "Count the distinct product IDs to avoid counting the same product multiple times if it meets both criteria."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT p.product_id) \nFROM Products p \nLEFT JOIN Ref_Colors c ON p.color_code = c.color_code \nLEFT JOIN Product_Characteristics pc ON p.product_id = pc.product_id \nLEFT JOIN Characteristics ch ON pc.characteristic_id = ch.characteristic_id \nWHERE c.color_description = 'white' OR ch.characteristic_name = 'hot';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n    \"1\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"2\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\"\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: We need to find the unit of measure for 'Herb' products, which involves the 'Ref_Product_Categories' and 'Products' tables.", "Determine the relationship: The 'Products' table has a foreign key relationship with the 'Ref_Product_Categories' table through 'product_category_code'.", "Filter the products: We need to filter the products to only those that have 'Herb' in their name. This can be done using a LIKE clause in the WHERE condition.", "Select the unit of measure: Finally, we select the 'unit_of_measure' from the 'Ref_Product_Categories' table based on the filtered products."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT pc.unit_of_measure \nFROM Ref_Product_Categories pc \nJOIN Products p ON pc.product_category_code = p.product_category_code \nWHERE p.product_name LIKE '%Herb%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"1\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\"\n}\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the tables needed: We need the 'Products' table for product details and 'Ref_Product_Categories' for the unit of measurement and product category code.", "Determine the columns to select: We need 'product_category_code' from 'Ref_Product_Categories' and 'unit_of_measure' from 'Ref_Product_Categories'.", "Establish the join condition: The 'product_category_code' in 'Products' should match with 'product_category_code' in 'Ref_Product_Categories'.", "Add the filter condition: We need to filter the results where the product name is 'chervil'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT pc.product_category_code, p.unit_of_measure \nFROM Products p \nJOIN Ref_Product_Categories pc ON p.product_category_code = pc.product_category_code \nWHERE p.product_name = 'chervil';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"1\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\",\n    \"2\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\"\n}\n"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["Identify the relevant tables: Products and Ref_Colors are needed to get the color descriptions for products.", "Join the Products table with the Ref_Colors table on the color_code to access color descriptions.", "Group the results by color_description to count how many products correspond to each color.", "Order the results by the count of products in descending order to find the most common color.", "Limit the results to 1 to get the description of the color for the most products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT Ref_Colors.color_description\nFROM Products\nJOIN Ref_Colors ON Products.color_code = Ref_Colors.color_code\nGROUP BY Ref_Colors.color_description\nORDER BY COUNT(Products.product_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\",\n    \"1\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n    \"2\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["We need to find the description of the color used by the least number of products.", "To do this, we will join the 'Ref_Colors' table with the 'Products' table on the 'color_code' column.", "Next, we will group the results by 'color_code' to count how many products are associated with each color.", "We will then order the results in ascending order based on the count of products, so that the color with the least products comes first.", "Finally, we will limit the results to 1 to get only the color description used by the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT color_description FROM Ref_Colors\nJOIN Products ON Ref_Colors.color_code = Products.color_code\nGROUP BY Ref_Colors.color_code\nORDER BY COUNT(Products.product_id) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\",\n    \"1\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n    \"2\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To achieve this, we will join the 'Characteristics' table with the 'Product_Characteristics' table to link characteristics to products.", "Next, we will join the 'Products' table to get the product information associated with each characteristic.", "We will group the results by the characteristic name to count how many distinct products each characteristic is associated with.", "Finally, we will use the HAVING clause to filter the results to only include characteristics that are linked to two or more distinct products."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT c.characteristic_name\nFROM Characteristics c\nJOIN Product_Characteristics pc ON c.characteristic_id = pc.characteristic_id\nJOIN Products p ON pc.product_id = p.product_id\nGROUP BY c.characteristic_name\nHAVING COUNT(DISTINCT p.product_id) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\",\n    \"1\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"2\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\"\n}\n"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to query.", "Select the 'Builder' column: We want to list the builders, so we will select this column.", "Use DISTINCT to avoid duplicate entries: Since multiple railways can have the same builder, we will use DISTINCT to ensure each builder is listed only once.", "Order the results: We need the results in ascending alphabetical order, so we will use ORDER BY Builder ASC.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "pred_sql": "SELECT DISTINCT Builder FROM railway ORDER BY Builder ASC;", "hint": "\n"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["Identify the relevant tables: railway and train.", "We need to find the railway associated with the most trains, so we will join the railway table with the train table on the Railway_ID.", "We will group the results by Railway_ID and Builder to count the number of trains associated with each railway.", "Use COUNT(train.Train_ID) to count the number of trains for each railway.", "Order the results in descending order based on the count of trains to get the railway with the most trains at the top.", "Limit the results to 1 to get only the railway associated with the most trains."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "pred_sql": "SELECT railway.Railway_ID, railway.Builder\nFROM railway\nJOIN train ON railway.Railway_ID = train.Railway_ID\nGROUP BY railway.Railway_ID, railway.Builder\nORDER BY COUNT(train.Train_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["We need to find the most common builder of railways, which means we need to count how many railways each builder has constructed.", "To do this, we will select the 'Builder' column from the 'railway' table and count the occurrences of each builder using COUNT(*).", "We will group the results by 'Builder' to aggregate the counts for each builder.", "Next, we will order the results in descending order based on the count of railways built (BuilderCount).", "Finally, we will limit the results to just one entry to get the most common builder."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "pred_sql": "SELECT Builder, COUNT(*) as BuilderCount \nFROM railway \nGROUP BY Builder \nORDER BY BuilderCount DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["Identify the table to query: The relevant table is 'Student' as we need the last names of students.", "Determine the conditions for selection: We need students who are either female, live in a city with the code 'BAL', or are male and under 20 years old.", "Construct the WHERE clause: The conditions can be combined using OR operators. The first condition checks for females, the second checks for the city code, and the third checks for males under 20.", "Select the required column: We only need the last names, so we will select 'LName'.", "Combine all parts into a full SQL query: The final query selects 'LName' from 'Student' where the specified conditions are met."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "pred_sql": "SELECT LName FROM Student WHERE (Sex = 'Female') OR (city_code = 'BAL') OR (Sex = 'Male' AND Age < '20');", "hint": "\n"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["Identify the tables involved: Dorm and Has_amenity.", "We need to count the number of amenities for each dormitory, so we will use COUNT() on the amenid from the Has_amenity table.", "We need to filter dorms that can accommodate more than 100 students, which is done using a WHERE clause on the student_capacity column in the Dorm table.", "To get the names of the dorms along with the count of amenities, we will select Dorm.dorm_name and the count of amenities.", "We will group the results by Dorm.dormid and Dorm.dorm_name to ensure we get the count of amenities for each dormitory."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "pred_sql": "SELECT Dorm.dorm_name, COUNT(Has_amenity.amenid) AS amenity_count\nFROM Dorm\nJOIN Has_amenity ON Dorm.dormid = Has_amenity.dormid\nWHERE Dorm.student_capacity > 100\nGROUP BY Dorm.dormid, Dorm.dorm_name;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\",\n    \"1\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\"\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables needed: Student, Lives_in, and Dorm.", "We need to count the total number of students, so we will use the COUNT() function.", "Join the Student table with the Lives_in table on the student ID (StuID) to find out where each student lives.", "Join the resulting table with the Dorm table on the dorm ID to access the gender of the dorm.", "Filter the results to include only those dorms that are designated for males (gender = 'male').", "Select the count of students from the filtered results."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(*) AS total_students\nFROM Student s\nJOIN Lives_in l ON s.StuID = l.stuid\nJOIN Dorm d ON l.dormid = d.dormid\nWHERE d.gender = 'male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\",\n    \"1\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\"\n}\n"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["Identify the tables involved: Student, Lives_in, Dorm, and Has_amenity.", "We need to find students' first names who live in the dorm with the most amenities.", "Join the Student table with the Lives_in table to link students to their dorms.", "Create a subquery that counts the number of amenities for each dorm by joining the Dorm and Has_amenity tables.", "Group the results of the subquery by dormid and order them by the count of amenities in descending order.", "Limit the subquery to return only the dorm with the highest count of amenities.", "Join the result of the subquery back to the Lives_in table to filter for students living in that dorm.", "Select the first names of those students."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT S.Fname \nFROM Student S \nJOIN Lives_in L ON S.StuID = L.stuid \nJOIN (\n    SELECT D.dormid \n    FROM Dorm D \n    JOIN Has_amenity HA ON D.dormid = HA.dormid \n    GROUP BY D.dormid \n    ORDER BY COUNT(HA.amenid) DESC \n    LIMIT 1\n) AS MostAmenities ON L.dormid = MostAmenities.dormid;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\",\n    \"1\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\"\n}\n"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["Identify the required fields: first name and age of students.", "Determine the relevant tables: Student, Lives_in, Dorm, Has_amenity, and Dorm_amenity.", "Establish relationships between tables: Students live in dorms, dorms have amenities.", "Join the Student table with Lives_in to find which students live in which dorms.", "Join the Dorm table to access dorm details and amenities.", "Join the Has_amenity and Dorm_amenity tables to filter for dorms that have a specific amenity, in this case, 'TV Lounge'.", "Use a WHERE clause to filter the results to only include dorms with a 'TV Lounge'."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "pred_sql": "SELECT Student.Fname, Student.Age \nFROM Student \nJOIN Lives_in ON Student.StuID = Lives_in.stuid \nJOIN Dorm ON Lives_in.dormid = Dorm.dormid \nJOIN Has_amenity ON Dorm.dormid = Has_amenity.dormid \nJOIN Dorm_amenity ON Has_amenity.amenid = Dorm_amenity.amenid \nWHERE Dorm_amenity.amenity_name = 'TV Lounge';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\",\n    \"1\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\"\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the main goal: Retrieve the email addresses of customers who have filed complaints about the product with the greatest number of complaints.", "To find the product with the greatest number of complaints, a subquery is needed that counts complaints grouped by product_id and orders them in descending order, limiting the result to the top product.", "Join the Customers table with the Complaints table on customer_id to access customer email addresses related to the complaints.", "Use the result of the subquery to filter the complaints to only those related to the product with the highest complaint count."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address\nFROM Customers c\nJOIN Complaints comp ON c.customer_id = comp.customer_id\nWHERE comp.product_id = (\n    SELECT product_id\n    FROM Complaints\n    GROUP BY product_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["Identify the products that have been complained about by customers.", "We need to find the customer who has filed the least amount of complaints.", "To do this, we can use a subquery that groups complaints by customer_id and counts them, ordering by the count in ascending order.", "The subquery will return the customer_id of the customer with the least complaints.", "We then join the Products table with the Complaints table on product_id to get the relevant product details for the identified customer."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT p.product_id, p.product_name \nFROM Products p \nJOIN Complaints c ON p.product_id = c.product_id \nWHERE c.customer_id = (\n    SELECT customer_id \n    FROM Complaints \n    GROUP BY customer_id \n    ORDER BY COUNT(complaint_id) ASC \n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the relevant tables: Complaints, Products, and Staff.", "We need to find the product with the lowest price, so we will use a subquery to get the minimum product price from the Products table.", "Next, we need to join the Complaints table with the Products table to link complaints to their respective products.", "We also need to join the Complaints table with the Staff table to find out which staff member is handling the complaint.", "Finally, we will select the last name of the staff member where the product price matches the lowest price found in the subquery."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT Staff.last_name \nFROM Complaints \nJOIN Products ON Complaints.product_id = Products.product_id \nJOIN Staff ON Complaints.staff_id = Staff.staff_id \nWHERE Products.product_price = (SELECT MIN(product_price) FROM Products);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["Identify the relevant table: The Complaints table contains the complaint status information.", "Determine the required fields: We need the complaint status code and the count of records for each status.", "Group the results: Use GROUP BY to aggregate the records by complaint status code.", "Filter the results: Use HAVING to filter out complaint statuses that have 3 or fewer records."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "pred_sql": "SELECT complaint_status_code, COUNT(*) as complaint_count \nFROM Complaints \nGROUP BY complaint_status_code \nHAVING COUNT(*) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["Identify the need to count customers based on their type.", "Use the Customers table to access customer_type_code and customer_id.", "Group the results by customer_type_code to get the count of customers for each type.", "Order the results in descending order based on the count of customers to find the most common type.", "Limit the results to 1 to get only the most common customer type."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT customer_type_code, COUNT(customer_id) AS customer_count \nFROM Customers \nGROUP BY customer_type_code \nORDER BY customer_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.\",\n    \"1\": \"This virtual table summarizes the states where customers reside, grouping the results by state and ordering them by the number of customers in each state. The placeholder in the LIMIT clause allows for specifying the maximum number of states to return.\",\n    \"2\": \"This virtual table summarizes the states where customers reside, grouping the results by state and ordering them by the number of customers in each state. The placeholder in the LIMIT clause allows for specifying the maximum number of states to return.\"\n}\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the goal: We need the first names of the top 5 staff members who have handled the greatest number of complaints.", "To achieve this, we will need to count the number of complaints handled by each staff member.", "We will use the Complaints table to group by staff_id and count the number of complaints for each staff member.", "Next, we will order the results in descending order based on the count of complaints to get the top staff members.", "Finally, we will limit the results to the top 5 staff members and select their first names from the Staff table."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Complaints GROUP BY staff_id ORDER BY COUNT(complaint_id) DESC LIMIT 5);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["We need to return the first names of staff members who have handled the most complaints.", "To find out which staff members handled the most complaints, we will need to count the number of complaints associated with each staff member.", "We can achieve this by using a subquery that selects the staff_id from the Complaints table, grouping by staff_id and ordering by the count of complaint_id in descending order.", "We will limit the results of this subquery to the top 5 staff members with the most complaints.", "Finally, we will select the first names of these staff members from the Staff table using the staff_ids obtained from the subquery."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Complaints GROUP BY staff_id ORDER BY COUNT(complaint_id) DESC LIMIT 5);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The user wants to see all investor details, which means we need to select all columns from the Investors table.", "The SQL command to retrieve all columns from a table is 'SELECT *'.", "The table we are interested in is 'Investors'.", "Therefore, the full SQL query is 'SELECT * FROM Investors'."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "pred_sql": "SELECT * FROM Investors;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\"\n}\n"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["We need to show details of all investors who have made transactions with a share count greater than 100.", "To do this, we will select the investor_id and Investor_details from the Investors table.", "We will join the Investors table with the Transactions table on the investor_id to link investors with their transactions.", "We will apply a WHERE clause to filter transactions where the share_count is greater than 100.", "Using DISTINCT ensures that we do not have duplicate investor entries in the result."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "pred_sql": "SELECT DISTINCT Investors.investor_id, Investors.Investor_details \nFROM Investors \nJOIN Transactions ON Investors.investor_id = Transactions.investor_id \nWHERE Transactions.share_count > 100;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\"\n}\n"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["Identify the relevant tables: Lots, Transactions, and Transactions_Lots are needed to get lot details associated with transactions.", "Use JOIN to connect Lots with Transactions through Transactions_Lots, as it links transactions to lots.", "Filter the results using a WHERE clause to only include transactions where the share count is less than 50.", "Select the lot details from the Lots table based on the filtered transactions."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT Lots.lot_details \nFROM Lots \nJOIN Transactions_Lots ON Lots.lot_id = Transactions_Lots.lot_id \nJOIN Transactions ON Transactions_Lots.transaction_id = Transactions.transaction_id \nWHERE Transactions.share_count < 50;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n    \"1\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\"\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["Identify the relevant tables: Transactions and Ref_Transaction_Types.", "We need to calculate the average transaction amount, so we will use the AVG() function on the amount_of_transaction column from the Transactions table.", "To categorize the average amounts by transaction types, we will join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code.", "We will group the results by transaction_type_description to get the average for each type.", "Finally, we will select the transaction type description and the calculated average transaction amount."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\"\n}\n"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["Identify the relevant tables: Transactions and Ref_Transaction_Types are needed to get transaction types and their share counts.", "Join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to get descriptions of each transaction type.", "Use aggregate functions MAX() and MIN() to find the maximum and minimum share counts for each transaction type.", "Group the results by transaction_type_description to get the max and min share counts for each type."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, MAX(t.share_count) AS max_share_count, MIN(t.share_count) AS min_share_count\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\",\n    \"1\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\"\n}\n"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["Identify the tables involved: Sales and Purchases.", "Determine the columns needed: sales_transaction_id and sales_details from Sales, purchase_transaction_id and purchase_details from Purchases.", "Since we want details of all sales and purchases, a FULL OUTER JOIN is appropriate to include all records from both tables, even if there are no matches.", "Construct the SQL query to select the required columns from both tables using the FULL OUTER JOIN."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "pred_sql": "SELECT Sales.sales_transaction_id, Sales.sales_details, Purchases.purchase_transaction_id, Purchases.purchase_details\nFROM Sales\nFULL OUTER JOIN Purchases ON Sales.sales_transaction_id = Purchases.purchase_transaction_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n    \"1\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\"\n}\n"}
{"sample_id": "train.5898", "db_id": "cre_Theme_park", "question": "What is the average price range of five star hotels that allow pets?", "rationale": ["Identify the relevant table: The 'Hotels' table contains information about hotel star ratings and whether pets are allowed.", "Determine the criteria: We need to filter for five-star hotels (star_rating_code = '5') and those that allow pets (pets_allowed_yn = 'Yes').", "Calculate the average price range: Use the AVG() function to calculate the average of the price_range column for the filtered hotels.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter the results accordingly."], "gold_sql": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  '5' AND pets_allowed_yn  =  1", "source_tables": ["hotels"], "pred_sql": "SELECT AVG(price_range) AS average_price_range\nFROM Hotels\nWHERE star_rating_code = '5' AND pets_allowed_yn = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average price range of hotels from the 'Hotels' table that meet specific criteria. The placeholders in the WHERE clause represent the star rating code and whether pets are allowed, allowing users to specify their desired conditions.\",\n    \"1\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n    \"2\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\"\n}\n"}
{"sample_id": "train.5904", "db_id": "cre_Theme_park", "question": "Find all the locations whose names contain the word \"film\".", "rationale": ["Identify the table that contains location names: Locations.", "Determine the column that holds the names of the locations: Location_Name.", "Use the SQL SELECT statement to retrieve all columns from the Locations table.", "Apply a WHERE clause to filter the results where Location_Name contains the word 'film'.", "Use the LIKE operator with wildcards '%' to match any location names that include 'film'."], "gold_sql": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE '%film%'", "source_tables": ["locations"], "pred_sql": "SELECT * FROM Locations WHERE Location_Name LIKE '%film%';", "hint": "\n"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["Identify the relevant table: Museums, which contains details about museums and their opening hours.", "Select the columns needed: Museum_ID for unique identification, Museum_Details for the description of the museum, and Opening_Hours for the hours during which the museum is open.", "Construct the SQL query to retrieve the selected columns from the Museums table."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT Museum_ID, Museum_Details, Opening_Hours FROM Museums;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n    \"1\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n    \"2\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5916", "db_id": "cre_Theme_park", "question": "Give me the detail and opening hour for each museum.", "rationale": ["Identify the relevant table: Museums, which contains details about museums and their opening hours.", "Select the columns needed: Museum_ID for unique identification, Museum_Details for the description, and Opening_Hours for the hours during which the museum is open.", "Construct the SQL query to retrieve the selected columns from the Museums table."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT Museum_ID, Museum_Details, Opening_Hours FROM Museums;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n    \"1\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n    \"2\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Royal_Family.", "Determine the relationship between the tables: Tourist_Attractions has a foreign key linking to Royal_Family.", "Select the desired columns: Name, Description, How_to_Get_There, and Other_Details from Tourist_Attractions.", "Join the Tourist_Attractions table with the Royal_Family table on the appropriate foreign key.", "Construct the SQL query to retrieve the required details about tourist attractions related to the royal family."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name, Tourist_Attractions.Description, Tourist_Attractions.How_to_Get_There, Tourist_Attractions.Other_Details \nFROM Tourist_Attractions \nJOIN Royal_Family ON Tourist_Attractions.Tourist_Attraction_ID = Royal_Family.Royal_Family_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n    \"1\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n    \"2\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5923", "db_id": "cre_Theme_park", "question": "What are the details of the shops that can be accessed by walk?", "rationale": ["Identify the relevant tables: Shops and Tourist_Attractions are needed to get shop details and their access methods.", "Determine the relationship: Shops are linked to Tourist_Attractions through the Shop_ID and Tourist_Attraction_ID.", "Filter the results: We need to find shops that can be accessed by walking, which is indicated in the How_to_Get_There column of the Tourist_Attractions table.", "Construct the SQL query: Use a SELECT statement to retrieve Shop_ID and Shop_Details from the Shops table, joining it with the Tourist_Attractions table, and applying a WHERE clause to filter for walking access."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "pred_sql": "SELECT Shops.Shop_ID, Shops.Shop_Details \nFROM Shops \nJOIN Tourist_Attractions ON Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Tourist_Attractions.How_to_Get_There LIKE '%walk%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n    \"1\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n    \"2\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5931", "db_id": "cre_Theme_park", "question": "Which tourist attractions does the visitor with detail 'Vincent' visit?", "rationale": ["Identify the relevant tables: We need to find tourist attractions visited by a specific visitor, so we will use the Visits, Tourist_Attractions, and Visitors tables.", "Determine the relationships: The Visits table links tourists to the attractions they visited, and the Visitors table contains details about the tourists.", "Construct the SQL query: We will select the names of the tourist attractions from the Tourist_Attractions table, joining it with the Visits table on the Tourist_Attraction_ID, and then joining with the Visitors table on the Tourist_ID.", "Filter the results: We will filter the results to only include visits by the visitor with the detail 'Vincent' using a WHERE clause."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name \nFROM Visits \nJOIN Tourist_Attractions ON Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID \nJOIN Visitors ON Visits.Tourist_ID = Visitors.Tourist_ID \nWHERE Visitors.Tourist_Details = 'Vincent';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n    \"1\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n    \"2\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5932", "db_id": "cre_Theme_park", "question": "Show the tourist attractions visited by the tourist whose detail is 'Vincent'.", "rationale": ["Identify the tables needed: We need to find tourist attractions visited by a specific tourist, so we will use the Visits, Visitors, and Tourist_Attractions tables.", "Determine the relationships: The Visits table links tourists to the attractions they visited, and the Visitors table contains details about the tourists.", "Select relevant columns: We want to retrieve the name and description of the tourist attractions, as well as the visit date.", "Construct the SQL query: We will join the Visits table with the Visitors table to filter by the tourist's details, and then join with the Tourist_Attractions table to get the attraction details. We will filter the results where the tourist's details match 'Vincent'."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name, Tourist_Attractions.Description, Visits.Visit_Date \nFROM Visits \nJOIN Visitors ON Visits.Tourist_ID = Visitors.Tourist_ID \nJOIN Tourist_Attractions ON Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Visitors.Tourist_Details = 'Vincent';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n    \"1\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n    \"2\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5941", "db_id": "cre_Theme_park", "question": "Show the details of the top 3 most expensive hotels.", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "Determine the requirement to show the top 3 most expensive hotels, which implies sorting by the 'price_range' column in descending order.", "Use the SQL 'ORDER BY' clause to sort the results by 'price_range' in descending order.", "Limit the results to the top 3 entries using the 'LIMIT' clause."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n    \"1\": \"This virtual table calculates the average price range of hotels from the 'Hotels' table that meet specific criteria. The placeholders in the WHERE clause represent the star rating code and whether pets are allowed, allowing users to specify their desired conditions.\",\n    \"2\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\"\n}\n"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the relevant table: The Hotels table contains the details of hotels, including their price range.", "Determine the sorting criteria: We need to find the three most expensive hotels, so we will order the results by the price_range column in descending order.", "Limit the results: To get only the top three hotels, we will use the LIMIT clause with a value of 3."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n    \"1\": \"This virtual table calculates the average price range of hotels from the 'Hotels' table that meet specific criteria. The placeholders in the WHERE clause represent the star rating code and whether pets are allowed, allowing users to specify their desired conditions.\",\n    \"2\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\"\n}\n"}
{"sample_id": "train.5944", "db_id": "cre_Theme_park", "question": "What are the details and star ratings of the three hotels with the lowest price ranges?", "rationale": ["Identify the relevant tables: Hotels and Ref_Hotel_Star_Ratings are needed to get hotel details and their star ratings.", "Select the necessary columns: We need hotel details (hotel_id, other_hotel_details) and star rating description (star_rating_description).", "Join the Hotels table with the Ref_Hotel_Star_Ratings table on the star_rating_code to get the star rating descriptions for each hotel.", "Order the results by price_range in ascending order to get the hotels with the lowest price ranges first.", "Limit the results to 3 to get only the three hotels with the lowest price ranges."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT h.hotel_id, h.other_hotel_details, r.star_rating_description \nFROM Hotels h \nJOIN Ref_Hotel_Star_Ratings r ON h.star_rating_code = r.star_rating_code \nORDER BY h.price_range ASC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n    \"1\": \"This virtual table calculates the average price range of hotels from the 'Hotels' table that meet specific criteria. The placeholders in the WHERE clause represent the star rating code and whether pets are allowed, allowing users to specify their desired conditions.\",\n    \"2\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\"\n}\n"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["Identify the relevant table: The question pertains to how people get to tourist attractions, which is related to the 'Tourist_Attractions' table and specifically the 'How_to_Get_There' column.", "Count the occurrences of each transportation method: We need to group the results by 'How_to_Get_There' to count how many times each method is mentioned.", "Order the results: To find the most popular method, we will order the results in descending order based on the count of each method.", "Limit the results: Since we only want the most chosen method, we will limit the results to 1."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Method_Count\nFROM Tourist_Attractions\nGROUP BY How_to_Get_There\nORDER BY Method_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n    \"1\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\"\n}\n"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant table: The question pertains to transportation methods used to reach tourist attractions, which is detailed in the 'How_to_Get_There' column of the 'Tourist_Attractions' table.", "Count occurrences: We need to count how many times each transportation method appears, which can be achieved using the COUNT() function.", "Group by method: To get the count for each unique transportation method, we will use GROUP BY on the 'How_to_Get_There' column.", "Order by count: To find the most frequently used method, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most used method, we will limit the results to 1."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Method_Count\nFROM Tourist_Attractions\nGROUP BY How_to_Get_There\nORDER BY Method_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n    \"1\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\"\n}\n"}
{"sample_id": "train.5955", "db_id": "cre_Theme_park", "question": "Show the names and ids of tourist attractions that are visited at most once.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Visits.", "We need to find tourist attractions that have been visited at most once, so we will join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID.", "Use a LEFT JOIN to ensure we include attractions that have never been visited (i.e., no entries in the Visits table).", "Group the results by Tourist_Attraction_ID to aggregate the visit counts for each attraction.", "Use the HAVING clause to filter the grouped results to include only those attractions that have a visit count of 1 or less."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT ta.Name, ta.Tourist_Attraction_ID\nFROM Tourist_Attractions ta\nLEFT JOIN Visits v ON ta.Tourist_Attraction_ID = v.Tourist_Attraction_ID\nGROUP BY ta.Tourist_Attraction_ID\nHAVING COUNT(v.Visit_ID) <= 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n    \"1\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\"\n}\n"}
{"sample_id": "train.5956", "db_id": "cre_Theme_park", "question": "What are the names and ids of the tourist attractions that are visited at most once?", "rationale": ["Identify the relevant tables: Tourist_Attractions and Visits.", "We need to find tourist attractions that have been visited at most once, so we will join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID.", "Use a LEFT JOIN to ensure we include attractions that may not have any visits.", "Group the results by Tourist_Attraction_ID to aggregate the visit counts for each attraction.", "Use the HAVING clause to filter the grouped results to only include attractions with a visit count of 0 or 1."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT ta.Name, ta.Tourist_Attraction_ID \nFROM Tourist_Attractions ta \nLEFT JOIN Visits v ON ta.Tourist_Attraction_ID = v.Tourist_Attraction_ID \nGROUP BY ta.Tourist_Attraction_ID \nHAVING COUNT(v.Visit_ID) <= 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n    \"1\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\"\n}\n"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find the names of tourist attractions that have specific features (parking or shopping).", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions with their features.", "Then, join the Features table to get the details of those features.", "Use a WHERE clause to filter the results to only include features that are either 'parking' or 'shopping'.", "Select the Name of the tourist attractions that meet the criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT Tourist_Attractions.Name \nFROM Tourist_Attractions \nJOIN Tourist_Attraction_Features ON Tourist_Attractions.Tourist_Attraction_ID = Tourist_Attraction_Features.Tourist_Attraction_ID \nJOIN Features ON Tourist_Attraction_Features.Feature_ID = Features.Feature_ID \nWHERE Features.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n    \"1\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n    \"2\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find the names of tourist attractions that have specific features (parking or shopping).", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table on the Tourist_Attraction_ID to link attractions with their features.", "Then, join the Features table to get the details of those features.", "Use a WHERE clause to filter the results to only include features that are either 'parking' or 'shopping'.", "Select the Name of the tourist attractions that meet these criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT ta.Name\nFROM Tourist_Attractions ta\nJOIN Tourist_Attraction_Features taf ON ta.Tourist_Attraction_ID = taf.Tourist_Attraction_ID\nJOIN Features f ON taf.Feature_ID = f.Feature_ID\nWHERE f.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n    \"1\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n    \"2\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5963", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions Vincent and Marcelle visit?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Visits, and Visitors are needed to find the names of attractions visited by specific tourists.", "Join the Visits table with the Tourist_Attractions table on the Tourist_Attraction_ID to link visits to their respective attractions.", "Join the Visitors table with the Visits table on the Tourist_ID to link visits to the tourists.", "Filter the results to include only those records where the Tourist_Details in the Visitors table match 'Vincent' or 'Marcelle'.", "Select the Name column from the Tourist_Attractions table to get the names of the attractions visited by these tourists."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name \nFROM Tourist_Attractions \nJOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID \nJOIN Visitors ON Visits.Tourist_ID = Visitors.Tourist_ID \nWHERE Visitors.Tourist_Details IN ('Vincent', 'Marcelle');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n    \"1\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\"\n}\n"}
{"sample_id": "train.5985", "db_id": "game_1", "question": "Which game type has most number of games?", "rationale": ["Identify the table that contains the game types, which is the 'Video_Games' table.", "We need to count the number of games for each game type, so we will use the COUNT() function.", "Group the results by the game type using GROUP BY GType.", "To find out which game type has the most games, we will order the results in descending order based on the count of games.", "Finally, we will limit the results to only the top entry using LIMIT 1."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType, COUNT(GameID) AS NumberOfGames\nFROM Video_Games\nGROUP BY GType\nORDER BY NumberOfGames DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the types or genres of video games from the 'Video_Games' table, grouped by their type. The placeholder in the LIMIT clause allows the user to specify the maximum number of genres to retrieve, sorted by the number of games in each genre in descending order.\",\n    \"1\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\",\n    \"2\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\"\n}\n"}
{"sample_id": "train.5988", "db_id": "game_1", "question": "What is the type with the fewest games?", "rationale": ["Identify the table that contains the types of video games, which is the 'Video_Games' table.", "We need to count the number of games for each type, so we will use the COUNT() function on 'GameID'.", "We will group the results by 'GType' to get the count for each type of game.", "To find the type with the fewest games, we will order the results in ascending order based on the count of games.", "Finally, we will limit the results to 1 to get only the type with the fewest games."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType, COUNT(GameID) AS NumberOfGames\nFROM Video_Games\nGROUP BY GType\nORDER BY NumberOfGames ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the types or genres of video games from the 'Video_Games' table, grouped by their type. The placeholder in the LIMIT clause allows the user to specify the maximum number of genres to retrieve, sorted by the number of games in each genre in descending order.\",\n    \"1\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\",\n    \"2\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\"\n}\n"}
{"sample_id": "train.6001", "db_id": "game_1", "question": "How many students play sports?", "rationale": ["The question asks for the number of students who play sports.", "To find this, we need to count the unique student identifiers (StuID) from the SportsInfo table, as this table contains information about students participating in sports.", "Using COUNT(DISTINCT StuID) ensures that we only count each student once, even if they play multiple sports."], "gold_sql": "SELECT count(DISTINCT StuID) FROM Sportsinfo", "source_tables": ["sportsinfo"], "pred_sql": "SELECT COUNT(DISTINCT StuID) AS TotalStudentsPlayingSports FROM SportsInfo;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n    \"1\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\"\n}\n"}
{"sample_id": "train.6003", "db_id": "game_1", "question": "List ids for all student who are on scholarship.", "rationale": ["Identify the relevant table: SportsInfo contains information about students involved in sports and their scholarship status.", "Determine the condition: We need to filter students who are on a sports scholarship, which is indicated by the 'OnScholarship' column.", "Construct the SQL query: We will select the 'StuID' from the SportsInfo table where 'OnScholarship' is 'Yes'."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\"\n}\n"}
{"sample_id": "train.6004", "db_id": "game_1", "question": "What are the ids for all sporty students who are on scholarship?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Focus on the requirement: We need to find students who are on a sports scholarship.", "Use the WHERE clause to filter students based on the OnScholarship column, specifically looking for those marked as 'Yes'.", "Select the StuID column to get the unique identifiers of these students."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n    \"1\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\"\n}\n"}
{"sample_id": "train.6006", "db_id": "game_1", "question": "What are the last names for all scholarship students?", "rationale": ["Identify the relevant table: We need to find last names of students who are on a sports scholarship, so we will use the Student and SportsInfo tables.", "Join the tables: We will join the Student table with the SportsInfo table on the StuID column to get the necessary information about the students and their scholarship status.", "Filter for scholarship students: We will add a WHERE clause to filter the results to only include students who are on a scholarship, indicated by the OnScholarship column being 'Yes'.", "Select the last names: Finally, we will select the LName column from the Student table to get the last names of the scholarship students."], "gold_sql": "SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT Student.LName \nFROM Student \nJOIN SportsInfo ON Student.StuID = SportsInfo.StuID \nWHERE SportsInfo.OnScholarship = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\"\n}\n"}
{"sample_id": "train.6010", "db_id": "game_1", "question": "What is the total number of all football games played by scholarship students?", "rationale": ["Identify the relevant table: SportsInfo contains information about sports participation.", "Determine the specific sport: The question asks about football games.", "Filter for scholarship students: We need to include only those students who are on a sports scholarship, indicated by the OnScholarship column.", "Use the SUM function: To get the total number of games played, we will sum the GamesPlayed column for the filtered results."], "gold_sql": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  'Football' AND onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SUM(GamesPlayed) AS TotalGamesPlayed\nFROM SportsInfo\nWHERE SportName = 'Football' AND OnScholarship = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n    \"1\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\"\n}\n"}
{"sample_id": "train.6014", "db_id": "game_1", "question": "What are the ids of all students along with how many sports and games did they play?", "rationale": ["Identify the tables needed: We need data from the Student, SportsInfo, and Plays_Games tables.", "We want to count the number of sports and games played by each student, so we will use COUNT() function.", "We will use LEFT JOIN to include all students even if they haven't played any games or participated in any sports.", "We will group the results by Student ID to get the counts for each student individually."], "gold_sql": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID", "source_tables": ["sportsinfo"], "pred_sql": "SELECT Student.StuID, COUNT(DISTINCT SportsInfo.SportName) AS TotalSports, COUNT(DISTINCT Plays_Games.GameID) AS TotalGames\nFROM Student\nLEFT JOIN SportsInfo ON Student.StuID = SportsInfo.StuID\nLEFT JOIN Plays_Games ON Student.StuID = Plays_Games.StuID\nGROUP BY Student.StuID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n    \"1\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\"\n}\n"}
{"sample_id": "train.6019", "db_id": "game_1", "question": "Which sport has most number of students on scholarship?", "rationale": ["Identify the relevant table: The 'SportsInfo' table contains information about students participating in sports and their scholarship status.", "Filter for students on scholarship: We need to include only those students who are on a sports scholarship, which is indicated by the 'OnScholarship' column.", "Group by sport: To find out how many students are on scholarship for each sport, we will group the results by 'SportName'.", "Count the number of students: We will count the number of unique 'StuID' entries for each sport to determine how many students are on scholarship for that sport.", "Order the results: To find the sport with the most students on scholarship, we will order the results in descending order based on the count of students.", "Limit the results: Since we only want the sport with the most students, we will limit the results to 1."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName, COUNT(StuID) AS NumberOfStudents\nFROM SportsInfo\nWHERE OnScholarship = 'Yes'\nGROUP BY SportName\nORDER BY NumberOfStudents DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n    \"1\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\"\n}\n"}
{"sample_id": "train.6020", "db_id": "game_1", "question": "What is the sport with the most scholarship students?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Filter the records to include only those students who are on a sports scholarship by using the condition 'OnScholarship = 'Yes' in the WHERE clause.", "Group the results by SportName to count the number of scholarship students in each sport using COUNT(*) and GROUP BY.", "Order the results in descending order based on the count of scholarship students to find the sport with the most scholarship students using ORDER BY ScholarshipCount DESC.", "Limit the results to only the top entry using LIMIT 1 to get the sport with the most scholarship students."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName, COUNT(*) AS ScholarshipCount\nFROM SportsInfo\nWHERE OnScholarship = 'Yes'\nGROUP BY SportName\nORDER BY ScholarshipCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n    \"1\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\"\n}\n"}
{"sample_id": "train.6024", "db_id": "game_1", "question": "What are the student ids for those on scholarship in major number 600?", "rationale": ["Identify the requirement: We need to find student IDs of those who are on a sports scholarship and have a specific major (number 600).", "The relevant table for scholarship information is 'SportsInfo', which contains the 'OnScholarship' column.", "We also need to filter students based on their major, which is found in the 'Student' table.", "To achieve this, we will use a subquery to first select the student IDs from the 'Student' table where the Major is '600'.", "Then, we will filter the 'SportsInfo' table to find those students who are on a scholarship (OnScholarship = 'Yes').", "Finally, we will combine these conditions to get the desired student IDs."], "gold_sql": "SELECT StuID FROM Student WHERE major  =  600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes' AND StuID IN (SELECT StuID FROM Student WHERE Major = '600');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\"\n}\n"}
{"sample_id": "train.6025", "db_id": "game_1", "question": "Show student ids who are female and play football.", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for student information and the 'SportsInfo' table for sports participation.", "We need to filter students based on gender, specifically females, which is found in the 'Sex' column of the 'Student' table.", "We also need to filter students who play football, which is found in the 'SportName' column of the 'SportsInfo' table.", "To get the student IDs, we will select 'StuID' from the 'Student' table.", "We will use a JOIN operation to combine the 'Student' and 'SportsInfo' tables on the 'StuID' column, ensuring we only get students who are involved in sports.", "Finally, we will apply the WHERE clause to filter for female students and those who play football."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN SportsInfo ON Student.StuID = SportsInfo.StuID \nWHERE Student.Sex = 'Female' AND SportsInfo.SportName = 'Football';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n    \"1\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\"\n}\n"}
{"sample_id": "train.6026", "db_id": "game_1", "question": "What are the ids of all female students who play football?", "rationale": ["Identify the relevant tables: We need to get information from the Student and SportsInfo tables.", "Determine the criteria: We are looking for female students who play football.", "Join the tables: We will join the Student table with the SportsInfo table on the StuID column to get the necessary information about students and their sports participation.", "Filter the results: We will filter the results to include only female students and those who play football."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN SportsInfo ON Student.StuID = SportsInfo.StuID \nWHERE Student.Sex = 'Female' AND SportsInfo.SportName = 'Football';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n    \"1\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\"\n}\n"}
{"sample_id": "train.6028", "db_id": "game_1", "question": "What are the ids of all male students who do not play football?", "rationale": ["Identify the target group: male students.", "Filter the Student table for male students by checking the 'Sex' column.", "To find male students who do not play football, we need to exclude those who are in the SportsInfo table with 'SportName' as 'Football'.", "Use a subquery to select all StuID from SportsInfo where SportName is 'Football'.", "Combine the conditions using NOT IN to filter out those students from the main query."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male' AND StuID NOT IN (SELECT StuID FROM SportsInfo WHERE SportName = 'Football');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n    \"1\": \"This virtual table summarizes the total hours per week and total games played by students from the 'SportsInfo' table who are younger than a specified age. The placeholders in the SELECT statement represent the aggregated values for hours and games, while the WHERE clause uses a placeholder for the age limit.\"\n}\n"}
{"sample_id": "train.6060", "db_id": "customers_and_addresses", "question": "Find the average order quantity per order.", "rationale": ["Identify the relevant table for order quantities, which is the 'Order_Items' table.", "To find the average order quantity, we need to use the AVG() function on the 'order_quantity' column.", "The query will select the average of the 'order_quantity' from the 'Order_Items' table."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "pred_sql": "SELECT AVG(order_quantity) AS average_order_quantity\nFROM Order_Items;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\"\n}\n"}
{"sample_id": "train.6071", "db_id": "customers_and_addresses", "question": "What are the details of all products?", "rationale": ["The user wants to retrieve details of all products.", "To get all details from the 'Products' table, a simple SELECT statement is sufficient.", "Using SELECT * will return all columns from the Products table."], "gold_sql": "SELECT DISTINCT product_details FROM products", "source_tables": ["products"], "pred_sql": "SELECT * FROM Products;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\"\n}\n"}
{"sample_id": "train.6075", "db_id": "customers_and_addresses", "question": "Find the detail of products whose detail contains the word \"Latte\" or the word \"Americano\"", "rationale": ["Identify the table to query: The question asks for product details, so we will query the 'Products' table.", "Determine the filtering criteria: We need to find products whose details contain the words 'Latte' or 'Americano'.", "Construct the SQL query: Use the SELECT statement to retrieve all columns from the 'Products' table, and apply the WHERE clause to filter based on the specified keywords in the 'product_details' column."], "gold_sql": "SELECT product_details FROM products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'", "source_tables": ["products"], "pred_sql": "SELECT * FROM Products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\"\n}\n"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: We need to find the city with the most customers, so we will use the Customer_Addresses and Addresses tables.", "Join the tables: We will join Customer_Addresses with Addresses on the address_id to get the city associated with each customer.", "Count distinct customers: We will count the distinct customer_id for each city to avoid counting the same customer multiple times.", "Group by city: We will group the results by city to aggregate the customer counts for each city.", "Order the results: We will order the results in descending order based on the customer count to find the city with the most customers.", "Limit the results: We will limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(DISTINCT customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6086", "db_id": "customers_and_addresses", "question": "Find the city where the most customers live.", "rationale": ["To find the city where the most customers live, we need to count the number of customers associated with each city.", "The relevant tables are Customer_Addresses (which links customers to addresses) and Addresses (which contains city information).", "We will join the Customer_Addresses table with the Addresses table on the address_id to get the city for each customer.", "Next, we will group the results by city and count the number of customer_ids for each city to get the total number of customers per city.", "Finally, we will order the results in descending order based on the customer count and limit the results to 1 to get the city with the most customers."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6097", "db_id": "customers_and_addresses", "question": "Which contact channel has been used by the customer with name \"Tillman Ernser\"?", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "We need to find the contact channels associated with a specific customer, so we will join these two tables on the customer_id.", "We will filter the results based on the customer's name, which is 'Tillman Ernser'.", "We will select the distinct contact channels used by this customer."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT DISTINCT Customer_Contact_Channels.channel_code \nFROM Customers \nJOIN Customer_Contact_Channels ON Customers.customer_id = Customer_Contact_Channels.customer_id \nWHERE Customers.customer_name = 'Tillman Ernser';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\"\n}\n"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the relevant tables: Customer_Contact_Channels and Customers.", "We need to find the 'active_to_date' for the contact channels associated with the customer named 'Tillman Ernser'.", "Join the Customer_Contact_Channels table with the Customers table on the customer_id to link contact channels to the specific customer.", "Filter the results to only include the customer with the name 'Tillman Ernser'.", "Order the results by 'active_to_date' in descending order to get the latest date first.", "Limit the results to 1 to get only the latest contact channel's 'active_to_date'."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT active_to_date \nFROM Customer_Contact_Channels ccc \nJOIN Customers c ON ccc.customer_id = c.customer_id \nWHERE c.customer_name = 'Tillman Ernser' \nORDER BY ccc.active_to_date DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\"\n}\n"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["To find the average time span of contact channels, we need to calculate the duration for each contact channel.", "The duration can be calculated by subtracting the 'active_from_date' from the 'active_to_date'.", "We can use the 'julianday' function to convert the date strings into Julian day numbers, which allows us to perform arithmetic on the dates.", "We then take the average of these durations using the AVG() function.", "The final SQL query selects the average duration from the 'Customer_Contact_Channels' table."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_time_span\nFROM Customer_Contact_Channels;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\"\n}\n"}
{"sample_id": "train.6103", "db_id": "customers_and_addresses", "question": "What is the channel code and contact number of the customer contact channel that was active for the longest time?", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the channel code and contact number.", "Determine the criteria for the longest active channel: This can be inferred as the channel that has the earliest active_from_date and has not been deactivated (active_to_date IS NULL).", "Construct a subquery to find the minimum active_from_date from Customer_Contact_Channels where active_to_date is NULL.", "Select the channel_code and contact_number from Customer_Contact_Channels where the active_from_date matches the result of the subquery."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT channel_code, contact_number \nFROM Customer_Contact_Channels \nWHERE active_from_date = \n    (SELECT MIN(active_from_date) \n     FROM Customer_Contact_Channels \n     WHERE active_to_date IS NULL) \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\"\n}\n"}
{"sample_id": "train.6108", "db_id": "customers_and_addresses", "question": "Find the name of the customer who made the order of the largest amount of goods.", "rationale": ["Identify the relevant tables: Customers, Customer_Orders, and Order_Items are needed to find the customer who made the largest order.", "Join the Customers table with Customer_Orders on customer_id to link customers to their orders.", "Join the resulting table with Order_Items on order_id to access the quantities of items ordered.", "Group the results by customer_id to aggregate the total quantity of items ordered by each customer.", "Use SUM(oi.order_quantity) to calculate the total amount of goods ordered by each customer.", "Order the results in descending order based on the total quantity ordered to find the customer with the largest order.", "Limit the results to 1 to get only the customer with the largest order."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)", "source_tables": ["customer_orders", "customers", "order_items"], "pred_sql": "SELECT c.customer_name\nFROM Customers c\nJOIN Customer_Orders co ON c.customer_id = co.customer_id\nJOIN Order_Items oi ON co.order_id = oi.order_id\nGROUP BY c.customer_id\nORDER BY SUM(oi.order_quantity) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6123", "db_id": "customers_and_addresses", "question": "What is the total number of products that are in orders with status \"Cancelled\"?", "rationale": ["Identify the relevant tables: We need to look at the 'Customer_Orders' table to find orders with the status 'Cancelled' and the 'Order_Items' table to find the products associated with those orders.", "Join the 'Customer_Orders' table with the 'Order_Items' table on the 'order_id' to link orders to their respective products.", "Filter the results to include only those orders where the 'order_status' is 'Cancelled'.", "Count the distinct 'product_id' from the 'Order_Items' table to get the total number of unique products in cancelled orders."], "gold_sql": "SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_status  =  'Cancelled'", "source_tables": ["customer_orders", "order_items"], "pred_sql": "SELECT COUNT(DISTINCT oi.product_id) AS total_products\nFROM Customer_Orders co\nJOIN Order_Items oi ON co.order_id = oi.order_id\nWHERE co.order_status = 'Cancelled';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\"\n}\n"}
{"sample_id": "train.6130", "db_id": "customers_and_addresses", "question": "What is the most frequently ordered product? Tell me the detail of the product", "rationale": ["Identify the tables involved: We need to look at the 'Order_Items' table to find out which products were ordered and the 'Products' table to get the details of those products.", "Join the 'Order_Items' table with the 'Products' table on the product_id to access product details for each order.", "Group the results by product_id to aggregate the order quantities for each product.", "Count the number of orders for each product using COUNT(Order_Items.order_quantity).", "Order the results in descending order to find the most frequently ordered product.", "Limit the results to 1 to get only the most frequently ordered product."], "gold_sql": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Products.product_id, Products.product_details \nFROM Order_Items \nJOIN Products ON Order_Items.product_id = Products.product_id \nGROUP BY Order_Items.product_id \nORDER BY COUNT(Order_Items.order_quantity) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\"\n}\n"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["Identify the tables involved: Products and Order_Items.", "We need to find the product with the largest total order quantity, so we will join the Products table with the Order_Items table on the product_id.", "We will group the results by product_id to aggregate the order quantities for each product.", "To find the product with the largest total order quantity, we will use the SUM function on the order_quantity column from the Order_Items table.", "We will order the results in descending order based on the total order quantity.", "Finally, we will limit the results to 1 to get only the product with the largest quantity."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT p.product_id, p.product_details\nFROM Products p\nJOIN Order_Items oi ON p.product_id = oi.product_id\nGROUP BY p.product_id\nORDER BY SUM(oi.order_quantity) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\"\n}\n"}
{"sample_id": "train.6132", "db_id": "customers_and_addresses", "question": "What are the name and ID of the product bought the most.", "rationale": ["Identify the relevant tables: Products and Order_Items.", "Join the Products table with the Order_Items table on product_id to link products with their order quantities.", "Group the results by product_id to aggregate the order quantities for each product.", "Count the number of times each product has been ordered using COUNT(oi.order_quantity).", "Order the results in descending order based on the count to find the most bought product.", "Limit the results to 1 to get only the top product."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT p.product_id, p.product_details\nFROM Products p\nJOIN Order_Items oi ON p.product_id = oi.product_id\nGROUP BY p.product_id\nORDER BY COUNT(oi.order_quantity) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\"\n}\n"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The question asks for addresses, so we will use the 'Addresses' table.", "Determine the filtering criteria: We need to find addresses in two specific cities (East Julianaside and Gleasonmouth) and their corresponding states (Texas and Arizona).", "Construct the WHERE clause: We will use the OR operator to combine the conditions for the two cities and states.", "Formulate the SQL query: We will select all columns from the 'Addresses' table where the conditions are met."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "\n"}
{"sample_id": "train.6155", "db_id": "music_4", "question": "What are the category of music festivals with result \"Awarded\"?", "rationale": ["Identify the relevant table: The question pertains to music festivals, so we will focus on the 'music_festival' table.", "Determine the required columns: We need the 'Category' of the music festivals that have a result of 'Awarded'.", "Construct the SQL query: We will select distinct categories from the 'music_festival' table where the result is 'Awarded'."], "gold_sql": "SELECT Category FROM music_festival WHERE RESULT  =  'Awarded'", "source_tables": ["music_festival"], "pred_sql": "SELECT DISTINCT Category FROM music_festival WHERE Result = 'Awarded';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the categories of awards or recognitions from the 'music_festival' table based on a specific result. The placeholder in the WHERE clause represents the outcome of the festival participation.\",\n    \"1\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\"\n}\n"}
{"sample_id": "train.6167", "db_id": "music_4", "question": "Please show the songs that have result \"nominated\" at music festivals.", "rationale": ["Identify the relevant tables: 'music_festival' for festival results and 'volume' for song identifiers.", "We need to find songs that have a result of 'nominated' in the music festivals.", "Join the 'music_festival' table with the 'volume' table on the Volume ID to link songs to their festival results.", "Use a WHERE clause to filter the results to only include those with 'nominated' as the result.", "Select the distinct songs from the resulting joined table to avoid duplicates."], "gold_sql": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  'Nominated'", "source_tables": ["music_festival", "volume"], "pred_sql": "SELECT DISTINCT volume.Song \nFROM music_festival \nJOIN volume ON music_festival.Volume = volume.Volume_ID \nWHERE music_festival.Result = 'nominated';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the categories of awards or recognitions from the 'music_festival' table based on a specific result. The placeholder in the WHERE clause represents the outcome of the festival participation.\",\n    \"1\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\"\n}\n"}
{"sample_id": "train.6180", "db_id": "music_4", "question": "Return the famous release date for the oldest artist.", "rationale": ["Identify the table that contains the release date of the famous title, which is the 'artist' table.", "To find the oldest artist, we need to sort the artists by their age in ascending order.", "We will select the 'Famous_Release_date' of the artist who is the oldest.", "Using 'LIMIT 1' will ensure that we only get the release date of the oldest artist."], "gold_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1", "source_tables": ["artist"], "pred_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\"\n}\n"}
{"sample_id": "train.6185", "db_id": "music_4", "question": "Please show the categories of the music festivals with count more than 1.", "rationale": ["We need to show the categories of music festivals that have a count greater than 1.", "To achieve this, we will select the 'Category' column from the 'music_festival' table.", "We will use the COUNT() function to count the occurrences of each category.", "We will group the results by 'Category' to aggregate the counts for each category.", "Finally, we will use the HAVING clause to filter the results to only include categories with a count greater than 1."], "gold_sql": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*)  >  1", "source_tables": ["music_festival"], "pred_sql": "SELECT Category, COUNT(*) as Count\nFROM music_festival\nGROUP BY Category\nHAVING COUNT(*) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the categories of awards or recognitions from the 'music_festival' table based on a specific result. The placeholder in the WHERE clause represents the outcome of the festival participation.\",\n    \"1\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\"\n}\n"}
{"sample_id": "train.6187", "db_id": "music_4", "question": "What is the song in the volume with the maximum weeks on top?", "rationale": ["Identify the table that contains the relevant information about songs and their weeks on top, which is the 'volume' table.", "We need to find the song that corresponds to the maximum number of weeks on top.", "To do this, we will use a subquery to first determine the maximum value of 'Weeks_on_Top' from the 'volume' table.", "Then, we will select the 'Song' from the 'volume' table where 'Weeks_on_Top' matches this maximum value."], "gold_sql": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT v.Song \nFROM volume v \nWHERE v.Weeks_on_Top = (SELECT MAX(Weeks_on_Top) FROM volume);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\"\n}\n"}
{"sample_id": "train.6195", "db_id": "music_4", "question": "What is the issue date of the volume with the minimum weeks on top?", "rationale": ["Identify the table that contains the issue date, which is the 'volume' table.", "Determine that we need to find the issue date corresponding to the minimum number of weeks a song has stayed at the top.", "Use a subquery to find the minimum value of 'Weeks_on_Top' from the 'volume' table.", "Select the 'Issue_Date' from the 'volume' table where 'Weeks_on_Top' matches the minimum value found in the subquery."], "gold_sql": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT Issue_Date FROM volume WHERE Weeks_on_Top = (SELECT MIN(Weeks_on_Top) FROM volume);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\"\n}\n"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["Identify the table that contains the competition information, which is the 'match' table.", "Determine that we need to select the 'Match_ID' from the 'match' table.", "Use a subquery to find the 'Competition' identifier for '1994 FIFA World Cup qualification'.", "Construct the SQL query to retrieve the 'Match_ID' based on the identified competition."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "pred_sql": "SELECT Match_ID FROM match WHERE Competition = (SELECT Competition FROM match WHERE Competition = '1994 FIFA World Cup qualification');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n    \"1\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\"\n}\n"}
{"sample_id": "train.6274", "db_id": "city_record", "question": "Which city has hosted the most events?", "rationale": ["Identify the relevant tables: 'city' for city names and 'hosting_city' for hosted matches.", "Join the 'city' table with the 'hosting_city' table on the city identifier to link cities with their hosted matches.", "Count the number of matches hosted by each city using COUNT(hc.Match_ID).", "Group the results by city to aggregate the counts using GROUP BY c.City.", "Order the results in descending order based on the count of hosted matches using ORDER BY Event_Count DESC.", "Limit the results to the top city using LIMIT 1."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "pred_sql": "SELECT c.City, COUNT(hc.Match_ID) AS Event_Count\nFROM city c\nJOIN hosting_city hc ON c.City_ID = hc.Host_City\nGROUP BY c.City\nORDER BY Event_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n    \"1\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\"\n}\n"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables: 'city' for city names and 'temperature' for temperature data.", "We need to find the city with the highest temperature in February, so we will select the 'City' from the 'city' table and 'Feb' from the 'temperature' table.", "Join the 'city' table with the 'temperature' table on 'City_ID' to combine city names with their corresponding February temperatures.", "Order the results by the February temperature in descending order to get the highest temperature at the top.", "Limit the results to 1 to get only the city with the highest temperature."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, t.Feb \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nORDER BY t.Feb DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n    \"1\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\"\n}\n"}
{"sample_id": "train.6287", "db_id": "city_record", "question": "In February, which city marks the highest temperature?", "rationale": ["We need to find the city with the highest temperature in February.", "The relevant data is in the 'city' table (for city names) and the 'temperature' table (for February temperatures).", "We will join the 'city' table with the 'temperature' table on the 'City_ID' column to access both city names and their February temperatures.", "We will order the results by the February temperature in descending order to get the highest temperature at the top.", "Finally, we will limit the results to 1 to get only the city with the highest temperature."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT City, Feb FROM city JOIN temperature ON city.City_ID = temperature.City_ID ORDER BY Feb DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n    \"1\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\"\n}\n"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: 'city' and 'temperature'.", "We need to retrieve city names, so we will select the 'City' column from the 'city' table.", "To filter based on temperature, we will join the 'city' table with the 'temperature' table using the 'City_ID' as the common key.", "The condition requires us to check if the temperature in March is lower than in July or higher than in October, which translates to the SQL conditions: 't.Mar < t.Jul OR t.Mar > t.Oct'.", "Construct the SQL query using the SELECT statement to get the city names based on the specified conditions."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Jul OR t.Mar > t.Oct;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\"\n}\n"}
{"sample_id": "train.6289", "db_id": "city_record", "question": "Which cities' temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: 'city' and 'temperature'.", "We need to retrieve city names and their temperature data for March, July, and October.", "Join the 'city' table with the 'temperature' table on the City_ID to access temperature data for each city.", "Apply the conditions: select cities where the temperature in March is lower than in July or higher than in October.", "Construct the SELECT statement to retrieve the city name and the relevant temperature columns."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, t.Mar, t.Jul, t.Oct \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Jul OR t.Mar > t.Oct;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\"\n}\n"}
{"sample_id": "train.6292", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in Dec and which have never been host cities.", "rationale": ["Identify the relevant tables: 'city' for city names and IDs, 'temperature' for temperature data.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Filter the results to include only those cities where the temperature in March (Mar) is lower than in December (Dec).", "Exclude cities that have hosted matches by using a subquery that selects 'Host_City' from the 'hosting_city' table.", "Select the City_ID and City name from the filtered results."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City_ID, c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n    \"1\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\"\n}\n"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the relevant tables: 'city' for city names and 'temperature' for temperature data.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Filter the results to find cities where the average temperature in March (t.Mar) is lower than in December (t.Dec).", "Exclude cities that have hosted matches by using a subquery that selects 'Host_City' from the 'hosting_city' table.", "Select the city names that meet both conditions."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n    \"1\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\"\n}\n"}
{"sample_id": "train.6298", "db_id": "city_record", "question": "Please give me a list of cities whose regional population is over 8000000 or under 5000000.", "rationale": ["Identify the table to query: The 'city' table contains the relevant information about cities and their populations.", "Determine the condition for filtering: We need cities with a regional population greater than 8,000,000 or less than 5,000,000.", "Construct the SQL SELECT statement: We will select the 'City' column from the 'city' table where the population conditions are met.", "Combine the conditions using the OR operator to ensure we capture both criteria in the query."], "gold_sql": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000", "source_tables": ["city"], "pred_sql": "SELECT City FROM city WHERE Regional_Population > 8000000 OR Regional_Population < 5000000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\"\n}\n"}
{"sample_id": "train.6313", "db_id": "e_government", "question": "What is the name of the party form that is most common?", "rationale": ["Identify the relevant tables: Party_Forms and Forms are needed to get the form names associated with each party.", "Join the Party_Forms table with the Forms table on the form_id to access the form names.", "Group the results by form_name to count how many times each form appears in the Party_Forms table.", "Use COUNT(*) to count the occurrences of each form name.", "Order the results in descending order based on the count to find the most common form.", "Limit the results to 1 to get only the most common form."], "gold_sql": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["forms", "party_forms"], "pred_sql": "SELECT form_name, COUNT(*) as form_count\nFROM Party_Forms\nJOIN Forms ON Party_Forms.form_id = Forms.form_id\nGROUP BY form_name\nORDER BY form_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6329", "db_id": "e_government", "question": "What are the names of the services that have never been used?", "rationale": ["Identify the relevant table: The question asks about services, so we will focus on the Services table.", "Determine the condition: We need to find services that have never been used, which means we need to check for services that do not have any entries in the Party_Services table.", "Construct the subquery: We will create a subquery that selects all service_ids from the Party_Services table, as these represent services that have been used.", "Use the NOT IN clause: We will use the NOT IN clause to filter out any service_ids from the Services table that are present in the subquery, thus giving us the services that have never been used.", "Select the service names: Finally, we will select the service_name from the Services table for the services that meet the criteria."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "pred_sql": "SELECT service_name FROM Services WHERE service_id NOT IN (SELECT service_id FROM Party_Services);", "hint": "\n"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table: The question asks for cities and states, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' for cities and 'state_province_county' for states.", "Use DISTINCT to avoid duplicate entries: Since we want the names of all cities and states, using DISTINCT will ensure that we only get unique combinations.", "Construct the SQL query: Combine the selected columns and the table name into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6342", "db_id": "e_government", "question": "Which state can address \"6862 Kaitlyn Knolls\" possibly be in?", "rationale": ["Identify the relevant table: The question pertains to addresses, so we will use the 'Addresses' table.", "Determine the specific column needed: We need to find the state, which is stored in the 'state_province_county' column.", "Formulate the SQL query: We will select distinct states from the 'Addresses' table where the 'line_1_number_building' matches '6862 Kaitlyn Knolls'."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT state_province_county FROM Addresses WHERE line_1_number_building = '6862 Kaitlyn Knolls';", "hint": "\n"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the relevant tables: Organization_Contact_Individuals and Individuals.", "We need to join these tables on the individual_id to get the last names of individuals.", "Filter the results based on the organization name by using a subquery to get the organization_id from the Organizations table.", "Order the results by the end date of the contact period (date_contact_to) in descending order to get the most recent contacts first.", "Use a LIMIT clause to restrict the number of results returned based on user input."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "pred_sql": "SELECT I.individual_last_name \nFROM Organization_Contact_Individuals OCI \nJOIN Individuals I ON OCI.individual_id = I.individual_id \nWHERE OCI.organization_id = (SELECT organization_id FROM Organizations WHERE organization_name = ?) \nORDER BY OCI.date_contact_to DESC \nLIMIT ?;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names of individuals who have contacted a specific organization. The organization is identified by its name, and the results are ordered by the end date of the contact period, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the organization name and the number of results to display.\"\n}\n"}
{"sample_id": "train.6371", "db_id": "flight_company", "question": "What are the names and types of the companies that have ever operated a flight?", "rationale": ["Identify the relevant tables: We need information from the 'operate_company' table for company names and types, and the 'flight' table to find out which companies have operated flights.", "Determine the relationship: The 'flight' table has a foreign key 'company_id' that links to the 'id' in the 'operate_company' table.", "Select the required columns: We need to select the 'name' and 'Type' columns from the 'operate_company' table.", "Use DISTINCT to avoid duplicate entries: Since a company may operate multiple flights, we use DISTINCT to get unique company names and types.", "Construct the SQL query: We will use a JOIN to combine the 'operate_company' and 'flight' tables based on the foreign key relationship."], "gold_sql": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id", "source_tables": ["flight", "operate_company"], "pred_sql": "SELECT DISTINCT operate_company.name, operate_company.Type \nFROM operate_company \nJOIN flight ON operate_company.id = flight.company_id;", "hint": "\n"}
{"sample_id": "train.6375", "db_id": "flight_company", "question": "What is the id, name and IATA code of the airport that had most number of flights?", "rationale": ["Identify the relevant tables: 'airport' and 'flight'.", "We need to find the airport with the most flights, so we will join the 'airport' table with the 'flight' table using the foreign key relationship (airport.id = flight.airport_id).", "Select the required columns: airport.id, airport.name, and airport.IATA.", "Group the results by airport.id, airport.name, and airport.IATA to aggregate the flight counts for each airport.", "Count the number of flights for each airport using COUNT(flight.id).", "Order the results in descending order based on the flight count to get the airport with the most flights at the top.", "Limit the results to 1 to get only the airport with the highest number of flights."], "gold_sql": "SELECT T1.id ,  T1.name ,  T1.IATA FROM airport AS T1 JOIN flight AS T2 ON T1.id  =  T2.airport_id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airport", "flight"], "pred_sql": "SELECT airport.id, airport.name, airport.IATA\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nGROUP BY airport.id, airport.name, airport.IATA\nORDER BY COUNT(flight.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6381", "db_id": "flight_company", "question": "How many companies operates airlines in each airport?", "rationale": ["Identify the relevant tables: airport, operate_company, and flight.", "We need to count the number of companies that operate airlines at each airport.", "Join the airport table with the flight table on airport.id and flight.airport_id.", "Join the flight table with the operate_company table on flight.company_id and operate_company.id.", "Filter the results to include only those companies that are of type 'airline'.", "Group the results by airport name to get the count of airlines for each airport."], "gold_sql": "SELECT T3.id ,  count(*) FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id JOIN airport AS T3 ON T2.airport_id  =  T3.id GROUP BY T3.id", "source_tables": ["airport", "flight", "operate_company"], "pred_sql": "SELECT airport.name AS Airport_Name, COUNT(operate_company.id) AS Number_of_Airlines\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nJOIN operate_company ON flight.company_id = operate_company.id\nWHERE operate_company.Type = 'airline'\nGROUP BY airport.name;", "hint": "\n"}
{"sample_id": "train.6517", "db_id": "wine_1", "question": "What is the name of the highest rated wine?", "rationale": ["Identify the relevant table: The 'wine' table contains the information about wines, including their names and scores.", "Determine the requirement: We need to find the name of the highest rated wine, which implies we need to sort the wines by their score in descending order.", "Construct the SQL query: Use SELECT to get the 'Name' of the wine from the 'wine' table, and use ORDER BY to sort the results by 'Score' in descending order.", "Limit the results to 1 to get only the highest rated wine."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n    \"1\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n    \"2\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\"\n}\n"}
{"sample_id": "train.6518", "db_id": "wine_1", "question": "Give the name of the wine with the highest score.", "rationale": ["Identify the table that contains the wine names and their scores, which is the 'wine' table.", "To find the wine with the highest score, we need to sort the results by the 'Score' column in descending order.", "Using 'ORDER BY Score DESC' will arrange the wines from highest to lowest score.", "To limit the results to only the top entry, we use 'LIMIT 1' to get the wine with the highest score."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n    \"1\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n    \"2\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\"\n}\n"}
{"sample_id": "train.6520", "db_id": "wine_1", "question": "What is the winery at which the wine with the highest score was made?", "rationale": ["Identify the table that contains the winery information, which is the 'wine' table.", "Determine that we need to find the wine with the highest score, which requires using an aggregate function (MAX) on the 'Score' column in the 'wine' table.", "Construct a subquery to find the maximum score from the 'wine' table.", "Use the result of the subquery to filter the 'wine' table to get the corresponding winery that produced the wine with the highest score."], "gold_sql": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Winery FROM wine WHERE Score = (SELECT MAX(Score) FROM wine);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n    \"1\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n    \"2\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\"\n}\n"}
{"sample_id": "train.6533", "db_id": "wine_1", "question": "List the names of all distinct wines that are made of red color grape.", "rationale": ["Identify the tables involved: 'wine' and 'grapes'.", "Determine the relationship between the tables: 'wine.Grape' corresponds to 'grapes.Grape'.", "Select the distinct names of wines from the 'wine' table.", "Filter the results to include only those wines made from grapes that are red in color by using a WHERE clause on 'grapes.Color'.", "Construct the SQL query using the SELECT statement to retrieve the distinct wine names, joining the two tables on the grape variety."], "gold_sql": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT wine.Name \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'red';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n    \"1\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n    \"2\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\"\n}\n"}
{"sample_id": "train.6544", "db_id": "wine_1", "question": "Give the names and scores of wines made from white grapes.", "rationale": ["Identify the tables involved: 'wine' and 'grapes'.", "Determine the columns needed: 'Name' and 'Score' from the 'wine' table.", "Establish the relationship between the tables: join 'wine' and 'grapes' on the 'Grape' column.", "Filter the results to include only wines made from white grapes by adding a WHERE clause that specifies grapes.Color = 'white'."], "gold_sql": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT wine.Name, wine.Score \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'white';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n    \"1\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n    \"2\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\"\n}\n"}
{"sample_id": "train.6547", "db_id": "wine_1", "question": "Find the the grape whose white color grapes are used to produce wines with scores higher than 90.", "rationale": ["We need to find grape varieties that are white in color.", "The relevant tables are 'grapes' and 'wine', which can be joined on the grape variety.", "We will filter the results to include only white grapes by using the condition grapes.Color = 'white'.", "Additionally, we want to filter the wines to include only those with scores higher than 90, using the condition wine.Score > 90.", "Finally, we will select the distinct grape names that meet these criteria."], "gold_sql": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White' AND T2.score  >  90", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT grapes.Grape \nFROM grapes \nJOIN wine ON grapes.Grape = wine.Grape \nWHERE grapes.Color = 'white' AND wine.Score > 90;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n    \"1\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n    \"2\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\"\n}\n"}
{"sample_id": "train.6550", "db_id": "wine_1", "question": "What are the names of wines made from red grapes and with prices above 50?", "rationale": ["Identify the tables involved: 'wine' and 'grapes'.", "Determine the relationship between the tables: 'wine' references 'grapes' through the 'Grape' column.", "Filter the results based on the color of the grapes: we want only red grapes.", "Add a condition to filter wines with prices above 50.", "Construct the SQL query using SELECT to get the names of the wines, JOIN to combine the tables, and WHERE to apply the filters."], "gold_sql": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red' AND T2.price  >  50", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT wine.Name \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'red' AND wine.Price > 50;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n    \"1\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n    \"2\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\"\n}\n"}
{"sample_id": "train.6558", "db_id": "wine_1", "question": "What are the distinct names of wines with prices higher than any wine from John Anthony winery.", "rationale": ["Identify the requirement to find distinct names of wines with prices higher than those from a specific winery (John Anthony).", "Use a subquery to find the maximum price of wines produced by John Anthony winery.", "The main query selects distinct wine names from the 'wine' table where the price is greater than the maximum price obtained from the subquery."], "gold_sql": "SELECT DISTINCT Name FROM WINE WHERE Price  >  (SELECT min(Price) FROM wine WHERE Winery  =  'John Anthony')", "source_tables": ["wine"], "pred_sql": "SELECT DISTINCT Name FROM wine WHERE Price > (SELECT MAX(Price) FROM wine WHERE Winery = 'John Anthony');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n    \"1\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n    \"2\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\"\n}\n"}
{"sample_id": "train.6566", "db_id": "wine_1", "question": "Give the color of the grape whose wine products have the highest average price?", "rationale": ["Identify the tables involved: 'grapes' and 'wine'.", "We need to find the grape color associated with the wine products that have the highest average price.", "Join the 'grapes' table with the 'wine' table on the grape variety.", "Group the results by grape color to calculate the average price of wines for each color.", "Order the results by the average price in descending order to get the highest average price at the top.", "Limit the results to 1 to get only the color of the grape with the highest average price."], "gold_sql": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT 1", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT g.Color\nFROM grapes g\nJOIN wine w ON g.Grape = w.Grape\nGROUP BY g.Color\nORDER BY AVG(w.Price) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n    \"1\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n    \"2\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\"\n}\n"}
{"sample_id": "train.6588", "db_id": "wine_1", "question": "Which 3 wineries produce the most wines made from white grapes?", "rationale": ["Identify the relevant tables: 'wine' and 'grapes'.", "We need to filter wines made from white grapes, so we will join the 'wine' table with the 'grapes' table on the grape variety.", "Use a WHERE clause to filter the results to only include grapes of color 'white'.", "To find the wineries that produce the most wines, we will group the results by 'Winery' and count the number of wines for each winery.", "Order the results in descending order based on the count of wines produced.", "Limit the results to the top 3 wineries."], "gold_sql": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  'White' GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT Winery, COUNT(*) as WineCount\nFROM wine\nJOIN grapes ON wine.Grape = grapes.Grape\nWHERE grapes.Color = 'white'\nGROUP BY Winery\nORDER BY WineCount DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n    \"1\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n    \"2\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\"\n}\n"}
{"sample_id": "train.6597", "db_id": "wine_1", "question": "Find the county where produces the most number of wines with score higher than 90.", "rationale": ["Identify the relevant tables: 'wine' for wine details and 'appellations' for county information.", "Join the 'wine' table with the 'appellations' table on the Appelation column to access county data.", "Filter the results to include only wines with a score greater than 90 using a WHERE clause.", "Group the results by County to count the number of wines per county.", "Order the results in descending order based on the count of wines to find the county with the most wines.", "Limit the results to 1 to get only the county with the highest count."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1", "source_tables": ["wine", "appellations"], "pred_sql": "SELECT County, COUNT(*) as WineCount\nFROM wine\nJOIN appellations ON wine.Appelation = appellations.Appelation\nWHERE wine.Score > 90\nGROUP BY County\nORDER BY WineCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n    \"1\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n    \"2\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\"\n}\n"}
{"sample_id": "train.6626", "db_id": "driving_school", "question": "Show the detail of vehicle with id 1.", "rationale": ["Identify the table that contains vehicle details, which is the Vehicles table.", "Determine the specific vehicle to retrieve by its unique identifier, which is '1'.", "Construct the SQL query to select all columns from the Vehicles table where the vehicle_id matches '1'."], "gold_sql": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;", "source_tables": ["vehicles"], "pred_sql": "SELECT * FROM Vehicles WHERE vehicle_id = '1';", "hint": "\n"}
{"sample_id": "train.6650", "db_id": "driving_school", "question": "How many staff live in state Georgia?", "rationale": ["Identify the relevant tables: Staff and Addresses.", "Determine the relationship between Staff and Addresses using the foreign key (staff_address_id).", "Count the number of staff members who live in Georgia by filtering the Addresses table on the state_province_county column.", "Construct the SQL query using COUNT(*) to get the total number of staff in Georgia."], "gold_sql": "SELECT count(*) FROM Addresses WHERE state_province_county = 'Georgia';", "source_tables": ["addresses"], "pred_sql": "SELECT COUNT(*) AS staff_count \nFROM Staff \nJOIN Addresses ON Staff.staff_address_id = Addresses.address_id \nWHERE Addresses.state_province_county = 'Georgia';", "hint": "\n"}
{"sample_id": "train.6665", "db_id": "driving_school", "question": "What is the status code, phone number, and email address of the customer whose last name is Kohler or whose first name is Marina?", "rationale": ["Identify the relevant table: The question pertains to customer information, so we will use the Customers table.", "Determine the required columns: The question asks for the status code, phone number, and email address of the customer.", "Construct the SELECT statement: We will select customer_status_code, phone_number, and email_address from the Customers table.", "Add the WHERE clause: We need to filter the results to include customers whose last name is 'Kohler' or whose first name is 'Marina'.", "Combine all parts to form the complete SQL query."], "gold_sql": "SELECT customer_status_code ,  cell_mobile_phone_number ,  email_address FROM Customers WHERE first_name = 'Marina' OR last_name  =  'Kohler'", "source_tables": ["customers"], "pred_sql": "SELECT customer_status_code, phone_number, email_address \nFROM Customers \nWHERE last_name = 'Kohler' OR first_name = 'Marina';", "hint": "\n"}
{"sample_id": "train.6676", "db_id": "driving_school", "question": "How many lessons taken by customer with first name as Rylan and last name as Goodwin were completed?", "rationale": ["Identify the relevant tables: Lessons and Customers.", "We need to count the number of lessons, so we will use the COUNT() function.", "We need to filter the lessons based on the customer's first and last name, which requires a JOIN between the Lessons and Customers tables.", "The WHERE clause will specify the conditions for the customer's first name and last name, as well as the lesson status code to ensure we only count completed lessons."], "gold_sql": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = 'Rylan' AND T2.last_name = 'Goodwin' AND T1.lesson_status_code = 'Completed';", "source_tables": ["lessons", "customers"], "pred_sql": "SELECT COUNT(*) AS completed_lessons_count\nFROM Lessons\nJOIN Customers ON Lessons.customer_id = Customers.customer_id\nWHERE Customers.first_name = 'Rylan' AND Customers.last_name = 'Goodwin' AND Lessons.lesson_status_code = 'completed';", "hint": "\n"}
{"sample_id": "train.6688", "db_id": "driving_school", "question": "Which city does has most number of customers?", "rationale": ["Identify the relevant tables: Customers and Addresses.", "Join the Customers table with the Addresses table on the customer_address_id and address_id columns to get the city for each customer.", "Group the results by city to count the number of customers in each city.", "Use COUNT() to count the number of customers for each city.", "Order the results in descending order based on the customer count to find the city with the most customers.", "Limit the results to 1 to get only the city with the highest number of customers."], "gold_sql": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "customers"], "pred_sql": "SELECT a.city, COUNT(c.customer_id) AS customer_count\nFROM Customers c\nJOIN Addresses a ON c.customer_address_id = a.address_id\nGROUP BY a.city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities where customers are located, derived from the 'Customers' and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6711", "db_id": "driving_school", "question": "What are the last names that are used by customers and staff?", "rationale": ["Identify the tables that contain last names: Customers and Staff.", "Use the SELECT statement to retrieve last names from both tables.", "Use DISTINCT to ensure unique last names are returned.", "Combine the results from both tables using UNION to get a single list of last names."], "gold_sql": "SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff", "source_tables": ["staff", "customers"], "pred_sql": "SELECT DISTINCT last_name FROM Customers UNION SELECT DISTINCT last_name FROM Staff;", "hint": "\n"}
{"sample_id": "train.6714", "db_id": "driving_school", "question": "What is the id and detail of the vehicle used in lessons for most of the times?", "rationale": ["Identify the relevant tables: The question pertains to vehicles used in lessons, so we need to look at the Lessons and Vehicles tables.", "Determine the required fields: We need the vehicle_id and vehicle_details from the Vehicles table.", "Count the number of times each vehicle is used in lessons: This can be done by grouping the Lessons table by vehicle_id and counting the occurrences.", "Sort the results to find the vehicle used the most: We will order the results by the count of lessons in descending order.", "Limit the results to the top entry: Since we only want the vehicle used the most, we will limit the results to 1."], "gold_sql": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["lessons", "vehicles"], "pred_sql": "SELECT vehicle_id, vehicle_details\nFROM Lessons\nGROUP BY vehicle_id\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the table that contains faculty information, which is the 'Faculty' table.", "Determine the column that stores the gender of faculty members, which is 'Sex'.", "Formulate a query to select the unique identifiers (FacID) of faculty members where the 'Sex' column is equal to 'Male'."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "pred_sql": "SELECT FacID FROM Faculty WHERE Sex = 'Male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n    \"1\": \"This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The results are ordered by the number of faculty members in each building in descending order, and the placeholder allows the user to specify the maximum number of buildings to return.\",\n    \"2\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\"\n}\n"}
{"sample_id": "train.6734", "db_id": "activity_1", "question": "What are the first name and last name of all the instructors?", "rationale": ["Identify the relevant table: The question asks for the first and last names of instructors, which corresponds to the Faculty table.", "Select the appropriate columns: We need to retrieve the first name (Fname) and last name (Lname) of faculty members.", "Construct the SQL query: Use the SELECT statement to get the required columns from the Faculty table."], "gold_sql": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  'Instructor'", "source_tables": ["faculty"], "pred_sql": "SELECT Fname, Lname FROM Faculty;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n    \"1\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n    \"2\": \"This virtual table lists the distinct last names of faculty members who participate in specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities of interest.\"\n}\n"}
{"sample_id": "train.6737", "db_id": "activity_1", "question": "Which building has most faculty members?", "rationale": ["Identify the table that contains information about faculty members and their office locations, which is the Faculty table.", "We need to count the number of faculty members in each building, so we will use the COUNT() function.", "Group the results by the Building column to get the count of faculty members per building.", "Order the results in descending order based on the count of faculty members to find the building with the most faculty members.", "Limit the results to 1 to get only the building with the highest count."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(FacID) AS FacultyCount\nFROM Faculty\nGROUP BY Building\nORDER BY FacultyCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The results are ordered by the number of faculty members in each building in descending order, and the placeholder allows the user to specify the maximum number of buildings to return.\",\n    \"1\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\",\n    \"2\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\"\n}\n"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their rank and gender.", "Filter for assistant professors: We need to focus on faculty members with the rank of 'Assistant Professor'.", "Group by gender: To get the count of male and female assistant professors, we will group the results by the 'Sex' column.", "Count the number of professors: We will use the COUNT function to count the number of faculty members in each gender group."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) as NumberOfProfessors \nFROM Faculty \nWHERE Rank = 'Assistant Professor' \nGROUP BY Sex;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n    \"1\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\"\n}\n"}
{"sample_id": "train.6748", "db_id": "activity_1", "question": "How many male and female assistant professors do we have?", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their rank and gender.", "Filter for assistant professors: We need to focus on faculty members with the rank of 'Assistant Professor'.", "Group by gender: To get the count of male and female assistant professors, we will group the results by the 'Sex' column.", "Count the number of faculty members: We will use the COUNT() function to count the number of assistant professors for each gender."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) AS Count\nFROM Faculty\nWHERE Rank = 'Assistant Professor'\nGROUP BY Sex;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n    \"1\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n    \"2\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\"\n}\n"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the tables needed: We need to get the advisor's name from the Faculty table and link it to the Student table to find Linda Smith's advisor.", "Linda Smith's advisor is represented by the 'Advisor' column in the Student table, which links to the 'FacID' in the Faculty table.", "We will perform a JOIN operation between the Faculty and Student tables on the condition that the Faculty's ID matches the Advisor ID of the Student.", "We will filter the results to only include the student with the first name 'Linda' and last name 'Smith'.", "Finally, we will select the first name and last name of the faculty member who is the advisor."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT F.Fname, F.Lname \nFROM Faculty F \nJOIN Student S ON F.FacID = S.Advisor \nWHERE S.Fname = 'Linda' AND S.Lname = 'Smith';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n    \"1\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\"\n}\n"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["Identify the relevant tables: We need to find students and their advisors, so we will use the 'Student' and 'Faculty' tables.", "Determine the relationship: The 'Student' table has a column 'Advisor' that references 'FacID' in the 'Faculty' table, indicating which faculty member is the advisor for each student.", "Construct the SQL query: We will select the 'StuID' from the 'Student' table and join it with the 'Faculty' table on the condition that 'Student.Advisor' matches 'Faculty.FacID'."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN Faculty ON Student.Advisor = Faculty.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n    \"1\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n    \"2\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\"\n}\n"}
{"sample_id": "train.6752", "db_id": "activity_1", "question": "Which students have professors as their advisors? Find their student ids.", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for student IDs and the 'Faculty' table for faculty IDs.", "Determine the relationship: Students have advisors who are faculty members, so we need to find students whose 'Advisor' field matches any 'FacID' in the 'Faculty' table.", "Construct the SQL query: We will select 'StuID' from the 'Student' table where the 'Advisor' is in the list of 'FacID' from the 'Faculty' table."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT StuID FROM Student WHERE Advisor IN (SELECT FacID FROM Faculty)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n    \"1\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n    \"2\": \"This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The results are ordered by the number of faculty members in each building in descending order, and the placeholder allows the user to specify the maximum number of buildings to return.\"\n}\n"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the relevant tables: We need to retrieve student information, specifically first and last names, and we need to filter based on the advisor's name.", "The 'Student' table contains the first name (Fname) and last name (LName) of students, and it also has a column for Advisor which links to the Faculty table.", "To find the students advised by Michael Goodrich, we need to first find the FacID of Michael Goodrich from the 'Faculty' table.", "We can do this by using a subquery that selects the FacID from the 'Faculty' table where the first name is 'Michael' and the last name is 'Goodrich'.", "Finally, we will select the first and last names of students from the 'Student' table where the Advisor matches the FacID obtained from the subquery."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Fname, LName \nFROM Student \nWHERE Advisor = (SELECT FacID FROM Faculty WHERE Fname = 'Michael' AND Lname = 'Goodrich');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n    \"1\": \"This virtual table lists the distinct last names of faculty members who participate in specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities of interest.\",\n    \"2\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\"\n}\n"}
{"sample_id": "train.6756", "db_id": "activity_1", "question": "What are the faculty id and the number of students each faculty has?", "rationale": ["Identify the tables needed: Faculty and Student, since we need faculty IDs and the number of students they have.", "Establish the relationship: Faculty members are advisors to students, so we will join the Faculty table with the Student table on the Advisor field.", "Use a LEFT JOIN to ensure we include all faculty members, even those without students.", "Count the number of students for each faculty member using COUNT(Student.StuID).", "Group the results by Faculty.FacID to get the count of students per faculty member."], "gold_sql": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Faculty.FacID, COUNT(Student.StuID) AS NumberOfStudents\nFROM Faculty\nLEFT JOIN Student ON Faculty.FacID = Student.Advisor\nGROUP BY Faculty.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n    \"1\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n    \"2\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\"\n}\n"}
{"sample_id": "train.6758", "db_id": "activity_1", "question": "How many students are advised by each rank of faculty? List the rank and the number of students.", "rationale": ["Identify the tables involved: Faculty and Student.", "Determine the relationship: Faculty members advise students, indicated by the Advisor field in the Student table.", "Join the Faculty table with the Student table on the Advisor relationship (Faculty.FacID = Student.Advisor).", "Group the results by Faculty Rank to aggregate the number of students advised by each rank.", "Count the number of students for each rank using COUNT(Student.StuID).", "Select the Rank from the Faculty table and the count of students as NumberOfStudents."], "gold_sql": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Faculty.Rank, COUNT(Student.StuID) AS NumberOfStudents\nFROM Faculty\nJOIN Student ON Faculty.FacID = Student.Advisor\nGROUP BY Faculty.Rank;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n    \"1\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n    \"2\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\"\n}\n"}
{"sample_id": "train.6761", "db_id": "activity_1", "question": "Show the ids for all the faculty members who have at least 2 students.", "rationale": ["Identify the requirement: We need to find faculty members who have at least 2 students assigned to them as advisors.", "Understand the relationship: The 'Student' table has a column 'Advisor' that links to the 'FacID' in the 'Faculty' table, indicating which faculty member is the advisor for each student.", "Use a subquery to count the number of students for each faculty member: We will group the 'Student' table by 'Advisor' and count the number of 'StuID' for each advisor.", "Filter the results: We will use the HAVING clause to ensure we only get advisors with 2 or more students.", "Select the faculty IDs: Finally, we will select the 'FacID' from the 'Faculty' table where the 'FacID' is in the list of advisors who have 2 or more students."], "gold_sql": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  2", "source_tables": ["faculty", "student"], "pred_sql": "SELECT FacID FROM Faculty WHERE FacID IN (SELECT Advisor FROM Student GROUP BY Advisor HAVING COUNT(StuID) >= 2);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n    \"1\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n    \"2\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\"\n}\n"}
{"sample_id": "train.6777", "db_id": "activity_1", "question": "Show the names of all the activities Mark Giuliano participates in.", "rationale": ["Identify the tables involved: Activity, Participates_in, and Student.", "We need to find activities that a specific student (Mark Giuliano) participates in.", "Join the Activity table with the Participates_in table on actid to link activities with student participation.", "Join the resulting table with the Student table on StuID to filter by the specific student.", "Use a WHERE clause to specify the first name as 'Mark' and the last name as 'Giuliano'.", "Select the activity_name from the final joined table."], "gold_sql": "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  'Mark' AND T1.lname  =  'Giuliano'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Activity.activity_name\nFROM Activity\nJOIN Participates_in ON Activity.actid = Participates_in.actid\nJOIN Student ON Participates_in.stuid = Student.StuID\nWHERE Student.Fname = 'Mark' AND Student.LName = 'Giuliano';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n    \"1\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\",\n    \"2\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\"\n}\n"}
{"sample_id": "train.6779", "db_id": "activity_1", "question": "Show the first and last name of all the faculty members who participated in some activity, together with the number of activities they participated in.", "rationale": ["We need to retrieve the first and last names of faculty members who participated in activities, along with the count of activities they participated in.", "To achieve this, we will select the first name (Fname) and last name (Lname) from the Faculty table.", "We will join the Faculty table with the Faculty_Participates_in table on the FacID to link faculty members with their activities.", "We will use the COUNT function to count the number of activities each faculty member participated in, grouping the results by the faculty member's ID (FacID).", "Finally, we will format the SQL query to include the necessary SELECT, JOIN, and GROUP BY clauses."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname, Faculty.Lname, COUNT(Faculty_Participates_in.actid) AS num_activities\nFROM Faculty\nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID\nGROUP BY Faculty.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n    \"1\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\",\n    \"2\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\"\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: We need to find students who participate in activities, so we will use the 'Participates_in' table and the 'Student' table.", "Determine the columns needed: We need the student IDs (stuid) from the 'Participates_in' table and we need to filter based on the age of the students from the 'Student' table.", "Join the tables: We will join 'Participates_in' with 'Student' on the student ID to get the necessary information about the students who participate in activities.", "Apply the age filter: We will add a WHERE clause to filter students who are under 20 years old."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT p.stuid \nFROM Participates_in p \nJOIN Student s ON p.stuid = s.StuID \nWHERE s.Age < 20;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\",\n    \"1\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\"\n}\n"}
{"sample_id": "train.6797", "db_id": "activity_1", "question": "Find the first names of professors who are not playing Canoeing or Kayaking.", "rationale": ["Identify the main goal: to find the first names of professors who are not participating in Canoeing or Kayaking.", "To achieve this, we need to select the first names from the Faculty table.", "We will use a subquery to find faculty members who are participating in Canoeing or Kayaking.", "The subquery will join the Faculty_Participates_in table with the Activity table to filter based on the activity names.", "The main query will select faculty members whose IDs are not in the list returned by the subquery."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty F \nWHERE F.FacID NOT IN (\n    SELECT FP.FacID \n    FROM Faculty_Participates_in FP \n    JOIN Activity A ON FP.actid = A.actid \n    WHERE A.activity_name IN ('Canoeing', 'Kayaking')\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n    \"1\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n    \"2\": \"This virtual table lists the distinct last names of faculty members who participate in specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities of interest.\"\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the main table to query from, which is the Faculty table to get the first names of professors.", "We need to filter out professors who participate in Canoeing or Kayaking activities.", "To do this, we will use a subquery that selects the FacID of faculty members who participate in these activities.", "The subquery joins the Faculty_Participates_in table with the Activity table to filter based on the activity names 'Canoeing' and 'Kayaking'.", "The main query selects the first names of faculty members whose FacID is not in the list returned by the subquery."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty F \nWHERE F.FacID NOT IN (\n    SELECT FP.FacID \n    FROM Faculty_Participates_in FP \n    JOIN Activity A ON FP.actid = A.actid \n    WHERE A.activity_name IN ('Canoeing', 'Kayaking')\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n    \"1\": \"This virtual table lists the distinct last names of faculty members who participate in specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities of interest.\",\n    \"2\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\"\n}\n"}
{"sample_id": "train.6799", "db_id": "activity_1", "question": "Find the first names of the faculty members who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables involved: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members who participate in specific activities, which are Canoeing and Kayaking.", "Join the Faculty table with the Faculty_Participates_in table on the FacID to get the activities they participate in.", "Join the resulting table with the Activity table on actid to filter by activity names.", "Use a WHERE clause to specify that we are only interested in the activities 'Canoeing' and 'Kayaking'.", "Select the first names of the faculty members from the Faculty table."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname \nFROM Faculty \nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID \nJOIN Activity ON Faculty_Participates_in.actid = Activity.actid \nWHERE Activity.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n    \"1\": \"This virtual table lists the distinct last names of faculty members who participate in specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities of interest.\",\n    \"2\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\"\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables involved: We need to find student IDs from the Participates_in table and the activity names from the Activity table.", "Determine the relationship: The Participates_in table has a foreign key 'actid' that links to the Activity table's 'actid'.", "Filter the activities: We are specifically looking for students who participate in 'Canoeing' and 'Kayaking'.", "Construct the SQL query: Use a SELECT statement to get 'stuid' from Participates_in, join it with Activity on 'actid', and filter the results based on the activity names."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT p.stuid \nFROM Participates_in p \nJOIN Activity a ON p.actid = a.actid \nWHERE a.activity_name IN ('Canoeing', 'Kayaking');", "hint": "\n"}
{"sample_id": "train.6825", "db_id": "flight_4", "question": "Find the number of routes operated by American Airlines.", "rationale": ["Identify the relevant table: The 'routes' table contains information about the routes operated by airlines.", "Determine the specific airline: The query is focused on 'American Airlines'.", "Count the number of routes: Use the COUNT() function to count the total number of routes associated with 'American Airlines'.", "Construct the SQL query: Combine the elements into a complete SQL statement that selects the count of routes for 'American Airlines'."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT COUNT(*) AS number_of_routes \nFROM routes \nWHERE airline = 'American Airlines';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n    \"2\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\"\n}\n"}
{"sample_id": "train.6826", "db_id": "flight_4", "question": "How many routes does American Airlines operate?", "rationale": ["Identify the relevant table: The 'routes' table contains information about the routes operated by airlines.", "Determine the specific airline: The question asks about 'American Airlines'.", "Count the number of routes: Use the COUNT() function to count the number of entries in the 'routes' table where the airline is 'American Airlines'.", "Construct the SQL query: Combine the elements into a complete SQL query that counts the routes for American Airlines."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT COUNT(*) AS route_count \nFROM routes \nWHERE airline = 'American Airlines';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n    \"2\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\"\n}\n"}
{"sample_id": "train.6831", "db_id": "flight_4", "question": "Find the name, city, and country of the airport that has the highest latitude.", "rationale": ["Identify the relevant table: The 'airports' table contains the necessary information about airports, including their names, cities, and countries.", "Determine the criteria for selection: We need to find the airport with the highest latitude, which is represented by the 'y' coordinate in the 'airports' table.", "Construct the SQL query: We will select the 'name', 'city', and 'country' columns from the 'airports' table, order the results by the 'y' coordinate in descending order to get the highest latitude first, and limit the results to 1 to get only the top result."], "gold_sql": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT 1", "source_tables": ["airports"], "pred_sql": "SELECT name, city, country FROM airports ORDER BY y DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n    \"1\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\"\n}\n"}
{"sample_id": "train.6834", "db_id": "flight_4", "question": "What is the name and city of the airport that the most routes end at?", "rationale": ["We need to find the airport that has the most routes ending at it, which means we will focus on the 'dst_apid' in the 'routes' table.", "To get the name and city of the airport, we will join the 'airports' table with the 'routes' table on the condition that the airport ID in the 'airports' table matches the destination airport ID in the 'routes' table.", "We will group the results by the airport ID to count the number of routes that end at each airport.", "To find the airport with the most routes, we will order the results by the count of routes in descending order.", "Finally, we will limit the results to just one record to get the airport with the highest count."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, airports.city\nFROM airports\nJOIN routes ON airports.apid = routes.dst_apid\nGROUP BY airports.apid\nORDER BY COUNT(routes.rid) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n    \"1\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n    \"2\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\"\n}\n"}
{"sample_id": "train.6838", "db_id": "flight_4", "question": "What is the name and city of the airport from most of the routes start?", "rationale": ["We need to find the airport that most routes start from, which means we will focus on the source airports in the 'routes' table.", "To get the names and cities of these airports, we will join the 'routes' table with the 'airports' table on the source airport ID (src_apid).", "We will group the results by the airport name and city to count how many routes originate from each airport.", "To find the airport with the most routes, we will order the results by the count of routes in descending order.", "Finally, we will limit the results to just one entry to get the airport with the highest count."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, airports.city\nFROM routes\nJOIN airports ON routes.src_apid = airports.apid\nGROUP BY airports.name, airports.city\nORDER BY COUNT(routes.rid) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n    \"1\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n    \"2\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\"\n}\n"}
{"sample_id": "train.6841", "db_id": "flight_4", "question": "Which countries has the most number of airlines?", "rationale": ["Identify the relevant table: The 'airlines' table contains information about airlines, including their country of origin.", "Determine the required information: We need to count the number of airlines grouped by their country.", "Use the COUNT function to count the number of airlines (alid) for each country.", "Group the results by country to aggregate the counts.", "Order the results in descending order to find which countries have the most airlines."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country, COUNT(alid) AS airline_count \nFROM airlines \nGROUP BY country \nORDER BY airline_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\",\n    \"1\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n    \"2\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.6842", "db_id": "flight_4", "question": "What is the name of the country with the most number of home airlines?", "rationale": ["Identify the relevant table: The 'airlines' table contains information about airlines, including their country of origin.", "Determine the required information: We need to find the country with the most number of home airlines.", "Group the data: Use GROUP BY to group the airlines by their country.", "Count the number of airlines per country: Use COUNT(alid) to count the number of airlines in each country.", "Order the results: Use ORDER BY COUNT(alid) DESC to sort the countries by the number of airlines in descending order.", "Limit the results: Use LIMIT 1 to get only the country with the highest count."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country FROM airlines GROUP BY country ORDER BY COUNT(alid) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\",\n    \"1\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n    \"2\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.6858", "db_id": "flight_4", "question": "What are the cities that have more than 2 airports sorted by number of airports?", "rationale": ["Identify the need to count the number of airports in each city.", "Use the airports table to access city and airport information.", "Group the results by city to aggregate the count of airports.", "Use the HAVING clause to filter cities that have more than 2 airports.", "Sort the results in descending order based on the count of airports."], "gold_sql": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)", "source_tables": ["airports"], "pred_sql": "SELECT city, COUNT(apid) AS airport_count \nFROM airports \nGROUP BY city \nHAVING COUNT(apid) > 2 \nORDER BY airport_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n    \"1\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n    \"2\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\"\n}\n"}
{"sample_id": "train.6862", "db_id": "flight_4", "question": "For each  airport name, how many routes start at that airport, ordered from most to least?", "rationale": ["We need to count the number of routes that start at each airport.", "To do this, we will join the 'airports' table with the 'routes' table on the airport ID, where the airport ID in the 'airports' table matches the source airport ID in the 'routes' table.", "We will select the airport name and the count of routes (using COUNT(routes.rid)).", "We will group the results by the airport name to get the count for each airport.", "Finally, we will order the results by the count of routes in descending order to show the airports with the most routes first."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, COUNT(routes.rid) AS route_count\nFROM airports\nJOIN routes ON airports.apid = routes.src_apid\nGROUP BY airports.name\nORDER BY route_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n    \"1\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n    \"2\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\"\n}\n"}
{"sample_id": "train.6867", "db_id": "flight_4", "question": "For each country and airline name, how many routes are there?", "rationale": ["We need to count the number of routes for each country and airline name.", "To achieve this, we will join the 'routes' table with the 'airlines' table using the airline ID (alid) as the foreign key.", "We will select the country from the 'airlines' table and the airline name along with the count of routes from the 'routes' table.", "The COUNT function will be used to count the number of unique route IDs (rid) for each combination of country and airline name.", "Finally, we will group the results by country and airline name to get the desired counts."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT a.country, r.airline, COUNT(r.rid) AS route_count \nFROM routes r \nJOIN airlines a ON r.alid = a.alid \nGROUP BY a.country, r.airline;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\",\n    \"1\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n    \"2\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.6868", "db_id": "flight_4", "question": "What is the total number of routes for each country and airline in that country?", "rationale": ["We need to find the total number of routes for each country and airline.", "To do this, we will join the 'routes' table with the 'airlines' table on the airline ID (alid).", "We will select the country from the airlines table and the airline name from the routes table.", "We will count the number of routes (rid) for each combination of country and airline.", "Finally, we will group the results by country and airline to get the total count for each combination."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT a.country, r.airline, COUNT(r.rid) AS total_routes\nFROM routes r\nJOIN airlines a ON r.alid = a.alid\nGROUP BY a.country, r.airline;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\",\n    \"1\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n    \"2\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\"\n}\n"}
{"sample_id": "train.6873", "db_id": "flight_4", "question": "Find the number of routes that have destination John F Kennedy International Airport.", "rationale": ["Identify the table to query: The 'routes' table contains information about routes including destination airports.", "Determine the condition: We need to filter the routes where the destination airport name is 'John F Kennedy International Airport'.", "Use the COUNT function: To find the number of routes, we will use the COUNT(*) function to count all rows that meet the condition.", "Construct the SQL query: Combine the SELECT statement with the COUNT function and the WHERE clause to filter by the destination airport name."], "gold_sql": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'", "source_tables": ["airports", "routes"], "pred_sql": "SELECT COUNT(*) AS route_count \nFROM routes \nWHERE dst_ap = 'John F Kennedy International Airport';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n    \"1\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n    \"2\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.6880", "db_id": "flight_4", "question": "What is the name of the airline with the most routes?", "rationale": ["We need to find the airline with the most routes, which involves counting the number of routes associated with each airline.", "To do this, we will join the 'airlines' table with the 'routes' table on the airline ID (alid).", "We will group the results by the airline ID to count the number of routes for each airline.", "Next, we will order the results in descending order based on the count of routes, so that the airline with the most routes appears first.", "Finally, we will limit the results to just one entry to get the airline with the most routes."], "gold_sql": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT a.name\nFROM airlines a\nJOIN routes r ON a.alid = r.alid\nGROUP BY a.alid\nORDER BY COUNT(r.rid) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n    \"1\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n    \"2\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.6883", "db_id": "flight_4", "question": "Find the busiest destination airport that runs most number of routes in China.", "rationale": ["Identify the destination airport from the routes table that has the most routes.", "Join the routes table with the airports table to get the destination airport names.", "Filter the results to include only those airports located in China.", "Group the results by the destination airport name to count the number of routes for each airport.", "Order the results in descending order based on the count of routes to find the busiest destination airport.", "Limit the results to return only the top result, which is the busiest destination airport."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT dst_ap, COUNT(rid) AS route_count\nFROM routes\nJOIN airports ON routes.dst_apid = airports.apid\nWHERE airports.country = 'China'\nGROUP BY dst_ap\nORDER BY route_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n    \"1\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n    \"2\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\"\n}\n"}
{"sample_id": "train.6884", "db_id": "flight_4", "question": "What is the name of the airport that is the destination of the most number of routes that start in China?", "rationale": ["Identify the relevant tables: We need to use the 'routes' table to find the destination airports and the 'airports' table to filter by the source airport's country (China).", "Join the 'routes' table with the 'airports' table on the source airport ID to get the country information.", "Filter the results to include only those routes that start in China by checking the country column in the 'airports' table.", "Group the results by the destination airport name to count the number of routes to each destination.", "Order the results by the count of routes in descending order to find the destination with the most routes.", "Limit the results to 1 to get only the top destination airport."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT dst_ap, COUNT(*) as route_count\nFROM routes r\nJOIN airports a ON r.src_apid = a.apid\nWHERE a.country = 'China'\nGROUP BY dst_ap\nORDER BY route_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n    \"1\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n    \"2\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\"\n}\n"}
{"sample_id": "train.6980", "db_id": "culture_company", "question": "Show all publishers which do not have a book in 1989.", "rationale": ["We need to find all publishers that do not have a book published in 1989.", "To do this, we will first identify all publishers that have published a book in 1989 using a subquery.", "The subquery will select distinct publishers from the 'book_club' table where the year is 1989.", "Next, we will select distinct publishers from the 'book_club' table and use the NOT IN clause to exclude those found in the subquery.", "This will give us the list of publishers that do not have any books published in 1989."], "gold_sql": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  1989", "source_tables": ["book_club"], "pred_sql": "SELECT DISTINCT Publisher \nFROM book_club \nWHERE Publisher NOT IN (\n    SELECT DISTINCT Publisher \n    FROM book_club \n    WHERE Year = '1989'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of publishers from the 'book_club' table, grouped by the publisher's name. The results are ordered by the number of books published by each publisher in descending order, with a limit on the number of publishers returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6990", "db_id": "culture_company", "question": "Show all director names who have a movie in the year 1999 or 2000.", "rationale": ["Identify the table that contains the information about movies, which is the 'movie' table.", "Determine the relevant column that contains the director's names, which is 'Director'.", "Identify the column that contains the year of the movie, which is 'Year'.", "Use the SQL 'SELECT' statement to retrieve distinct director names from the 'movie' table.", "Apply a 'WHERE' clause to filter the results for the years 1999 and 2000 using the 'IN' operator."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6991", "db_id": "culture_company", "question": "Which directors had a movie in either 1999 or 2000?", "rationale": ["Identify the relevant table: The question pertains to movie directors, so we will focus on the 'movie' table.", "Determine the columns needed: We need the 'Director' column to answer the question.", "Filter the results: We need to filter the movies based on the years 1999 and 2000.", "Use the DISTINCT keyword: Since we want to know which directors had movies in those years, we should use DISTINCT to avoid duplicate entries for directors who may have multiple movies in those years."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6996", "db_id": "culture_company", "question": "Show the movie titles and book titles for all companies in China.", "rationale": ["Identify the tables involved: culture_company, movie, and book_club.", "Determine the columns needed: movie titles from the movie table and book titles from the book_club table.", "Establish the relationships between the tables using JOINs: culture_company to movie and culture_company to book_club.", "Filter the results to only include companies based in China using a WHERE clause."], "gold_sql": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  'China'", "source_tables": ["culture_company", "movie", "book_club"], "pred_sql": "SELECT movie.Title AS Movie_Title, book_club.Book_Title AS Book_Title\nFROM culture_company\nJOIN movie ON culture_company.movie_id = movie.movie_id\nJOIN book_club ON culture_company.book_club_id = book_club.book_club_id\nWHERE culture_company.Company_name = 'China';", "hint": "\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant tables: car_names, model_list, and cars_data are needed to find the car model and its horsepower.", "Join the car_names table with the model_list table on the Model column to get the car maker information.", "Join the resulting table with the cars_data table on the MakeId to access the horsepower data.", "Order the results by horsepower in ascending order to find the minimum value.", "Limit the results to 1 to get only the model with the minimum horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower FROM car_names JOIN model_list ON car_names.Model = model_list.Model JOIN cars_data ON car_names.MakeId = cars_data.Id ORDER BY Horsepower ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n    \"1\": \"The virtual table describes the car models from the 'car_names' table that have a weight less than the average weight of all cars in the 'cars_data' table. The query uses a subquery to calculate the average weight, ensuring that only lighter models are selected.\",\n    \"2\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\"\n}\n"}
{"sample_id": "dev.103", "db_id": "car_1", "question": "Which distinct car models are the produced after 1980?", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data are needed to get distinct car models and their manufacturing year.", "Join the model_list table with the car_names table on the Model column to get the car make information.", "Join the resulting table with the cars_data table on the MakeId to access the manufacturing year of the car models.", "Filter the results to include only those models manufactured after 1980 using the WHERE clause.", "Select distinct car models to avoid duplicates in the final output."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "pred_sql": "SELECT DISTINCT ml.Model \nFROM model_list ml \nJOIN car_names cn ON ml.Model = cn.Model \nJOIN cars_data cd ON cn.MakeId = cd.Id \nWHERE cd.Year > 1980;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"1\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n    \"2\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\"\n}\n"}
{"sample_id": "dev.106", "db_id": "car_1", "question": "What is the name of each continent and how many car makers are there in each one?", "rationale": ["Identify the tables needed: continents, countries, and car_makers.", "We need to count the number of car makers for each continent, so we will use the COUNT() function.", "Join the continents table with the countries table on the ContId and Continent columns.", "Join the countries table with the car_makers table on the CountryId and Country columns.", "Group the results by continent to get the count of car makers for each continent."], "gold_sql": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;", "source_tables": ["countries", "car_makers", "continents"], "pred_sql": "SELECT c.Continent, COUNT(cm.Id) AS CarMakerCount\nFROM continents c\nJOIN countries co ON c.ContId = co.Continent\nJOIN car_makers cm ON co.CountryId = cm.Country\nGROUP BY c.Continent;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: We need to find the accelerate time for a specific car make, which involves the 'cars_data', 'car_names', 'model_list', and 'car_makers' tables.", "Determine the relationships: 'cars_data' is linked to 'car_names' through 'MakeId', 'car_names' is linked to 'model_list' through 'Model', and 'model_list' is linked to 'car_makers' through 'Maker'.", "Filter the results: We need to filter the results to only include the car make 'amc hornet sportabout (sw)'.", "Select the desired column: We want to retrieve the 'Accelerate' column from the 'cars_data' table."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT cars_data.Accelerate \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nJOIN model_list ON car_names.Model = model_list.Model \nJOIN car_makers ON model_list.Maker = car_makers.Id \nWHERE car_names.Make = 'amc hornet sportabout (sw)';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n    \"1\": \"The virtual table describes the car models from the 'car_names' table that have a weight less than the average weight of all cars in the 'cars_data' table. The query uses a subquery to calculate the average weight, ensuring that only lighter models are selected.\",\n    \"2\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the relevant tables: car_makers and countries.", "We need to count distinct car makers based in France.", "Join the car_makers table with the countries table on the country identifier.", "Filter the results to include only those countries where the CountryName is 'France'.", "Use the COUNT function to get the number of distinct car makers."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(DISTINCT car_makers.Id) AS NumberOfCarMakers\nFROM car_makers\nJOIN countries ON car_makers.Country = countries.CountryId\nWHERE countries.CountryName = 'France';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"1\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n    \"2\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\"\n}\n"}
{"sample_id": "dev.114", "db_id": "car_1", "question": "What is the number of makers of care in France?", "rationale": ["Identify the relevant tables: We need to find the number of car makers in France, so we will use the 'car_makers' and 'countries' tables.", "Determine the relationship: The 'car_makers' table has a foreign key 'Country' that references 'countries.CountryId'. We will join these two tables on this key.", "Filter for France: We need to filter the results to only include car makers based in France. This is done by checking the 'CountryName' in the 'countries' table.", "Count distinct makers: We want the count of unique car makers, so we will use COUNT(DISTINCT car_makers.Id) to get the number of unique makers in France."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(DISTINCT car_makers.Id) AS NumberOfMakers\nFROM car_makers\nJOIN countries ON car_makers.Country = countries.CountryId\nWHERE countries.CountryName = 'France';", "hint": "\n"}
{"sample_id": "dev.115", "db_id": "car_1", "question": "How many car models are produced in the usa?", "rationale": ["Identify the relevant tables: We need to find car models produced in the USA, so we will use the 'model_list', 'car_makers', and 'countries' tables.", "Join the tables: We will join 'model_list' with 'car_makers' on the 'Maker' field, and then join 'car_makers' with 'countries' on the 'Country' field to filter by country.", "Filter by country: We will add a WHERE clause to filter the results to only include car makers from the USA.", "Count distinct models: We will use COUNT(DISTINCT ml.Model) to count the unique car models produced in the USA."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "pred_sql": "SELECT COUNT(DISTINCT ml.Model) AS NumberOfModels\nFROM model_list ml\nJOIN car_makers cm ON ml.Maker = cm.Id\nJOIN countries c ON cm.Country = c.CountryId\nWHERE c.CountryName = 'USA';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"1\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n    \"2\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\"\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the countries in Europe by filtering the 'countries' table where the continent is Europe.", "Join the 'car_makers' table to the 'countries' table to find car manufacturers based in those countries.", "Count the number of manufacturers for each country using a subquery that groups by the maker and filters for those with at least 3 manufacturers.", "Select the country names from the 'countries' table that meet the criteria of having at least 3 car manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName\nFROM countries c\nJOIN car_makers cm ON c.CountryId = cm.Country\nJOIN (SELECT Maker, COUNT(*) as ManufacturerCount\n      FROM car_makers\n      GROUP BY Maker\n      HAVING ManufacturerCount >= 3) as m ON cm.Id = m.Maker\nWHERE c.Continent = (SELECT ContId FROM continents WHERE Continent = 'Europe');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the relevant tables: 'cars_data' for horsepower and cylinders, and 'car_names' for the make of the car.", "We need to find the maximum horsepower, so we will use the MAX() function on the 'Horsepower' column from the 'cars_data' table.", "We need to filter the results to only include car models with 3 cylinders, which will be done using a WHERE clause.", "To get the make of the car models, we will join the 'cars_data' table with the 'car_names' table on the appropriate foreign key relationship.", "Finally, we will group the results by the make of the car to ensure we get the maximum horsepower for each make that has models with 3 cylinders."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(cars_data.Horsepower) AS MaxHorsepower, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Cylinders = 3 \nGROUP BY car_names.Make;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n    \"1\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n    \"2\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\"\n}\n"}
{"sample_id": "dev.133", "db_id": "car_1", "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.", "rationale": ["Identify the relevant tables: 'cars_data' for MPG and 'car_names' for car models.", "Join 'cars_data' and 'car_names' on the common key 'MakeId'.", "Select the 'Model' and 'MPG' columns from the joined tables.", "Order the results by 'MPG' in descending order to get the model with the highest fuel efficiency.", "Limit the results to 1 to get only the model that saves the most gasoline."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, MPG FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId ORDER BY MPG DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n    \"1\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n    \"2\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\"\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["Identify the relevant tables: We need to get information from the 'car_makers' and 'model_list' tables.", "Join the 'car_makers' table with the 'model_list' table on the car maker's ID to associate each maker with their models.", "Group the results by the car maker's ID and name to aggregate the number of models each maker has.", "Use the HAVING clause to filter the groups to only include those makers that have more than 3 models."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(ml.ModelId) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"1\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n    \"2\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\"\n}\n"}
{"sample_id": "dev.158", "db_id": "car_1", "question": "For a volvo model, how many cylinders does the version with least accelerate have?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car models.", "We need to filter for the model 'volvo' from the 'car_names' table.", "Join 'cars_data' with 'car_names' on the appropriate foreign key (MakeId).", "Select the 'Cylinders' column from 'cars_data'.", "Order the results by 'Accelerate' in ascending order to find the version with the least acceleration time.", "Limit the results to 1 to get only the top result."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT cars_data.Cylinders \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE car_names.Model = 'volvo' \nORDER BY cars_data.Accelerate ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n    \"1\": \"The virtual table describes the car models from the 'car_names' table that have a weight less than the average weight of all cars in the 'cars_data' table. The query uses a subquery to calculate the average weight, ensuring that only lighter models are selected.\",\n    \"2\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\"\n}\n"}
{"sample_id": "dev.160", "db_id": "car_1", "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?", "rationale": ["Identify the requirement: We need to count the number of cars with an acceleration time greater than the maximum horsepower.", "To find the maximum horsepower, we can use a subquery that selects the maximum value from the 'Horsepower' column in the 'cars_data' table.", "We then need to count the number of entries in the 'cars_data' table where the 'Accelerate' value is greater than the result of the subquery.", "The final SQL query combines these elements to count the cars that meet the specified condition."], "gold_sql": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "source_tables": ["cars_data"], "pred_sql": "SELECT COUNT(*) \nFROM cars_data \nWHERE Accelerate > (SELECT MAX(Horsepower) \n                    FROM cars_data)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n    \"1\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n    \"2\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\"\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car models.", "We need to filter the cars based on the number of cylinders, specifically those with 4 cylinders.", "Join the 'cars_data' table with the 'car_names' table on the appropriate foreign key (cars_data.Id = car_names.MakeId).", "Select the car model and the maximum horsepower for cars with 4 cylinders.", "Group the results by car model to aggregate the horsepower values.", "Order the results by maximum horsepower in descending order to find the model with the largest horsepower.", "Limit the results to 1 to get only the top model."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT car_names.Model, MAX(cars_data.Horsepower) AS MaxHorsepower\nFROM cars_data\nJOIN car_names ON cars_data.Id = car_names.MakeId\nWHERE cars_data.Cylinders = 4\nGROUP BY car_names.Model\nORDER BY MaxHorsepower DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n    \"1\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n    \"2\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\"\n}\n"}
{"sample_id": "dev.166", "db_id": "car_1", "question": "For all of the 4 cylinder cars, which model has the most horsepower?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car models.", "We need to filter for cars with 4 cylinders, so we will use a WHERE clause on 'cars_data.Cylinders'.", "To find the model with the most horsepower, we will select the 'Model' from 'car_names' and the maximum 'Horsepower' from 'cars_data'.", "We will join 'cars_data' and 'car_names' on the appropriate foreign key, which is 'cars_data.Id' and 'car_names.MakeId'.", "We will group the results by 'car_names.Model' to aggregate the horsepower values for each model.", "Finally, we will order the results by the maximum horsepower in descending order and limit the output to 1 to get the model with the highest horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT car_names.Model, MAX(cars_data.Horsepower) AS MaxHorsepower\nFROM cars_data\nJOIN car_names ON cars_data.Id = car_names.MakeId\nWHERE cars_data.Cylinders = 4\nGROUP BY car_names.Model\nORDER BY MaxHorsepower DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n    \"1\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n    \"2\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\"\n}\n"}
{"sample_id": "dev.168", "db_id": "car_1", "question": "Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car make information.", "We need to find cars with less than 4 cylinders, so we will filter on the 'Cylinders' column in the 'cars_data' table.", "We also need to exclude cars with the minimum horsepower, so we will use a subquery to find the minimum horsepower from the 'cars_data' table.", "Join 'cars_data' with 'car_names' on the 'Id' and 'MakeId' to get the make information for the cars.", "Select the 'MakeId' and 'Make' from the joined tables where the horsepower is greater than the minimum horsepower and the number of cylinders is less than 4."], "gold_sql": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  4;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT car_names.MakeId, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Horsepower > (SELECT MIN(Horsepower) FROM cars_data) \nAND cars_data.Cylinders < 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n    \"1\": \"The virtual table describes the car models from the 'car_names' table that have a weight less than the average weight of all cars in the 'cars_data' table. The query uses a subquery to calculate the average weight, ensuring that only lighter models are selected.\",\n    \"2\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["We need to find car makers that produce at least 2 models and make more than 3 cars.", "To do this, we will join the 'car_makers' table with the 'model_list' table to get the models associated with each maker.", "Next, we will join the 'car_names' table to link the models to their respective makes.", "Finally, we will join the 'cars_data' table to count the number of cars produced by each maker.", "We will group the results by the car maker's ID and name, and use the HAVING clause to filter for makers that have at least 2 distinct models and more than 3 cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nJOIN car_names cn ON ml.Model = cn.Model\nJOIN cars_data cd ON cn.MakeId = cd.Id\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(DISTINCT ml.Model) >= 2 AND COUNT(cd.Id) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n    \"1\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\",\n    \"2\": \"The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.\"\n}\n"}
{"sample_id": "dev.180", "db_id": "flight_2", "question": "What country is Jetblue Airways affiliated with?", "rationale": ["Identify the relevant table: The 'airlines' table contains information about airlines, including their country affiliation.", "Determine the specific airline of interest: The user is asking about 'Jetblue Airways'.", "Construct the SQL query to select the 'Country' column from the 'airlines' table where the 'Airline' column matches 'Jetblue Airways'."], "gold_sql": "SELECT Country FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "pred_sql": "SELECT Country FROM airlines WHERE Airline = 'Jetblue Airways';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\",\n    \"1\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.194", "db_id": "flight_2", "question": "Give the airline with abbreviation 'UAL'.", "rationale": ["Identify the relevant table: The 'airlines' table contains the abbreviation information.", "Determine the condition: We need to filter the results to find the airline with the abbreviation 'UAL'.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'airlines' table where the abbreviation matches 'UAL'."], "gold_sql": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  'UAL'", "source_tables": ["airlines"], "pred_sql": "SELECT * FROM airlines WHERE Abbreviation = 'UAL';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\",\n    \"1\": \"This virtual table lists unique airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The placeholder in the LIMIT clause represents the maximum number of airport codes to return.\"\n}\n"}
{"sample_id": "dev.214", "db_id": "flight_2", "question": "Give the number of Jetblue Airways flights.", "rationale": ["Identify the relevant table: The 'flights' table contains information about the flights, including the airline name.", "Determine the condition: We need to filter the flights to only include those operated by 'Jetblue Airways'.", "Count the number of flights: Use the COUNT() function to get the total number of flights that meet the condition."], "gold_sql": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = 'JetBlue Airways'", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT COUNT(*) AS NumberOfFlights\nFROM flights\nWHERE Airline = 'Jetblue Airways';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\",\n    \"1\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.225", "db_id": "flight_2", "question": "What is the code of airport that has the highest number of flights?", "rationale": ["Identify the relevant tables: 'flights' and 'airports'.", "Determine that we need to find the airport code with the highest number of flights.", "Recognize that flights can be either source or destination, so we need to consider both SourceAirport and DestAirport.", "Use a UNION to combine the counts of flights from both SourceAirport and DestAirport.", "Group the results by airport code to count the number of flights for each airport.", "Order the results by the count of flights in descending order to get the airport with the highest number of flights.", "Limit the results to 1 to get only the airport code with the highest number of flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT SourceAirport AS AirportCode\nFROM flights\nGROUP BY SourceAirport\nUNION ALL\nSELECT DestAirport AS AirportCode\nFROM flights\nGROUP BY DestAirport\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table lists unique airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The placeholder in the LIMIT clause represents the maximum number of airport codes to return.\"\n}\n"}
{"sample_id": "dev.227", "db_id": "flight_2", "question": "What is the code of airport that has fewest number of flights?", "rationale": ["Identify the airports that are either source or destination for flights.", "Use a subquery to get a list of unique airport codes from the 'flights' table by combining source and destination airports.", "Group the results by airport code to count the number of flights associated with each airport.", "Order the grouped results in ascending order based on the count of flights to find the airport with the fewest flights.", "Limit the results to return only the top result, which is the airport code with the fewest number of flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT AirportCode FROM airports WHERE AirportCode IN (SELECT SourceAirport FROM flights UNION SELECT DestAirport FROM flights) GROUP BY AirportCode ORDER BY COUNT(*) ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table lists unique airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The placeholder in the LIMIT clause represents the maximum number of airport codes to return.\"\n}\n"}
{"sample_id": "dev.229", "db_id": "flight_2", "question": "Which airline has most number of flights?", "rationale": ["Identify the relevant tables: 'flights' and 'airlines'.", "We need to count the number of flights for each airline, so we will use the COUNT() function on the 'FlightNo' column from the 'flights' table.", "Group the results by the 'Airline' column to aggregate the flight counts for each airline.", "Order the results in descending order based on the count of flights to find the airline with the most flights.", "Limit the results to 1 to get only the airline with the highest number of flights."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT Airline, COUNT(FlightNo) AS NumberOfFlights\nFROM flights\nGROUP BY Airline\nORDER BY NumberOfFlights DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\",\n    \"1\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.232", "db_id": "flight_2", "question": "What is the abbreviation of the airilne has the fewest flights and what country is it in?", "rationale": ["Identify the airline with the fewest flights by counting the number of flights for each airline in the 'flights' table.", "Group the results by airline name and order them in ascending order based on the count of flights.", "Limit the results to only the airline with the fewest flights.", "Join the result with the 'airlines' table to get the abbreviation and country of that airline.", "Select the abbreviation and country from the joined tables."], "gold_sql": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT a.Abbreviation, a.Country \nFROM airlines a \nJOIN (\n    SELECT Airline, COUNT(*) AS FlightCount \n    FROM flights \n    GROUP BY Airline \n    ORDER BY FlightCount ASC \n    LIMIT 1\n) f ON a.Airline = f.Airline;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The placeholder in the LIMIT clause represents the maximum number of airport codes to return.\",\n    \"1\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.244", "db_id": "flight_2", "question": "Which airlines have less than 200 flights?", "rationale": ["Identify the relevant tables: 'airlines' and 'flights'.", "We need to find airlines with less than 200 flights, so we will join the 'airlines' table with the 'flights' table on the airline name.", "Group the results by airline name to count the number of flights for each airline.", "Use the HAVING clause to filter the grouped results to only include airlines with a count of flights less than 200."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT a.Airline \nFROM airlines a \nJOIN flights f ON a.Airline = f.Airline \nGROUP BY a.Airline \nHAVING COUNT(f.FlightNo) < 200;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.258", "db_id": "flight_2", "question": "Which airports do not have departing or arriving flights?", "rationale": ["Identify the airports from the 'airports' table that do not have any flights departing or arriving.", "To find airports without flights, we need to check which airport codes are not present in the 'flights' table as either SourceAirport or DestAirport.", "We can achieve this by using a subquery that selects all SourceAirport and DestAirport from the 'flights' table and combines them using UNION to get a unique list of airport codes that have flights.", "The main query will then select all airports from the 'airports' table where the AirportCode is not in the list generated by the subquery."], "gold_sql": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)", "source_tables": ["airports", "flights"], "pred_sql": "SELECT AirportCode, AirportName FROM airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM flights UNION SELECT DestAirport FROM flights);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table lists unique airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The placeholder in the LIMIT clause represents the maximum number of airport codes to return.\"\n}\n"}
{"sample_id": "dev.308", "db_id": "cre_Doc_Template_Mgt", "question": "Count the number of documents that use the PPT template type.", "rationale": ["Identify the tables involved: We need to count documents, so we will use the 'Documents' table.", "We need to link documents to their respective templates, which requires joining the 'Documents' table with the 'Templates' table on 'Template_ID'.", "To filter the documents by the specific template type, we will use the 'Template_Type_Code' from the 'Templates' table.", "The specific template type we are interested in is 'PPT'.", "We will use the COUNT function to count the number of documents that meet the criteria."], "gold_sql": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'", "source_tables": ["templates", "documents"], "pred_sql": "SELECT COUNT(Documents.Document_ID) AS Document_Count\nFROM Documents\nJOIN Templates ON Documents.Template_ID = Templates.Template_ID\nWHERE Templates.Template_Type_Code = 'PPT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\",\n    \"1\": \"This virtual table summarizes the number of documents associated with each template from the 'Documents' table. The placeholder in the SELECT clause represents the unique identifier of the template, while the count function aggregates the total number of documents linked to each template.\"\n}\n"}
{"sample_id": "dev.311", "db_id": "cre_Doc_Template_Mgt", "question": "What is the id and type code for the template used by the most documents?", "rationale": ["Identify the tables involved: Templates and Documents.", "We need to find the template used by the most documents, so we will join the Templates table with the Documents table on Template_ID.", "We will group the results by Template_ID and Template_Type_Code to count the number of documents associated with each template.", "Use COUNT(Documents.Document_ID) to count the number of documents for each template.", "Order the results in descending order based on the count of documents to get the template with the most documents at the top.", "Limit the results to 1 to get only the top template."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Templates.Template_ID, Templates.Template_Type_Code\nFROM Templates\nJOIN Documents ON Templates.Template_ID = Documents.Template_ID\nGROUP BY Templates.Template_ID, Templates.Template_Type_Code\nORDER BY COUNT(Documents.Document_ID) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\",\n    \"1\": \"This virtual table summarizes the number of documents associated with each template from the 'Documents' table. The placeholder in the SELECT clause represents the unique identifier of the template, while the count function aggregates the total number of documents linked to each template.\"\n}\n"}
{"sample_id": "dev.312", "db_id": "cre_Doc_Template_Mgt", "question": "Return the id and type code of the template that is used for the greatest number of documents.", "rationale": ["We need to find the template that is used for the greatest number of documents.", "To do this, we will join the 'Templates' table with the 'Documents' table on the 'Template_ID' column.", "We will group the results by 'Template_ID' and 'Template_Type_Code' to aggregate the count of documents for each template.", "We will use the COUNT function to count the number of documents associated with each template.", "Finally, we will order the results in descending order based on the count of documents and limit the result to 1 to get the template with the greatest number of documents."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Templates.Template_ID, Templates.Template_Type_Code\nFROM Templates\nJOIN Documents ON Templates.Template_ID = Documents.Template_ID\nGROUP BY Templates.Template_ID, Templates.Template_Type_Code\nORDER BY COUNT(Documents.Document_ID) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\",\n    \"1\": \"This virtual table summarizes the number of documents associated with each template from the 'Documents' table. The placeholder in the SELECT clause represents the unique identifier of the template, while the count function aggregates the total number of documents linked to each template.\"\n}\n"}
{"sample_id": "dev.341", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template type codes and the number of documents using each type.", "rationale": ["Identify the tables involved: Templates and Documents.", "Determine the relationship between the tables: Documents are linked to Templates via Template_ID.", "Select the Template_Type_Code from the Templates table and count the number of Document_IDs from the Documents table.", "Use a JOIN to combine the Templates and Documents tables based on the Template_ID.", "Group the results by Template_Type_Code to get the count of documents for each template type."], "gold_sql": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code", "source_tables": ["templates", "documents"], "pred_sql": "SELECT T.Template_Type_Code, COUNT(D.Document_ID) AS Document_Count\nFROM Templates T\nJOIN Documents D ON T.Template_ID = D.Template_ID\nGROUP BY T.Template_Type_Code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\",\n    \"1\": \"This virtual table summarizes the number of documents associated with each template from the 'Documents' table. The placeholder in the SELECT clause represents the unique identifier of the template, while the count function aggregates the total number of documents linked to each template.\"\n}\n"}
{"sample_id": "dev.346", "db_id": "cre_Doc_Template_Mgt", "question": "What are the codes of template types that are not used for any document?", "rationale": ["We need to find template types that are not used for any document.", "To do this, we will start by selecting the 'Template_Type_Code' from the 'Ref_Template_Types' table.", "We will perform a LEFT JOIN with the 'Templates' table on 'Template_Type_Code' to include all template types, even those that do not have any associated templates.", "Next, we will perform another LEFT JOIN with the 'Documents' table on 'Template_ID' to include all documents associated with the templates.", "Finally, we will filter the results using a WHERE clause to check for NULL values in 'Documents.Document_ID', which indicates that there are no documents associated with those template types."], "gold_sql": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Ref_Template_Types.Template_Type_Code \nFROM Ref_Template_Types \nLEFT JOIN Templates ON Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code \nLEFT JOIN Documents ON Templates.Template_ID = Documents.Template_ID \nWHERE Documents.Document_ID IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\",\n    \"1\": \"This virtual table summarizes the number of documents associated with each template from the 'Documents' table. The placeholder in the SELECT clause represents the unique identifier of the template, while the count function aggregates the total number of documents linked to each template.\"\n}\n"}
{"sample_id": "dev.361", "db_id": "cre_Doc_Template_Mgt", "question": "Show paragraph details for paragraph with text 'Korea ' .", "rationale": ["Identify the table that contains paragraph details, which is the 'Paragraphs' table.", "Determine the column that contains the text of the paragraph, which is 'Paragraph_Text'.", "Formulate a SQL query to select all columns from the 'Paragraphs' table where 'Paragraph_Text' matches the specified text 'Korea '."], "gold_sql": "select other_details from paragraphs where paragraph_text like 'korea'", "source_tables": ["paragraphs"], "pred_sql": "SELECT * FROM Paragraphs WHERE Paragraph_Text = 'Korea ';", "hint": "\n"}
{"sample_id": "dev.367", "db_id": "cre_Doc_Template_Mgt", "question": "Show all document ids and the number of paragraphs in each document. Order by document id.", "rationale": ["We need to retrieve all document IDs and the count of paragraphs associated with each document.", "To achieve this, we will use a LEFT JOIN between the 'Documents' table and the 'Paragraphs' table on the 'Document_ID' field.", "Using COUNT(p.Paragraph_ID) will allow us to count the number of paragraphs for each document, even if some documents have no paragraphs (hence the LEFT JOIN).", "We will group the results by 'Document_ID' to ensure we get a count for each document.", "Finally, we will order the results by 'Document_ID' to meet the requirement of ordering the output."], "gold_sql": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id", "source_tables": ["paragraphs"], "pred_sql": "SELECT d.Document_ID, COUNT(p.Paragraph_ID) AS Number_of_Paragraphs\nFROM Documents d\nLEFT JOIN Paragraphs p ON d.Document_ID = p.Document_ID\nGROUP BY d.Document_ID\nORDER BY d.Document_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of documents associated with each template from the 'Documents' table. The placeholder in the SELECT clause represents the unique identifier of the template, while the count function aggregates the total number of documents linked to each template.\",\n    \"1\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\"\n}\n"}
{"sample_id": "dev.439", "db_id": "wta_1", "question": "Find the highest rank of losers in all matches.", "rationale": ["Identify the relevant tables: We need to look at the 'matches' table to find the losers and the 'rankings' table to find their ranks.", "We need to find the 'loser_id' from the 'matches' table, which represents the players who lost in the matches.", "Next, we will use the 'rankings' table to find the ranks of these losers by filtering the 'player_id' based on the 'loser_id' from the matches.", "To find the highest rank among the losers, we will use the MIN function on the ranking values of the losers."], "gold_sql": "SELECT min(loser_rank) FROM matches", "source_tables": ["matches"], "pred_sql": "SELECT MIN(ranking) AS highest_rank FROM rankings WHERE player_id IN (SELECT loser_id FROM matches)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\"\n}\n"}
{"sample_id": "dev.458", "db_id": "wta_1", "question": "What are the full names of all left handed players, in order of birth date?", "rationale": ["Identify the relevant table: The 'players' table contains the information about players, including their names and handedness.", "Determine the condition: We need to filter for left-handed players, which is specified in the 'hand' column.", "Select the required fields: We need the full names of the players, which can be constructed by concatenating 'first_name' and 'last_name'.", "Order the results: The results should be ordered by 'birth_date' to get the players in chronological order of their birth.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date", "source_tables": ["players"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name\nFROM players\nWHERE hand = 'left'\nORDER BY birth_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\"\n}\n"}
{"sample_id": "dev.464", "db_id": "wta_1", "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?", "rationale": ["Identify the relevant tables: matches, players, and rankings are needed to get the winner's name and their rank points.", "Join the matches table with the players table on the winner_id to get the winner's name.", "Join the resulting table with the rankings table on player_id to get the rank points for each winner.", "Group the results by winner_name to count the number of matches won by each player.", "Use COUNT(*) to count the number of matches for each winner and ORDER BY this count in descending order to find the player with the most wins.", "Select the winner_name and the maximum rank_points for that player.", "Limit the results to 1 to get only the top winner."], "gold_sql": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["matches"], "pred_sql": "SELECT winner_name, MAX(rank_points) AS rank_points\nFROM matches\nJOIN players ON matches.winner_id = players.player_id\nJOIN rankings ON players.player_id = rankings.player_id\nGROUP BY winner_name\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\"\n}\n"}
{"sample_id": "dev.471", "db_id": "wta_1", "question": "Find the total ranking points for each player and their first name.", "rationale": ["The query needs to find the total ranking points for each player along with their first name.", "To achieve this, we will select the 'first_name' from the 'players' table and the sum of 'ranking_points' from the 'rankings' table.", "We will join the 'players' table with the 'rankings' table on the 'player_id' column, which is common in both tables.", "We will group the results by 'first_name' to calculate the total ranking points for each player.", "Finally, we will use the SUM function to aggregate the ranking points for each player."], "gold_sql": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name", "source_tables": ["rankings", "players"], "pred_sql": "SELECT players.first_name, SUM(rankings.ranking_points) AS total_ranking_points\nFROM players\nJOIN rankings ON players.player_id = rankings.player_id\nGROUP BY players.first_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\"\n}\n"}
{"sample_id": "dev.479", "db_id": "wta_1", "question": "Find the total number of tours for each ranking date.", "rationale": ["The query needs to find the total number of tours for each ranking date.", "We will select the 'ranking_date' from the 'rankings' table.", "To count the distinct tours for each ranking date, we will use the COUNT function with DISTINCT on the 'tours' column.", "We will group the results by 'ranking_date' to get the total tours for each date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(DISTINCT tours) AS total_tours\nFROM rankings\nGROUP BY ranking_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\"\n}\n"}
{"sample_id": "dev.480", "db_id": "wta_1", "question": "How many total tours were there for each ranking date?", "rationale": ["The question asks for the total number of tours for each ranking date.", "We need to select the 'ranking_date' from the 'rankings' table.", "To count the distinct tours for each ranking date, we will use the COUNT function with DISTINCT on the 'tours' column.", "We will group the results by 'ranking_date' to get the count for each date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(DISTINCT tours) AS total_tours\nFROM rankings\nGROUP BY ranking_date;", "hint": "\n"}
{"sample_id": "dev.533", "db_id": "student_transcripts_tracking", "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to find students who are enrolled in two different degree programs in the same semester.", "Join the Students table with the Student_Enrolment table to get student details along with their enrolment records.", "To find students enrolled in two degree programs, we can join the Student_Enrolment table to itself (self-join) on the student_id.", "In the self-join, ensure that the degree_program_id is different for the two records but the semester_id is the same.", "Select the required fields: first_name, middle_name, last_name, and student_id."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Student_Enrolment se2 ON s.student_id = se2.student_id\nWHERE se.degree_program_id != se2.degree_program_id\nAND se.semester_id = se2.semester_id;", "hint": "\n"}
{"sample_id": "dev.536", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs.", "We need to select the first, middle, and last names of students, which are in the Students table.", "To find out which students are enrolled in a Bachelors program, we need to join the Students table with the Student_Enrolment table on student_id.", "Next, we join the Student_Enrolment table with the Degree_Programs table on degree_program_id to filter for Bachelors programs.", "The condition for the Bachelors program is specified in the WHERE clause using a LIKE statement to match any degree program that includes 'Bachelors'."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name \nFROM Students s \nJOIN Student_Enrolment se ON s.student_id = se.student_id \nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id \nWHERE dp.degree_summary_name LIKE '%Bachelors%';", "hint": "\n"}
{"sample_id": "dev.537", "db_id": "student_transcripts_tracking", "question": "Find the kind of program which most number of students are enrolled in?", "rationale": ["Identify the relevant tables: We need to find the degree programs and the number of students enrolled in each program, so we will use the Student_Enrolment and Degree_Programs tables.", "Join the tables: We will join the Student_Enrolment table with the Degree_Programs table on the degree_program_id to associate each enrolment with its corresponding program.", "Count the number of students: We will use the COUNT function to count the number of student enrolments for each degree program.", "Group the results: We will group the results by the degree_summary_name to get the count of students for each program.", "Order the results: We will order the results in descending order based on the student count to find the program with the most students enrolled.", "Limit the results: Finally, we will limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_summary_name, COUNT(se.student_enrolment_id) AS student_count\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nGROUP BY dp.degree_summary_name\nORDER BY student_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["Identify the relevant tables: Degree_Programs and Student_Enrolment.", "We need to find the degree program with the most students enrolled, so we will join these two tables on the degree_program_id.", "Group the results by degree_program_id and degree_summary_name to count the number of students enrolled in each program.", "Use COUNT(se.student_id) to count the number of students for each program.", "Order the results in descending order based on the count of students to get the program with the most enrollments at the top.", "Limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_program_id, dp.degree_summary_name\nFROM Degree_Programs dp\nJOIN Student_Enrolment se ON dp.degree_program_id = se.degree_program_id\nGROUP BY dp.degree_program_id, dp.degree_summary_name\nORDER BY COUNT(se.student_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to count the number of enrollments for each student, so we will join the Students table with the Student_Enrolment table on the student_id.", "Use COUNT() to count the number of enrollments for each student.", "Group the results by student_id to get the count for each student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Limit the results to 1 to get only the student with the highest number of enrollments."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name, COUNT(se.student_enrolment_id) AS number_of_enrollments\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id\nORDER BY number_of_enrollments DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["Identify the relevant tables: Courses and Student_Enrolment_Courses, which links courses to student enrollments.", "Join the Courses table with the Student_Enrolment_Courses table on course_id to get the course names associated with enrollments.", "Join the Student_Enrolment table to count the number of enrollments for each course.", "Group the results by course name to aggregate the enrollments for each course.", "Order the results by the count of enrollments in descending order to find the course with the most enrollments.", "Limit the results to 1 to get only the course with the highest number of enrollments."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT Courses.course_name\nFROM Courses\nJOIN Student_Enrolment_Courses ON Courses.course_id = Student_Enrolment_Courses.course_id\nJOIN Student_Enrolment ON Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id\nGROUP BY Courses.course_name\nORDER BY COUNT(Student_Enrolment.student_enrolment_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of course names from the 'Courses' table that are associated with student enrolments. The results are grouped by course name and ordered by the number of enrolments in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of course names to return.\"\n}\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant table: We need to retrieve last names of students, so we will focus on the 'Students' table.", "Filter students based on their address: We need to find students who live in North Carolina. This requires a subquery to the 'Addresses' table to get the 'address_id' for North Carolina.", "Check for students not registered in any degree programs: We need to ensure that these students have not enrolled in any degree programs, which requires another subquery to the 'Student_Enrolment' table to filter out those who have a record in that table.", "Combine the conditions: The final query will select the last names of students whose current address is in North Carolina and who do not have any enrolment records."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "SELECT last_name \nFROM Students \nWHERE current_address_id IN (\n    SELECT address_id \n    FROM Addresses \n    WHERE state_province_county = 'North Carolina'\n) \nAND student_id NOT IN (\n    SELECT student_id \n    FROM Student_Enrolment\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\",\n    \"1\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile number.\"\n}\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table: The 'Students' table contains the information about students, including their mobile phone numbers.", "Determine the columns needed: We need the 'cell_mobile_number' column to get the mobile phone number.", "Specify the conditions: We need to filter the results to find the student named 'Timmothy Ward'. This requires checking both the 'first_name' and 'last_name' columns.", "Construct the SQL query: Using the SELECT statement to retrieve the 'cell_mobile_number' from the 'Students' table where the first name is 'Timmothy' and the last name is 'Ward'."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\",\n    \"1\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile number.\"\n}\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["Identify the relevant tables: We need to look at the 'Addresses' table for address details and the 'Students' table to count the number of students associated with each address.", "Join the 'Addresses' table with the 'Students' table on the current address ID to link students to their addresses.", "Group the results by address ID to count how many students are associated with each address.", "Order the results by the count of students in descending order to find the address with the most students.", "Limit the results to 1 to get only the address with the highest count of students."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT a.address_id, a.line_1, a.line_2, a.line_3\nFROM Addresses a\nJOIN Students s ON a.address_id = s.current_address_id\nGROUP BY a.address_id\nORDER BY COUNT(s.student_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\",\n    \"1\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile number.\"\n}\n"}
{"sample_id": "dev.576", "db_id": "student_transcripts_tracking", "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?", "rationale": ["Identify the relevant tables: Student_Enrolment and Degree_Programs.", "We need to find semesters that had both Masters and Bachelors students enrolled.", "Join the Student_Enrolment table with the Degree_Programs table on the degree_program_id.", "Filter the results to include only those degree programs that are either 'Masters' or 'Bachelors'.", "Group the results by semester_id to aggregate the data for each semester.", "Use HAVING clause to ensure that both degree types are present in the results by counting distinct degree_summary_name and checking if it equals 2."], "gold_sql": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT DISTINCT se.semester_id\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nWHERE dp.degree_summary_name IN ('Masters', 'Bachelors')\nGROUP BY se.semester_id\nHAVING COUNT(DISTINCT dp.degree_summary_name) = 2;", "hint": "\n"}
{"sample_id": "dev.580", "db_id": "student_transcripts_tracking", "question": "What other details can you tell me about students in reverse alphabetical order?", "rationale": ["The question asks for 'other details' about students, which corresponds to the 'other_student_details' column in the Students table.", "To retrieve this information, we will select the 'other_student_details' column from the Students table.", "The question specifies that the results should be in reverse alphabetical order, which means we need to order the results by the last name and first name of the students in descending order.", "Thus, the SQL query will select 'other_student_details' from the Students table and order the results by 'last_name' and 'first_name' in descending order."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "pred_sql": "SELECT other_student_details FROM Students ORDER BY last_name DESC, first_name DESC;", "hint": "\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve the details of a section, we need to select all columns from the Sections table.", "We will use a WHERE clause to filter the results to only include the section where the section_name is 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT * FROM Sections WHERE section_name = 'h';", "hint": "\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries and their government forms.", "Determine the specific information needed: We need to count the number of countries with a government form of 'Republic'.", "Construct the SQL query: Use the COUNT function to count the rows in the 'country' table where the GovernmentForm is 'Republic'."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(*) FROM country WHERE GovernmentForm = 'Republic';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n    \"1\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n    \"2\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\"\n}\n"}
{"sample_id": "dev.730", "db_id": "world_1", "question": "What is the average GNP and total population in all nations whose government is US territory?", "rationale": ["Identify the relevant table: The 'country' table contains the necessary information about GNP and population.", "Determine the required calculations: We need to calculate the average GNP and the total population.", "Use the AVG() function to calculate the average GNP and the SUM() function to calculate the total population.", "Filter the results based on the government form: We need to include only those countries where the GovernmentForm is 'US territory'.", "Construct the SQL query using the SELECT statement with the appropriate aggregate functions and the WHERE clause."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT AVG(GNP) AS AverageGNP, SUM(Population) AS TotalPopulation \nFROM country \nWHERE GovernmentForm = 'US territory';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n    \"1\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\"\n}\n"}
{"sample_id": "dev.734", "db_id": "world_1", "question": "How many type of governments are in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and continent.", "Determine the filtering criteria: We need to filter the countries to only those located in Africa.", "Select distinct government forms: To find out how many types of governments exist, we will select distinct values from the 'GovernmentForm' column."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Continent = 'Africa';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n    \"1\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n    \"2\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\"\n}\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their form of government and continent.", "Determine the specific requirement: We need to find the different forms of government in Africa.", "Use the DISTINCT keyword: To ensure we only get unique forms of government, we will use the DISTINCT keyword in our SELECT statement.", "Filter by continent: We will add a WHERE clause to filter the results to only include countries in Africa."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Continent = 'Africa';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n    \"1\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n    \"2\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\"\n}\n"}
{"sample_id": "dev.742", "db_id": "world_1", "question": "Which continent has the most diverse languages?", "rationale": ["To determine which continent has the most diverse languages, we need to count the distinct languages spoken in each continent.", "We will join the 'country' table with the 'countrylanguage' table using the 'CountryCode' to link them together.", "We will group the results by 'continent' to aggregate the language counts for each continent.", "We will use COUNT(DISTINCT Language) to count the unique languages spoken in each continent.", "Finally, we will order the results by the count of languages in descending order and limit the results to 1 to get the continent with the most diverse languages."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT continent, COUNT(DISTINCT Language) AS LanguageCount\nFROM country\nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode\nGROUP BY continent\nORDER BY LanguageCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n    \"1\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n    \"2\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.743", "db_id": "world_1", "question": "Which continent speaks the most languages?", "rationale": ["We need to find out which continent speaks the most languages.", "To do this, we will join the 'country' table with the 'countrylanguage' table on the 'CountryCode'.", "We will count the distinct languages spoken in each continent by grouping the results by 'country.Continent'.", "We will order the results by the count of languages in descending order to get the continent with the most languages at the top.", "Finally, we will limit the results to 1 to get only the continent that speaks the most languages."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT country.Continent, COUNT(DISTINCT countrylanguage.Language) AS LanguageCount\nFROM country\nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode\nGROUP BY country.Continent\nORDER BY LanguageCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n    \"1\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n    \"2\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.746", "db_id": "world_1", "question": "What are the names of nations speak both English and French?", "rationale": ["Identify the countries that speak both English and French.", "To do this, we need to join the 'country' table with the 'countrylanguage' table twice: once for English and once for French.", "The join condition will be based on the country code, which is the common field between these tables.", "We will filter the results using a WHERE clause to specify that one language is 'English' and the other is 'French'.", "Finally, we will select the names of the countries that meet these criteria."], "gold_sql": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'French'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Name \nFROM country c \nJOIN countrylanguage cl1 ON c.Code = cl1.CountryCode \nJOIN countrylanguage cl2 ON c.Code = cl2.CountryCode \nWHERE cl1.Language = 'English' AND cl2.Language = 'French';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n    \"1\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\",\n    \"2\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\"\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["Identify the tables needed: We need data from the 'country' and 'countrylanguage' tables.", "We want to find countries with either English or Dutch as an official language, so we will use a JOIN between 'country' and 'countrylanguage' on the country code.", "We will filter the results using a WHERE clause to check if the language is either 'English' or 'Dutch' and if it is marked as an official language (IsOfficial = 'T').", "We use DISTINCT to ensure that we only get unique country names in the result."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT country.Name \nFROM country \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE countrylanguage.Language IN ('English', 'Dutch') AND countrylanguage.IsOfficial = 'T';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n    \"1\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\",\n    \"2\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\"\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the total population of countries that do not use English as an official language.", "To achieve this, we need to sum the population from the 'country' table.", "We will filter out countries that have English as an official language using a subquery.", "The subquery selects country codes from the 'countrylanguage' table where the language is 'English' and it is marked as official.", "The main query then sums the populations of countries whose codes are not in the list returned by the subquery."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation\nFROM country c\nWHERE c.Code NOT IN (\n    SELECT cl.CountryCode\n    FROM countrylanguage cl\n    WHERE cl.Language = 'English' AND cl.IsOfficial = 'Yes'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n    \"1\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n    \"2\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.767", "db_id": "world_1", "question": "How many people live in countries that do not speak English?", "rationale": ["Identify the total population of countries that do not speak English.", "To find countries that do not speak English, we need to exclude countries where English is an official language.", "We can achieve this by using a subquery that selects country codes from the countrylanguage table where the language is 'English' and it is marked as official.", "The main query will then sum the populations of countries whose codes are not in the result of the subquery."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation\nFROM country c\nWHERE c.Code NOT IN (\n    SELECT cl.CountryCode\n    FROM countrylanguage cl\n    WHERE cl.Language = 'English' AND cl.IsOfficial = 'Yes'\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n    \"1\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\",\n    \"2\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\"\n}\n"}
{"sample_id": "dev.783", "db_id": "world_1", "question": "Return the codes of countries that do not speak English and do not have Republics for governments.", "rationale": ["Identify the requirement to find country codes that do not speak English and do not have Republics for governments.", "To find countries that do not speak English, we can use a subquery to select country codes from the countrylanguage table where the language is 'English'.", "We will use the NOT IN clause to exclude these country codes from our main query.", "Next, we need to filter out countries that have 'Republic' in their GovernmentForm. We can use the NOT LIKE operator for this purpose.", "Finally, we will select the Code from the country table that meets both conditions."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English') AND GovernmentForm NOT LIKE '%Republic%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n    \"1\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\",\n    \"2\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\"\n}\n"}
{"sample_id": "dev.784", "db_id": "world_1", "question": "Which cities are in European countries where English is not the official language?", "rationale": ["Identify the cities that are located in European countries.", "Join the 'city' table with the 'country' table using the CountryCode to filter by continent.", "Specify the continent as 'Europe' in the WHERE clause.", "Use a subquery to find countries where English is an official language.", "Exclude those countries from the main query using the NOT IN clause."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT c.Name \nFROM city c \nJOIN country co ON c.CountryCode = co.Code \nWHERE co.Continent = 'Europe' \nAND c.CountryCode NOT IN (\n    SELECT cl.CountryCode \n    FROM countrylanguage cl \n    WHERE cl.Language = 'English' \n    AND cl.IsOfficial = 'Yes'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\",\n    \"1\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n    \"2\": \"This virtual table provides the names and populations of cities from the 'city' table that have a specific language spoken, as indicated in the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name, while the placeholder in the LIMIT clause specifies the maximum number of results to return.\"\n}\n"}
{"sample_id": "dev.785", "db_id": "world_1", "question": "What are the names of cities in Europe for which English is not the official language?", "rationale": ["Identify the relevant tables: 'city' for city names and 'country' for continent information.", "Join the 'city' table with the 'country' table on the 'CountryCode' to filter cities in Europe.", "Use a WHERE clause to specify that the continent is 'Europe'.", "Use a subquery to find country codes where English is an official language by checking the 'countrylanguage' table.", "Exclude those country codes from the main query to get cities where English is not an official language."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT c.Name \nFROM city c \nJOIN country co ON c.CountryCode = co.Code \nWHERE co.Continent = 'Europe' \nAND c.CountryCode NOT IN (\n    SELECT cl.CountryCode \n    FROM countrylanguage cl \n    WHERE cl.Language = 'English' \n    AND cl.IsOfficial = 'T'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n    \"1\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\",\n    \"2\": \"This virtual table provides the names and populations of cities from the 'city' table that have a specific language spoken, as indicated in the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name, while the placeholder in the LIMIT clause specifies the maximum number of results to return.\"\n}\n"}
{"sample_id": "dev.788", "db_id": "world_1", "question": "What are the name, independence year, and surface area of the country with the smallest population?", "rationale": ["Identify the required fields: Name, Independence Year (IndepYear), and Surface Area from the country table.", "Determine the condition to find the country with the smallest population, which involves using a subquery to get the minimum population from the country table.", "Construct the SQL query to select the specified fields from the country table where the population matches the minimum population found in the subquery."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n    \"1\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n    \"2\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\"\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the required fields: Name, year of independence (IndepYear), and surface area (SurfaceArea) from the country table.", "Determine the condition to find the country with the lowest population, which involves using a subquery to get the minimum population from the country table.", "Construct the main query to select the desired fields from the country table where the population matches the minimum population found in the subquery."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n    \"1\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n    \"2\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\"\n}\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["We need to find countries that speak more than 2 languages.", "To do this, we will join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' columns respectively.", "We will group the results by the country code to count the number of languages spoken in each country.", "Using the COUNT function, we will count the number of languages for each country.", "Finally, we will filter the results using the HAVING clause to only include countries that have more than 2 languages."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Name, COUNT(cl.Language) AS LanguageCount\nFROM country c\nJOIN countrylanguage cl ON c.Code = cl.CountryCode\nGROUP BY c.Code\nHAVING COUNT(cl.Language) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n    \"1\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n    \"2\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.796", "db_id": "world_1", "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.", "rationale": ["Identify the relevant table: The 'country' table contains the columns for GovernmentForm, Population, and LifeExpectancy.", "Filter the results: We need to include only those countries where the LifeExpectancy is greater than 72.", "Group the results: We want to group the results by GovernmentForm to get the total population for each form of government.", "Select the required columns: We need to select the GovernmentForm and the total population, which can be calculated using SUM(Population)."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation\nFROM country\nWHERE LifeExpectancy > 72\nGROUP BY GovernmentForm;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n    \"1\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n    \"2\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\"\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the relevant table: The 'country' table contains the columns for GovernmentForm, Population, and LifeExpectancy.", "Filter the countries based on the condition: We need to select countries where the average life expectancy is greater than 72.", "Group the results by GovernmentForm: We want to summarize the total population for each type of government.", "Use the SUM function to calculate the total population for each government form.", "Construct the SQL query using the SELECT statement to retrieve the GovernmentForm and the total population, applying the necessary filters and grouping."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation\nFROM country\nWHERE LifeExpectancy > 72\nGROUP BY GovernmentForm;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n    \"1\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\"\n}\n"}
{"sample_id": "dev.801", "db_id": "world_1", "question": "Return the names and surface areas of the 5 largest countries.", "rationale": ["Identify the table needed: The 'country' table contains the names and surface areas of countries.", "Determine the required columns: We need 'Name' and 'SurfaceArea' from the 'country' table.", "Sort the results: To find the largest countries, we need to order the results by 'SurfaceArea' in descending order.", "Limit the results: We only want the top 5 largest countries, so we will use 'LIMIT 5' in the query."], "gold_sql": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5", "source_tables": ["country"], "pred_sql": "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n    \"1\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n    \"2\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\"\n}\n"}
{"sample_id": "dev.810", "db_id": "world_1", "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?", "rationale": ["Identify the relevant table: The 'country' table contains the necessary information about countries, including population and surface area.", "Determine the required fields: We need to calculate the total population and average surface area of countries.", "Apply the conditions: We need to filter countries that are in the continent of 'North America' and have a surface area greater than 3000.", "Construct the SQL query: Use SUM() to get the total population and AVG() to get the average surface area, applying the necessary WHERE conditions."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT SUM(Population) AS TotalPopulation, AVG(SurfaceArea) AS AverageArea \nFROM country \nWHERE Continent = 'North America' AND SurfaceArea > 3000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n    \"1\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n    \"2\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\"\n}\n"}
{"sample_id": "dev.811", "db_id": "world_1", "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .", "rationale": ["Identify the continent of interest, which is North America.", "Determine the criteria for filtering countries, which is a surface area greater than 3000.", "Select the total population and average surface area from the 'country' table.", "Use the SUM function to calculate the total population and the AVG function to calculate the average surface area for the filtered countries."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT SUM(Population) AS TotalPopulation, AVG(SurfaceArea) AS AverageSurfaceArea \nFROM country \nWHERE Continent = 'North America' AND SurfaceArea > 3000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n    \"1\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n    \"2\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\"\n}\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the relevant table: The question asks about cities, so we will use the 'city' table.", "Determine the condition: We need to filter cities based on their population being between 160000 and 900000.", "Construct the SQL query: Use the SELECT statement to retrieve all columns from the 'city' table where the population meets the specified range."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT * FROM city WHERE Population BETWEEN '160000' AND '900000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and populations of cities from the 'city' table that have a specific language spoken, as indicated in the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name, while the placeholder in the LIMIT clause specifies the maximum number of results to return.\",\n    \"1\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n    \"2\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\"\n}\n"}
{"sample_id": "dev.921", "db_id": "dog_kennels", "question": "Find the average age of the dogs who went through treatments.", "rationale": ["To find the average age of dogs who went through treatments, we need to focus on the 'Dogs' table and the 'Treatments' table.", "We will select the 'age' column from the 'Dogs' table.", "To filter the dogs that have received treatments, we will use a subquery that selects 'dog_id' from the 'Treatments' table.", "The main query will calculate the average age of the dogs whose 'dog_id' is in the list returned by the subquery."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT AVG(age) AS average_age\nFROM Dogs\nWHERE dog_id IN (\n    SELECT dog_id\n    FROM Treatments\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\",\n    \"1\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n    \"2\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\"\n}\n"}
{"sample_id": "dev.924", "db_id": "dog_kennels", "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to find dogs that have not cost their owner more than 1000 for treatment, which implies we need to sum the treatment costs for each dog.", "Join the Dogs table with the Treatments table on the dog_id to access treatment costs for each dog.", "Group the results by dog_id to aggregate the treatment costs for each dog.", "Use the HAVING clause to filter the grouped results to only include dogs where the total treatment cost is less than or equal to 1000.", "Select the dog names from the Dogs table based on the filtered results."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.name \nFROM Dogs d \nLEFT JOIN Treatments t ON d.dog_id = t.dog_id \nGROUP BY d.dog_id \nHAVING SUM(t.cost_of_treatment) <= 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\",\n    \"1\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n    \"2\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\"\n}\n"}
{"sample_id": "dev.937", "db_id": "dog_kennels", "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.", "rationale": ["We need to find the owner who spent the most on treatments for their dogs.", "To do this, we will join the Owners table with the Dogs table using the owner_id, and then join the Treatments table using the dog_id.", "We will group the results by owner_id and last_name to aggregate the total treatment costs for each owner.", "We will use the SUM function to calculate the total cost of treatments for each owner.", "Finally, we will order the results in descending order based on the total treatment costs and limit the results to 1 to get the owner who spent the most."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT Owners.owner_id, Owners.last_name\nFROM Owners\nJOIN Dogs ON Owners.owner_id = Dogs.owner_id\nJOIN Treatments ON Dogs.dog_id = Treatments.dog_id\nGROUP BY Owners.owner_id, Owners.last_name\nORDER BY SUM(Treatments.cost_of_treatment) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n    \"1\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\",\n    \"2\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\"\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "We need to find professionals who have administered treatments, so we will join the Professionals table with the Treatments table on the professional_id.", "We want to count the number of distinct treatment types each professional has administered, so we will use COUNT(DISTINCT t.treatment_type_code).", "To ensure we only get professionals who have done at least two types of treatments, we will use the HAVING clause with a condition that the count is greater than or equal to 2.", "Finally, we will select the professional_id and cell_number from the Professionals table."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT p.professional_id, p.cell_number\nFROM Professionals p\nJOIN Treatments t ON p.professional_id = t.professional_id\nGROUP BY p.professional_id\nHAVING COUNT(DISTINCT t.treatment_type_code) >= 2;", "hint": "\n"}
{"sample_id": "dev.943", "db_id": "dog_kennels", "question": "Find the id and cell phone of the professionals who operate two or more types of treatments.", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "We need to find professionals who operate two or more types of treatments, so we will join the Professionals table with the Treatments table on the professional_id.", "We will group the results by professional_id to aggregate the treatment types for each professional.", "Using the COUNT function, we will count the distinct treatment_type_code for each professional.", "We will filter the results using HAVING to include only those professionals who have two or more distinct treatment types."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT p.professional_id, p.cell_number\nFROM Professionals p\nJOIN Treatments t ON p.professional_id = t.professional_id\nGROUP BY p.professional_id\nHAVING COUNT(DISTINCT t.treatment_type_code) >= 2;", "hint": "\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["Identify the tables needed: Owners, Dogs, and Sizes.", "Determine the columns to select: first_name and last_name from Owners, and size_description from Sizes.", "Establish the relationships between the tables: Owners are linked to Dogs via owner_id, and Dogs are linked to Sizes via size_code.", "Construct the SQL query using JOINs to combine the relevant tables and select the desired columns."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\",\n    \"1\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n    \"2\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\"\n}\n"}
{"sample_id": "dev.954", "db_id": "dog_kennels", "question": "List the names of the dogs of the rarest breed and the treatment dates of them.", "rationale": ["Identify the tables needed: Dogs, Breeds, and Treatments.", "We need to list the names of dogs and their treatment dates, so we will select 'Dogs.name' and 'Treatments.date_of_treatment'.", "Join the Dogs table with the Breeds table on 'breed_code' to access breed information.", "Join the Dogs table with the Treatments table on 'dog_id' to access treatment information.", "To find the rarest breed, we need to determine which breed has the least number of dogs. This can be done using a subquery that groups by 'breed_code' and orders by the count of dogs in ascending order, limiting the result to 1.", "The outer query will filter the results to only include dogs of the rarest breed found in the subquery."], "gold_sql": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT Dogs.name, Treatments.date_of_treatment \nFROM Dogs \nJOIN Breeds ON Dogs.breed_code = Breeds.breed_code \nJOIN Treatments ON Dogs.dog_id = Treatments.dog_id \nWHERE Breeds.breed_name = (SELECT breed_name \n                           FROM Breeds \n                           WHERE breed_code = (SELECT breed_code \n                                              FROM Dogs \n                                              GROUP BY breed_code \n                                              ORDER BY COUNT(*) ASC \n                                              LIMIT 1))", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\",\n    \"1\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n    \"2\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\"\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need the arriving and departing dates of dogs, which are in the Dogs table.", "We also need to filter the dogs that have undergone treatments, which is indicated by the Treatments table.", "Join the Dogs table with the Treatments table on the dog_id to get only those dogs that have received treatments.", "Select the date_arrived and date_departed from the Dogs table."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.date_arrived, d.date_departed \nFROM Dogs d \nJOIN Treatments t ON d.dog_id = t.dog_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\",\n    \"1\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n    \"2\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\"\n}\n"}
{"sample_id": "dev.960", "db_id": "dog_kennels", "question": "List the last name of the owner owning the youngest dog.", "rationale": ["Identify the tables involved: Owners and Dogs.", "We need to find the last name of the owner, so we will select Owners.last_name.", "To find the youngest dog, we need to determine the minimum age from the Dogs table.", "Join the Owners table with the Dogs table on the owner_id to link owners with their dogs.", "Use a subquery to find the minimum age of dogs and filter the results to get the owner of the youngest dog."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.last_name \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nWHERE Dogs.age = (SELECT MIN(age) FROM Dogs);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n    \"1\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\",\n    \"2\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\"\n}\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["We need to find distinct combinations of breed types and size types for dogs.", "To achieve this, we will select distinct values from the 'Breeds' and 'Sizes' tables.", "We will join the 'Dogs' table with the 'Breeds' table using the 'breed_code' foreign key to get the breed names.", "We will also join the 'Dogs' table with the 'Sizes' table using the 'size_code' foreign key to get the size descriptions.", "Finally, we will select the distinct breed names and size descriptions from the joined tables."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT B.breed_name, S.size_description\nFROM Dogs D\nJOIN Breeds B ON D.breed_code = B.breed_code\nJOIN Sizes S ON D.size_code = S.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\",\n    \"1\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n    \"2\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\"\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["Identify the required information: professional's first name and treatment description.", "Determine the relevant tables: Professionals and Treatment_Types.", "Recognize that Treatments table links Professionals and Treatment_Types through foreign keys.", "Use JOIN statements to combine the tables based on their relationships: Treatments with Professionals and Treatments with Treatment_Types.", "Select the desired columns from the resulting joined tables."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT Professionals.first_name, Treatment_Types.treatment_type_description\nFROM Treatments\nJOIN Professionals ON Treatments.professional_id = Professionals.professional_id\nJOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code;", "hint": "\n"}
